<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、Node.js 介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js学习笔记">
<meta property="og:url" content="http://nicolejay.github.io/2022/01/15/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="一、Node.js 介绍">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-15T10:05:42.000Z">
<meta property="article:modified_time" content="2022-01-17T10:16:07.883Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://nicolejay.github.io/2022/01/15/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Node.js学习笔记 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Node-js-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">一、Node.js 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1、介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Node-%E6%98%AF%E5%AF%B9-ES-%E6%A0%87%E5%87%86%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">2、Node 是对 ES 标准的一个实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Node-%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="nav-number">1.3.</span> <span class="nav-text">3、Node 的服务器是单线程的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Node-%E7%94%A8%E9%80%94"><span class="nav-number">1.4.</span> <span class="nav-text">4、Node 用途</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81CommonJS-%E8%A7%84%E8%8C%83"><span class="nav-number">2.</span> <span class="nav-text">二、CommonJS 规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81ECMAScript-%E6%A0%87%E5%87%86%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">2.1.</span> <span class="nav-text">1、ECMAScript 标准的缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">2、模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81CommonJS"><span class="nav-number">2.3.</span> <span class="nav-text">3、CommonJS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Node-js-%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">三、Node.js 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">1、模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%9A%B4%E9%9C%B2"><span class="nav-number">3.1.1.</span> <span class="nav-text">模块暴露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5"><span class="nav-number">3.1.2.</span> <span class="nav-text">模块引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%E6%98%AF%E5%B1%80%E9%83%A8%E7%9A%84"><span class="nav-number">3.1.3.</span> <span class="nav-text">模块中的变量和方法是局部的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E5%8C%85%E8%A3%85%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%AD%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.4.</span> <span class="nav-text">模块中的代码是包装在一个函数中执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exports-%E5%92%8C-module-exports-%E5%AF%B9%E6%AF%94"><span class="nav-number">3.1.5.</span> <span class="nav-text">exports 和 module.exports 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1-global"><span class="nav-number">3.2.</span> <span class="nav-text">2、全局对象 global</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%8C%85-package"><span class="nav-number">3.3.</span> <span class="nav-text">3、包 package</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81npm"><span class="nav-number">3.4.</span> <span class="nav-text">4、npm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#npm-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">3.4.1.</span> <span class="nav-text">npm 相关命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.</span> <span class="nav-text">5、文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.5.1.</span> <span class="nav-text">Buffer 缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">相关方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fs%EF%BC%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="nav-number">3.5.2.</span> <span class="nav-text">fs（文件系统）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">文件写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">文件读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">fs 模块的其他方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2022/01/15/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Node.js学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-15 18:05:42" itemprop="dateCreated datePublished" datetime="2022-01-15T18:05:42+08:00">2022-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、Node-js-介绍"><a href="#一、Node-js-介绍" class="headerlink" title="一、Node.js 介绍"></a>一、Node.js 介绍</h1><a id="more"></a>

<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Node.js 是一个<strong>能在服务器端运行 JavaScript **的开放源代码、跨平台的</strong> JavaScript 运行环境**，Node.js 与传统服务器端的多线程不同，Node.js 是单线程（既是优点也是缺点，渲染页面快，但对于用户较多的场景有局限）</p>
<p>Node 采用 Google 开发的V8 引擎运行 js 代码，使用<strong>事件驱动、非阻塞和异步I/O模型</strong>等技术来提高性能，可优化应用程序的传输量和规模</p>
<p>Node 大部分基本模块都用 JavaScript 编写，在 Node 出现之前 JS 通常作为客户端程序设计语言使用，用 JS 写出的程序常在用户的浏览器上运行</p>
<p>目前 Node 已被 IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、LinkedIn、Rakuten、PayPal、Voxer 和 GoDaddy 等企业采用</p>
<h2 id="2、Node-是对-ES-标准的一个实现"><a href="#2、Node-是对-ES-标准的一个实现" class="headerlink" title="2、Node 是对 ES 标准的一个实现"></a>2、Node 是对 ES 标准的一个实现</h2><p>Node 是对 ES 标准的一个实现，Node 也是一个 JS 引擎，但 Node 仅仅对 ES 标准进行了实现，所以<strong>在 Node 中不包含 DOM 和 BOM</strong></p>
<p>Node 中可使用所有内建对象：String、Number、Boolean、Math、Date、RegExp、Function、Object、Array，而 BOM 和 DOM 不能使用，但可以使用 console 也可以使用定时器（setTimeout()、setInterval()）</p>
<h2 id="3、Node-的服务器是单线程的"><a href="#3、Node-的服务器是单线程的" class="headerlink" title="3、Node 的服务器是单线程的"></a>3、Node 的服务器是单线程的</h2><p>Node 可在后台编写服务器，Node 编写服务器都是单线程的服务器（Node 处理请求时是单线程，但是在后台拥有一个 I/O（对磁盘的读写操作）线程池）</p>
<p>而传统的服务器都是多线程的（即每进来一个请求，就创建一个线程去处理请求）</p>
<h2 id="4、Node-用途"><a href="#4、Node-用途" class="headerlink" title="4、Node 用途"></a>4、Node 用途</h2><p>（1）Web 服务 API，如 REST</p>
<p>（2）实时多人游戏</p>
<p>（3）后端的 Web 服务，如跨域、服务器端的请求</p>
<p>（4）基于 Web 的应用</p>
<p>（5）多客户端的通信，如即时通信</p>
<h1 id="二、CommonJS-规范"><a href="#二、CommonJS-规范" class="headerlink" title="二、CommonJS 规范"></a>二、CommonJS 规范</h1><h2 id="1、ECMAScript-标准的缺陷"><a href="#1、ECMAScript-标准的缺陷" class="headerlink" title="1、ECMAScript 标准的缺陷"></a>1、ECMAScript 标准的缺陷</h2><p>（1）没有模块系统</p>
<p>（2）标准库较少</p>
<p>（3）没有标准接口</p>
<p>（4）缺乏管理系统，如下载各模块需要去相应官网下载不方便</p>
<h2 id="2、模块化"><a href="#2、模块化" class="headerlink" title="2、模块化"></a>2、模块化</h2><p>若程序设计的规模达到一定程度，则必须对其进行模块化</p>
<p>模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制</p>
<p>CommonJS 的模块功能可帮我们解决该问题</p>
<h2 id="3、CommonJS"><a href="#3、CommonJS" class="headerlink" title="3、CommonJS"></a>3、CommonJS</h2><p>CommonJS 规范的提出主要是为了弥补当前 JavaScript 没有模块标准的缺陷</p>
<p>CommonJS 规范为 JS 指定了一个美好的愿景，希望 JS 能在任何地方运行</p>
<p>CommonJS 对模块的定义：模块引用、模块定义、模块标识（即模块的名字，是传递给 require() 方法的参数，必须是符合驼峰命名法的字符串或相对/绝对路径）</p>
<p>Node 中使用的是 CommonJS 规范</p>
<h1 id="三、Node-js-基础"><a href="#三、Node-js-基础" class="headerlink" title="三、Node.js 基础"></a>三、Node.js 基础</h1><h2 id="1、模块化"><a href="#1、模块化" class="headerlink" title="1、模块化"></a>1、模块化</h2><p>在 Node 中模块分为三类：底层由 C++ 编写的内建模块、Node 提供的核心模块（通过 npm 安装）、用户编写的模块（称为文件模块）</p>
<p>在 Node 中一个 js 文件就是一个模块</p>
<h3 id="模块暴露"><a href="#模块暴露" class="headerlink" title="模块暴露"></a>模块暴露</h3><p>在 Node 中每个 js 文件中的 js 代码都是独立运行在一个函数中，变量和方法是局部变量/方法，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问</p>
<p>可通过 exports 向外部暴露变量和方法，只需将需要暴露给外部的变量或方法设置为 exports 的属性即可</p>
<pre><code>exports.x = &#39;xxx&#39; //或 module.exports.x = &#39;xxx&#39;
exports.fn = function()&#123;&#125;</code></pre>
<h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><p>（1）核心模块</p>
<p>对于由 node 引擎提供的核心模块，标识就是模块的名字，通过 <code>require(&quot;模块名&quot;)</code> 引入</p>
<p>node 在使用模块名字来引入时会首先在当前目录的 node_modules 中寻找是否含有该模块，若有则直接使用，若没有则去上一级目录的 node_modules 中寻找，若有则直接使用，若没有再去上一级目录的 node_modules 中寻找，直到找到为止，若直到找到磁盘的根目录依然没有则报错</p>
<p>（2）文件模块</p>
<p>文件模块是由用户自己创建的模块，通过 require(文件路径) 函数引入外部模块，若使用相对路径必须以 <code>.</code> 或 <code>..</code> 开头</p>
<p>使用 require 引入模块后，该函数会返回一个对象，这个对象代表的是引入的模块</p>
<h3 id="模块中的变量和方法是局部的"><a href="#模块中的变量和方法是局部的" class="headerlink" title="模块中的变量和方法是局部的"></a>模块中的变量和方法是局部的</h3><p>console.log(global.变量) 的结果是 undefined 可证明这一说法</p>
<h3 id="模块中的代码是包装在一个函数中执行"><a href="#模块中的代码是包装在一个函数中执行" class="headerlink" title="模块中的代码是包装在一个函数中执行"></a>模块中的代码是包装在一个函数中执行</h3><p>在模块中执行 console.log(arguments) 输出有结果说明模块是相当于一个函数</p>
<p>或 console.log(arguments.callee) 输出 [Function] 也说明模块是相当于一个函数</p>
<p>注：arguments.callee 这个属性保存的是当前执行的函数对象</p>
<p>node 在执行模块中的代码时，会首先在代码最顶部添加如下代码</p>
<pre><code>function (exports, require, module, __filename__, __dirname__)&#123;&#125;</code></pre>
<p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时同时传递进 5 个实参：</p>
<pre><code>exports 该对象用来将变量或函数暴露到外部
require 是个函数，用来引入外部模块
module 代表的是当前模块本身，exports 就是 module 的属性，既可以使用 exports 导出，也可以使用 module.exports 导出
__filename__ 当前模块的完整路径
__dirname__ 当前模块所在文件夹的完整路径</code></pre>
<h3 id="exports-和-module-exports-对比"><a href="#exports-和-module-exports-对比" class="headerlink" title="exports 和 module.exports 对比"></a>exports 和 module.exports 对比</h3><p>二者的效果基本相同</p>
<p>但通过 exports 只能使用 <code>export.xxx = xxx</code> 的方式来向外暴露内部变量，注意不能使用 exports = {}</p>
<p>而 module.exports 既可通过 <code>module.export.xxx = xxx</code> 的形式，也可以直接赋值 <code>module.exports = &#123;&#125;</code> 来向外暴露内部变量，且可一次性暴露多个变量或方法</p>
<pre><code>//方式一
module.exports.name = &#39;xxx&#39;; //或 exports.name = &#39;xxx&#39;;
module.exports.age = 12;
module.exports.sayName = function()&#123;&#125;
//方式二
module.exports = &#123;
    name: &#39;xxx&#39;,
    age: 12,
    sayNamge:function()&#123;&#125;
&#125;</code></pre>
<h2 id="2、全局对象-global"><a href="#2、全局对象-global" class="headerlink" title="2、全局对象 global"></a>2、全局对象 global</h2><p>在 node 中有一个全局对象 global，它的作用和网页中的 window 类似</p>
<p>在全局中创建的变量都会作为 global 的属性保存</p>
<p>在全局中创建的函数都会作为 global 的方法保存</p>
<h2 id="3、包-package"><a href="#3、包-package" class="headerlink" title="3、包 package"></a>3、包 package</h2><p>CommonJS 的包规范允许将一组相关的模块组合到一起，形成一组完整的工具</p>
<p>CommonJS 的包规范由<strong>包结构</strong>和<strong>包描述文件</strong>两部分组成，包实际上就是一个压缩文件，解压后还原为目录，该目录包含如下文件或子目录</p>
<pre><code>package.json  描述文件，只有该文件在包目录中是必须的
bin  可执行二进制文件，非必须
lib  js 代码，非必须
doc  文档，非必须
test  单元测试，非必须</code></pre>
<p>包结构：用于组织包中的各种文件</p>
<p>包描述文件：描述包的非代码相关信息，以供外部读取分析，它是一个 JSON 格式的文件 package.json，文件中不能写注释，位于包的根目录下，是包的重要组成部分，其中字段包括 name、description、version、keyword、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies</p>
<h2 id="4、npm"><a href="#4、npm" class="headerlink" title="4、npm"></a>4、npm</h2><p>CommonJS 包规范是理论，npm（Node Package Manager）是其中一种实践</p>
<p>对于 Node 而言，npm 帮助其完成了第三方模块的发布、安装和依赖等</p>
<p>借助 npm，Node 与第三方模块之间形成了很好的一个生态系统</p>
<h3 id="npm-相关命令"><a href="#npm-相关命令" class="headerlink" title="npm 相关命令"></a>npm 相关命令</h3><p><code>npm -v</code>  查看版本</p>
<p><code>npm version</code>  查看所有模块的版本</p>
<p><code>npm</code>  帮助说明</p>
<p><code>npm search 包名</code>  搜索模块包</p>
<p><code>npm install 包名</code> 或 <code>npm i 包名</code> 在当前目录安装包</p>
<p><code>npm install 包名 -g</code>  全局模式安装包（全局安装的包一般都是一些工具）</p>
<p><code>npm install 包名 --save</code>  安装包并添加到依赖中</p>
<p><code>npm install</code>  下载当前项目所依赖的包</p>
<p><code>npm remove 包名</code> 或 <code>npm r 包名</code>  删除一个模块</p>
<p><code>npm install 文件路径</code>  从本地安装</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  安装 cnpm</p>
<p><code>npm install 包名 --registry=地址</code>  从镜像源安装</p>
<p><code>npm config set registry 地址</code>  设置镜像源</p>
<h2 id="5、文件系统"><a href="#5、文件系统" class="headerlink" title="5、文件系统"></a>5、文件系统</h2><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h3><p>Buffer 是传输数据时保存数据的缓冲区</p>
<p>Buffer 的结构和数组很像，它的元素为 16 进制的两位数，操作的方法也和数组类似</p>
<p>实际上一个元素就表示内存中的一个字节</p>
<p>Buffer 是 Node.js 中扩充的对象，使用 Buffer 不需要引入模块，直接使用即可</p>
<p>数组中不能存储二进制文件，而 Buffer 就是专门用来存储二进制数据，在 Buffer 中存储的都是二进制数据，但是显示时都是以 16 进制的形式显示，传输的时候都是二进制，buffer 中每个元素的范围是 00 - ff（即 00000000 - 11111111），buffer 中的英文一个元素占用内存的一个字节，一个汉字占用 3 个字节（传输数据的最小单位是字节（8 bit））</p>
<p>Buffer 中的内存不是通过 JavaScript 分配的，而是在底层通过 C++ 申请的，也就是可以直接通过 Buffer 来创建内存中的空间</p>
<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>Buffer.from(字符串)  将一个字符串转换为 buffer</p>
<p>Buffer.alloc(大小)  创建一个指定大小的 Buffer</p>
<p>Buffer.allocUnsafe(大小)  创建一个指定大小的 Buffer，但可能含有敏感数据</p>
<p>Buffer实例对象.toString()  将缓冲区中的数据转换为字符串</p>
<pre><code>//将一个字符串保存到 buffer 中
var str = &#39;hello&#39;;
var buf = Buffer.from(str);
console.log(buf);  //输出 &lt;Buffer 48 65 6c 6c 6f&gt;（计算机中所有的二进制都会以十六进制显示）
console.log(buf.length); //输出 5，表示占用内存的大小占用 5 个字节
console.log(str.length); //输出 5，表示字符串的长度

var str = &#39;hello 你好&#39;;
var buf = Buffer.from(str);
console.log(buf.length); //输出 12，即 6 + 2 * 3，表示占用 12 个字节
console.log(str.length); //输出 8

//通过构造函数创建一个指定大小的 buffer，不推荐使用
var buf2 = new Buffer(10);  //10 个字节的 buffer

//通过类方法 Buffer.alloc 创建一个指定大小的 buffer，在分配内存时清空之前的数据
var buf3 = Buffer.alloc(10);  //10 个字节的 buffer

//通过类方法 Buffer.allocUnsafe 创建一个指定大小的 buffer，但 buffer 中可能含有敏感数据，在分配内存时不清空之前的数据
var buf4 = Buffer.allocUnsafe(10);  //10 个字节的 buffer</code></pre>
<p>注意 Buffer 的构造函数都不推荐使用</p>
<p>Buffer 的大小一旦确定则不能修改，Buffer 实际上是对底层内存的直接操作，一般会给 Buffer 分配一段连续内存空间，当给 Buffer 中超出范围的索引赋值时该位置内存可能已被其他程序占用，则需要分配其他与前面不连续的内存空间会降低效率，所以为避免这种情况 Buffer 的大小确定后不能修改</p>
<p>可以通过索引操作 Buffer 中的元素</p>
<p>只要数字在控制台或页面中输出一定是十进制，若要输出非十进制只需 <code>.toString(进制)</code></p>
<h3 id="fs（文件系统）"><a href="#fs（文件系统）" class="headerlink" title="fs（文件系统）"></a>fs（文件系统）</h3><p>在 Node 中，与文件系统的交互很重要，服务器的本质是将本地文件发送给远程客户端</p>
<p>Node 通过 fs 模块来和文件系统交互对系统中的文件进行操作，该模块提供了一些标准文件访问 API 来打开、读取、写入文件以及与其交互</p>
<p>fs 模块是 Node 中已经继承好了，不需要再使用 npm 下载，直接引入即可</p>
<p>加载 fs 模块 <code>const fs = require(&quot;fs&quot;);</code></p>
<p>fs 模块中所有的操作都有同步和异步两种形式可供选择</p>
<p>同步文件系统会阻塞程序的执行，即除非操作完毕，否则不会向下执行代码</p>
<p>异步文件系统不会阻塞程序的执行，而是在操作完成时通过回调函数将结果返回</p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>（1）同步文件写入</p>
<p><code>fs.openSync(path, flags[,mode])</code> 打开文件，返回一个文件的描述符作为结果，可通过该描述符来对文件进行各种操作</p>
<pre><code>-path 要打开文件的路径
-flags 打开文件要做的操作类型，如 r（只读）、w（可写）
-mode 设置文件的操作权限，一般不传</code></pre>
<p><code>fs.writeSync(fd, string[,position[,encoding]])</code> 向文件写入内容</p>
<pre><code>-fd 文件的描述符，需要传递要写入的文件的描述符
-string 要写入的内容
-position 写入的起始索引位置
-encoding 写入的编码，默认 utf-8</code></pre>
<p><code>fs.closeSync(fd)</code> 关闭文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
var fd = fs.openSync(&#39;hello.txt&#39;,&#39;w&#39;,2);
fs.writeSync(fd,&#39;xxxx&#39;);
fs.closeSync(fd);</code></pre>
<p>（2）异步文件写入</p>
<p><code>fs.open(path, flags[, mode], callback)</code> 打开文件，没有返回值，异步调用的方法结果都是通过回调函数的参数返回的</p>
<pre><code>回调函数有两个参数：
    err 错误对象，若没有错误则为 null
    fd 文件的描述符</code></pre>
<p><code>fs.write(fd, string[, position[, encoding]], callback)</code> 异步写入一个文件</p>
<p><code>fs.close(fd, callback)</code> 关闭文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
fs.open(&#39;hello.txt&#39;,&#39;w&#39;, function(err, fd)&#123;
    if(!err)&#123;
        console.log(fd);
        fs.write(fd,&quot;异步写入的内容&quot;,function(err)&#123;
            if(!err)&#123;
                console.log(&quot;写入成功&quot;);
            &#125;
            fs.close(fd, function(err)&#123;
                if(!err)&#123;
                    console.log(&quot;文件已关闭&quot;);
                &#125;
            &#125;)
        &#125;)
    &#125;else&#123;
        conosle.log(err);
    &#125;
&#125;);
fs.writeSync(fd,&#39;xxxx&#39;);
fs.closeSync(fd);</code></pre>
<p>相比同步，异步代码较为繁琐但执行效率更高，且同步中没有对错误进行处理，若遇到一个错误则整个程序就结束</p>
<p>（3）简单文件写入</p>
<p>异步：<code>fs.writeFile(file, data[, options], callback)</code></p>
<p>同步：<code>fs.writeFileSync(file, data[, options])</code></p>
<pre><code>-file 要操作的文件的路径
-data 要写入的数据
-options 选项对象，可对写入进行一些设置，包括 encoding（默认是 &#39;utf8&#39;）、mode（权限，默认是 0o666）、flag（默认是 &#39;w&#39;）
-callback 当写入完成后执行的函数

var fs = require(&quot;fs&quot;);
fs.writeFile(&#39;hello.txt&#39;,&#39;写入的内容&#39;, &#123;flag:&#39;w&#39;&#125;, function(err)&#123;
    if(!err)&#123;
        console.log(&#39;写入成功&#39;);
    &#125;
&#125;);</code></pre>
<p>通过上述方式写入文件无需手动打开关闭文件</p>
<p>（4）流式文件写入</p>
<p>上述文件写入方式是要将写入内容在内存准备好一次性全写入，内容较多时内存占用多，且速度慢，因此同步、异步、简单文件写入都不适合大文件的写入，性能较差，容易导致内存溢出</p>
<p><code>fs.createWriteStream(path[, options])</code> 创建一个可写流</p>
<pre><code>-path 文件路径
-options 配置的参数</code></pre>
<p><code>可写流.write(写入的内容)</code> 通过可写流像文件中输出内容，只要流还在可分多次写入</p>
<p><code>可写流.end()</code> 关闭流</p>
<p>可通过监听流的 open 和 close 事件来监听流的打开和关闭</p>
<p><code>可写流.on(事件字符串,function()&#123;&#125;)</code> on 绑定的是长期事件</p>
<p><code>可写流.once(事件字符串,function()&#123;&#125;)</code> once 是绑定一个一次性事件，该事件将会在触发一次后自动失效</p>
<pre><code>var fs = require(&quot;fs&quot;);
var ws = fs.createWriteStream(&#39;hello.txt&#39;);
ws.once(&#39;open&#39;, function()&#123;
    console.log(&#39;流打开了&#39;)
&#125;);
ws.once(&#39;close&#39;, function()&#123;
    console.log(&#39;流关闭了&#39;)
&#125;);
ws.write(&quot;写入的内容1&quot;);
ws.write(&quot;写入的内容2&quot;);
ws.write(&quot;写入的内容3&quot;);

ws.end();
//若使用 ws.close(); 则只会写入“写入的内容1”，因为内容还没写完就把流输出端关闭，而 ws.end(); 可理解为把流的输入端关闭，内容只要进入流中都会写入</code></pre>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>（1）同步文件读取</p>
<p>和同步文件写入差不多</p>
<p>（2）异步文件读取</p>
<p>和异步文件写入差不多</p>
<p>（3）简单文件读取</p>
<p>异步：<code>fs.readFile(path[, options], callback)</code></p>
<p>同步：<code>fs.readFileSync(path[, options])</code></p>
<pre><code>-path 要读取的文件的路径
-options 读取的选项
-callback 异步中回调函数，通过回调函数将读取到的内容返回，回调函数参数有 err 和 data
    err 错误对象
    data 读取到的数据，会返回一个 Buffer，因为文件可能为文本、图片、音频等，返回 Buffer 通用性更高

var fs = require(&quot;fs&quot;);
fs.readFile(&#39;xxx.jpg&#39;, function(err, data)&#123;
    if(!err)&#123;
        //将 data 写入文件中
        fs.writeFile(&#39;xxx1.jpg&#39;, data, function(err)&#123;
            console.log(&quot;文件写入成功&quot;);
        &#125;)
    &#125;
&#125;);</code></pre>
<p>（4）流式文件读取</p>
<p>流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中</p>
<p>使用方式基本和流式文件写入相似</p>
<p>若要读取一个可读流中的数据，必须要为可读流绑定一个 data 事件，data 事件绑定完毕会自动开始读取数据，读完会自动关闭</p>
<p><code>可读流.pipe(可写流)</code> 可将可读流中的内容直接输出到可写流中</p>
<p>例子：读取文件内容写入新文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
var rs = fs.createReadStream(&#39;xxx.mp3&#39;);
var ws = fs.createWriteStream(&#39;xx1.mp3&#39;);
rs.once(&#39;open&#39;, function()&#123;
    console.log(&#39;可读流打开了&#39;)
&#125;);
rs.once(&#39;close&#39;, function()&#123;
    console.log(&#39;可读流关闭了&#39;);
    //数据读取完毕，关闭可写流
    ws.end();
&#125;);
ws.once(&#39;open&#39;, function()&#123;
    console.log(&#39;可写流打开了&#39;)
&#125;);
ws.once(&#39;close&#39;, function()&#123;
    console.log(&#39;可写流关闭了&#39;)
&#125;);
rs.on(&quot;data&quot;, function(data)&#123;
    console.log(data.length);  //每次读取的长度
    //将读取到的数据写入可写流中
    ws.write(data);
&#125;);</code></pre>
<p>更简便的写法，使用 pipe()</p>
<pre><code>var fs = require(&quot;fs&quot;);
var rs = fs.createReadStream(&#39;xxx.mp3&#39;);
var ws = fs.createWriteStream(&#39;xx1.mp3&#39;);
rs.pipe(ws);</code></pre>
<h4 id="fs-模块的其他方法"><a href="#fs-模块的其他方法" class="headerlink" title="fs 模块的其他方法"></a>fs 模块的其他方法</h4><p>（1）验证路径是否存在</p>
<p><code>fs.exists(path, callback)</code>（被废弃，使用 fs.stat() 或 fs.access() 代替）</p>
<p><code>fs.existsSync(path)</code> 返回布尔值</p>
<p>（2）获取文件状态</p>
<p><code>fs.stat(path, callback)</code>，返回一个对象，该对象中保存了当前对象状态的相关信息，回调有两个参数(err, stats)，第一个是错误，第二个是 fs.Stats 对象</p>
<p>fs.Stats 对象中有属性/方法：</p>
<pre><code>size 文件的大小
isFile() 是否是一个文件
isDirectory() 是否是一个文件夹（目录）</code></pre>
<p><code>fs.statSync(path)</code></p>
<pre><code>fs.stat(&#39;xx.mp3&#39;, function(err, stat)&#123;
    console.log(stat);
    console.log(stat.isDirectory());
&#125;)</code></pre>
<p>（3）删除文件</p>
<p><code>fs.unlink(path, callback)</code></p>
<p><code>fs.unlinkSync(path)</code> </p>
<p>（4）读取目录的目录结构</p>
<p><code>fs.readdir(path[, options], callback)</code></p>
<p><code>fs.readdirSync(path[, options])</code> 读取一个目录的目录结构，回调函数参数一个是错误 err，一个是字符串数组 files，files 中每个元素就是一个文件夹或文件的名字</p>
<pre><code>fs.readdir(&#39;.&#39;,function(err, files)&#123;
    if(!err)&#123;
        console.log(files);
    &#125;
&#125;)</code></pre>
<p>（5）截断文件</p>
<p><code>fs.truncate(path, len, callback)</code></p>
<p><code>fs.truncateSync(path, len)</code></p>
<p>将文件修改为指定字节长度大小，其中一个字母占一个字节，一个汉字占 3 个字节</p>
<p>（6）建立目录</p>
<p><code>fs.mkdir(path[, mode], callback)</code></p>
<p><code>fs.mkdirSync(path[, mode])</code></p>
<p>（7）删除目录</p>
<p><code>fs.rmdir(path, callback)</code></p>
<p><code>fs.rmdirSync(path)</code></p>
<p>（8）重命名/剪切文件和目录</p>
<p><code>fs.rename(oldPath, newPath, callback)</code></p>
<p><code>fs.renameSync(oldPath, newPath)</code></p>
<p>（9）监视文件更改写入</p>
<p><code>fs.watchFile(filename[, options], listener)</code></p>
<pre><code>-filename 要监视的文件的名字
-options 配置选项，可传参数 persistent（默认是 true）、interval（监视的间隔时间默认是 5007 ms）
-listener 回调函数，当文件发生变化时，回调函数会执行，回调函数中有两个参数
    curr 当前文件的状态，是 fs.Stats 对象
    prev 修改前文件的状态，是 fs.Stats 对象

fs.watchFile(&#39;hello.txt&#39;, &#123;interval: 1000&#125;, function(curr, prev)&#123;
    console.log(&quot;修改前文件大小：&quot; + prev.size);
    console.log(&quot;修改后文件大小：&quot; + curr.size);
&#125;);</code></pre>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/12/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="AngularJS学习笔记">
                  <i class="fa fa-chevron-left"></i> AngularJS学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/18/Zepto-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Zepto.js学习笔记">
                  Zepto.js学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
