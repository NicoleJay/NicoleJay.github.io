<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、WebpackWebpack 是一种前端资源构建工具，一个静态模块打包器（module bundler）">
<meta property="og:type" content="article">
<meta property="og:title" content="Webpack学习笔记">
<meta property="og:url" content="http://nicolejay.github.io/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="一、WebpackWebpack 是一种前端资源构建工具，一个静态模块打包器（module bundler）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nicolejay.github.io/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85.png">
<meta property="article:published_time" content="2022-01-24T14:50:30.000Z">
<meta property="article:modified_time" content="2022-02-07T17:17:49.844Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nicolejay.github.io/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85.png">


<link rel="canonical" href="http://nicolejay.github.io/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Webpack学习笔记 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Webpack"><span class="nav-number">1.</span> <span class="nav-text">一、Webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Webpack-%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1、Webpack 五个核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Entry"><span class="nav-number">1.1.1.</span> <span class="nav-text">（1）Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Output"><span class="nav-number">1.1.2.</span> <span class="nav-text">（2）Output</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Loader"><span class="nav-number">1.1.3.</span> <span class="nav-text">（3）Loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Plugins"><span class="nav-number">1.1.4.</span> <span class="nav-text">（4）Plugins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Mode"><span class="nav-number">1.1.5.</span> <span class="nav-text">（5）Mode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#development"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">development</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#production"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">production</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">开发环境和生产环境的异同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8-Webpack"><span class="nav-number">1.2.</span> <span class="nav-text">2、使用 Webpack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8-webpack-%E6%89%93%E5%8C%85%E6%A0%B7%E5%BC%8F%E8%B5%84%E6%BA%90"><span class="nav-number">1.3.</span> <span class="nav-text">3、使用 webpack 打包样式资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8-webpack-%E6%89%93%E5%8C%85-html-%E8%B5%84%E6%BA%90"><span class="nav-number">1.4.</span> <span class="nav-text">4、使用 webpack 打包 html 资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E4%BD%BF%E7%94%A8-webpack-%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.</span> <span class="nav-text">5、使用 webpack 打包图片资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8-webpack-%E6%89%93%E5%8C%85%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%EF%BC%88%E5%A6%82%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">6、使用 webpack 打包其他资源（如字体图标）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81devServer"><span class="nav-number">1.7.</span> <span class="nav-text">7、devServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.8.</span> <span class="nav-text">8、开发环境基本配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="nav-number">1.9.</span> <span class="nav-text">9、生产环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%9C%80%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.9.1.</span> <span class="nav-text">生产环境中需解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96-css-%E6%88%90%E5%8D%95%E7%8B%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.2.</span> <span class="nav-text">提取 css 成单独文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#css-%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86"><span class="nav-number">1.9.3.</span> <span class="nav-text">css 兼容性处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9-css"><span class="nav-number">1.9.4.</span> <span class="nav-text">压缩 css</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5-eslint"><span class="nav-number">1.9.5.</span> <span class="nav-text">js 语法检查 eslint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js-%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86-eslint"><span class="nav-number">1.9.6.</span> <span class="nav-text">js 兼容性处理 eslint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9-html-%E5%92%8C-js"><span class="nav-number">1.9.7.</span> <span class="nav-text">压缩 html 和 js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.8.</span> <span class="nav-text">生产环境基本配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.10.</span> <span class="nav-text">10、性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.10.1.</span> <span class="nav-text">开发环境性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-HMR"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">（1）优化打包构建速度 ———— HMR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-source-map"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">（2）优化代码调试 ———— source-map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.10.2.</span> <span class="nav-text">生产环境性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">（1）优化打包构建速度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#oneOf"><span class="nav-number">1.10.2.1.1.</span> <span class="nav-text">oneOf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-babel-%E7%BC%93%E5%AD%98"><span class="nav-number">1.10.2.1.2.</span> <span class="nav-text">缓存 ———— babel 缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%89%93%E5%8C%85"><span class="nav-number">1.10.2.1.3.</span> <span class="nav-text">多进程打包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#externals"><span class="nav-number">1.10.2.1.4.</span> <span class="nav-text">externals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DLL"><span class="nav-number">1.10.2.1.5.</span> <span class="nav-text">DLL</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">（2）优化代码运行的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98-%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98"><span class="nav-number">1.10.2.2.1.</span> <span class="nav-text">缓存 ———— 文件资源缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tree-shaking"><span class="nav-number">1.10.2.2.2.</span> <span class="nav-text">tree shaking</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#code-split"><span class="nav-number">1.10.2.2.3.</span> <span class="nav-text">code split</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#js-%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.10.2.2.4.</span> <span class="nav-text">js 的懒加载和预加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PWA"><span class="nav-number">1.10.2.2.5.</span> <span class="nav-text">PWA</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81webpack-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">二、webpack 配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81entry"><span class="nav-number">2.1.</span> <span class="nav-text">1、entry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81output"><span class="nav-number">2.2.</span> <span class="nav-text">2、output</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81module"><span class="nav-number">2.3.</span> <span class="nav-text">3、module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81resolve"><span class="nav-number">2.4.</span> <span class="nav-text">4、resolve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81devServer"><span class="nav-number">2.5.</span> <span class="nav-text">5、devServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81optimization"><span class="nav-number">2.6.</span> <span class="nav-text">6、optimization</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81webpack-5"><span class="nav-number">3.</span> <span class="nav-text">三、webpack 5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8-webpack-5"><span class="nav-number">3.1.</span> <span class="nav-text">1、使用 webpack 5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81webpack-5-%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">3.2.</span> <span class="nav-text">2、webpack 5 重点关注的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%B8%80%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="nav-number">3.3.</span> <span class="nav-text">3、一些特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4-Node-js-Polyfills"><span class="nav-number">3.3.1.</span> <span class="nav-text">自动删除 Node.js Polyfills</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-%E5%92%8C-%E6%A8%A1%E5%9D%97-ID"><span class="nav-number">3.3.2.</span> <span class="nav-text">chunk 和 模块 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#chunk-ID"><span class="nav-number">3.3.3.</span> <span class="nav-text">chunk ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tree-shaking-%E5%8A%9F%E8%83%BD%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7"><span class="nav-number">3.3.4.</span> <span class="nav-text">tree shaking 功能更加强大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ouput"><span class="nav-number">3.3.5.</span> <span class="nav-text">ouput</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#optimization-%E4%B8%AD-splitChunk"><span class="nav-number">3.3.6.</span> <span class="nav-text">optimization 中 splitChunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#caching-%E7%BC%93%E5%AD%98"><span class="nav-number">3.3.7.</span> <span class="nav-text">caching 缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.8.</span> <span class="nav-text">监视输出文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.</span> <span class="nav-text">其他</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Webpack学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-24 22:50:30" itemprop="dateCreated datePublished" datetime="2022-01-24T22:50:30+08:00">2022-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、Webpack"><a href="#一、Webpack" class="headerlink" title="一、Webpack"></a>一、Webpack</h1><p>Webpack 是一种前端资源构建工具，一个静态模块打包器（module bundler）</p>
<a id="more"></a>

<p><img src="/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85.png" alt="静态模块打包"></p>
<p>在 Webpack 中前端所有资源文件（js/json/css/img/less/…）都会作为模块处理，它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）</p>
<h2 id="1、Webpack-五个核心概念"><a href="#1、Webpack-五个核心概念" class="headerlink" title="1、Webpack 五个核心概念"></a>1、Webpack 五个核心概念</h2><h3 id="（1）Entry"><a href="#（1）Entry" class="headerlink" title="（1）Entry"></a>（1）Entry</h3><p>入口（Entry）指示 Webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</p>
<h3 id="（2）Output"><a href="#（2）Output" class="headerlink" title="（2）Output"></a>（2）Output</h3><p>输出（Output）指示 Webpack 打包后的资源 bundles 输出到哪里，以及如何命名</p>
<h3 id="（3）Loader"><a href="#（3）Loader" class="headerlink" title="（3）Loader"></a>（3）Loader</h3><p>Loader 让 Webpack 能够处理那些非 JavaScript 文件（如样式 css 文件、图片等）（Webpack 自身只能理解 JavaScript）</p>
<p>使用 loader 需要：1）下载 2）使用（配置loader）</p>
<h3 id="（4）Plugins"><a href="#（4）Plugins" class="headerlink" title="（4）Plugins"></a>（4）Plugins</h3><p>插件（Plugins）可以用于执行范围更广的任务，插件的范围包括从打包优化和压缩，到重新定义环境中的变量等</p>
<p>使用 plugins 需要：1）下载 2）引入 3）使用</p>
<h3 id="（5）Mode"><a href="#（5）Mode" class="headerlink" title="（5）Mode"></a>（5）Mode</h3><p>模式（Mode）指示 Webpack 使用相应模式的配置，模式分为 development 开发模式和 production 生产模式</p>
<h4 id="development"><a href="#development" class="headerlink" title="development"></a>development</h4><p>development 会将 process.env.NODE_ENV 的值设置为 development，启用 NamedChunksPlugin 和 NamesModulesPlugin</p>
<p>特点：能让代码本地调试运行的环境</p>
<h4 id="production"><a href="#production" class="headerlink" title="production"></a>production</h4><p>production 会将 process.env.NODE_ENV 的值设置为 production，启用 FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin、OccurenceOrderPlugin、SideEffectsFlagPlugin、UglifyJsPlugin/TerserPlugin（压缩 js 代码）</p>
<p>特点：能让代码优化上线运行的环境</p>
<h4 id="开发环境和生产环境的异同"><a href="#开发环境和生产环境的异同" class="headerlink" title="开发环境和生产环境的异同"></a>开发环境和生产环境的异同</h4><p>生产环境和开发环境能将 ES6 模块化编译称浏览器能识别的模块化</p>
<p>生产环境生产的打包文件压缩了 js 代码，而开发环境没有，因此生产环境打包后生成的文件较小</p>
<h2 id="2、使用-Webpack"><a href="#2、使用-Webpack" class="headerlink" title="2、使用 Webpack"></a>2、使用 Webpack</h2><p>新建项目文件夹，在文件夹下使用命令 <code>npm init</code> 初始化生成 package.json 文件</p>
<p>全局安装 webpack 和 webpack-cli <code>npm i webpack webpack-cli -g</code></p>
<p>本地安装 webpack 和 webpack-cli <code>npm i webpack webpack-cli -D</code></p>
<p>在项目下新建文件夹 src 存放源码，并新建 index.js 文件作为入口文件，在项目下新建文件夹 build 存放打包后的文件</p>
<p>在 index.js 中编写相关代码</p>
<pre><code>function add(x,y)&#123;
    return x+y;
&#125;
console.log(add(1,2))</code></pre>
<p>运行指令</p>
<pre><code>开发环境中
webpack ./src/index.js -o ./build/built.js --mode=development
webpack 会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js，整体打包环境是开发环境

生产环境
webpack ./src/index.js -o ./build/built.js --mode=production
webpack 会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js，整体打包环境是生产环境</code></pre>
<p>打包后会生成 built.js 文件，且命令行输出中有个 Hash 相当于文件的 id，后面可以利用它作为文件命名的方式</p>
<p>在生产环境生成的 built.js 中压缩了 js 代码</p>
<p>使用 <code>node .\build\built.js</code> 运行代码，也可在 html 文件中使用 <code>&lt;script&gt;</code> 标签引入打包后的 built.js 文件</p>
<h2 id="3、使用-webpack-打包样式资源"><a href="#3、使用-webpack-打包样式资源" class="headerlink" title="3、使用 webpack 打包样式资源"></a>3、使用 webpack 打包样式资源</h2><p>要打包样式资源需要用到 loader，而 loader 需要定义配置文件</p>
<p>在和 src 同级目录下新建配置文件 webpack.config.js，运行 webpack 指令时会加载里面的配置指示 webpack 干哪些活，内容如下</p>
<pre><code>//resolve 用来拼接绝对路径的方法
const &#123;resolve&#125; = require(&#39;path&#39;);
module.exports = &#123;
    //webpack 配置
    //入口起点
    entry:&#39;./src/index.js&#39;,
    //输出
    output:&#123;
        //输出文件名
        filename: &#39;built.js&#39;,
        //输出路径，__dirname 是 node.js 的变量，代表当前文件的目录绝对路径
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    //loader 的配置
    module:&#123;
        rules:[
            //详细 loader 配置，不同类型文件必须配置不同 loader 处理
            //处理 css 文件
            &#123;
                //匹配哪些文件
                test:/\.css$/, //匹配以 .css 结尾的文件
                //使用哪些loader进行处理
                use:[
                    //use 数组中 loader 执行顺序：从右到左，从下到上依次执行，下列 loader 先执行 css-loader 再执行 style-loader
                    &#39;style-loader&#39;,  //创建 style 标签，将 js 中的样式资源插入进去，添加到 head 中生效
                    &#39;css-loader&#39;  //将 css 文件变成 CommonJS 模块加载到 js 中，里面内容是样式字符串
                ]
            &#125;,
            //处理 less 文件
            &#123;
                test:/\.less$/, //匹配以 .less 结尾的文件
                use:[
                    &#39;style-loader&#39;,  //创建 style 标签，将 js 中的样式资源插入进去，添加到 head 中生效
                    &#39;css-loader&#39;,  //将 css 文件变成 CommonJS 模块加载到 js 中，里面内容是样式字符串
                    &#39;less-loader&#39;  //将 less 文件编译成 css 文件，注意这里需要下载 less-loader 和 less
                ]
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        //详细 plugins 的配置
    ],
    //模式
    mode: &#39;development&#39;,
    //mode:&#39;production&#39;
&#125;</code></pre>
<p>注意：要使用多个 loader 处理时用 use，若只需一个 loader 时再 rules 的对象中直接使用 <code>loader:</code> 进行配置</p>
<p>注意：所有构建工具都是基于 node.js 平台运行的，模块化默认采用 CommonJS 规范，而 src 文件夹中写的项目相关代码所使用的模块化是 ES6 规范的</p>
<h2 id="4、使用-webpack-打包-html-资源"><a href="#4、使用-webpack-打包-html-资源" class="headerlink" title="4、使用 webpack 打包 html 资源"></a>4、使用 webpack 打包 html 资源</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        //详细 plugins 的配置
        //html-webpack-plugin 默认会创建一个空的 html 文件，自动引入打包输出的所有资源（js/css）
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39; //复制 ./src/index.html 文件并自动引入打包输出的所有资源
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<h2 id="5、使用-webpack-打包图片资源"><a href="#5、使用-webpack-打包图片资源" class="headerlink" title="5、使用 webpack 打包图片资源"></a>5、使用 webpack 打包图片资源</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.less$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;, //需要下载 url-loader 和 file-loader 两个包
                options:&#123;
                    //这里设置图片大小小于 8kb 就会被转换为 base64 编码的一种字符串，以 base64 处理
                    //优点：减少请求数量，减轻服务器压力
                    //缺点：图片体积会更大，文件请求速度更慢（如原先图片 10kb，转为 base64 编码后可能有 14kb）
                    //所以一般不会对大图片进行 base64 处理，会对 8-12kb 图片进行 base64 处理
                    limit:8*1024,
                    esModule: false,
                    //给图片重命名
                    name:&#39;[hash:10].[ext]&#39;//取图片 hash 的前 10 位以及文件原扩展名来命名，这样文件也会小一点
                &#125;
            &#125;,
            //注意：上面的方式默认处理不了 html 中的 img 图片（通过 img 标签的 src 属性引入的图片）
            &#123;
                test:/\.html$/,
                //处理 html 文件的 img 图片（负责引入 img，从而能被 url-loader 进行处理）
                loader:&#39;html-loader&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<p>注意：打包图片资源需要下载 url-loader 和 file-loader 两个包，因为 url-loader 依赖于 file-loader</p>
<p>问题：url-loader 默认处理不了 html 中的 img 图片，因为 url-loader 是使用 ES6 中的 module 去处理模块，而 html-loader 打包后引入的 img 是通过 CommonJS 规范引入，所以通过 url-loader 去解析 html-loader 引入的图片解析不了会报错，即打包后 img 标签中 src 会变成 [object Module]</p>
<p>解决：<code>esModule: false</code> 关闭 url-loader 的 ES6 模块化，使用 CommonJS 解析</p>
<p>注意：当一个文件多次使用时，webpack 只会打包一次，不会重复打包一个文件 </p>
<h2 id="6、使用-webpack-打包其他资源（如字体图标）"><a href="#6、使用-webpack-打包其他资源（如字体图标）" class="headerlink" title="6、使用 webpack 打包其他资源（如字体图标）"></a>6、使用 webpack 打包其他资源（如字体图标）</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //打包其他资源（除了 html/js/css/less 以外的资源）
            &#123;
                //排除 css/js/html 资源
                exclude:/\.(css|js|html|less)$/,
                loader:&#39;file-loader&#39;
            &#125;,
            options:&#123;
                name:&#39;[hash:10].[ext]&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<h2 id="7、devServer"><a href="#7、devServer" class="headerlink" title="7、devServer"></a>7、devServer</h2><p>开发服务器 devServer 用来自动化，可自动编译、自动打开浏览器、自动刷新浏览器</p>
<p>特点：只会在内存中编译打包，不会有任何输出</p>
<p>需下载包 webpack-dev-server，启动 devServer 指令：<code>npx webpack-dev-server</code>（若没有全局安装 webpack-dev-server 需要使用 npx 启动）</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //打包其他资源（除了 html/js/css/less 以外的资源）
            &#123;
                //排除 css/js/html 资源
                exclude:/\.(css|js|html|less)$/,
                loader:&#39;file-loader&#39;
            &#125;,
            options:&#123;
                name:&#39;[hash:10].[ext]&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;,
    devServer:&#123;
        contentBase:resolve(__dirname,&#39;build&#39;), //要运行的项目构建后的目录
        compress:true,  //启动 gzip 压缩，使代码更小运行更快
        port:3000,  //端口号
        open:true  //自动打开浏览器
    &#125;
&#125;</code></pre>
<h2 id="8、开发环境基本配置"><a href="#8、开发环境基本配置" class="headerlink" title="8、开发环境基本配置"></a>8、开发环境基本配置</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //处理 css
            &#123;
                test:/\.less$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]
            &#125;,
            //处理 less
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;,
                options:&#123;
                    limit:8*1024,
                    esModule: false,
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                &#125;
            &#125;,
            //处理 html 中 img 资源
            &#123;
                test:/\.html$/,
                loader:&#39;html-loader&#39;
            &#125;,
            //处理其他资源
            &#123;
                exclude:/\.(css|js|html|less|jpg|png|gif)/,
                loader:&#39;file-loader&#39;,
                options:&#123;
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                &#125;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    devServer:&#123;
        contentBase:resolve(__dirname,&#39;build&#39;), 
        compress:true,
        port:3000,
        open:true
    &#125;,
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<p>运行项目指令：</p>
<p>1）<code>webpack</code> 会将打包结果输出出去</p>
<p>2）<code>npx webpack-dev-server</code> 只会在内存中编译打包，没有输出</p>
<h2 id="9、生产环境"><a href="#9、生产环境" class="headerlink" title="9、生产环境"></a>9、生产环境</h2><h3 id="生产环境中需解决的问题"><a href="#生产环境中需解决的问题" class="headerlink" title="生产环境中需解决的问题"></a>生产环境中需解决的问题</h3><p>（1）经过上面的配置，css 文件在打包后都会添加到 js 代码中，使得 js 代码很大，且由于要先加载 js 代码才能解析出其中所需的 css 样式，因此会出现闪屏现象</p>
<p>（2）在生产环境中需要对代码进行压缩</p>
<p>（3）还需要考虑一些样式代码（如一些 css3 的效果）和 js 的兼容性问题</p>
<p>……</p>
<h3 id="提取-css-成单独文件"><a href="#提取-css-成单独文件" class="headerlink" title="提取 css 成单独文件"></a>提取 css 成单独文件</h3><p>使用插件 mini-css-extract-plugin 可将 css 提取成单独文件</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    //&#39;style-loader&#39;, //创建 style 标签，将样式放入
                    MiniCssExtractPlugin.loader, //这个 loader 取代 style-loader，提取 js 中的 css 成单独文件
                    &#39;css-loader&#39; //将 css 文件整合到 js 文件中
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39; //对输出的 css 文件进行重命名，生成的 css 文件会在 build/css/built.css
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>通过上述方式从打包生成的 js 文件中提取 css 样式成单独文件后，生成的 build/index.html 中引入样式的方式就不是通过 style 标签引入，而是通过 <code>&lt;link ref=&quot;css/built.css&quot; rel=&quot;stylesheet&quot;&gt;</code> 引入样式，这样也解决了闪屏现象，并且生成的 js 文件体积也没那么大了</p>
<h3 id="css-兼容性处理"><a href="#css-兼容性处理" class="headerlink" title="css 兼容性处理"></a>css 兼容性处理</h3><p>css 兼容性处理需要使用库 postcss，在 webpack 中通过 postcss-loader 以及插件 postcss-preset-env（帮助 postcss 识别某些环境，从而加载指定的配置，能让兼容性精确到某一个浏览器的版本）使用</p>
<p>其中 postcss-preset-env 帮助 postcss 找到 package.json 中 browserlist 里面的配置，通过配置加载指定的 css 兼容性样式</p>
<p>安装 postcss-loader 和 postcss-preset-env <code>npm i postcss-loader postcss-preset-env -D</code></p>
<p>在 webpack.config.js 中内容如下</p>
<pre><code>//设置 Nodejs 环境变量，决定使用 browserlists 的哪个环境，因为默认是看 package.json 中的生产环境
process.env.NODE_ENV = &#39;development&#39;;
const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    MiniCssExtractPlugin.loader,
                    &#39;css-loader&#39;,
                    //使用 loader 的默认配置
                    //&#39;postcss-loader&#39; //相当于&#123;loader:&#39;postcss-loader&#39;&#125;
                    //修改 loader 的配置
                    &#123;
                        loader:&#39;postcss-loader&#39;,
                        options:&#123;
                            ident: &#39;postcss&#39;,
                            plugins: () =&gt; [
                                //postcss 的插件
                                require(&#39;postcss-preset-env&#39;)()
                            ]
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>在 package.json 文件中添加如下内容，在开发环境中兼容最新版本的各浏览器，在生产环境中兼容 99.8% 的浏览器，不要已经 dead 和 op_mini 浏览器</p>
<pre><code>&quot;browserslist&quot;: &#123;
    &quot;development&quot;: [
        &quot;last 1 chrome version&quot;,
        &quot;last 1 firefox version&quot;,
        &quot;last 1 safari version&quot;
    ]
    &quot;production&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not op_mini all&quot;
    ]
&#125;</code></pre>
<h3 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h3><p>使用插件 optimize-css-assets-webpack-plugin 进行压缩</p>
<p>安装 <code>npm i optimize-css-assets-webpack-plugin -D</code></p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    MiniCssExtractPlugin.loader,
                    &#39;css-loader&#39;,
                    &#123;
                        loader:&#39;postcss-loader&#39;,
                        options:&#123;
                            ident: &#39;postcss&#39;,
                            plugins: () =&gt; [
                                //postcss 的插件
                                require(&#39;postcss-preset-env&#39;)()
                            ]
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<h3 id="js-语法检查-eslint"><a href="#js-语法检查-eslint" class="headerlink" title="js 语法检查 eslint"></a>js 语法检查 eslint</h3><p>在 webpack 中通过 eslint-loader 进行语法检查，eslint-loader 依赖于 eslint 库，因此需要安装两者，<code>npm i eslint-loader eslint -D</code></p>
<p>注意：语法检查只检查自己写的源代码，第三方的库是不用检查的</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.js$/,
                exclude: /node_modules/, //不检查 node_modules 中的第三方库
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true //自动修复 eslint 的错误
                &#125;
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>这里使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-config-airbnb-base">airbnb 代码规范</a>对 eslint 进行配置，还需要下载库 eslint-config-airbnb-base 和 eslint-plugin-import</p>
<p>在 package.json 中的 eslintConfig 中设置</p>
<pre><code>“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;
&#125;</code></pre>
<p>项目上线时无需 console.log 语句，可在源代码中的 console.log 语句的上一行加上 <code>//eslint-disable-next-line</code> 使得下一行 eslint 所有规则都失效，即不对下一行进行 eslint 检查</p>
<h3 id="js-兼容性处理-eslint"><a href="#js-兼容性处理-eslint" class="headerlink" title="js 兼容性处理 eslint"></a>js 兼容性处理 eslint</h3><p>在 IE 浏览器中不能识别 ES6 语法，因此需要对 js 进行兼容性处理，将 ES6 语法转换为 ES5 及以下的语法</p>
<p>在 webpack 中通过使用 babel-loader，同时还需要下载 @babel/core 和 @babel/preset-env</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.js$/,
                exclude: /node_modules/, //不检查 node_modules 中的第三方库
                loader:&#39;babel-loader&#39;,
                options:&#123;
                    presets:[&#39;@babel/preset-env&#39;] //预设：指示 babel 做怎样的兼容性处理
                &#125;
            &#125;
        ],
        plugins:[
            new HtmlWebpackPlugin(&#123;
                template:&#39;./src/index.html&#39;
            &#125;)
        ],
        mode: &#39;development&#39;
    &#125;
&#125;</code></pre>
<p>其中在 babel-loader 的配置 presets 中 </p>
<pre><code>1、@babel/preset-env 
    实现基本 js 兼容性处理
    问题：只能转换基本语法，如 promise 等高级不能转换
2、@babel/polyfill 
    可对全部 js 做兼容性处理，注意它不是作为插件在配置中设置，只需在 js 源代码中使用 import &#39;@babel/polyfill&#39; 引入即可
    问题：往往只需解决部分兼容性问题，但它会将所有兼容性代码全部引入，使得代码文件体积太大了
3、core-js
    按需加载，需要做兼容性处理的就做，同时 presets 设置需改为
    presets:[
        [
            &#39;@babel/preset-env&#39;,
            &#123;
                //按需加载
                useBuiltIns: &#39;usage&#39;,
                //指定 core-js 版本
                corejs: &#123;
                    version: 3
                &#125;,
                //指定兼容性做到哪个版本浏览器
                targets: &#123;
                    chrome: &#39;60&#39;,
                    firefox: &#39;60&#39;,
                    ie: &#39;9&#39;,
                    safari: &#39;10&#39;,
                    edge: &#39;17&#39;
                &#125;
            &#125;
        ]
    ]</code></pre>
<p>通过 1、3 或 1、2（一般不用） 搭配使用</p>
<h3 id="压缩-html-和-js"><a href="#压缩-html-和-js" class="headerlink" title="压缩 html 和 js"></a>压缩 html 和 js</h3><p>要完成 js 的压缩只需将 webpack.config.js 文件中的 mode 设置为 production 即可，因为生产环境下会自动压缩 js 代码</p>
<p>要完成 html 代码的压缩只需在 webpack.config.js 文件中的 plugin 中进行设置</p>
<pre><code>plugins:[
    new HtmlWebpackPlugin(&#123;
        template:&#39;./src/index.html&#39;,
        //压缩 html 代码
        minify: &#123;
            //移除空格
            collapseWhitespace: true,
            //移除注释
            removeComments: true
        &#125;
    &#125;)
]</code></pre>
<p>注意：html 代码无需做兼容性处理，浏览器认识就认识，不认识就不认识</p>
<h3 id="生产环境基本配置"><a href="#生产环境基本配置" class="headerlink" title="生产环境基本配置"></a>生产环境基本配置</h3><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
//复用 loader
const commonCssLoader = [
    MiniCssExtractPlugin.loader,
    &#39;css-loader&#39;,
    &#123;
        //还需要在 package.json 中定义 browserslist
        loader:&#39;postcss-loader&#39;,
        options:&#123;
            ident: &#39;postcss&#39;,
            plugins: () =&gt; [
                require(&#39;postcss-preset-env&#39;)()
            ]
        &#125;
    &#125;
]
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //处理 css
            &#123;
                test:/\.less$/,
                use:[...commonCssLoader]
            &#125;,
            //处理 less
            &#123;
                test:/\.css$/,
                use:[...commonCssLoader,&#39;less-loader&#39;]
            &#125;,
            //js 语法检查
            &#123;
                //还需在 package.json 中配置 eslintConfig
                test:/\.js$/,
                exclude: /node_modules/,
                enforce: &#39;pre&#39;, //优先执行
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true
                &#125;
            &#125;,
            // js 兼容性处理
            &#123;
                test:/\.js$/,
                exclude: /node_modules/,
                loader:&#39;babel-loader&#39;,
                options:&#123;
                    presets:[
                        [
                            &#39;@babel/preset-env&#39;,
                            &#123;
                                useBuiltIns: &#39;usage&#39;,
                                corejs: &#123;
                                    version: 3
                                &#125;,
                                targets: &#123;
                                    chrome: &#39;60&#39;,
                                    firefox: &#39;60&#39;,
                                    ie: &#39;9&#39;,
                                    safari: &#39;10&#39;,
                                    edge: &#39;17&#39;
                                &#125;
                            &#125;
                        ]
                    ]
                &#125;
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;,
                options:&#123;
                    limit:8*1024,
                    esModule: false,
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                &#125;
            &#125;,
            //处理 html 中 img 资源
            &#123;
                test:/\.html$/,
                loader:&#39;html-loader&#39;
            &#125;,
            //处理其他资源
            &#123;
                exclude:/\.(css|js|html|less|jpg|png|gif)/,
                loader:&#39;file-loader&#39;,
                options:&#123;
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                &#125;
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;,
            minify: &#123;
                collapseWhitespace: true,
                removeComments: true
            &#125;
        &#125;);
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    //模式
    mode: &#39;production&#39;
&#125;</code></pre>
<p>还需在 package.json 文件中添加如下内容</p>
<pre><code>&quot;browserslist&quot;: &#123;
    &quot;development&quot;: [
        &quot;last 1 chrome version&quot;,
        &quot;last 1 firefox version&quot;,
        &quot;last 1 safari version&quot;
    ]
    &quot;production&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not op_mini all&quot;
    ]
&#125;,
“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;
&#125;</code></pre>
<p>注意：正常来讲一个文件只能被一个 loader 处理，当一个文件要被多个 loader 处理时，一定要指定 loader 的执行现后顺序，如 js 的语法检查和兼容性处理需要先执行 eslint 再执行 babel</p>
<p>原因1：先做语法检查，若语法检查出现错误后续工作无意义</p>
<p>原因2：使用 babel 后会把 ES6 语法转为 ES5 及以下语法，若此时再使用 eslint 进行语法检查又会报错，如 var 等不好用</p>
<h2 id="10、性能优化"><a href="#10、性能优化" class="headerlink" title="10、性能优化"></a>10、性能优化</h2><p>webpack 的性能优化包括开发环境性能优化和生产环境性能优化</p>
<h3 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h3><p>开发环境性能优化包括（1）优化打包构建速度（通过 HMR）（2）优化代码调试（通过 source-map）</p>
<h4 id="（1）优化打包构建速度-————-HMR"><a href="#（1）优化打包构建速度-————-HMR" class="headerlink" title="（1）优化打包构建速度 ———— HMR"></a>（1）优化打包构建速度 ———— HMR</h4><p><strong>问题1：</strong>在开发环境中若只修改 css 样式文件或只修改了某个文件，其他文件没有变动，但 webpack 会把 css、js 等文件一起全部重新打包一次</p>
<p><strong>解决：</strong>可通过 webpack 的 HMR（hot module replacement 热模块替换/模块热替换）功能，HMR 是基于 devServer 的</p>
<p><strong>作用：</strong>一个模块发生变化，只会重新打包这个模块，而不是打包所有模块，极大提升了构建速度</p>
<p>只需修改 webpack.config.js 文件中的 devServer 设置，添加语句 <code>hot: true</code> 开启 HMR 功能</p>
<pre><code>devServer:&#123;
    contentBase: resolve(__dirname,&#39;build&#39;), 
    compress: true,
    port: 3000,
    open: true,
    //开启 HMR 功能
    hot: true
&#125;,</code></pre>
<p>启动 webpack 服务：<code>npx webpack-dev-server</code></p>
<p><strong>问题2：</strong></p>
<p>样式文件：可以使用 HMR 功能，因为 style-loader 内部实现了</p>
<p>js 文件：默认不能使用 HMR 功能</p>
<p>html 文件：默认不能使用 HMR 功能，同时会导致 html 文件不能热更新了</p>
<p><strong>解决：</strong>修改 webpack.config.js 文件中的 entry 入口，将 html 文件加入，此时若修改 html 文件能热更新了，整个页面重新刷新，依然不能使用 HMR 功能（但是 html 无需 HMR 功能，因为项目中只会创建一个 html 文件，当该文件发生变化时自然也需要重新加载这个文件）</p>
<pre><code>entry:[&#39;./src/js/index.js&#39;,&#39;./src/index.html&#39;]</code></pre>
<p>在 index.js 文件中添加如下代码让 js 文件的 HMR 功能生效</p>
<pre><code>if(module.hot)&#123;
    //一旦 module.hot 为 true，说明开启了 HMR 功能
    module.hot.accept(./xxx1.js,function()&#123;
        //方法会监听 xxx.js 文件的变化，一旦发生变化，其他模块不会重新打包构建，会执行回调函数
        print();
    &#125;);
    module.hot.accept(./xxx2.js,function()&#123;
        print();
    &#125;)
&#125;</code></pre>
<p>此时若修改 xxx1.js 文件或 xxx2.js 文件只会重新加载相应文件</p>
<p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件</p>
<p>注意：当修改了 webpack 配置，新配置要想生效，必须重新启动 webpack 服务</p>
<h4 id="（2）优化代码调试-————-source-map"><a href="#（2）优化代码调试-————-source-map" class="headerlink" title="（2）优化代码调试 ———— source-map"></a>（2）优化代码调试 ———— source-map</h4><p>source-map 是一种提供源代码到构建后代码映射的技术，若构建后代码出错了，会通过映射关系可以追踪源代码错误</p>
<p>在 webpack.config.js 文件中添加</p>
<pre><code>devtool: &#39;source-map&#39;</code></pre>
<p>打包后会在 js 的输出文件夹下生成 built.js.map 文件</p>
<p>devtool 的参数有<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code>，其中</p>
<pre><code>source-map：外部，能提供错误代码的准确信息和源代码的错误位置（第几行）
inline-source-map：内联，只生成一个 source-map，能提供错误代码的准确信息和源代码的错误位置
hidden-source-map：外部，能提供代码错误的原因，不能追踪源代码错误，只能提示构建后代码的错误位置（可以半隐藏源代码）
eval-source-map：内联，每个文件都生成对应的 source-map，都在 eval 中，能提供错误代码的准确信息和源代码的错误位置（第几行），只是在错误文件名中多了个哈希值
nosources-source-map：外部，能提供错误代码的准确信息，但没有任何源代码信息（可以隐藏源代码）
cheap-source-map：外部，能提供错误代码的准确信息和源代码的错误位置，但只能精确到行，而前面的方式（如 source-map 可精确到行列）
cheap-module-source：外部，能提供错误代码的准确信息和源代码的错误位置，但只能精确到行，module 会将 loader 的 source-map 加入</code></pre>
<p><strong>外部方式和内联方式的区别：</strong>（1）使用外部方式会生成 built.js.map 文件，而使用内联方式不会生成文件，而是嵌入在 built.js 文件中，（2）但内联的构建速度更快</p>
<p>开发环境下：需要速度快，调试更友好</p>
<pre><code>速度快（eval &gt; inline &gt; cheap &gt; ...）
    最快：eval-cheap-source-map
    其次：eval-source-map
调试更友好
    最友好：source-map
    其次：cheap-module-source-map
    再其次：cheap-source-map
综合：可选择 eval-source-map 或 eval-cheap-module-source-map</code></pre>
<p>生产环境下：需要考虑源代码要不要隐藏？调试要不要更友好？</p>
<p>由于内联会让代码体积变大，所以在生产环境不用内联</p>
<pre><code>考虑源代码隐藏
    nosources-source-map（全部隐藏）
    hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息和位置）
调试更友好
    source-map
    同时速度更快点：cheap-module-source-map</code></pre>
<h3 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h3><p>生产环境性能优化包括（1）优化打包构建速度（oneOf、babel缓存、多进程打包、externals、DLL）（2）优化代码运行的性能（文件资源缓存、tree shaking、code split、懒加载/预加载、PWA）</p>
<h4 id="（1）优化打包构建速度"><a href="#（1）优化打包构建速度" class="headerlink" title="（1）优化打包构建速度"></a>（1）优化打包构建速度</h4><p><strong>问题：</strong>一般一个文件只会使用一种 loader 进行处理（除了 js 文件需要 eslint-loader 和 babel-loader 两种进行处理），但是每加载一个文件都会把所有 loader 过一遍，影响速度</p>
<h5 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h5><p><strong>解决1：</strong>通过将 webpack.config.js 中的各种 loader 放在 oneOf 中，并把 eslint-loader 单独放到 oneOf 前面</p>
<pre><code>module:&#123;
    rules:[
        //js 语法检查
        &#123;
            //还需在 package.json 中配置 eslintConfig
            test:/\.js$/,
            exclude: /node_modules/,
            enforce: &#39;pre&#39;, //优先执行
            loader:&#39;eslint-loader&#39;,
            options:&#123;
                fix:true
            &#125;
        &#125;,
        &#123;
            //以下 loader 只会匹配一个，不能有两个配置处理同一种类型文件
            oneOf:[
                //处理 css
                &#123;
                    test:/\.less$/,
                    use:[...commonCssLoader]
                &#125;,
                //处理 less
                &#123;
                    test:/\.css$/,
                    use:[...commonCssLoader,&#39;less-loader&#39;]
                &#125;,
                // js 兼容性处理
                &#123;
                    test:/\.js$/,
                    exclude: /node_modules/,
                    loader:&#39;babel-loader&#39;,
                    options:&#123;
                        presets:[
                            [
                                &#39;@babel/preset-env&#39;,
                                &#123;
                                    useBuiltIns: &#39;usage&#39;,
                                    corejs: &#123;
                                        version: 3
                                    &#125;,
                                    targets: &#123;
                                        chrome: &#39;60&#39;,
                                        firefox: &#39;60&#39;,
                                        ie: &#39;9&#39;,
                                        safari: &#39;10&#39;,
                                        edge: &#39;17&#39;
                                    &#125;
                                &#125;
                            ]
                        ]
                    &#125;
                &#125;,
                //处理图片资源
                &#123;
                    test:/\.(jpg|png|gif)$/,
                    loader:&#39;url-loader&#39;,
                    options:&#123;
                        limit:8*1024,
                        esModule: false,
                        name:&#39;[hash:10].[ext]&#39;,
                        outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                    &#125;
                &#125;,
                //处理 html 中 img 资源
                &#123;
                    test:/\.html$/,
                    loader:&#39;html-loader&#39;
                &#125;,
                //处理其他资源
                &#123;
                    exclude:/\.(css|js|html|less|jpg|png|gif)/,
                    loader:&#39;file-loader&#39;,
                    options:&#123;
                        name:&#39;[hash:10].[ext]&#39;,
                        outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                    &#125;
                &#125;
            ]
        &#125;
    ]
&#125;,</code></pre>
<h5 id="缓存-————-babel-缓存"><a href="#缓存-————-babel-缓存" class="headerlink" title="缓存 ———— babel 缓存"></a>缓存 ———— babel 缓存</h5><p><strong>问题：</strong>修改某个 js 文件后其他未变动的 js 无需重新编译，但 HMR 是基于 devServer 的，所以在生产环境中无法使用</p>
<p><strong>解决：</strong>babel 缓存————让第二次打包构建速度更快</p>
<p>只需在 babel-loader 中进行设置</p>
<pre><code>&#123;
    test:/\.js$/,
    exclude: /node_modules/,
    loader:&#39;babel-loader&#39;,
    options:&#123;
        presets:[
            [
                &#39;@babel/preset-env&#39;,
                &#123;
                    useBuiltIns: &#39;usage&#39;,
                    corejs: &#123;
                        version: 3
                    &#125;,
                    targets: &#123;
                        chrome: &#39;60&#39;,
                        firefox: &#39;60&#39;,
                        ie: &#39;9&#39;,
                        safari: &#39;10&#39;,
                        edge: &#39;17&#39;
                    &#125;
                &#125;
            ]
        ],
        //开启 babel 缓存，第二次构建时会读取之前的缓存
        cacheDirectory: true
    &#125;
&#125;,</code></pre>
<h5 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h5><p>通过 thread-loader 库进行多进程打包，在webpack.config.js 配置文件的 babel-loader 中添加 thread-loader</p>
<p>进程启动大概为 600ms，进程通信也有开销，只有工作消耗事件比较长，才需要多进程打包，若乱用反而会增加打包时间</p>
<p>一般 js 代码较多 babel 干的活久时使用多进程打包的加速效果更明显</p>
<pre><code>&#123;
    test:/\.js$/,
    exclude: /node_modules/,
    use: [
        //开启多进程打包
        &#123;
            loader:&#39;thread-loader&#39;,
            options:&#123;
                workers: 2 //2个进程
            &#125;
        &#125;,
        &#123;
            loader:&#39;babel-loader&#39;,
            options:&#123;
                presets:[
                    [
                        &#39;@babel/preset-env&#39;,
                        &#123;
                            useBuiltIns: &#39;usage&#39;,
                            corejs: &#123;
                                version: 3
                            &#125;,
                            targets: &#123;
                                chrome: &#39;60&#39;,
                                firefox: &#39;60&#39;,
                                ie: &#39;9&#39;,
                                safari: &#39;10&#39;,
                                edge: &#39;17&#39;
                            &#125;
                        &#125;
                    ]
                ],
                //开启 babel 缓存，第二次构建时会读取之前的缓存
                cacheDirectory: true
            &#125;
        &#125;
    ]
&#125;,</code></pre>
<h5 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h5><p>externals 防止将某些包打包到最终输出的 bundle 中，如想要 jQuery 通过 CDN 链接引入，就要禁止将它打包</p>
<p>在 webpack.config.js 文件中添加 externals</p>
<pre><code>externals: &#123;
    //忽略库名（npm 包名）
    jquery: &#39;jQuery&#39; //拒绝 jQuery 被打包进来
&#125; </code></pre>
<p>不打包就要在 html 中通过 <code>&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</code> 引入 jQuery 才能使用</p>
<h5 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h5><p>DLL 可以对代码进行单独打包</p>
<p>和 externals 类似，DLL 也是禁止一些库被打包进来，不同的是 DLL<br>会对一些库进行单独打包，在上面的 code split 代码分割中是把 node_modules 所有第三方库打包成一个 chunk，而 DLL 会把不同库分开打包</p>
<p>externals 中还需要通过 CDN 引入第三方库，而 DLL 会自动引入自己打包的第三方库</p>
<p>使用 dll 技术对某些第三方库（如 jQuery、react、vue…）进行单独打包</p>
<p>需要新建文件 webpack.dll.js 写入如下内容</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);
module.exports = &#123;
    entry: &#123;
        //打包生成的名字[name]: [&#39;要打包的库&#39;]
        jquery: [&#39;jquery&#39;]
    &#125;,
    output: &#123;
        filename: &#39;[name].js&#39;,
        path: resolve(__dirname,&#39;dll&#39;),
        library: &#39;[name]_[hash]&#39;, //打包的库里向外暴露出去的内容叫什么名字
    &#125;,
    plugins: [
        //打包生成一个 manifest.json 告诉 webpack 说 jQuery 不需要打包，并且提供和 jQuery 映射
        new webpack.DllPlugin(&#123;
            name: &#39;[name]_[hash]&#39;,  //映射库的暴露的内容名称
            path: resolve(__dirname,&#39;dll/manifest.json&#39;)  //最终这个库输出到哪里去
        &#125;)
    ],
    mode: &#39;production&#39;
&#125;</code></pre>
<p>运行打包 <code>webpack --config webpack.dll.js</code>，因为运行 webpack 时默认查找 webpack.config.js 配置文件，要想运行 webpack.dll.js 配置，需要使用 –config 参数指定</p>
<p>打包后会生成 dll/jquery.js 和 dll/manifest.json，只需打包一次，此后 jQuery 无需再重复打包</p>
<p>下载 add-asset-html-webpack-plugin 包</p>
<pre><code>npm i add-asset-html-webpack-plugin -D</code></pre>
<p>在 webpack.config.js 文件中同样引入 webpack 和 add-asset-html-webpack-plugin</p>
<pre><code>const webpack = require(&#39;webpack&#39;);
const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;);</code></pre>
<p>在 webpack.config.js 文件 的 plugins 中添加</p>
<pre><code>//告诉 webpack 哪些库不参与打包，同时使用时的名称也得变
new webpack.DllReferencePlugin(&#123;
    manifest: resolve(__dirname,&#39;dll/manifest.json&#39;)
&#125;)
//将某个文件打包输出出去，并在 html 中自动引入该资源
new AddAssetHtmlWebpackPlugin(&#123;
    filepath: resolve(__dirname,&#39;dll/jquery.js&#39;)
&#125;)</code></pre>
<p>通过上述配置就会把 jQuery 库单独打包，并在 html 中自动引入自己打包的 jQuery 库，无需再手动通过 script 标签通过 CDN 引入 jQuery</p>
<h4 id="（2）优化代码运行的性能"><a href="#（2）优化代码运行的性能" class="headerlink" title="（2）优化代码运行的性能"></a>（2）优化代码运行的性能</h4><h5 id="缓存-————-文件资源缓存"><a href="#缓存-————-文件资源缓存" class="headerlink" title="缓存 ———— 文件资源缓存"></a>缓存 ———— 文件资源缓存</h5><p>文件资源缓存————让代码上线运行缓存更好使用</p>
<p>可在打包输出的 built.js 文件名以及 css 文件名中添加 webpack 每次构建时生成的唯一 hash 值，当文件改变重新打包后生成的文件名改变则必须重新请求，不会读取缓存中的文件</p>
<p>有三种 hash 值：hash、chunkhash、contenthash</p>
<pre><code>hash：每次 webpack 构建时会生成一个 hash 值
    问题：因为 js 和 css 同时使用一个 hash 值，若重新打包会导致所有缓存失效（可能只改动了一个文件）
chunkhash：根据 chunk 生成的 hash 值，若打包来源于同一个 chunk，则 hash 值就一样
    问题：因为 css 是在 js 中被引入的，所以同属于一个 chunk，打包后都在 built.js 中，所以 js 和 css 文件的 chunkhash 还是一样的
contenthash：根据文件内容生成 hash 值，不同文件的 hash 值一定不一样</code></pre>
<p>更改后配置文件如下</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
process.env.NODE_ENV = &#39;production&#39;;
//复用 loader
const commonCssLoader = [
    MiniCssExtractPlugin.loader,
    &#39;css-loader&#39;,
    &#123;
        //还需要在 package.json 中定义 browserslist
        loader:&#39;postcss-loader&#39;,
        options:&#123;
            ident: &#39;postcss&#39;,
            plugins: () =&gt; [
                require(&#39;postcss-preset-env&#39;)()
            ]
        &#125;
    &#125;
]
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.[contenthash:10].js&#39;,  //添加 contenthash
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //js 语法检查
            &#123;
                //还需在 package.json 中配置 eslintConfig
                test:/\.js$/,
                exclude: /node_modules/,
                enforce: &#39;pre&#39;, //优先执行
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true
                &#125;
            &#125;,
            &#123;
                //以下 loader 只会匹配一个，不能有两个配置处理同一种类型文件
                oneOf:[
                    //处理 css
                    &#123;
                        test:/\.less$/,
                        use:[...commonCssLoader]
                    &#125;,
                    //处理 less
                    &#123;
                        test:/\.css$/,
                        use:[...commonCssLoader,&#39;less-loader&#39;]
                    &#125;,
                    // js 兼容性处理
                    &#123;
                        test:/\.js$/,
                        exclude: /node_modules/,
                        loader:&#39;babel-loader&#39;,
                        options:&#123;
                            presets:[
                                [
                                    &#39;@babel/preset-env&#39;,
                                    &#123;
                                        useBuiltIns: &#39;usage&#39;,
                                        corejs: &#123;
                                            version: 3
                                        &#125;,
                                        targets: &#123;
                                            chrome: &#39;60&#39;,
                                            firefox: &#39;60&#39;,
                                            ie: &#39;9&#39;,
                                            safari: &#39;10&#39;,
                                            edge: &#39;17&#39;
                                        &#125;
                                    &#125;
                                ]
                            ],
                            //开启 babel 缓存，第二次构建时会读取之前的缓存
                            cacheDirectory: true
                        &#125;
                    &#125;,
                    //处理图片资源
                    &#123;
                        test:/\.(jpg|png|gif)$/,
                        loader:&#39;url-loader&#39;,
                        options:&#123;
                            limit:8*1024,
                            esModule: false,
                            name:&#39;[hash:10].[ext]&#39;,
                            outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                        &#125;
                    &#125;,
                    //处理 html 中 img 资源
                    &#123;
                        test:/\.html$/,
                        loader:&#39;html-loader&#39;
                    &#125;,
                    //处理其他资源
                    &#123;
                        exclude:/\.(css|js|html|less|jpg|png|gif)/,
                        loader:&#39;file-loader&#39;,
                        options:&#123;
                            name:&#39;[hash:10].[ext]&#39;,
                            outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;,
            minify: &#123;
                collapseWhitespace: true,
                removeComments: true
            &#125;
        &#125;);
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.[contenthash:10].css&#39;  //添加contenthash
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    //模式
    mode: &#39;production&#39;,
    devtool: &#39;source-map&#39;
&#125;</code></pre>
<p>服务器端代码</p>
<pre><code>const express = require(&#39;express&#39;);
//创建应用对象
const app = express();
app.use(express.static(&#39;build&#39;,&#123;maxAge:1000 * 3600&#125;));
//监听端口启动服务
app.listen(8000)</code></pre>
<h5 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h5><p>tree shaking 用于去除无用代码</p>
<p>tree shaking 前提：（1）必须使用 ES6 模块化（2）mode 使用 production 环境即可自动开启 tree shaking</p>
<p>tree shaking 作用：减少代码体积，从而使得请求和加载速度更快</p>
<p>注意：在旧版本 webpack 中或设置 <code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用，即都可以进行 tree shaking，这可能把 css 或 @babel/polyfill 等副作用文件都消除掉，因此需在 package.json 中配置 <code>&quot;sideEffects&quot;: [&quot;*.css&quot;,&quot;*.less&quot;]</code></p>
<h5 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h5><p>通过 code split 代码分割把打包后的文件分成多个，这样在加载时可并行加载速度更快，且可按需加载</p>
<p>代码分割主要是关注 js 文件</p>
<p><strong>方式一：多入口</strong></p>
<p>通过在 entry 中设置多入口来拆分文件（之前的单入口方式一般用在单页面应用，多入口用于多页面应用）</p>
<pre><code>entry:&#123;
    //多入口：每个入口最终都输出一个 bundle
    index: &#39;./src/js/index.js&#39;,
    test: &#39;./src/js/test.js&#39;
&#125;,
output:&#123;
    filename: &#39;js/[name].[contenthash:10].js&#39;
    path: resolve(__dirname,&#39;build&#39;)
&#125;</code></pre>
<p><strong>方式二：splitChunks</strong></p>
<p>若使用单入口 + splitChunks 可以将 node_modules 中代码（第三方代码）单独打包一个 chunk 输出</p>
<p>若使用多入口 + splitChunks 还会自动分析多入口 chunk 中有没有公共的文件，若有则只会把该公共文件打包成一个单独的 chunk 不会重复打包多次</p>
<pre><code>entry:&#123;
    index: &#39;./src/js/index.js&#39;,
    test: &#39;./src/js/test.js&#39;
&#125;,
output:&#123;
    filename: &#39;js/[name].[contenthash:10].js&#39;
    path: resolve(__dirname,&#39;build&#39;)
&#125;,
optimization: &#123;
    splitChunks: &#123;
        chunks: &#39;all&#39;
    &#125;
&#125;,</code></pre>
<p>上述配置中若 index.js 和 test.js 都引入了 jQuery，则打包后会生成三个 bundle 分别对应 index.js、test.js 和 jQuery</p>
<p><strong>方式三：import 动态导入语法</strong></p>
<p>修改 js 代码，使用 impor 动态导入语法，让某个文件被单独打包成一个 chunk</p>
<p>在某 js 文件（如 index.js）中引入另一 js 文件时不使用 <code>import &#123;mul,red&#125; from &#39;./xxx.js&#39;</code>，而使用如下方式</p>
<pre><code>import(/* webpackChunkName: &#39;打包后的文件名&#39; */&#39;./xxx.js)
    .then((&#123;mul,red&#125;) =&gt; &#123;
        //eslint-disable-next-line
        console.log(mul(1,2));
    &#125;)
    .cache(() =&gt; &#123;
        //eslint-disable-next-line
        console.log(&#39;文件加载失败&#39;);
    &#125;);</code></pre>
<p>其中 xxx.js 中定义了 mul 和 red 两个方法</p>
<pre><code>export function mul(x, y) &#123;
    return x * y;
&#125;
export function red(x, y) &#123;
    return x - y;
&#125;</code></pre>
<p>打包后会生成两个 bundle 分别对应 index.js 和 xxx.js</p>
<p>注意：一般多入口使用较少，会使用单入口 + splitChunks，并把其他要单独打包的 js 文件使用 import 动态导入语法来完成</p>
<h5 id="js-的懒加载和预加载"><a href="#js-的懒加载和预加载" class="headerlink" title="js 的懒加载和预加载"></a>js 的懒加载和预加载</h5><p>懒加载：当文件需要使用时才加载，是通过把代码分割的 import 动态导入语法放在一个异步函数中来实现</p>
<p>预加载：在使用之前提前加载 js 文件，但兼容性较差</p>
<p>正常加载是并行加载，即同一时间加载多个文件，而预加载是等其他资源加载完毕，浏览器空闲了再偷偷加载资源</p>
<p>如在 index.js 中编写点击按钮触发 xxx.js 中定义的方法</p>
<pre><code>document.getElementById(&#39;btn&#39;).onclick = function()&#123;
    //懒加载和预加载（webpackPrefetch）
    import(/* webpackChunkName: &#39;xxx&#39;, webpackPrefetch: true */&#39;./xxx.js)
    .then((&#123;mul&#125;) =&gt; &#123;
        //eslint-disable-next-line
        console.log(mul(1,2));
    &#125;)
&#125;</code></pre>
<h5 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h5><p>PWA（渐进式网络应用开发程序）让网页向 app 一样可以离线访问，性能也会更好</p>
<p>PWA 通过 workbox 实现，在 webpack 中通过使用 workbox-webpack-plugin 插件</p>
<p>下载后，在 webpack.config.js 文件中引入 workbox-webpack-plugin</p>
<pre><code>const WorkboxWebpackPlugin = require(&#39;workbox-webpack-plugin&#39;)</code></pre>
<p>在 webpack.config.js 文件中的 plugins 里添加</p>
<pre><code>new WorkboxWebpackPlugin.GenerateSW(&#123;
    clientsClaim: true, //删除旧的 serviceworker
    skipWaiting: true //帮助 serviceworker 快速启动
&#125;)//会生成一个 serviceworker 配置文件</code></pre>
<p>在 index.js 中添加如下代码</p>
<pre><code>if(&#39;serviceWorker&#39; in navigator)&#123;
    window.addEventListener(&#39;load&#39;,() =&gt; &#123;
        navigator.serviceWorker
            .register(&#39;/service-worker.js&#39;) //注册 serviceworker
            .then(() =&gt; &#123;
                console.log(&#39;sw注册成功&#39;);
            &#125;)
            .catch(() =&gt; &#123;
                console.log(&#39;sw注册失败&#39;);
            &#125;);
    &#125;);
&#125;</code></pre>
<p>eslint 不认识 window、navigator 全局变量，因此需要在 package.json 中 eslintConfig 修改为</p>
<pre><code>“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;,
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true
    &#125;
&#125;</code></pre>
<p>serviceworker 代码必须运行在服务器上，这里通过 serve 包快速构建一个服务器进行测试，下载 serve 包 <code>npm -i serve -g</code>，再启动服务器 <code>serve -s build</code> 其中 build 表示打包后的目录，将 build 目录下所有资源作为静态资源暴露出去</p>
<h1 id="二、webpack-配置详解"><a href="#二、webpack-配置详解" class="headerlink" title="二、webpack 配置详解"></a>二、webpack 配置详解</h1><h2 id="1、entry"><a href="#1、entry" class="headerlink" title="1、entry"></a>1、entry</h2><p>entry 的值可以是 string、array、object，一般用 string 和 object 较多</p>
<p><strong>string：单入口 ———— ‘./src/index.js’</strong></p>
<p>打包形成一个 chunk，输出一个 bundle 文件，此时 chunk 名称默认是 main</p>
<p><strong>array：多入口 ———— [‘./src/index.js’,’./src/xxx.js’]</strong></p>
<p>所有入口文件最终只会形成一个 chunk，输出只有一个 bundle 文件 默认是 main.js（当 output 中 filename 是 [name].js 时）</p>
<p>一般用在 HMR 功能中让 html 热更新生效</p>
<p><strong>object：多入口 ———— {index: ‘./src/index.js’, xxx: ‘./src/xxx.js’}</strong></p>
<p>有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 名称是 key</p>
<p><strong>特殊用法：</strong></p>
<pre><code>entry: &#123;
    index:[&#39;./src/index.js&#39;,&#39;./src/mul.js&#39;], //mul 和 index 形成一个 chunk 打包输出在一个 bundle 文件中
    add: &#39;./src/add.js&#39;  //形成一个 chunk，输出一个 bundle
&#125;</code></pre>
<h2 id="2、output"><a href="#2、output" class="headerlink" title="2、output"></a>2、output</h2><p>output 中可以设置</p>
<p>filename ———— 文件名称（指定该名称 + 目录）</p>
<pre><code>filename: &#39;js/[name].js&#39;</code></pre>
<p>path ———— 输出文件目录（将来所有资源输出的公共目录）</p>
<pre><code>path: resolve(__dirname,&#39;build&#39;)</code></pre>
<p>publicPath ———— 所有资源引入时的公共路径前缀，一般用于生产环境</p>
<pre><code>publicPath: &#39;/&#39; //当引入 imgs/a.jpg 时路径为 /imgs/a.jpg</code></pre>
<p>chunkFilename ———— 非入口 chunk 的名称（entry 中指定的就是入口文件）</p>
<p>如使用 import 动态导入语法进行代码单独打包时，打包输出的文件按 chunkFilename 指定的规则命名，若不修改名称默认使用 filename，这会与入口文件的输出文件名称冲突，webpack 会自动修改导入文件的打包后文件名称，命名方式可能不方便使用</p>
<pre><code>chunkFilename: &#39;js/[name]_chunk.js&#39;</code></pre>
<p>library ———— 整个库向外暴露的变量名，一般配合 dll 使用</p>
<pre><code>library: &#39;[name]&#39;</code></pre>
<p>libraryTarget ———— 变量名添加到哪里</p>
<pre><code>libraryTarget: &#39;window&#39; //将库添加到浏览器的 window 上
libraryTarget: &#39;global&#39; //添加到 node 上
libraryTarget: &#39;commonjs&#39;
libraryTarget: &#39;amd&#39;</code></pre>
<h2 id="3、module"><a href="#3、module" class="headerlink" title="3、module"></a>3、module</h2><pre><code>module: &#123;
    rules: [
        //loader 配置
        &#123;
            test: /\.css$/
            //多个 loader 用 use
            use: [&#39;style-loader&#39;,&#39;&#39;css-loader]
        &#125;,
        &#123;
            test: /\.js$/
            //排除 node_modules 下的 js 文件
            exclude: /node_modules/,
            //只检查 src 目录下的 js 文件
            include: resolve(__dirname, &#39;src&#39;),
            //优先执行
            enforce: &#39;pre&#39;,
            //延后执行 enforce: &#39;post&#39;,
            //单个 loader 用 loader
            loader: &#39;eslint-loader&#39;,
            options: &#123;&#125;
        &#125;,
        &#123;
            //以下配置只会生效一个
            oneOf: []
        &#125;
    ]
&#125;</code></pre>
<h2 id="4、resolve"><a href="#4、resolve" class="headerlink" title="4、resolve"></a>4、resolve</h2><p>resolve 用于解析模块的规则</p>
<p>参数 alias ———— 配置解析模块路径别名：优点简写路径，缺点路径没有提示</p>
<p>参数 extensions ———— 配置省略文件路径的后缀名，默认值是 .js 和 .json</p>
<p>参数 modules ———— 告诉 webpack 解析模块是去哪个目录找加快解析速度</p>
<p>在 webpack.config.js 中添加</p>
<pre><code>resolve:&#123;
    alias: &#123;
        $css: resolve(__dirname, &#39;src/css&#39;)
    &#125;,
    extensions: [&#39;.js&#39;,&#39;.json&#39;, &#39;.jsx&#39;, &#39;.css&#39;]
    modules: [resolve(__dirname, &#39;../../node_modules&#39;), &#39;node_modules&#39;]
&#125;</code></pre>
<h2 id="5、devServer"><a href="#5、devServer" class="headerlink" title="5、devServer"></a>5、devServer</h2><p>devServer 用于开发环境</p>
<pre><code>devServer:&#123;
    contentBase:resolve(__dirname,&#39;build&#39;), //要运行的项目构建后的目录
    watchContentBase: true, //监视 contentBase 目录下的所有文件，一旦文件变化就会 reload
    watchOptions: &#123;
        //忽略文件
        ignored: /node_modules/
    &#125;
    compress:true,  //启动 gzip 压缩，使代码更小运行更快
    port:5000,  //端口号
    open:true,  //自动打开浏览器
    hot: true,  //开启 HMR 功能
    clientLogLevel: &#39;none&#39;, //不显示启动服务器日志信息
    quiet: true, //除了一些基本启动信息外，其他内容都不要显示
    overlay: false, //如果出错不要全屏提示，在日志中打印出来就好
    proxy: &#123; //服务器代理，解决开发环境跨域问题（浏览器和服务器间有跨域问题，服务器和服务器间没有跨域问题）
        &#39;/api&#39;: &#123;
            target: &#39;http://localhost:3000&#39;, //一旦 devServer（5000）服务器接收到 /api/xxx 的请求，就会把请求转发到另一个服务器（3000）
            pathRewrite: &#123; //发送请求时，请求路径重写
                &#39;^/api&#39;:&#39;&#39; //将 /api/xxx 重写为 /xxx（去掉 /api）
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="6、optimization"><a href="#6、optimization" class="headerlink" title="6、optimization"></a>6、optimization</h2><p>optimization 在生产环境中才有意义</p>
<p>参数 splitChunks 用于提取公共代码成单独 chunk 打包</p>
<p>参数 runtimeChunk 将当前模块中记录其他模块 hash 的部分单独打包为一个文件，当 a 模块发生变化时 a 文件以及对应的 runtime 文件重新打包，而其他引用 a 的模块不重新打包 ———— 解决修改 a 文件导致 b 文件的 contenthash 变化产生的缓存失效需要重新打包 b 的问题</p>
<p>因此写代码分割时一定要加上 runtimeChunk，否则会导致缓存失效</p>
<p>参数 minimizer 配置生产环境的压缩方案（针对 js 和 css）</p>
<p>在 webpack 4.26 之前是使用 UglifyJsPlugin 插件进行 js 压缩，之后的版本是使用 terser-webpack-plugin 插件进行压缩</p>
<pre><code>const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);
optimization: &#123;
    splitChunks: &#123;
        chunks: &#39;all&#39;,
        //下面设置的这些都是用的默认值
        minSize: 30 * 1024, //分割的 chunk 最小为 30kb（即文件大于 30kb 才会分割）
        minChunks: 1, //要提取的 chunk 最少被引用 1 次
        maxAsyncRequests: 5, //按需加载时并行加载在的文件最大数量（所以最多也只会打包成相应数量 chunk）
        maxInitialRequests: 3, //入口 js 文件最大并行请求数量
        automaticNameDelimiter: &#39;~&#39;, //名称连接符
        name: true, //可以使用命名规则
        cacheGroups: &#123; //分割 chunk 的组
            vendors: &#123;
                test: /[\\/]node_modules[\\/]/, //node_modules 文件（也需满足上面规则如大小超过 30kb，至少被引用一次）会被打包到 vendors 组的 chunk 中，即会输出 vendors~xxx.js
                priority: -10  //打包的优先级
            &#125;,
            default:&#123;
                minChunks: 2, //要提取的 chunk 最少被引用 2 次
                priority: -20, //打包优先级
                reuseExistingChunk: true //若当前要打包的模块和之前已经被提取的模块是同一个就会复用，而不是重新打包模块
            &#125;
        &#125;
    &#125;,
    runtimeChunk: &#123;
        name: entrypoint =&gt; `runtime-$&#123;entrypoint.name&#125;`
    &#125;,
    minimizer: [
        new TerserWebpackPlugin(&#123;
            cache: true, //开启缓存
            parallel: true, //开启多进程打包，速度更快
            sourceMap: true //启动 source-map
        &#125;)
    ]
&#125;,</code></pre>
<h1 id="三、webpack-5"><a href="#三、webpack-5" class="headerlink" title="三、webpack 5"></a>三、webpack 5</h1><h2 id="1、使用-webpack-5"><a href="#1、使用-webpack-5" class="headerlink" title="1、使用 webpack 5"></a>1、使用 webpack 5</h2><p>首先初始化 npm <code>npm init</code></p>
<p>下载 webpack 5 <code>npm i webpack@next webpack-cli -D</code></p>
<p>在 webpack 5 中 webpack.config.js 配置文件中只有 mode 是需要设置的其他可使用默认值，这不同于 webpack 4，在 webpack 4 中需要设置 entry、output、mode</p>
<p>同样使用命令 <code>webpack</code> 打包</p>
<p>webpack 5 中默认输出的目录是 dist</p>
<p>其中 webpack 5 中使用的默认值如下</p>
<pre><code>entry: &quot;./src/index.js&quot;
output.path: path.resolve(__dirname, &quot;dist&quot;)
output.filename: &quot;[name].js&quot;</code></pre>
<h2 id="2、webpack-5-重点关注的内容"><a href="#2、webpack-5-重点关注的内容" class="headerlink" title="2、webpack 5 重点关注的内容"></a>2、webpack 5 重点关注的内容</h2><p><strong>（1）</strong>通过持久缓存提高构建性能</p>
<p><strong>（2）</strong>使用更好的算法和默认值来改善长期缓存（如 hash 值的相关算法）</p>
<p><strong>（3）</strong>通过更好的 tree shaking 和代码生产来改善 bundle 大小</p>
<p>（4）清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改</p>
<p>（5）通过引入重大更改来为将来的功能做准备，使我们能尽可能长时间使用 v5</p>
<h2 id="3、一些特点"><a href="#3、一些特点" class="headerlink" title="3、一些特点"></a>3、一些特点</h2><h3 id="自动删除-Node-js-Polyfills"><a href="#自动删除-Node-js-Polyfills" class="headerlink" title="自动删除 Node.js Polyfills"></a>自动删除 Node.js Polyfills</h3><p>早期 webpack 的目标是允许在浏览器中允许大多数 node.js 模块，但模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的，webpack &lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用，尽管这使使用 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中，许多情况下，这些 polyfill 是不必要的，webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块</p>
<p>在 webpack 5 中尽可能尝试使用与前端兼容的模块。可为 node.js 核心模块手动添加一个 polyfill，错误消息会提示如何实现</p>
<h3 id="chunk-和-模块-ID"><a href="#chunk-和-模块-ID" class="headerlink" title="chunk 和 模块 ID"></a>chunk 和 模块 ID</h3><p>添加了用于长期缓存的新算法（更优化的 hash 值算法），在生产模式下默认启用这些功能</p>
<pre><code>chunkIds:&quot;deterministic&quot;, moduleIds:&quot;deterministic&quot;</code></pre>
<h3 id="chunk-ID"><a href="#chunk-ID" class="headerlink" title="chunk ID"></a>chunk ID</h3><p>可以不使用 <code>import(/* webpackChunkName:&quot;name&quot; */ &quot;module&quot;)</code> 在开发环境来为 chunk 命名，生产环境还是有必要的</p>
<p>webpack 内部有 chunk 命名规则，不再是以 id(0,1,2) 命名了</p>
<h3 id="tree-shaking-功能更加强大"><a href="#tree-shaking-功能更加强大" class="headerlink" title="tree shaking 功能更加强大"></a>tree shaking 功能更加强大</h3><p><strong>（1） webpack 5 能处理嵌套模块的 tree shaking</strong></p>
<pre><code>//a.js
export const aa = 1;
export const bb = 2;

//b.js
import * as  a from &#39;./a&#39;;
export &#123; a &#125;;

//c.js
import * as b from &#39;./b&#39;;
console.log(b.a.aa);</code></pre>
<p>在生产环境中，a 模块暴露的 bb 会被删除（因为没有被用到）</p>
<p><strong>（2） webpack 5 能处理多个模块间的关系</strong></p>
<pre><code>import &#123; something &#125; from &#39;./something&#39;;
function usingSomething()&#123;
    return something;
&#125;
export function test()&#123;
    return usingSomething();
&#125;</code></pre>
<p>当设置了 “sideEffects”: false 时，一旦发现 test 方法没有使用，不但删除 test，还会删除 ./something</p>
<p><strong>（3） webpack 5 能处理 Commonjs 模块化的 tree shaking（之前 webpack 4 中都是以 ES6 模块化和生产环境为例）</strong></p>
<h3 id="ouput"><a href="#ouput" class="headerlink" title="ouput"></a>ouput</h3><p>webpack 4 默认只能输出 ES5 代码，webpack 5 开始新增属性 output.ecmaVersion 可以生成 ES5 和 ES6/ES2015 代码</p>
<pre><code>output.ecmaVersion: 2015</code></pre>
<h3 id="optimization-中-splitChunk"><a href="#optimization-中-splitChunk" class="headerlink" title="optimization 中 splitChunk"></a>optimization 中 splitChunk</h3><p>webpack 4 中</p>
<pre><code>minSize: 30000;</code></pre>
<p>webpack 5 中，可进行更精确的划分</p>
<pre><code>minSize: &#123;
    javascript: 30000,
    style: 50000
&#125;</code></pre>
<h3 id="caching-缓存"><a href="#caching-缓存" class="headerlink" title="caching 缓存"></a>caching 缓存</h3><p>webpack 4 中设置了 babel 缓存等</p>
<p>webpack 5 在 cache 中设置缓存</p>
<pre><code>//配置缓存
cache: &#123;
    //磁盘存储
    type:&#39;filesystem&#39;,
    buildDependencies: &#123;
        //当配置修改时，缓存失效
        config: [__filename]
    &#125;
&#125;</code></pre>
<p>缓存将存储到 node_modules/.cache/webpack</p>
<h3 id="监视输出文件"><a href="#监视输出文件" class="headerlink" title="监视输出文件"></a>监视输出文件</h3><p>之前 webpack 总是在第一次构建时输出全部文件，重新构建时会只更新修改的文件</p>
<p>webpack 5 在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>webpack 可以处理 js、json 资源，不能处理 css、img 等其他资源</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/19/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="MongoDB学习笔记">
                  <i class="fa fa-chevron-left"></i> MongoDB学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Git学习笔记">
                  Git学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
