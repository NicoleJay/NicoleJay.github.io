<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、React 简介React 是用于构建用户界面的 JavaScript 库，是一个将数据渲染为 HTML 视图的开源 JavaScript 库，只关注操作 DOM 和呈现页面">
<meta property="og:type" content="article">
<meta property="og:title" content="React学习笔记">
<meta property="og:url" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="一、React 简介React 是用于构建用户界面的 JavaScript 库，是一个将数据渲染为 HTML 视图的开源 JavaScript 库，只关注操作 DOM 和呈现页面">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react-redux%E6%A8%A1%E5%9E%8B%E5%9B%BE.png">
<meta property="article:published_time" content="2022-02-17T12:16:08.000Z">
<meta property="article:modified_time" content="2022-02-25T12:57:39.497Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">


<link rel="canonical" href="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>React学习笔记 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81React-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">一、React 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%8E%9F%E7%94%9F-JS-%E7%9A%84%E7%97%9B%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">1、原生 JS 的痛点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81React-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">2、React 的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81React-%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.3.</span> <span class="nav-text">3、React 高效的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E7%9B%B8%E5%85%B3-js-%E5%BA%93"><span class="nav-number">1.4.</span> <span class="nav-text">4、相关 js 库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E8%99%9A%E6%8B%9F-DOM-%E5%92%8C-%E7%9C%9F%E5%AE%9E-DOM"><span class="nav-number">1.5.</span> <span class="nav-text">5、虚拟 DOM 和 真实 DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F-DOM"><span class="nav-number">1.6.</span> <span class="nav-text">6、创建虚拟 DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BA%AF-js%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E7%94%A8%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">方式一：纯 js（一般不用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9AJSX"><span class="nav-number">1.6.2.</span> <span class="nav-text">方式二：JSX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81JSX"><span class="nav-number">1.7.</span> <span class="nav-text">7、JSX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jsx-%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">1.7.1.</span> <span class="nav-text">jsx 语法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86-js-%E8%AF%AD%E5%8F%A5%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89%E4%B8%8E-js-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.7.2.</span> <span class="nav-text">区分 js 语句（代码）与 js 表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">二、模块与组件、模块化与组件化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">2.1.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">组件化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81React-%E9%9D%A2%E5%90%91%E7%BB%84%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">三、React 面向组件编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">简单组件与复杂组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">定义组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">方式一：函数式组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">方式二：类式组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">复习类相关知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">创建类式组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%EF%BC%88%E7%94%A8%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%89%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="nav-number">3.3.</span> <span class="nav-text">组件实例（用类定义的组件）的三大核心属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81state"><span class="nav-number">3.3.1.</span> <span class="nav-text">1、state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81props"><span class="nav-number">3.3.2.</span> <span class="nav-text">1、props</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#props-%E7%9A%84%E6%89%B9%E9%87%8F%E4%BC%A0%E9%80%92"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">props 的批量传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9-props-%E8%BF%9B%E8%A1%8C%E9%99%90%E5%88%B6"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">对 props 进行限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#props-%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">props 的简写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%8E-props"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">类式组件中的构造器与 props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8-props"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">函数式组件使用 props</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81refs"><span class="nav-number">3.3.3.</span> <span class="nav-text">3、refs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="nav-number">3.4.</span> <span class="nav-text">事件绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">事件处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">3.5.</span> <span class="nav-text">非受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">3.6.</span> <span class="nav-text">受控组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">3.7.1.</span> <span class="nav-text">函数柯里化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.8.</span> <span class="nav-text">组件的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A7%E7%89%88%E7%9A%84-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.8.1.</span> <span class="nav-text">旧版的 React 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%89%88%E7%9A%84-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88v17-0-1%E4%B9%8B%E5%90%8E%EF%BC%89"><span class="nav-number">3.8.2.</span> <span class="nav-text">新版的 React 生命周期（v17.0.1之后）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-%E7%9A%84-Diffing-%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">DOM 的 Diffing 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81-Diffing-%E7%AE%97%E6%B3%95"><span class="nav-number">3.9.1.</span> <span class="nav-text">验证 Diffing 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key"><span class="nav-number">3.9.2.</span> <span class="nav-text">key</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81React-%E5%BA%94%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">四、React 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81react-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="nav-number">4.1.</span> <span class="nav-text">1、react 脚手架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA-react-%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="nav-number">4.2.</span> <span class="nav-text">2、使用脚手架创建 react 项目并启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81react-%E8%84%9A%E6%89%8B%E6%9E%B6%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">3、react 脚手架项目结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%A0%B7%E5%BC%8F%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">4.4.</span> <span class="nav-text">4、样式模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81vscode-%E4%B8%AD-react-%E6%8F%92%E4%BB%B6"><span class="nav-number">4.5.</span> <span class="nav-text">5、vscode 中 react 插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%8A%9F%E8%83%BD%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.6.</span> <span class="nav-text">6、功能界面的组件化编码流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84-state-%E4%B8%AD%EF%BC%9F"><span class="nav-number">4.7.</span> <span class="nav-text">7、如何确定将数据放在哪个组件的 state 中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="nav-number">4.8.</span> <span class="nav-text">8、父子组件间数据传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81react-ajax"><span class="nav-number">5.</span> <span class="nav-text">五、react ajax</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84-ajax-%E8%AF%B7%E6%B1%82%E5%BA%93"><span class="nav-number">5.1.</span> <span class="nav-text">1、常用的 ajax 请求库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.</span> <span class="nav-text">2、跨域问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81fetch-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="nav-number">5.3.</span> <span class="nav-text">3、fetch 发送请求</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9A%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">六、任意组件间的通信：消息订阅——发布机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81React-%E8%B7%AF%E7%94%B1"><span class="nav-number">7.</span> <span class="nav-text">七、React 路由</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81SPA-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">7.1.</span> <span class="nav-text">1、SPA 的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">7.2.</span> <span class="nav-text">2、路由的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">7.2.1.</span> <span class="nav-text">路由的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#history"><span class="nav-number">7.2.2.</span> <span class="nav-text">history</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81react-%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.</span> <span class="nav-text">3、react 中路由的基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#react-router-dom"><span class="nav-number">7.3.1.</span> <span class="nav-text">react-router-dom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react-router-%E7%9B%B8%E5%85%B3-API"><span class="nav-number">7.3.2.</span> <span class="nav-text">react-router 相关 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react-router-dom-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">react-router-dom 基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%92%8C%E4%B8%80%E8%88%AC%E7%BB%84%E4%BB%B6"><span class="nav-number">7.3.4.</span> <span class="nav-text">路由组件和一般组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NavLink"><span class="nav-number">7.3.5.</span> <span class="nav-text">NavLink</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NavLink"><span class="nav-number">7.3.5.1.</span> <span class="nav-text">使用 NavLink</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85-NavLink"><span class="nav-number">7.3.5.2.</span> <span class="nav-text">封装 NavLink</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.6.</span> <span class="nav-text">Switch 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%A0%B7%E5%BC%8F%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-number">7.3.7.</span> <span class="nav-text">解决样式丢失问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E4%B8%8E%E4%B8%A5%E6%A0%BC%E5%8C%B9%E9%85%8D"><span class="nav-number">7.3.8.</span> <span class="nav-text">路由的模糊匹配与严格匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redirect-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.9.</span> <span class="nav-text">Redirect 的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%EF%BC%88%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.</span> <span class="nav-text">4、嵌套路由（二级路由）的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%90%91%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">7.5.</span> <span class="nav-text">5、向路由组件传递参数数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%91%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92-params-%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.1.</span> <span class="nav-text">方式一：向路由组件传递 params 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%91%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92-search-%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.2.</span> <span class="nav-text">方式二：向路由组件传递 search 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%90%91%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92-state-%E5%8F%82%E6%95%B0"><span class="nav-number">7.5.3.</span> <span class="nav-text">方式三：向路由组件传递 state 参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F-push-%E5%92%8C-replace"><span class="nav-number">7.6.</span> <span class="nav-text">6、路由跳转的两种模式 push 和 replace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="nav-number">7.7.</span> <span class="nav-text">7、编程式路由导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81withRouter-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.8.</span> <span class="nav-text">8、withRouter 的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81BrowserRouter-%E4%B8%8E-HashRouter-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.9.</span> <span class="nav-text">9、BrowserRouter 与 HashRouter 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81React-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="nav-number">8.</span> <span class="nav-text">八、React UI 组件库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#antd"><span class="nav-number">8.1.</span> <span class="nav-text">antd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#antd-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">8.1.1.</span> <span class="nav-text">antd 的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">8.1.2.</span> <span class="nav-text">高级配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E6%A0%B7%E5%BC%8F"><span class="nav-number">8.1.2.1.</span> <span class="nav-text">按需引入样式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#antd-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98"><span class="nav-number">8.1.2.2.</span> <span class="nav-text">antd 自定义主题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81redux"><span class="nav-number">9.</span> <span class="nav-text">九、redux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.1.</span> <span class="nav-text">redux 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-redux"><span class="nav-number">9.2.</span> <span class="nav-text">什么情况下需要使用 redux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">9.3.</span> <span class="nav-text">redux 工作流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">9.4.</span> <span class="nav-text">redux 三个核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#action"><span class="nav-number">9.4.1.</span> <span class="nav-text">action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reducer"><span class="nav-number">9.4.2.</span> <span class="nav-text">reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store"><span class="nav-number">9.4.3.</span> <span class="nav-text">store</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">9.5.</span> <span class="nav-text">redux 的简单使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E7%9A%84%E5%AE%8C%E6%95%B4%E5%86%99%E6%B3%95"><span class="nav-number">9.6.</span> <span class="nav-text">redux 的完整写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-action"><span class="nav-number">9.7.</span> <span class="nav-text">异步 action</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5-action"><span class="nav-number">9.7.1.</span> <span class="nav-text">使用异步 action</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-redux"><span class="nav-number">9.8.</span> <span class="nav-text">react-redux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-react-redux-%E5%90%8E%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E8%A6%81%E5%92%8C-redux-%E6%89%93%E4%BA%A4%E9%81%93%E8%A6%81%E7%BB%8F%E8%BF%87%E5%93%AA%E5%87%A0%E6%AD%A5%EF%BC%9F"><span class="nav-number">9.8.1.</span> <span class="nav-text">利用 react-redux 后一个组件要和 redux 打交道要经过哪几步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E4%B8%8E-UI-%E7%BB%84%E4%BB%B6"><span class="nav-number">9.8.2.</span> <span class="nav-text">连接容器组件与 UI 组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="nav-number">9.8.3.</span> <span class="nav-text">优化程序编写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-mapDispatchToProps"><span class="nav-number">9.8.3.1.</span> <span class="nav-text">优化 mapDispatchToProps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%9C%80%E5%AF%B9-store-%E4%B8%AD%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%B5%8B%E9%87%8D%E6%96%B0-render"><span class="nav-number">9.8.3.2.</span> <span class="nav-text">无需对 store 中状态进行监测重新 render</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Provider-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.8.3.3.</span> <span class="nav-text">Provider 组件的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%90%88-UI-%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">9.8.3.4.</span> <span class="nav-text">整合 UI 组件与容器组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react-redux-%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E7%BB%88%E7%89%88"><span class="nav-number">9.8.4.</span> <span class="nav-text">react-redux 使用的最终版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-number">9.8.5.</span> <span class="nav-text">多个组件间的数据共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="nav-number">9.9.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redux-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7"><span class="nav-number">9.10.</span> <span class="nav-text">redux 开发者工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8C"><span class="nav-number">10.</span> <span class="nav-text">十、项目打包运行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%89%A9%E5%B1%95"><span class="nav-number">11.</span> <span class="nav-text">十一、扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">setState 更新状态的两种写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lazyLoad"><span class="nav-number">11.2.</span> <span class="nav-text">lazyLoad</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hooks"><span class="nav-number">11.3.</span> <span class="nav-text">Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84-Hook"><span class="nav-number">11.3.1.</span> <span class="nav-text">三个常用的 Hook</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#State-Hook%EF%BC%9AReact-useState"><span class="nav-number">11.3.1.1.</span> <span class="nav-text">State Hook：React.useState()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Effect-Hook%EF%BC%9AReact-useEffect"><span class="nav-number">11.3.1.2.</span> <span class="nav-text">Effect Hook：React.useEffect()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ref-Hook%EF%BC%9AReact-useRef"><span class="nav-number">11.3.1.3.</span> <span class="nav-text">Ref Hook：React.useRef()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fragment"><span class="nav-number">11.4.</span> <span class="nav-text">Fragment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context"><span class="nav-number">11.5.</span> <span class="nav-text">Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PureComponent"><span class="nav-number">11.6.</span> <span class="nav-text">PureComponent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#render-props"><span class="nav-number">11.7.</span> <span class="nav-text">render props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ErrorBoundary-%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C"><span class="nav-number">11.8.</span> <span class="nav-text">ErrorBoundary 错误边界</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text">十二、组件通信方式总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81ReactRouter-6"><span class="nav-number">13.</span> <span class="nav-text">十三、ReactRouter 6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E6%AF%94-ReactRouter-5-x-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">13.1.</span> <span class="nav-text">相比 ReactRouter 5.x 的变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-Routes-gt-%E4%B8%8E-lt-Route-gt"><span class="nav-number">13.2.</span> <span class="nav-text">&lt;Routes&#x2F;&gt; 与 &lt;Route&#x2F;&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-Navigate-gt-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">13.3.</span> <span class="nav-text">&lt;Navigate&#x2F;&gt; 重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-NavLink-gt-%E9%AB%98%E4%BA%AE"><span class="nav-number">13.4.</span> <span class="nav-text">&lt;NavLink&#x2F;&gt; 高亮</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#useRoutes-%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-number">13.5.</span> <span class="nav-text">useRoutes 路由表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1"><span class="nav-number">13.6.</span> <span class="nav-text">嵌套路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-params-%E5%8F%82%E6%95%B0"><span class="nav-number">13.7.</span> <span class="nav-text">路由的 params 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-search-%E5%8F%82%E6%95%B0"><span class="nav-number">13.8.</span> <span class="nav-text">路由的 search 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-state-%E5%8F%82%E6%95%B0"><span class="nav-number">13.9.</span> <span class="nav-text">路由的 state 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="nav-number">13.10.</span> <span class="nav-text">编程式路由导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E8%BE%83%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84-Hooks"><span class="nav-number">13.11.</span> <span class="nav-text">一些其他较不常用的 Hooks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">14.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#defaultChecked-%E5%92%8C-checked"><span class="nav-number">14.1.</span> <span class="nav-text">defaultChecked 和 checked</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E4%BB%B6"><span class="nav-number">14.2.</span> <span class="nav-text">React 中定义的一些事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id-%E7%94%9F%E6%88%90"><span class="nav-number">14.3.</span> <span class="nav-text">id 生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">14.4.</span> <span class="nav-text">确认对话框</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chrome-%E4%B8%AD%E6%8F%92%E4%BB%B6"><span class="nav-number">14.5.</span> <span class="nav-text">Chrome 中插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">14.6.</span> <span class="nav-text">解构赋值</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 20:16:08" itemprop="dateCreated datePublished" datetime="2022-02-17T20:16:08+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、React-简介"><a href="#一、React-简介" class="headerlink" title="一、React 简介"></a>一、React 简介</h1><p>React 是用于构建用户界面的 JavaScript 库，是一个将数据渲染为 HTML 视图的开源 JavaScript 库，只关注操作 DOM 和呈现页面</p>
<a id="more"></a>

<p>React 由 Facebook 开发且开源</p>
<h2 id="1、原生-JS-的痛点"><a href="#1、原生-JS-的痛点" class="headerlink" title="1、原生 JS 的痛点"></a>1、原生 JS 的痛点</h2><p>（1）原生 JavaScript 操作 DOM 繁琐、效率低（DOM-API 操作 UI），</p>
<p>（2）使用 JavaScript 直接操作 DOM，浏览器会进行大量的重绘重排</p>
<p>（3）原生 JavaScript 没有组件化编码方案，代码复用率低</p>
<h2 id="2、React-的特点"><a href="#2、React-的特点" class="headerlink" title="2、React 的特点"></a>2、React 的特点</h2><p>（1）采用<strong>组件化</strong>模式，<strong>声明式编码</strong>，关注结果，过程能自动完成（而非命令式编码，需要关注中间过程），提高开发效率及组件复用率</p>
<p>（2）在 React Native 中可以使用 React 语法进行移动端原生应用开发（利用 js 完成安卓和 ios 移动端开发）</p>
<p>（3）使用虚拟 DOM + 优秀的 Diffing 算法，尽量减少与真实 DOM 的交互</p>
<h2 id="3、React-高效的原因"><a href="#3、React-高效的原因" class="headerlink" title="3、React 高效的原因"></a>3、React 高效的原因</h2><p>（1）使用虚拟 DOM，不总是直接操作页面真实 DOM</p>
<p>（2）DOM Diffing 算法，最小化页面重绘</p>
<h2 id="4、相关-js-库"><a href="#4、相关-js-库" class="headerlink" title="4、相关 js 库"></a>4、相关 js 库</h2><p>babel.min.js：解析 JSX 代码语法转为 JS 代码的库</p>
<p>react.development.js：React 核心库</p>
<p>react-dom.development.js：提供操作 DOM 的 react 扩展库</p>
<p>要先引入 react-dom.development.js，后引入 react.development.js</p>
<h2 id="5、虚拟-DOM-和-真实-DOM"><a href="#5、虚拟-DOM-和-真实-DOM" class="headerlink" title="5、虚拟 DOM 和 真实 DOM"></a>5、虚拟 DOM 和 真实 DOM</h2><p>虚拟 DOM 本质是 Object 类型的对象（一般对象）</p>
<p>虚拟 DOM 比较 “轻”，属性较少，而真实 DOM 较 “重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性（如 style 等）</p>
<p>虚拟 DOM 最终会被 React 转化为真实 DOM 呈现在页面上</p>
<h2 id="6、创建虚拟-DOM"><a href="#6、创建虚拟-DOM" class="headerlink" title="6、创建虚拟 DOM"></a>6、创建虚拟 DOM</h2><h3 id="方式一：纯-js（一般不用）"><a href="#方式一：纯-js（一般不用）" class="headerlink" title="方式一：纯 js（一般不用）"></a>方式一：纯 js（一般不用）</h3><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/JavaScript&quot;&gt; /* 此处写 JavaScript */
        //1.使用 js 创建虚拟 DOM
        const VDOM = React.createElementt(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,&#39;Hello&#39;)
        //2.渲染虚拟 DOM 到页面
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="方式二：JSX"><a href="#方式二：JSX" class="headerlink" title="方式二：JSX"></a>方式二：JSX</h3><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt; /* 此处一定要写 babel */
        //1.使用 jsx 创建虚拟 DOM
        const VDOM = &lt;h1&gt;Hello&lt;/h1&gt; /* 此处一定不要写引号 */
        //2.渲染虚拟 DOM 到页面
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>当要创建嵌套标签的虚拟 DOM 时，使用 js 很繁琐，而使用 jsx 就像写 html 一样很方便，babel 编译后依然是使用 js 创建虚拟 DOM 时的语法，因此 JSX 创建虚拟 DOM 就是 js 创建虚拟 DOM 写法的语法糖</p>
<h2 id="7、JSX"><a href="#7、JSX" class="headerlink" title="7、JSX"></a>7、JSX</h2><p>JSX（JavaScript XML）是 react 定义的一种类似于 XML 的 JS 扩展语法（JS + XML）</p>
<p>（XML 早期用于存储和传输数据，后来用 JSON 用的更多更方便简单）</p>
<p>JSX 本质是 <code>React.createElementt(标签名,&#123;属性名:属性值&#125;,&#39;标签体内容&#39;)</code> 方法的语法糖</p>
<p>作用：用来简化创建虚拟 DOM，<code>var ele = &lt;h1&gt;Hello&lt;/h1&gt;</code>，注意它不是字符串也不是 HTML/XML 标签，它最终产生的就是一个 JS 对象</p>
<p>JSX 中标签名任意，可以是 HTML 标签或其他标签</p>
<h3 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h3><p>（1）定义虚拟 DOM 时不要写引号</p>
<p>（2）标签中混入 JS 表达式时要用 <code>&#123;&#125;</code></p>
<p>（3）样式的类名指定不要用 class，要用 className</p>
<p>（4）内联样式要用 <code>style=&#123;&#123;key:value&#125;&#125;</code> 的形式写</p>
<p>（5）虚拟 DOM 必须只有一个根标签</p>
<p>（6）标签必须闭合，如 <code>&lt;input /&gt;</code> 或 <code>&lt;input&gt;&lt;/input&gt;</code></p>
<p>（7）标签首字母</p>
<pre><code>1）若是小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该编起对应的同名元素，则报错
2）若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错</code></pre>
<p>（8）给一个{数组} react 会自动遍历，但给一个对象不会</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        .title&#123;
            background-color:red;
            width: 100px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        const myId = &#39;xXx&#39;;
        const myData = &#39;123aBc&#39;;
        const VDOM = (
            &lt;h1 className=&quot;title&quot; id=&#123;myId.toLowerCase()&#125;&gt;
                &lt;span style=&#123;&#123;color:'white',fontSize:'20px'&#125;&#125;&gt;&#123;&#123;myData.toLowerCase()&#125;&#125;&lt;/span&gt;
            &lt;/h1&gt;
        )
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="区分-js-语句（代码）与-js-表达式"><a href="#区分-js-语句（代码）与-js-表达式" class="headerlink" title="区分 js 语句（代码）与 js 表达式"></a>区分 js 语句（代码）与 js 表达式</h3><p>表达式：一个表达式会产生一个值（即通过 <code>const x =</code> 来接能接到值就是表达式，否则不是），可放在任何一个需要值的地方，如</p>
<pre><code>a
a+b
demo(1) //函数调用表达式
arr.map()
function test()&#123;&#125;
console.log()</code></pre>
<p>而语句（代码）如</p>
<pre><code>if()&#123;&#125;
for()&#123;&#125;
switch()&#123;case:xxx&#125;</code></pre>
<h1 id="二、模块与组件、模块化与组件化"><a href="#二、模块与组件、模块化与组件化" class="headerlink" title="二、模块与组件、模块化与组件化"></a>二、模块与组件、模块化与组件化</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是向外提供特定功能的 js 程序，一般就是一个 js 文件</p>
<p>为什么要拆成模块？：随着业务逻辑增加，代码越来越多且复杂</p>
<p>作用：复用 js，简化 js 的编写（每个 js 文件不那么庞大），提高 js 运行效率</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件用来实现局部功能效果的代码和资源的集合（html/css/js/image等）</p>
<p>为什么用组件？：一个界面的功能更复杂</p>
<p>作用：复用编码，简化项目编码，提高运行效率</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>当应用的 js 都以模块来编写的，这个应用就是一个模块化的应用</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p>
<h1 id="三、React-面向组件编程"><a href="#三、React-面向组件编程" class="headerlink" title="三、React 面向组件编程"></a>三、React 面向组件编程</h1><p>可现在 Chrome 浏览器中安装插件 React Developer Tools</p>
<h2 id="简单组件与复杂组件"><a href="#简单组件与复杂组件" class="headerlink" title="简单组件与复杂组件"></a>简单组件与复杂组件</h2><p>若组件中有状态 state 就是复杂组件</p>
<p>组件的数据存在 state 里，组件的状态 state 驱动页面</p>
<h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><h3 id="方式一：函数式组件"><a href="#方式一：函数式组件" class="headerlink" title="方式一：函数式组件"></a>方式一：函数式组件</h3><p>用函数定义的组件适用于简单组件</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        //1.创建函数式组件
        function Demo()&#123; //组件首字母要大写
            console.log(this); //此处的 this 是 undefined，因为 babel 编译后开启了严格模式（禁止自定义函数中 this 指向 window）
            return &lt;h1&gt;xxx&lt;/h1&gt;
        &#125;
        //2.渲染组件到页面
        ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>执行了 <code>ReactDOM.render(&lt;demo/&gt;...)</code> 后发生了什么？</p>
<p>— 1.React 解析组件标签，找到了 Demo 组件</p>
<p>— 2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中</p>
<h3 id="方式二：类式组件"><a href="#方式二：类式组件" class="headerlink" title="方式二：类式组件"></a>方式二：类式组件</h3><p>用类定义的组件适用于复杂组件</p>
<p>构造器　constructor　调用　１　次</p>
<p>render　调用　１＋n　次（其中　１　是初始化的那次，n　是状态　state　更新的次数）</p>
<p>事件函数触发几次（如点击）调用几次</p>
<h4 id="复习类相关知识"><a href="#复习类相关知识" class="headerlink" title="复习类相关知识"></a>复习类相关知识</h4><p>类中的构造器不是必须写的，要对实例进行初始化操作时（如添加指定属性）才写</p>
<p>类中的构造器方法中的 this 是类的实例对象</p>
<p>类中的一般方法是放在了类型的原型对象上（__proto__），供实例使用，通过实例对象调用类中的方法式，方法中的 this 就是实例对象</p>
<p>若 A 类继承了 B 类，且 A 类中写了构造器，则 A 类构造器中的 super 是必须调用的</p>
<p>类中的方法默认开启了局部的严格模式，所以方法中的　this　为　undefined</p>
<p>且在外部通过　const x = 实例对象.方法，然后　x()　进行调用此时依然不是通过实例对象调用，而是直接调用，因此调用的方法中的　this　不是实例对象</p>
<p>类中可以直接写复制语句　｀a：１｀，相当于给实例对象自身上添加一个属性　a　值为　１</p>
<p>类中箭头函数中没有this，但若使用this不报错，而是去外部找this</p>
<h4 id="创建类式组件"><a href="#创建类式组件" class="headerlink" title="创建类式组件"></a>创建类式组件</h4><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        //1.创建类式组件
        class MyComponent extends React.Component&#123; //必须继承React.Component
            render()&#123;  //必须有 render 函数，render 是放在 MyComponent 类的原型对象上，供实例使用，render 中的 this 是 MyComponent 实例对象（也叫 MyComponent 实例对象）
                return &lt;h1&gt;xxx&lt;/h1&gt;
            &#125;
        &#125;
        //2.渲染组件到页面
        ReactDOM.render(&lt;MyComponent/&gt;, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>执行了 <code>ReactDOM.render(&lt;MyComponent/&gt;...)</code> 后发生了什么？</p>
<p>— 1.React 解析组件标签，找到了 MyComponent 组件</p>
<p>— 2.发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用到原型上的 render 方法</p>
<p>— 3.将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中</p>
<h2 id="组件实例（用类定义的组件）的三大核心属性"><a href="#组件实例（用类定义的组件）的三大核心属性" class="headerlink" title="组件实例（用类定义的组件）的三大核心属性"></a>组件实例（用类定义的组件）的三大核心属性</h2><h3 id="1、state"><a href="#1、state" class="headerlink" title="1、state"></a>1、state</h3><p>state 是组件实例对象最重要的属性，值是对象，可包含多个 key-value 的组合</p>
<p>组件被称为“状态机”，通过更新组件的 state 来更新对应的页面显式（重新渲染组件）</p>
<p>注意：（1）组件中 render 方法中的 this　为组件实例对象</p>
<p>（2）组件自定义的方法中　this　为　undefined　如何解决？</p>
<pre><code>a）强制绑定 this：通过函数对象的 bind（）
b）赋值语句＋箭头函数</code></pre>
<p>（3）状态数据不能直接修改或更新，需要使用　this.setState({state中属性:值})，且更新是一种合并（重名的覆盖掉），不是替换</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            //初始化状态
            this.state=&#123;isHot:true&#125;
        &#125;
        render()&#123;
            return &lt;h1&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>state　的简写方式</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        //constructor(props)&#123;
            //super(props)
            //this.state=&#123;isHot:true&#125;
        //&#125;
        state=&#123;isHot:true&#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
        //自定义方法：用赋值语句的形式＋箭头函数，因为类中箭头函数中没有this，但若使用this不报错，而是去外部找this（这里即实例对象），这样在定义事件方法时就不要再this.demo=this.demo.bind(this)
        demo=()=＞&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="1、props"><a href="#1、props" class="headerlink" title="1、props"></a>1、props</h3><p>每个组件对象都会有　props（properties的简写）属性</p>
<p>组件标签的所有属性都保存在　props　中</p>
<p><strong>作用：</strong></p>
<p>—（1）通过标签属性从组件外向组件内传递变化的数据</p>
<p>—（2）注意：组件内部不要修改 props 数据</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39;/&gt;, document.getElementById(&#39;test&#39;))
    ReactDOM.render(&lt;Person　name=&#39;xxxxx&#39; sex=&#39;女&#39;/&gt;, document.getElementById(&#39;test1&#39;))
&lt;/script&gt; </code></pre>
<p>注意：props 是只读的</p>
<h4 id="props-的批量传递"><a href="#props-的批量传递" class="headerlink" title="props 的批量传递"></a>props 的批量传递</h4><p>在标签属性中使用 <code>&#123;...对象&#125;</code>，react + babel 允许使用展开运算符展开对象，<code>...对象</code> 这也仅适用于标签属性的传递，如在 <code>console.log(...对象)</code> 就无效，啥也不输出，注意这里的花括号表示里面表达式，和 js 中拷贝对象的含义不同</p>
<pre><code>const p =&#123;name:&#39;xxx&#39;,sex:&#39;男&#39;&#125;
ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;, document.getElementById(&#39;test&#39;))</code></pre>
<h4 id="对-props-进行限制"><a href="#对-props-进行限制" class="headerlink" title="对 props 进行限制"></a>对 props 进行限制</h4><p>需要引入 prop-types，用于对组件标签属性进行类型、必要性、默认值限制，引入后全局多了个对象 PropTypes</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./prop-types.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;

    Person.propTypes = &#123;
        name:PropTypes.string.isRequired, //使得 name 必传且为字符串。在 React v15.5 之前使用 name:React.PropTypes.string.isRequired，且不需要引入 prop-types，v15.5 之后单独封装成 prop-types，减轻 React 重量
        sex:PropTypes.string,
        age:PropTypes.number,
        speak:PropTypes.func
    &#125;
    Person.defaultProps = &#123; //设置不传某属性时使用的默认值
        sex:&#39;男&#39;,
        age:18
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39; speak=&#123;speak&#125;/&gt;, document.getElementById(&#39;test&#39;))

    function speak()&#123;
        console.log(&#39;xxx&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<h4 id="props-的简写方式"><a href="#props-的简写方式" class="headerlink" title="props 的简写方式"></a>props 的简写方式</h4><p>把 <code>组件对象.propTypes</code> 和 <code>组件对象.defaultProps</code> 放到类内部，前面加上 static 关键字</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./prop-types.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        static propTypes = &#123;
            name:PropTypes.string.isRequired, //使得 name 必传且为字符串
            sex:PropTypes.string,
            age:PropTypes.number,
            speak:PropTypes.func
        &#125;
        static defaultProps = &#123; //设置不传某属性时使用的默认值
            sex:&#39;男&#39;,
            age:18
        &#125;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39; speak=&#123;speak&#125;/&gt;, document.getElementById(&#39;test&#39;))

    function speak()&#123;
        console.log(&#39;xxx&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<h4 id="类式组件中的构造器与-props"><a href="#类式组件中的构造器与-props" class="headerlink" title="类式组件中的构造器与 props"></a>类式组件中的构造器与 props</h4><p>在 React 中构造函数仅用于以下两种情况：</p>
<p>—（1）通过 <code>this.state = &#123;...&#125;</code> 来初始化 state（但这种初始化方式可在构造器外直接使用 <code>state = &#123;&#125;</code> 来赋值）</p>
<p>—（2）为事件处理函数绑定实例 <code>this.demo=this.demo.bind(this)</code>（但这种绑定可直接在定义函数时使用箭头函数来省略这步）</p>
<p>因此构造器不是必须的</p>
<p>但是有时需要接收和访问实例对象的 props 值，需要在构造器中接收 props 并传递给 super(props)，若要访问 <code>this.props</code> 则必须将 props 传给 super</p>
<p>即构造器是否接收 props，是否传递给 super 取决于是否希望在构造器中通过 this 访问 props</p>
<pre><code>constructor(props)&#123;
    super(props)
    console.log(this.props)
&#125;</code></pre>
<h4 id="函数式组件使用-props"><a href="#函数式组件使用-props" class="headerlink" title="函数式组件使用 props"></a>函数式组件使用 props</h4><p>若不是通过类创建组件，而是通过函数定义的组件，则无法使用 state 和 refs（除非使用最新版 React 中的 hooks），因为没有类就没有实例就没有 this，但可以使用 props</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建函数式组件
    function Person(props)&#123;
        const &#123;name,age,sex&#125; = props
        return (
            &lt;ul&gt;
                &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
            &lt;/ul&gt;
        )
    &#125;
    Person.propTypes = &#123;
        name:PropTypes.string.isRequired, //使得 name 必传且为字符串
        sex:PropTypes.string,
        age:PropTypes.number,
        speak:PropTypes.func
    &#125;
    Person.defaultProps = &#123; //设置不传某属性时使用的默认值
        sex:&#39;男&#39;,
        age:18
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&quot;x&quot;/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt;</code></pre>
<h3 id="3、refs"><a href="#3、refs" class="headerlink" title="3、refs"></a>3、refs</h3><p>组件内的标签可以定义 ref 属性来标识自己，这样就可以不使用 id 和 getElementById，而是使用 this.refs.ref名 来替代（注意这样拿到的是真实 DOM 节点，而不是虚拟 DOM 节点）</p>
<p>定义形式：</p>
<p>—（1）字符串形式的 ref <code>&lt;input ref=&quot;input1&quot;/&gt;</code>（因为存在效率问题，这种方式以不被官方推荐使用，可能在未来 React 版本中移除）</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this.refs
            console.log(input1.value)
        &#125;
        showData2=()=＞&#123;
            const &#123;input2&#125; = this.refs
            console.log(input2.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&quot;input1&quot; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&quot;input2&quot; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>—（2）回调形式的 ref <code>&lt;input ref=&#123;(c)=&gt;&#123;this.input1=c&#125;&#125;/&gt;</code> 执行 render 函数时就会执行该回调函数，其中参数 c 表示当前所处 DOM 节点，把当前 DOM 节点挂在实例自身（this）上，并取名为 input1</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this
            console.log(input1.value)
        &#125;
        showData2=()=＞&#123;
            const &#123;input2&#125; = this
            console.log(input2.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&#123;(c)=&gt;&#123;this.input2 = c&#125;&#125; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意：若 ref 回调函数是以内联函数的方式定义，在更新过程中（第二次触发 render() 开始）它会被执行两次，第一次闯入参数 null，第二次才传入 DOM 元素，因为每次渲染时会创建一个新的函数实例，所以 React 会传入 null 清空旧的 ref 再设置新的</p>
<p>通过 ref 回调函数定义或 class 的绑定函数的方式可避免上述问题，但大多数情况下它是无关紧要的，可以使用内联方式</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this
            console.log(input1.value)
        &#125;
        saveInput=(c)=＞&#123;
            this.input1 = c
            console.log(c)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;this.saveInput&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&#123;(c)=&gt;&#123;this.input2 = c&#125;&#125; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>—（3）createRef 创建 ref 容器 <code>myRef = React.createRef()</code>，调用后会返回一个容器，该容器可存储被 ref 标识的节点，把当前 ref 所在 DOM 节点直接存储到容器中（官方推荐使用）</p>
<p>注意：该容器是 “专人专用” 的，如果两个 DOM 节点都放在同一个容器中，后放入的会覆盖前面的</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        myRef = React.createRef() //把这个容器挂在组件实例自身上
        myRef2 = React.createRef()
        showData=()=＞&#123;
            console.log(this.myRef.current.value)
        &#125;
        showData2=()=＞&#123;
            console.log(this.myRef2.current.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意：不要过度使用 ref，如当发生事件的元素和当前操作的元素是同一个就可以不使用 ref，而是 event.target 来获取，如 <code>&lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot;/&gt;</code> 可换成 <code>&lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;</code> 在 showData2 中定义如下</p>
<pre><code>showData2=(event)=＞&#123;
    console.log(event.target.value)
&#125;</code></pre>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>在　React　中使用<code>onClick</code>、<code>onBlur</code> 等绑定事件，注意在原生 js 中是 <code>onclick</code>、<code>onblur</code>　</p>
<p>方式一：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            this.state=&#123;isHot:true&#125;
        &#125;
        render()&#123;
            return &lt;h1 onClick=&#123;demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))

    function demo()&#123;
        console.log(&#39;哈哈哈&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<p>方式二：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            this.state=&#123;isHot:true&#125;
            this.demo1=this.demo.bind(this)//生成一个新函数，这个新函数的this为实例对象，并把这个新函数取名为demo1挂在实例上，解决　demo　中　this　指向问题
        &#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;　//这里　demo　在　Weather　原型对象上，供实例使用，由于　demo　是作为　onClick　的回调，所以不是通过实例调用的，是直接调用，且类中的方法默认开启局部的严格模式，因此　demo　中的　this　为　undefined，所以需要　this.demo=this.demo.bind(this)
        &#125;
        demo()&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>方式三：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        //constructor(props)&#123;
            //super(props)
            //this.state=&#123;isHot:true&#125;
        //&#125;
        state=&#123;isHot:true&#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
        //自定义方法：用赋值语句的形式＋箭头函数，因为类中箭头函数中没有this，但若使用this不报错，而是去外部找this（这里即实例对象），这样在定义事件方法时就不要再this.demo=this.demo.bind(this)
        demo=()=＞&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>（1）通过 onXxx 属性指定事件处理函数（注意大小写）</p>
<p>— React 使用的是自定义（合成）事件（如 onClick），而不是使用原生 DOM 事件（如 onclick），这是为了更好的兼容性</p>
<p>— React 中的事件是通过事件委托（冒泡）方式处理的（委托给组件最外层的元素），这是为了更高效</p>
<p>（2）通过 event.target 得到发生事件的 DOM 元素对象，这可以解决过度使用 ref 的情况</p>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>页面中所有输入类的 DOM 节点（如 checkbox、radio 等）现用现取就是非受控组件</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this
            alert($&#123;username.value&#125;,$&#123;password.value&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input ref=&#123;c=&gt;this.username=c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input ref=&#123;c=&gt;this.password=c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>页面中所有输入类的 DOM 节点，随着输入的变化存入维护到状态 state 中，需要时从 state 中取，这种就属于受控组件</p>
<p>受控组件的优势在于可以省略掉 ref</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveUsername=(event)=&gt;&#123;
            this.setState(&#123;username:event.target.value&#125;)
        &#125;
        savePassword=(event)=&gt;&#123;
            this.setState(&#123;password:event.target.value&#125;)
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;this.saveUsername&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;this.savePassword&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意上述代码中是把 this.saveUsername 函数传给 onChange 作为事件回调</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数：若一个函数符合下面两个规范中的任何一个，那么该函数就是高阶函数</p>
<p>（1）若 A 函数接收的参数是个函数，那么 A 就可称之为高阶函数</p>
<p>（2）若 A 函数调用的返回值依然是个函数，那么 A 就可称之为高阶函数</p>
<p>常见的高阶函数有：Promise、setTimeout、setInterval、arr.map() 等</p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式，如</p>
<pre><code>function sum(a)&#123;
    return (b)=&gt;&#123;
        return (c)=&gt;&#123;
            return a+b+c
        &#125;
    &#125;
&#125;</code></pre>
<p>例子：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveFormData=(dataType)=&gt;&#123;
            return (event)=&gt;&#123;
                this.setState(&#123;[dataType]:event.target.value&#125;)
            &#125;
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;this.saveFormData(&#39;username&#39;)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;this.saveFormData(&#39;password&#39;)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意上述代码中 <code>onChange=&#123;this.saveFormData(&#39;username&#39;)</code> 的 saveFormData 后加了括号，所以表示把 saveFormData 的返回值传给 onChange，而不是把 saveFormData 函数传给 onChange</p>
<p>上述代码也可不用函数柯里化实现</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveFormData=(dataType,event)=&gt;&#123;
            this.setState(&#123;[dataType]:event.target.value&#125;)
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;event =&gt; this.saveFormData(&#39;username&#39;,event)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;event =&gt; this.saveFormData(&#39;password&#39;,event)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>组件对象从创建到死亡会经历特定阶段</p>
<p>React 组件对象包含一系列勾子函数（生命周期回调函数），在特定的时刻调用</p>
<p>在定义组件时，在特定的生命周期回调函数中做特定工作</p>
<p>生命周期钩子中的 this 都是组件实例对象</p>
<p><strong>render：</strong>初始化渲染、状态更新之后调用</p>
<p><strong>componentDidMount：</strong>组件挂在页面之后调用</p>
<p><strong>componentWillReceiveProps(props)：</strong>子组件将要接收新的 props 的钩子，也可以不传参，但是父子组件第一次 render 时不会调用该函数，当父组件第二次 render 时给子组件传 props 才会调用该函数</p>
<p><strong>shouldComponentUpdate：</strong>控制组件更新的 “阀门” 表示组件是否应该被更新，调用 setState 后会调用 shouldComponentUpdate，返回布尔值，默认返回 true，若写了 shouldComponentUpdate 函数就要写返回值</p>
<p><strong>componentWillUpdate：</strong>组件将要更新的钩子</p>
<p><strong>componentDidUpdate：</strong>组件更新完毕的钩子</p>
<p><strong>componentWillUnmount：</strong>组件将要卸载时调用</p>
<h3 id="旧版的-React-生命周期"><a href="#旧版的-React-生命周期" class="headerlink" title="旧版的 React 生命周期"></a>旧版的 React 生命周期</h3><p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="旧版生命周期"></p>
<p><strong>生命周期的三个阶段（旧版）：</strong></p>
<p>（1）初始化阶段：由 ReactDOM.render() 触发—初次渲染</p>
<pre><code>1. constructor()
2. componentWillMount()
3. render()
4. componentDidMount() ==&gt; 常用，一般在这个钩子中做一些初始化的事，如开启定时器、发送网络请求、订阅消息</code></pre>
<p>（2）更新阶段：由组件内部 this.setState() 或父组件重新 render 触发</p>
<pre><code>1. shouldComponentUpdate()
2. componentWillUpdate()
3. render()  ==&gt; 必须使用的一个
4. componentDidUpdate()</code></pre>
<p>（3）卸载组件：由 ReactDOM.unmountComponentAtNode() 触发</p>
<pre><code>1. componentWillUnmount() ==&gt; 常用，一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</code></pre>
<p><strong>例子：</strong></p>
<p>h2 标签中的文字2s逐渐变淡直到完全透明后又变黑再逐渐变淡，而当点击按钮时删除 h2</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Life extends React.Component&#123;
        state=&#123;opacity:1&#125;
        death=()=&gt;&#123;
            //卸载组件
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        //组件挂载完毕
        componentDidMount()&#123;
            this.timer = setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if(opacity &lt;= 0) opacity = 1
                this.setState(&#123;opacity&#125;) //这里相当于 this.setState(&#123;opacity:opacity&#125;)，因为俩 opacity 同名所以可以简写
            &#125;,200)
        &#125;
        //组件将要卸载
        componentWillUnmount()&#123;
            clearInterval(this.timer)
        &#125;
        render()&#123;

            return(
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;xxx&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;xx&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Life/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p><strong>例子：</strong></p>
<p>每点击一次按钮就 + 1</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Count extends React.Component&#123;
        constructor(props)&#123;
            console.log(&#39;constructor&#39;)
            super(props)
            this.state=&#123;count:0&#125;
        &#125;

        add=()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
        force=()=&gt;&#123;
            this.forceUpdate() //强制更新
        &#125;
        //组件将要挂载
        componentWillMount()&#123;
            console.log(&#39;componentWillMount&#39;)
        &#125;
        //组件挂载完毕
        componentDidMount()&#123;
            console.log(&#39;componentDidMount&#39;)
        &#125;
        //组件将要卸载
        componentWillUnmount()&#123;

        &#125;
        render()&#123;
            console.log(&#39;render&#39;)
            return(
                &lt;div&gt;
                    &lt;h2&gt;当前求和为：&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;点击+1&lt;/button&gt;
                    &lt;button onClick=&#123;this.force&#125;&gt;强制更新&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Count/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="新版的-React-生命周期（v17-0-1之后）"><a href="#新版的-React-生命周期（v17-0-1之后）" class="headerlink" title="新版的 React 生命周期（v17.0.1之后）"></a>新版的 React 生命周期（v17.0.1之后）</h3><p>与旧版本不同的是 componentWillReceiveProps、componentWillMount、componentWillUpdate 重命名为 UNSAFE_componentWillReceiveProps、UNSAFE_componentWillMount、UNSAFE_componentWillUpdate，且 v18.x 版本开始必须加 UNSAFE_ 才行</p>
<p>注意：UNSAFE_ 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染后</p>
<p><strong>新旧版本对比：</strong>新版本废弃了三个钩子 componentWillReceiveProps、componentWillMount、componentWillUpdate，新引入了两个钩子 getDerivedStateFromProps 和 getSnapshotBeforeUpdate</p>
<p><strong>getDerivedStateFromProps(props,state)：</strong>返回一个对象来更新 state，或返回 null 则不更新任何内容，并且这个更新的 state 无法修改，值只能是 props 的值</p>
<pre><code>static getDerivedStateFromProps(props)&#123;
    return props
&#125;</code></pre>
<p>注意：getDerivedStateFromProps 适用于 state 的值在任何时候都取决于 props 值的情况</p>
<p>getDerivedStateFromProps 会导致代码冗余，并使组件难以维护</p>
<p><strong>getSnapshotBeforeUpdate：</strong>在最近一次渲染输出（提交到 DOM 节点）之前调用，它使得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置），此生命周期的任何返回值将作为参数传给 componentDidUpdate，返回 snapshot 或 null</p>
<pre><code>getSnapshotBeforeUpdate()&#123;
    return &#39;xx&#39; //或 return null
&#125;</code></pre>
<p>此用法不常见，可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等</p>
<p>如随着时间 list 的顶部一直增加一定高度的内容，但下拉至某位置后滚动条位置不动且不影响上面继续添加</p>
<pre><code>getSnapshotBeforeUpdate()&#123;
    return this.refs.list.scrollHeight
&#125;
componentDidUpdate(preProps,preState,height)&#123;
    this.refs.list.scrollTop += this.refs.list.scrollHeight - height
&#125;</code></pre>
<p><strong>componentDidUpdate(preProps,preState)：</strong></p>
<pre><code>componentDidUpdate(preProps,preState,snapshotValue)&#123;
    console.log(&#39;上一个props&#39;+preProps+&#39;上一个state&#39;+preState+&#39;getSnapshotBeforeUpdate return来的&#39;+snapshotValue)
&#125;</code></pre>
<p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="新版生命周期"></p>
<p><strong>生命周期的三个阶段（新版）：</strong></p>
<p>（1）初始化阶段：由 ReactDOM.render() 触发—初次渲染</p>
<pre><code>1. constructor()
2. getDerivedStateFromProps()
3. render()
4. componentDidMount() ==&gt; 常用，一般在这个钩子中做一些初始化的事，如开启定时器、发送网络请求、订阅消息</code></pre>
<p>（2）更新阶段：由组件内部 this.setState() 或父组件重新 render 触发</p>
<pre><code>1. getDerivedStateFromProps
2. shouldComponentUpdate()
3. render()
4. getSnapshotBeforeUpdate()
5. componentDidUpdate()</code></pre>
<p>（3）卸载组件：由 ReactDOM.unmountComponentAtNode() 触发</p>
<pre><code>1. componentWillUnmount() ==&gt; 常用，一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</code></pre>
<h2 id="DOM-的-Diffing-算法"><a href="#DOM-的-Diffing-算法" class="headerlink" title="DOM 的 Diffing 算法"></a>DOM 的 Diffing 算法</h2><h3 id="验证-Diffing-算法"><a href="#验证-Diffing-算法" class="headerlink" title="验证 Diffing 算法"></a>验证 Diffing 算法</h3><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p><strong>问题1：</strong> react/vue 中 key 有什么作用？（key 的内部原理是什么？）</p>
<p>虚拟 DOM 中 key 的作用：</p>
<pre><code>1）简单的说：key 是虚拟 DOM 对象的标识，在更新显式时 key 起着极其重要的作用
2）详细的说：当状态中数据发生变化时，react 会根据【新数据】生成【新的虚拟 DOM】，随后 react 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 对比，比较规则如下：
    a.旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key
        若虚拟 DOM 中内容没变，直接使用之前的真实 DOM
        若虚拟 DOM 中的内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM
    b.旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，则根据数据创建新的真实 DOM，随后渲染到页面</code></pre>
<p><strong>问题2：</strong>为什么遍历列表时 key 最好不要用 index？</p>
<p>用 index 作为 key 可能会引发的问题：</p>
<pre><code>1）若对数据进行逆序添加、逆序删除等破坏顺序操作时会产生没有必要的真实 DOM 更新 =&gt; 界面效果没问题，但效率低
2）若结构中还包含输入类的 DOM，会产生错误 DOM 更新 =&gt; 界面会出问题
3）注意若不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的</code></pre>
<p><strong>问题3：</strong>开发中如何选择 key？</p>
<p>1）最好使用每条数据的唯一标识作为 key，如 id、手机号、身份证号、学号等唯一值</p>
<p>2）若确定只是简单的展示数据，用 index 也是可以的</p>
<p><strong>例子：</strong>点击按钮后在数组头部增加一条数据并显示</p>
<pre><code>add=()=&gt;&#123;
    const &#123;personArr&#125; = this.state
    const p = &#123;id:personArr.length+1,name:&#39;c&#39;,age:20&#125;
    this.setState(&#123;personArr:[p,...personArr]&#125;)
&#125;

render()&#123;
    return(
        &lt;ul&gt;
            &#123;
                this.state.personArr.map((personObj,index)=&gt;&#123;  //这里用 index 做 key
                    return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<p>当使用 index 作为 key 时</p>
<pre><code>初始数据：
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=0&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
更新后的数据：
    &#123;id:3,name:&#39;c&#39;,age:20&#125;
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=0&gt;c---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</code></pre>
<p>这种情况下增加数据后，头两条数据的 input 框中内容和之前一样，这是已导致了混乱</p>
<p>当使用 id 作为 key 时</p>
<pre><code>初始数据：
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=1&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
更新后的数据：
    &#123;id:3,name:&#39;c&#39;,age:20&#125;
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=30&gt;c---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</code></pre>
<p>这种情况下增加数据后，第一条数据后的 input 框中为空白，后两条数据的 input 框中内容和之前一样</p>
<h1 id="四、React-应用"><a href="#四、React-应用" class="headerlink" title="四、React 应用"></a>四、React 应用</h1><h2 id="1、react-脚手架"><a href="#1、react-脚手架" class="headerlink" title="1、react 脚手架"></a>1、react 脚手架</h2><p>xxx 脚手架是用来帮助程序员快速创建一个基于 xxx 库的模板项目</p>
<p>脚手架中包含了所有需要的配置（语法检查、jsx 编译、devServer…）、下载好了所有相关依赖、可以直接运行一个简单的效果</p>
<p>react 提供了一个用于创建 react 项目的脚手架库：create-react-app</p>
<p>项目的整体技术架构为 react + webpack + es6 + eslint</p>
<p>使用脚手架开发的项目的特点：模块化、组件化、工程化（工程化就是写好代码后会自动进行语法检查、代码压缩、编译、兼容性处理等一系列操作）</p>
<h2 id="2、使用脚手架创建-react-项目并启动"><a href="#2、使用脚手架创建-react-项目并启动" class="headerlink" title="2、使用脚手架创建 react 项目并启动"></a>2、使用脚手架创建 react 项目并启动</h2><p>（1）全局安装 create-react-app 库</p>
<pre><code>npm install -g create-react-app</code></pre>
<p>（2）切换到想创建项目的目录，并创建项目 <code>create-react-app 项目名</code></p>
<p>（3）进入项目文件夹，并启动项目 <code>npm start</code></p>
<h2 id="3、react-脚手架项目结构"><a href="#3、react-脚手架项目结构" class="headerlink" title="3、react 脚手架项目结构"></a>3、react 脚手架项目结构</h2><p>public — 静态资源文件夹</p>
<pre><code>facion.icon --- 网站页签图标
index.html --- 主页面
logo192.png --- logo 图
logo512.png --- logo 图
manifest.json --- 应用加壳（将网络加壳成安卓或 ios 应用）的配置文件
robots.txt --- 爬虫协议文件</code></pre>
<p>src — 源码文件夹</p>
<pre><code>App.css --- App 组件的样式
App.js --- App 组件
App.test.js --- 用于给 App 做测试
index.css --- 样式
index.js --- 入口文件
logo.svg ---logo 图
reportWebVitals.js --- 页面性能分析文件（需要 web-vitals 库的支持）
setupTests.js --- 用于做应用的整体测试或组件单元测试（需要 jest-dom 库支持）</code></pre>
<h2 id="4、样式模块化"><a href="#4、样式模块化" class="headerlink" title="4、样式模块化"></a>4、样式模块化</h2><p>若组件内都直接使用 import ‘./组件.css’ 引入样式，不同组件间可能定义了 className 相同的标签而设置的样式不同就会产生冲突</p>
<p>要解决这种冲突的一种方式是使用 less</p>
<p>另一种方式是组件的 css 文件都命名为 xxx.module.css，在 组件.js 文件中引入样式时使用 <code>import xxx from &#39;./xxx.module.css&#39;</code>，使用样式时如 <code>&lt;h1 className=&#123;xxx.类名&#125;&gt;&lt;/h1&gt;</code></p>
<h2 id="5、vscode-中-react-插件"><a href="#5、vscode-中-react-插件" class="headerlink" title="5、vscode 中 react 插件"></a>5、vscode 中 react 插件</h2><p>ES7 React/Redux/GraphQL/React-Native snippets 插件便于生成代码模板，如 <code>rcc + 回车</code> 即可生成类式组件代码模板，<code>rfc + 回车</code> 即可生成函数式组件代码模板</p>
<h2 id="6、功能界面的组件化编码流程"><a href="#6、功能界面的组件化编码流程" class="headerlink" title="6、功能界面的组件化编码流程"></a>6、功能界面的组件化编码流程</h2><p>（1）拆分组件：拆分界面，抽取组件</p>
<p>（2）实现静态组件：使用组件实现静态页面效果</p>
<p>（3）实现动态组件：</p>
<p>— 1）动态显示初始化数据：数据类型、数据名称、保存在哪个组件</p>
<p>— 2）交互（从绑定事件监听开始）</p>
<h2 id="7、如何确定将数据放在哪个组件的-state-中？"><a href="#7、如何确定将数据放在哪个组件的-state-中？" class="headerlink" title="7、如何确定将数据放在哪个组件的 state 中？"></a>7、如何确定将数据放在哪个组件的 state 中？</h2><p>若某个组件使用，则放在其自身的 state 中</p>
<p>若某些组件使用，则放在他们共同的父组件 state 中（也称为状态提升）</p>
<p>状态在哪，操作状态的方法就在哪</p>
<h2 id="8、父子组件间数据传递"><a href="#8、父子组件间数据传递" class="headerlink" title="8、父子组件间数据传递"></a>8、父子组件间数据传递</h2><p>【父组件】给【子组件】传数据可在子组件传属性，在子组件中通过 props 获取数据</p>
<p>【子组件】给【父组件】传数据，在父组件定义函数并传给子组件，在子组件中调用该函数 this.props.函数()</p>
<h1 id="五、react-ajax"><a href="#五、react-ajax" class="headerlink" title="五、react ajax"></a>五、react ajax</h1><p>React 本身只关注于界面，并不包含发送 ajax 请求的代码</p>
<p>前端应用需要通过 ajax 请求与后台进行交互（json 数据）</p>
<p>react 应用中需要集成第三方 ajax 库（或自己封装）</p>
<h2 id="1、常用的-ajax-请求库"><a href="#1、常用的-ajax-请求库" class="headerlink" title="1、常用的 ajax 请求库"></a>1、常用的 ajax 请求库</h2><p>（1）jQuery：比较重，若需要另外引入不建议使用</p>
<p>（2）axios：轻量级，建议使用</p>
<p>—a）封装 XmlHttpRequest 对象的 ajax</p>
<p>—b）promise 风格</p>
<p>—c）可以用在浏览器端和 node 服务器端</p>
<h2 id="2、跨域问题"><a href="#2、跨域问题" class="headerlink" title="2、跨域问题"></a>2、跨域问题</h2><p>ajax 引擎会拦截不同源返回的数据，所以需要一个中间代理服务器，该服务器的和前端 ajax 引擎是同源的，前端给服务器发请求时是给代理服务器发送请求，代理服务器再转发至服务器，然后服务器将数据返回给代理服务器，最后再返回给前端</p>
<p><strong>解决方式一：</strong>在脚手架中配置代理解决跨域</p>
<p>在 package.json 文件中添加</p>
<pre><code>&quot;proxy&quot;:&quot;服务器端地址:服务器端口&quot;
但这种方式会把服务器端口写死，只能向这个地址这个端口发请求</code></pre>
<p>在代码中发送请求时地址写前端运行的端口</p>
<pre><code>axios.get(&#39;http://localhost:前端端口/获取后端数据的api&#39;)</code></pre>
<p>因为在前端找不到相应 api，所以代理服务器会转发至后端</p>
<p>优点：配置简单，前端请求资源时可以不加任何前缀</p>
<p>缺点：不能配置多个代理</p>
<p>工作方式：当请求了前端如 3000 端口不存在的资源时，该请求会转发给配置的服务器如 5000 端口（优先匹配前端资源）</p>
<p><strong>解决方式二：</strong>也是在脚手架中配置代理解决跨域</p>
<p>新加文件 src/setupProxy.js 文件，并添加如下内容，React 脚手架会自动找到这个文件进行代理服务器配置</p>
<pre><code>const proxy = require(&#39;http-proxy-middleware&#39;)
module.exports = function(app)&#123;
    app.use(
        proxy(&#39;/api1&#39;,&#123;  //遇见 /api1 前缀的请求，就会触发该代理配置
            target:&#39;http://localhost:5000&#39;, //请求转发给哪个服务器
            changeOrigin: true, //控制服务器收到的请求头中 Host 字段的值，设为 true 后服务器端输出请求头的 Host 值时就不是真正前端地址，而是服务器自身地址，这样服务器设置一些限制时不会有问题
            pathRewrite:&#123;&#39;^/api1&#39;:&#39;&#39;&#125; //重写请求路径，删掉前面的 /api1
        &#125;),
        /*changeOrigin 为 true 时，服务器收到的请求头中 host 为如 localhost:5000（服务器自身地址）
        changeOrigin 为 false 时，服务器收到的请求头中 host 为如 localhost:3000（前端地址）
        changeOrigin 默认为 false，一般将其设为 true
        */
        proxy(&#39;/api2&#39;,&#123;
            target:&#39;http://localhost:5001&#39;,
            changeOrigin: true,
            pathRewrite:&#123;&#39;^/api2&#39;:&#39;&#39;&#125;
        &#125;)
    )
&#125;</code></pre>
<p>在代码中发送请求时写的地址要加上 <code>/api1</code> 或 <code>/api2</code> 这样会去相应服务器中获取数据</p>
<p>优点：可以配置多个代理，可灵活的控制请求是否走代理</p>
<p>缺点：配置繁琐，前端请求资源时必须加前缀，若不写前缀就不走代理</p>
<h2 id="3、fetch-发送请求"><a href="#3、fetch-发送请求" class="headerlink" title="3、fetch 发送请求"></a>3、fetch 发送请求</h2><p>关于 fetch 可查看 <a target="_blank" rel="noopener" href="https://github.github.io/fetch/">github</a> 和 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003810652">思否</a> 的相关文档</p>
<p>之前发送请求都是通过 XMLHttpRequest，即使是使用 jQuery、axios、zepto 等，这些其实是对 XMLHttpRequest 的封装</p>
<p>此外有另一种发送请求的方式 fetch（因为兼容性问题所以不常用）</p>
<p>fetch 是原生函数，不再使用 XMLHttpRequest 对象提交 ajax 请求，注意老版本浏览器可能不支持</p>
<p>fetch 体现了 “关注分离” 的原则（即不是一步到位，而是分步走）</p>
<pre><code>fetch(url, options).then(
    response =&gt; &#123;
        console.log(&#39;联系服务器成功了&#39;,response.json()) //response.json() 返回 Promise 实例对象，若联系服务器成功且获取数据成功则里面存着获取到数据，若联系服务器成功但获取数据失败则里面存着失败的原因
        return response.json()  //返回 Promise 实例对象,因此才能有下面的 .then 链式调用
    &#125;,
    error =&gt; &#123;
        console.log(&#39;联系服务器失败了&#39;)
        return new Promise(()=&gt;&#123;&#125;) //返回初始化状态的 Promise 来阻断往下走执行下面的 then，若没有这个 return 则会返回 undefined，且当前这个 then 对应的 Promise 返回是成功状态，值为 undefined
    &#125;
).then(
    response =&gt; &#123;console.log(&#39;获取数据成功了&#39;,response);&#125;,
    error =&gt; &#123;console.log(&#39;获取数据失败了&#39;,error)&#125;
)</code></pre>
<p>对上面的代码进行优化</p>
<pre><code>fetch(url, options).then(
    response =&gt; &#123;
        console.log(&#39;联系服务器成功了&#39;,response.json())
        return response.json()
    &#125;,
).then(
    response =&gt; &#123;console.log(&#39;获取数据成功了&#39;,response);&#125;,
).catch(
    error =&gt; &#123;console.log(&#39;请求出错&#39;,error)&#125;
)</code></pre>
<p>对上面代码继续优化</p>
<pre><code>事件响应函数 = async() =&gt; &#123;
    try&#123;
        const response = await fetch(url) //此时等到的就是上面未优化代码中 Promise 成功时返回的 response.json()
        const data = await response.json()
        console.log(data)
    &#125;catch(error)&#123;
        console.log(&#39;请求出错&#39;,error)
    &#125;
&#125;</code></pre>
<h1 id="六、任意组件间的通信：消息订阅——发布机制"><a href="#六、任意组件间的通信：消息订阅——发布机制" class="headerlink" title="六、任意组件间的通信：消息订阅——发布机制"></a>六、任意组件间的通信：消息订阅——发布机制</h1><p>需要借助工具库 PubSubJS</p>
<p>下载 <code>npm install pubsub-js --save</code></p>
<p>使用</p>
<pre><code>import PubSub from &#39;pubsub-js&#39; //引入
let token = PubSub.subscribe(&#39;订阅的消息&#39;,回调函数(消息名,收到的数据)=&gt;&#123;...&#125;)  //在需要获取消息的组件中订阅
PubSub.unsubscribe(token) //取消订阅
PubSub.publish(&#39;消息名&#39;,携带的数据)  //发布消息</code></pre>
<p>如在订阅消息的组件中</p>
<pre><code>componentDidMount()&#123;
    this.token = PubSub.subscribe(&#39;xx&#39;,(_,data)&#123;
        conosle.log(data)
    &#125;)
&#125;
//取消订阅
componentWillUnmount()&#123;
    PubSub.unsubscribe(this.token)
&#125;</code></pre>
<p>在发布消息的组件中</p>
<pre><code>PubSub.publish(&#39;xx&#39;,&#123;name:&#39;tom&#39;,age:18&#125;)</code></pre>
<h1 id="七、React-路由"><a href="#七、React-路由" class="headerlink" title="七、React 路由"></a>七、React 路由</h1><h2 id="1、SPA-的理解"><a href="#1、SPA-的理解" class="headerlink" title="1、SPA 的理解"></a>1、SPA 的理解</h2><p>单页 Web 应用（single page web application, SPA）中整个应用只有一个完整的页面，react、vue 等写的都是单页面多组件应用</p>
<p>点击页面中的链接不会刷新页面，只会做页面的局部更新</p>
<p>数据都需要通过 ajax 请求获取，并在前端异步展现</p>
<h2 id="2、路由的理解"><a href="#2、路由的理解" class="headerlink" title="2、路由的理解"></a>2、路由的理解</h2><p>一个路由就是一个映射关系（key:value），key 为路径，value 可能是 function 或 component</p>
<h3 id="路由的分类"><a href="#路由的分类" class="headerlink" title="路由的分类"></a>路由的分类</h3><p>（1）后端路由：</p>
<p>后端路由的 value 是 function，用来处理客户端提交的请求</p>
<p>注册路由：<code>router.get(path,function(req,res))</code></p>
<p>工作过程：当 node 接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应数据</p>
<p>（2）前端路由：</p>
<p>浏览器路由 value 是 component，用于展示页面的内容</p>
<p>原生 html 中，靠 <code>&lt;a&gt;</code> 跳转不同的页面，在 React 中靠路由链接实现切换组件 </p>
<p>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></p>
<p>工作过程：点击某组件引起路由跳转，路径改变，当浏览器的 path 变为 /test 时，被前端路由器监测到进行匹配组件，当前路由组件就会变为 Test 组件</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>在 BOM 对象（window 也在 BOM 上）上有个属性 history 专门管理浏览器的路径、历史记录等，这是前端路由的基石</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/history/4.7.2/history.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    //方法一
    let history = History.createBrowserHistory() //这种方式是直接使用 H5 推出的 BOM 上 history 身上的 API，这行代码里定义的 history 最终操作的就是 BOM 上的 history
    //方法二
    //let history = History.createHashHistory() //这种方式是使用 hash 值（锚点），路由为 http://xx.xxx.xx.x/xx#/xxx，其中 path 放在 # 后面，# 后的资源都不会发给服务器，且锚点跳转不会引起页面刷新，但会留下历史记录，且这种方式对浏览器兼容性极佳
    function push(path)&#123;
        history.push(path)
    &#125;
    function replace(path)&#123;
        history.replace(path)
    &#125;
    function back()&#123;
        history.gBack()
    &#125;
    function forward()&#123;
        history.goForward()
    &#125;
    history.listen((location)=&gt;&#123;
        conosle.log(&#39;请求路由变化了&#39;,location)
    &#125;)
&lt;/script&gt;</code></pre>
<h2 id="3、react-中路由的基本使用"><a href="#3、react-中路由的基本使用" class="headerlink" title="3、react 中路由的基本使用"></a>3、react 中路由的基本使用</h2><h3 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h3><p>react-router 库有三种实现，分别给三种平台使用，一种是 react-router-dom 给网页开发应用人员，一种是 native 给 React Native 用 React 做原生应用开发，还有一种是 any 在哪都能用，虽然通用性更强但学习它的相关 API 没有前两种方便</p>
<p>react-router-dom 是 react 的一个插件库，专门用来实现一个 SPA 应用</p>
<p>基于 react 的项目基本都会用到此库</p>
<h3 id="react-router-相关-API"><a href="#react-router-相关-API" class="headerlink" title="react-router 相关 API"></a>react-router 相关 API</h3><p>内置组件</p>
<pre><code>&lt;BrowserRouter&gt;
&lt;HashRouter&gt;
&lt;Route&gt;
&lt;Redirect&gt;
&lt;Link&gt;
&lt;NavLink&gt;
&lt;Switch&gt;</code></pre>
<p>其它</p>
<pre><code>history 对象
match 对象
withRouter 函数</code></pre>
<h3 id="react-router-dom-基本使用"><a href="#react-router-dom-基本使用" class="headerlink" title="react-router-dom 基本使用"></a>react-router-dom 基本使用</h3><p>需要下载 <code>npm install react-router-dom</code> 这样下载的是最新版本（目前是版本6），也可指定版本下载 <code>npm install react-router-dom@5</code></p>
<p>在项目的入口文件 index.js 中引入路由器（BrowserRouter 或 HashRouter），该文件内容如下</p>
<pre><code>//引入 react 核心库
import React from &#39;react&#39;    
//引入 ReactDOM
import ReactDOM from &#39;react-dom&#39;
//引入路由器    
import &#123;BrowserRouter&#125; from &#39;react-router-dom&#39;
//引入 App 组件
import App from &#39;./App&#39;

ReactDOM.render(
    &lt;BrowserRouter&gt;
        &lt;App/&gt;
    &lt;/BrowserRouter&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<p>在组件中引入 Link 和 Route</p>
<pre><code>import &#123;Link,Route&#125; from &#39;react-router-dom&#39;</code></pre>
<p>在组件中使用，导航区的 a 标签改为 Link 标签，展示区写 Route 标签进行路径的匹配</p>
<pre><code>&#123;/*编写路由链接*/&#125;
&lt;Link to=&quot;/xxx&quot;&gt;xxx&lt;/Link&gt;
&#123;/*注册路由*/&#125;
&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p>（1）写法不同</p>
<p>一般组件是直接通过 <code>&lt;xxx/&gt;</code> 使用</p>
<p>而路由组件是通过 <code>&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code> 进行路由匹配</p>
<p>（2）存放位置不同</p>
<p>一般组件放在 components 文件夹下</p>
<p>路由组件放在 pages 文件夹下</p>
<p>（3）接收到的 props 不同</p>
<p>一般组件写组件标签时传递了什么就能收到什么，若没传属性，this.props 中就为空</p>
<p>而路由组件会收到三个固定的属性，是路由器发送的三个 props，分别是 history、location、match</p>
<pre><code>history:
    action:
    block:
    createHref:
    go:
    goBack:
    goForward:
    length:
    listen:
    location:
    push:
    replace:

location:
    hash:&quot;&quot;
    key:&quot;随机生成&quot;
    pathname:&quot;/xx&quot;
    search:
    state:

match:
    isExact:
    params:&#123;&#125;
    path:&quot;/xx&quot;
    url:&quot;/xx&quot;</code></pre>
<p>其中 history.location 和 直接获取 location 相同</p>
<h3 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h3><p>若要给 Link 标签对应的导航栏中当前所在路由对应的按钮添加高亮显示，可把 Link 标签替换为 NavLink，在 NavLink 中可添加属性 activeClassName 表示给要高亮显示的标签追加有个样式类（不写该属性的话默认是给 className 中添加 active），然后自己定义这个类对应的高亮样式即可</p>
<h4 id="使用-NavLink"><a href="#使用-NavLink" class="headerlink" title="使用 NavLink"></a>使用 NavLink</h4><p>需要现引入</p>
<pre><code>import &#123;NavLink,Route&#125; from &#39;react-router-dom&#39;</code></pre>
<p>再使用</p>
<pre><code>&#123;/*编写路由链接*/&#125;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&#123;/*注册路由*/&#125;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;</code></pre>
<h4 id="封装-NavLink"><a href="#封装-NavLink" class="headerlink" title="封装 NavLink"></a>封装 NavLink</h4><p>可定义一个组件如 MyNavLink</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;
import &#123;NavLink&#125; from &#39;react-router-dom&#39;
export default class MyNavLink extends Component&#123;
    render()&#123;
        return(
            &lt;NavLink activeClassName=&quot;xxx&quot; &#123;...this.props&#125;/&gt;
        ) //这里显式写标签体是因为标签体是特殊的标签属性，它其实是标签的 children 属性，外面传来的所有属性都在 this.props 中
    &#125;    
&#125;</code></pre>
<p>在其他组件中使用自己定义的 MyNavLink</p>
<pre><code>import MyNavLink from &#39;./components/MyNavLink/MyNavLink&#39;

&lt;MyNavLink to=&quot;/xxx&quot;&gt;标签体&lt;/MyNavLink&gt;
&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<h3 id="Switch-的使用"><a href="#Switch-的使用" class="headerlink" title="Switch 的使用"></a>Switch 的使用</h3><p>使用 <code>&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code> 进行路由匹配，若有多个组件匹配同一个路由地址，默认情况下路由地址匹配到一个组件后会继续往下匹配，会都展示，但是若这两行代码中间有很多个其他路由匹配代码，那么效率就很低</p>
<p>因此可利用 Switch 提高路由匹配效率（单一匹配）</p>
<p>在 Route 外包裹 <code>&lt;Switch&gt;</code>，那么匹配到当前路由的组件后就不会继续往下匹配了</p>
<pre><code>&lt;Switch&gt;
    &lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
    &lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;/Switch&gt;</code></pre>
<h3 id="解决样式丢失问题"><a href="#解决样式丢失问题" class="headerlink" title="解决样式丢失问题"></a>解决样式丢失问题</h3><p>对于有多级路由的地址（如 /xx1/xx2），若点击浏览器的刷新按钮后会出现 index.html 中引入的 css 文件（如 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt;</code>）失效的问题</p>
<p>假设 bootstrap.css 文件存放在 public 文件夹（该文件夹其实就是对应 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 这个地址）下，正常情况下要获取样式访问的是 <a target="_blank" rel="noopener" href="http://localhost:3000/css/bootstrap.css%EF%BC%8C%E8%80%8C%E5%88%B7%E6%96%B0%E5%90%8E%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%AD%A4%E6%97%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://localhost:3000/css/bootstrap.css，而刷新后样式失效是因为此时访问的是</a> <a target="_blank" rel="noopener" href="http://localhost:3000/xx1/css/bootstrap.css">http://localhost:3000/xx1/css/bootstrap.css</a></p>
<p><strong>解决方式一：</strong>修改 public/index.html 中引入样式的地址，去掉前面的 <code>.</code>，使用根目录（在浏览器中根目录就是 public 文件夹，且对应 <a href="http://localhost:3000）">http://localhost:3000）</a></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;</code></pre>
<p><strong>解决方式二：</strong>在 public/index.html 中引入样式的地址使用绝对路径，<code>%PUBLIC_URL%</code> 表示的就是 public 文件夹所在路径</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot;&gt;</code></pre>
<p><strong>解决方式三</strong>：修改路由模式，使用 HashRouter（这种解决方式比较少见），在入口文件 index.js 中将 BrowserRouter 换成 HashRouter，这样会在根路径后添加 #，如 <a target="_blank" rel="noopener" href="http://localhost:3000/#/xx1/xx2%EF%BC%8C#">http://localhost:3000/#/xx1/xx2，#</a> 后表示都是前端资源</p>
<pre><code>//引入 react 核心库
import React from &#39;react&#39;    
//引入 ReactDOM
import ReactDOM from &#39;react-dom&#39;
//引入路由器    
import &#123;HashRouter&#125; from &#39;react-router-dom&#39;
//引入 App 组件
import App from &#39;./App&#39;

ReactDOM.render(
    &lt;HashRouter&gt;
        &lt;App/&gt;
    &lt;/HashRouter&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<h3 id="路由的模糊匹配与严格匹配"><a href="#路由的模糊匹配与严格匹配" class="headerlink" title="路由的模糊匹配与严格匹配"></a>路由的模糊匹配与严格匹配</h3><p>默认是模糊匹配，即输入的路径必须包含要匹配的路径，且顺序要一致</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1/a/b&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 不能显示

&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1/a/b&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 可正常显示

&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/a/xxx1/b&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 也不能显示</code></pre>
<p>在注册路由时添加属性 <code>exact=&#123;true&#125;</code> 或 <code>exact</code> 就可以开启精准匹配</p>
<pre><code>&lt;Route exact path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
或
&lt;Route exact=&#123;true&#125; path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;</code></pre>
<p>注意：若模糊匹配时页面可正常显示就不要开启严格匹配，有时开启严格匹配会导致无法继续匹配二级路由</p>
<h3 id="Redirect-的使用"><a href="#Redirect-的使用" class="headerlink" title="Redirect 的使用"></a>Redirect 的使用</h3><p>Redirect 是 react-router-dom 的内置组件</p>
<p>一般把 Redirect 写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 Redirect 指定的路由</p>
<p>引入</p>
<pre><code>import &#123;NavLink,Route,Redirect&#125; from &#39;react-router-dom&#39;</code></pre>
<p>使用</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1&quot;/&gt;</code></pre>
<p>当路由谁都匹配不上时就去 Redirect 设置的地址</p>
<h2 id="4、嵌套路由（二级路由）的使用"><a href="#4、嵌套路由（二级路由）的使用" class="headerlink" title="4、嵌套路由（二级路由）的使用"></a>4、嵌套路由（二级路由）的使用</h2><p>注册子路由时要写上父路由的 path 值</p>
<p>路由的匹配是按照注册路由的顺序进行的，每次路由匹配都是从最开始注册的路由开始过一遍</p>
<p>如一级路由下组件先注册</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1&quot;/&gt;</code></pre>
<p>二级路由下组件后注册</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx11&quot;&gt;组件11&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx12&quot;&gt;组件12&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1/xx11&quot; component=&#123;组件11名&#125;/&gt;
&lt;Route path=&quot;/xxx1/xx12&quot; component=&#123;组件12名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1/xx11&quot;/&gt;</code></pre>
<p>当点击【组件1】时路由会自动跳转到 /xxx1/xx11，因为 /xxx1 匹配后，相同一级路由下的【组件11】和【组件12】就会挂载，此时这两个组件都未点击，所以 redirect 到 /xxx1/xx11</p>
<p>当访问 /xxx1/xx11 时，先匹配先注册的 /xxx1，再匹配到 /xxx1/xx11，所以【组件1】和【组件11】的内容都会渲染</p>
<h2 id="5、向路由组件传递参数数据"><a href="#5、向路由组件传递参数数据" class="headerlink" title="5、向路由组件传递参数数据"></a>5、向路由组件传递参数数据</h2><h3 id="方式一：向路由组件传递-params-参数"><a href="#方式一：向路由组件传递-params-参数" class="headerlink" title="方式一：向路由组件传递 params 参数"></a>方式一：向路由组件传递 params 参数</h3><pre><code>&#123;/*向路由组件传递 params 参数*/&#125;
&lt;Link to=&#123;`/xxx1/xx11/x111/$&#123;变量1&#125;/$&#123;变量2&#125;`&#125;&gt;xxx&lt;/Link&gt;
&#123;/*声明接收 params 参数*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x111/:id/:title&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.match.params 获取这些传来的变量</p>
<pre><code>const &#123;id,title&#125; = this.props.match.params</code></pre>
<h3 id="方式二：向路由组件传递-search-参数"><a href="#方式二：向路由组件传递-search-参数" class="headerlink" title="方式二：向路由组件传递 search 参数"></a>方式二：向路由组件传递 search 参数</h3><pre><code>&#123;/*向路由组件传递 search 参数*/&#125;
&lt;Link to=&#123;`/xxx1/xx11/x111/?id=$&#123;变量1&#125;&amp;title=$&#123;变量2&#125;`&#125;&gt;xxx&lt;/Link&gt;
&#123;/*search 参数无需声明接收，正常注册路由即可*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x11&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.location.search 获取这些传来的search 参数，但收到的是 <code>&quot;?id=xxx&amp;title=xxx&quot;</code> （key=value&amp;key=value 这种形式称为 urlencoded 编码）的字符串</p>
<pre><code>const &#123;search&#125; = this.props.location</code></pre>
<p>可借助 querystring 库解析，对 urlencoded 编码和对象进行互相转换</p>
<pre><code>import qs from &#39;querystring&#39;
const &#123;search&#125; = this.props.location
cosnt &#123;id,title&#125; = qs.parse(search.slice(1)) //urlencoded =&gt; 对象形式
qs.stringfy(对象) //对象形式 =&gt; urlencoded</code></pre>
<h3 id="方式三：向路由组件传递-state-参数"><a href="#方式三：向路由组件传递-state-参数" class="headerlink" title="方式三：向路由组件传递 state 参数"></a>方式三：向路由组件传递 state 参数</h3><p>注意这里的 state 是路由组件上独有的 state</p>
<pre><code>&#123;/*向路由组件传递 state 参数*/&#125;
&lt;Link to=&#123;&#123;pathname:'/xxx1/xx11/x111',state:&#123;id:变量1,title:变量2&#125;&#125;&#125;&gt;xxx&lt;/Link&gt;
&#123;/*state 参数无需声明接收，正常注册路由即可*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x11&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.location.state 接收 state 参数</p>
<pre><code>const &#123;id,title&#125; = this.props.location.state || &#123;&#125; // || &#123;&#125; 是为了若第一次直接访问 /xxx1/xx11/x111 时没有传参时不报错</code></pre>
<p>这种方式在地址栏中没有体现，地址栏中都是 /xxx1/xx11/x111，但刷新也可以保留住参数，因为都在 history 中维护</p>
<h2 id="6、路由跳转的两种模式-push-和-replace"><a href="#6、路由跳转的两种模式-push-和-replace" class="headerlink" title="6、路由跳转的两种模式 push 和 replace"></a>6、路由跳转的两种模式 push 和 replace</h2><p>默认是使用 push 模式</p>
<p>可给 Link 标签添加 <code>replace=&#123;true&#125;</code> <code>replace</code> 开启 replace 模式，使用 replace 不会留下痕迹</p>
<pre><code>&lt;Link replace=&#123;true&#125; to=&#123;`/xxx1/xx11/x111`&#125;&gt;xxx&lt;/Link&gt;
或
&lt;Link replace to=&#123;`/xxx1/xx11/x111`&#125;&gt;xxx&lt;/Link&gt;</code></pre>
<h2 id="7、编程式路由导航"><a href="#7、编程式路由导航" class="headerlink" title="7、编程式路由导航"></a>7、编程式路由导航</h2><p>在按钮上绑定 onClick，并定义响应函数如下</p>
<pre><code>replaceShow = (id,title)&#123;
    //replace 跳转 + 携带 params 参数
    //this.props.history.replace(`/xxx1/xx11/x111/$&#123;id&#125;/$&#123;title&#125;`)
    //replace 跳转 + 携带 search 参数
    //this.props.history.replace(`/xxx1/xx11/x111/?ID=$&#123;id&#125;&amp;title=$&#123;title&#125;`)
    //replace 跳转 + 携带 state 参数
    //this.props.history.replace(`/xxx1/xx11/x111`,&#123;id,title&#125;)
&#125;
pushShow = (id,title)&#123;
    //push 跳转 + 携带 params 参数
    //this.props.history.push(`/xxx1/xx11/x111/$&#123;id&#125;/$&#123;title&#125;`)
    //push 跳转 + 携带 search 参数
    //this.props.history.push(`/xxx1/xx11/x111/?ID=$&#123;id&#125;&amp;title=$&#123;title&#125;`)
    //push 跳转 + 携带 state 参数
    //this.props.history.push(`/xxx1/xx11/x111`,&#123;id,title&#125;)
&#125;
back = () =&gt; &#123;
    this.props.history.goBack()
&#125;
forward = () =&gt; &#123;
    this.props.history.goForward()
&#125;
go = () =&gt; &#123;
    this.props.history.go(整数) //正整数表示前进 n 步，负整数表示后退 n 步
&#125;</code></pre>
<p>注意使用 push 或 replace 中携带不同参数则对应的传参方式和接收参数的方式也要改</p>
<h2 id="8、withRouter-的使用"><a href="#8、withRouter-的使用" class="headerlink" title="8、withRouter 的使用"></a>8、withRouter 的使用</h2><p>withRouter 可以加工一般组件，让一般组件上也有路由组件中特有的 API（history、location、match）</p>
<p>withRouter 的返回值是一个新组件</p>
<p>在一般组件中</p>
<pre><code>import React, &#123;Component&#125; from &#39;react&#39;
import &#123;withRouter&#125; form &#39;react-router-dom&#39;
class 组件名 extends Component &#123;...&#125;
export default withRouter(组件名)</code></pre>
<h2 id="9、BrowserRouter-与-HashRouter-的区别"><a href="#9、BrowserRouter-与-HashRouter-的区别" class="headerlink" title="9、BrowserRouter 与 HashRouter 的区别"></a>9、BrowserRouter 与 HashRouter 的区别</h2><p>（1）底层原理不一样</p>
<p>BrowserRouter 使用的是 H5 的 history（this.props.histyor 是 react 对 H5 的 history 的二次封装） API，不兼容 IE9 及以下版本</p>
<p>HashRouter 使用的是 URL 的哈希值</p>
<p>（2）path 表现形式不一样</p>
<p>BrowserRouter 的路径中没有 #，例如 localhost:3000/xxx/xx</p>
<p>HashRouter 的路径包含 #，例如 localhost:3000/#/xxx/xx</p>
<p>（3）刷新后对路由 state 参数的影响</p>
<p>a. BrowserRouter 没有任何影响，因为 state 保存在 history 对象中</p>
<p>b. HashRouter 刷新后会导致路由 state 参数丢失</p>
<p>（4）HashRouter 可用于解决一些路径错误相关的问题（如样式丢失问题）</p>
<h1 id="八、React-UI-组件库"><a href="#八、React-UI-组件库" class="headerlink" title="八、React UI 组件库"></a>八、React UI 组件库</h1><p>（1）国外的 material-ui，可访问<a target="_blank" rel="noopener" href="http://www.material-ui.com/#/">官网</a>或<a target="_blank" rel="noopener" href="https://github.com/callemall/material-ui">GitHub</a></p>
<p>（3）国内蚂蚁金服 ant-design，可访问<a target="_blank" rel="noopener" href="https://ant.design/index-cn">官网</a>或<a target="_blank" rel="noopener" href="https://github.com/ant-design/ant-design/">GitHub</a></p>
<p>（3）饿了么团队出的 Element UI for react，Element UI 原先是基于 vue 的</p>
<p>（4）有道团队推出的 vantUI，主要针对移动端（基于 vue）</p>
<h2 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h2><h3 id="antd-的基本使用"><a href="#antd-的基本使用" class="headerlink" title="antd 的基本使用"></a>antd 的基本使用</h3><p>下载 ant-design</p>
<pre><code>npm install antd --save-dev</code></pre>
<p>如要使用 antd 中封装好的按钮：</p>
<p>要先引入该组件</p>
<pre><code>import &#123;Button&#125; from &#39;antd&#39; //引入 Button 组件</code></pre>
<p>粘贴官方文档中的使用代码，若要修改属性可查看文档中的 API</p>
<pre><code>&lt;Button type=&quot;primary&quot;&gt;Primary Button&lt;/Button&gt;</code></pre>
<p>引入样式</p>
<pre><code>import &#39;antd/dist/antd.css&#39;</code></pre>
<p>优化：按需引入样式</p>
<h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p>可参考<a target="_blank" rel="noopener" href="https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">官方文档</a></p>
<p>先下载 react-app-rewired（靠这个库启动）和 customize-cra（靠这个库执行规则的修改）</p>
<pre><code>npm install react-app-rewired customize-cra -D</code></pre>
<p>修改 package.json 文件中的 “scripts”</p>
<pre><code>&quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;react-app-rewired start&quot;,
    &quot;build&quot;: &quot;react-app-rewired build&quot;,
    &quot;test&quot;: &quot;react-app-rewired test&quot;,
&#125;</code></pre>
<p>然后在项目根目录创建一个 config-overrides.js 文件用于修改默认配置</p>
<pre><code>module.exports = function override(config, env) &#123;
  //修改或做一些 webpack 配置...
  return config;
&#125;;</code></pre>
<h4 id="按需引入样式"><a href="#按需引入样式" class="headerlink" title="按需引入样式"></a>按需引入样式</h4><p>babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件</p>
<p>下载</p>
<pre><code>npm install babel-plugin-import -D</code></pre>
<p>将 config-overrides.js 文件改为</p>
<pre><code>const &#123; override, fixBabelImports &#125; = require(&#39;customize-cra&#39;);

module.exports = override(
    fixBabelImports(&#39;import&#39;, &#123;
        libraryName: &#39;antd&#39;,
        libraryDirectory: &#39;es&#39;,
        style: &#39;css&#39;,
    &#125;),
);</code></pre>
<p>此时不要在组件文件中 <code>import &#39;antd/dist/antd.css&#39;</code> 引入样式</p>
<h4 id="antd-自定义主题"><a href="#antd-自定义主题" class="headerlink" title="antd 自定义主题"></a>antd 自定义主题</h4><p>antd 中的样式最初是使用 less 写的然后编译成 css，自定义主题需要用到 less 变量覆盖功能</p>
<p>首先需要下载 less 和 less-loader</p>
<pre><code>npm install less less-loader -D</code></pre>
<p>将 config-overrides.js 文件改为</p>
<pre><code>const &#123; override, fixBabelImports, addLessLoader &#125; = require(&#39;customize-cra&#39;);

module.exports = override(
    fixBabelImports(&#39;import&#39;, &#123;
        libraryName: &#39;antd&#39;,
        libraryDirectory: &#39;es&#39;,
        style: true,
    &#125;),
    addLessLoader(&#123;
        lessOptions:&#123;
            javascriptEnabled: true,
            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,
        &#125;
    &#125;),
);</code></pre>
<p>在 addLessLoader 的 lessOptions 中的 modifyVars 里设置主题颜色</p>
<h1 id="九、redux"><a href="#九、redux" class="headerlink" title="九、redux"></a>九、redux</h1><p>redux 可参考相关<a target="_blank" rel="noopener" href="https://redux.js.org/">英文文档</a>、<a target="_blank" rel="noopener" href="http://www.redux.org.cn/">中文文档</a>、<a target="_blank" rel="noopener" href="https://github.com/reactjs/redux">GitHub</a></p>
<h2 id="redux-介绍"><a href="#redux-介绍" class="headerlink" title="redux 介绍"></a>redux 介绍</h2><p>redux 是一个专门用于做状态管理的 JS 库（不是 react 插件库）</p>
<p>它可以用在 react、angular、vue 等项目中，但基本与 react 配合使用</p>
<p><strong>作用：</strong>集中式管理 react 应用中多个组件共享的状态</p>
<h2 id="什么情况下需要使用-redux"><a href="#什么情况下需要使用-redux" class="headerlink" title="什么情况下需要使用 redux"></a>什么情况下需要使用 redux</h2><p>（1）某个组件的状态需要让其他组件可以随时拿到（共享）</p>
<p>（2）一个组件需要改变另一个组件的状态（通信）</p>
<p>（3）总体原则：能不用就不用，若不用比较吃力才考虑使用</p>
<h2 id="redux-工作流程图"><a href="#redux-工作流程图" class="headerlink" title="redux 工作流程图"></a>redux 工作流程图</h2><p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="redux工作流程"></p>
<p>Action Creators 负责把动作包装成一个对象</p>
<p>Reducers 负责初始化状态和加工状态</p>
<h2 id="redux-三个核心概念"><a href="#redux-三个核心概念" class="headerlink" title="redux 三个核心概念"></a>redux 三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action 是动作的对象，包含两个属性</p>
<pre><code>type：标识属性，值为字符串，唯一，必要属性
data：数据属性，值类型任意，可选属性</code></pre>
<p>如 <code>&#123;type:&#39;ADD_STUDENT&#39;,data:&#123;name:&#39;xx&#39;,age:18&#125;&#125;</code></p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>reducer 用于初始化状态、加工状态</p>
<p>加工时，根据旧的 state 和 action，产生新的 state 的纯函数</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store 是将 state、action、reducer 联系在一起的对象</p>
<p>如何得到 store 对象</p>
<pre><code>（1）import &#123;createStore&#125; from &#39;redux&#39;
（2）import reducer from &#39;./reducers&#39;
（3）const store = createStore(reducer)</code></pre>
<p>store 对象的功能</p>
<pre><code>（1）getState()：得到 state
（2）dispatch(action)：分发 action，触发 reducer 调用，产生新的 state
（3）subscribe(listener)：注册监听，当产生了新的 state 时，自动调用</code></pre>
<h2 id="redux-的简单使用"><a href="#redux-的简单使用" class="headerlink" title="redux 的简单使用"></a>redux 的简单使用</h2><p>下载 <code>npm install redux -D</code></p>
<p>例子：下拉框中选择数字，按钮有加、减、奇数时加、异步加</p>
<p>（1）创建 src/redux 文件夹</p>
<p>（2）创建 reducers/reducer.js（可以不为此名） 文件，用于创建一个为某组件服务的 reducer</p>
<pre><code>const initState = 0 //初始化状态
export default function countReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action //从 action 对象中获取 type、data
    switch(type)&#123;
        case &#39;increment&#39;:
            return preState + data
        case &#39;decrement&#39;:
            return preState - data
        default:
            return preState
    &#125;
&#125;</code></pre>
<p>reducer 的本质是一个函数，reducer 函数会接收到两个参数：之前的状态（preState）和动作对象（action）</p>
<p>reducer 第一次被调用是 store 自动触发的，传递的 preState 为 undefined，action 为 {type:@@REDUX/INIT.x.x.x.x}</p>
<p>（3）创建 store.js 文件，该文件专门用于暴露一个 store 对象，整个应用只有一个 store 对象</p>
<pre><code>import &#123;createStore&#125; from &#39;redux&#39; //引入 createStore 专门用于创建 redux 中最核心的 store 对象
import countReducer from &#39;./reducer.js&#39; //引入为 Count 组件服务的 reducer
export default createStore(countReducer) //暴露 store</code></pre>
<p>（4）在要使用 store 的组件中</p>
<p>引入 store</p>
<pre><code>import store form &#39;../../redux/store.js&#39;</code></pre>
<p>在要使用 store 调用 reducer 的地方</p>
<pre><code>store.dispatch(&#123;type:&#39;increment&#39;,data:1&#125;)</code></pre>
<p>在要读取 store 中状态值的地方</p>
<pre><code>store.getState()</code></pre>
<p>监测 redux 中状态的变化，只要变化，就调用 render</p>
<pre><code>componentDidMount()&#123;
    store.subscribe(()=&gt;&#123;
        this.setState(&#123;&#125;) //只要调用 setState 就会自动触发 render
    &#125;)
&#125;</code></pre>
<p>（5）优化：上面最后一步监测 redux 中状态变化调用 render 可不写在组件中，直接写在入口文件 index.js 中，这样写一次就行不用每个组件都写，在 index.js 中添加如下代码</p>
<pre><code>import store from &#39;./redux/store&#39;
store.subscribe(()=&gt;&#123;
    ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;))
&#125;)</code></pre>
<p>只要 store 中状态有一个发生改变就调用 render，因为 react 渲染时使用 diff 算法所以这样效率也不会低</p>
<p>注意：redux 只负责状态管理，状态发生变化时不会自动调用 render 重新渲染，需要自己监测并手动调用 render</p>
<h2 id="redux-的完整写法"><a href="#redux-的完整写法" class="headerlink" title="redux 的完整写法"></a>redux 的完整写法</h2><p>相比于上述 redux 的简单使用，增加如下部分</p>
<p>（1）在 src/redux 文件夹下创建 constant.js 文件用于定义 action 对象中 type 类型的常量值，便于管理的同时防止程序员单词写错</p>
<pre><code>export const INCREMENT = &#39;increment&#39;
export const DECREMENT = &#39;decrement&#39;</code></pre>
<p>（2）在 src/redux 文件夹下创建 actions/count_action.js（也可以不为此名），该文件专门为 Count 组件生成 action 对象</p>
<pre><code>import &#123;INCREMENT,DECREMENT&#125; from &#39;./constant&#39;
export const createIncrementAction = data =&gt; &#123;
    return &#123;type:INCREMENT,data&#125;
&#125;
export const createDecrementAction = data =&gt; (&#123;type:DECREMENT,data&#125;) //这种写法相当于上面的写法，返回的是个对象</code></pre>
<p>（3）在 reducer.js 中同样使用 constant.js 中定义的常量</p>
<pre><code>import &#123;INCREMENT,DECREMENT&#125; from &#39;../constant&#39;
const initState = 0 //初始化状态
export default function countReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action //从 action 对象中获取 type、data
    switch(type)&#123;
        case INCREMENT:
            return preState + data
        case DECREMENT:
            return preState - data
        default:
            return preState
    &#125;
&#125;</code></pre>
<p>（4）在组件中</p>
<p>引入 actionCreator（专门用于创建 action 对象）</p>
<pre><code>import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;</code></pre>
<p>在要使用 store 调用 reducer 的地方</p>
<pre><code>store.dispatch(createIncrementAction(1))</code></pre>
<h2 id="异步-action"><a href="#异步-action" class="headerlink" title="异步 action"></a>异步 action</h2><p>若 action 的值为 Object 类型的一般对象就是同步 action</p>
<p>若 action 的值是个函数（因为只有函数才能开启异步任务，而数字、数组等不行）就是异步 action，该函数由 store 调用</p>
<p>异步 action 中一般都会调用同步 action</p>
<p>何时需要异步 action？</p>
<pre><code>当延迟的动作不想交给组件自身，想交给 action
想要对状态进行操作，但具体的数据靠异步任务返回时</code></pre>
<p>异步 action 不是必须的，也可以自己在组件中等待异步任务的结果再去分发同步 action</p>
<h3 id="使用异步-action"><a href="#使用异步-action" class="headerlink" title="使用异步 action"></a>使用异步 action</h3><p>要使用异步 action 需要安装中间件 </p>
<pre><code>npm install redux-thunk</code></pre>
<p>修改 store.js 文件</p>
<pre><code>import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39; //引入 createStore 专门用于创建 redux 中最核心的 store 对象
import countReducer from &#39;./reducer.js&#39; //引入为 Count 组件服务的 reducer
import thunk from &#39;redux-thunk&#39; //引入 redux-thunk 用于支持异步 action
export default createStore(countReducer,applyMiddleware(thunk)) //执行中间件 thunk 并暴露 store</code></pre>
<p>在 action 文件中</p>
<pre><code>import store from &#39;./store&#39;
//异步 action
export const createIncrementAsyncAction = (data,time) =&gt; &#123;
    return () =&gt; &#123;
        setTimeout(() =&gt; &#123;
            store.dispatch(createIncrementAction(data))
        &#125;,time)
    &#125;
&#125;
或
因为异步 action 返回的函数由 store 调用，所以，可不手动引入 store
//异步 action
export const createIncrementAsyncAction = (data,time) =&gt; &#123;
    return (dispatch) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            dispatch(createIncrementAction(data))
        &#125;,time)
    &#125;
&#125;</code></pre>
<p>在组件中使用异步 action</p>
<pre><code>store.createIncrementAsyncAction(1,1000)</code></pre>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 是 Facebook 出的插件库</p>
<p>react-redux 的模型图如下</p>
<p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react-redux%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="react-redux模型图"></p>
<p>所有的 UI 组件都应该包裹一个容器组件，他们是父子关系</p>
<p>容器组件是真正和 redux 打交道的，里面可以随意使用 redux 的 api</p>
<p>UI 组件中不能使用任何 redux 的 api</p>
<p>容器组件会通过 props 传给 UI 组件（1）redux 中保存的状态（2）用于操作状态的方法</p>
<h3 id="利用-react-redux-后一个组件要和-redux-打交道要经过哪几步？"><a href="#利用-react-redux-后一个组件要和-redux-打交道要经过哪几步？" class="headerlink" title="利用 react-redux 后一个组件要和 redux 打交道要经过哪几步？"></a>利用 react-redux 后一个组件要和 redux 打交道要经过哪几步？</h3><pre><code>（1）定义 UI 组件 --- 不暴露
（2）引入 connect 生成一个容器组件，并暴露，写法如下
    connect(
        state =&gt; (&#123;key:value&#125;), //映射状态
        &#123;key:xxxAction&#125;  //映射操作状态的方法
    )(UI组件)
（3）在 UI 组件中通过 this.props.xxx 读取和操状态</code></pre>
<h3 id="连接容器组件与-UI-组件"><a href="#连接容器组件与-UI-组件" class="headerlink" title="连接容器组件与 UI 组件"></a>连接容器组件与 UI 组件</h3><p>下载 <code>npm install react-redux -D</code></p>
<p>新建 src/containers 用于存放容器组件，UI 组件依然存放在 src/components 里</p>
<p>在 containers 文件夹中新建一个容器组件的文件夹（如 Count），Count 文件夹下新建 index.js</p>
<pre><code>//引入 Count 的 UI 组件
import CountUI from &#39;../../components/Count&#39;
//引入 action
import &#123;createIncrementAction,createDecrementAction,createIncrementAsyncAction&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;
//mapStateToProps 函数返回的是个对象，返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为传递给 UI 组件 props 的 value，mapStateToProps 用于传递状态
function mapStateToProps(state)&#123; //react-redux 调用的 a 函数，调用时已经 store.getState() 获取到状态，并作为参数传给 a 函数
    return &#123;count:state&#125; //这样相当于 &lt;CountUI count=xxx/&gt;
&#125;
//mapDispatchToProps 函数返回的是个对象，返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为传递给 UI 组件 props 的 value，mapDispatchToProps 用于传递操作状态的方法
function mapDispatchToProps(dispatch)&#123;
    return &#123;
        inc:number =&gt; dispatch(createIncrementAction(number)),
        dec:number =&gt; dispatch(createDecrementAction(number)),
        incAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time))
    &#125;
&#125;
//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(mapStateToProps,mapDispatchToProps)(CountUI)</code></pre>
<p>最后应渲染容器组件，在使用 Count 组件的组件（如 App.js）中</p>
<pre><code>import React,&#123; Component &#125; from &#39;react&#39;
import store from &#39;./redux/store&#39;
import Count from &#39;./containers/Count&#39;
export default class App extends Component&#123;
    render(
        return(
            &lt;div&gt;
                &lt;Count store=&#123;store&#125;/&gt;
            &lt;/div&gt;
        )
    )
&#125;</code></pre>
<p>注意：容器组件中的 store 是靠 props 传进去的，不是在容器组件中直接 import 引入的</p>
<h3 id="优化程序编写"><a href="#优化程序编写" class="headerlink" title="优化程序编写"></a>优化程序编写</h3><h4 id="优化-mapDispatchToProps"><a href="#优化-mapDispatchToProps" class="headerlink" title="优化 mapDispatchToProps"></a>优化 mapDispatchToProps</h4><p>mapDispatchToProps 可以是个函数也可以是个对象</p>
<pre><code>import CountUI from &#39;../../components/Count&#39;
import &#123;createIncrementAction,createDecrementAction,createIncrementAsyncAction&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;
//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(
    state =&gt; (&#123;count:state&#125;),
    //mapDispatchToProps 的一般写法
    /*dispatch =&gt; (
        &#123;
            inc:number =&gt; dispatch(createIncrementAction(number)),
            dec:number =&gt; dispatch(createDecrementAction(number)),
            incAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time))
        &#125;
    )*/
    //mapDispatchToProps 的简写
    &#123;
        inc:createIncrementAction, //这是因为 react-redux 收到传来的 action 对象能自动掉 dispatch
        dec:createDecrementAction,
        incAsync:createIncrementAsyncAction
    &#125;
)(CountUI)</code></pre>
<h4 id="无需对-store-中状态进行监测重新-render"><a href="#无需对-store-中状态进行监测重新-render" class="headerlink" title="无需对 store 中状态进行监测重新 render"></a>无需对 store 中状态进行监测重新 render</h4><p>使用 react-redux 后可删除之前在入口文件 index.js 文件中写的</p>
<pre><code>import store from &#39;./redux/store&#39;
store.subscribe(()=&gt;&#123;
    ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;))
&#125;)</code></pre>
<p>因为 react-redux 中使用 connect()() 创建容器组件就会自动监测 store 中的状态变化</p>
<h4 id="Provider-组件的使用"><a href="#Provider-组件的使用" class="headerlink" title="Provider 组件的使用"></a>Provider 组件的使用</h4><p>之前需要给容器组件传递 store，有几个容器组件就要传几次 store</p>
<pre><code>&lt;Count store=&#123;store&#125;/&gt;</code></pre>
<p>利用 Provider 只需写一次即可给所有容器组件传 store，在入口文件 index.js 中</p>
<pre><code>import React from &#39;react&#39;    
import ReactDOM from &#39;react-dom&#39;
import &#123;HashRouter&#125; from &#39;react-router-dom&#39;
import App from &#39;./App&#39;
import store from &#39;./redux/store&#39;
import &#123;Provider&#125; from &#39;react-redux&#39;

ReactDOM.render(
    &lt;Provider store=&#123;store&#125;&gt; /*Provider 让该组件的所有后代容器组件都能接收到 store*/
        &lt;App/&gt;
    &lt;/Provider&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<h4 id="整合-UI-组件与容器组件"><a href="#整合-UI-组件与容器组件" class="headerlink" title="整合 UI 组件与容器组件"></a>整合 UI 组件与容器组件</h4><p>有多少需要和 redux 关联的 UI 组件就需要写多少容器组件，目前文件太多，从文件层面进行优化，可以把 UI 组件和容器组件写在一个文件中</p>
<pre><code>import React, &#123;Component&#125; from &#39;react&#39;    
import &#123;
    createIncrementAction,
    createDecrementAction,
    createIncrementAsyncAction
&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;

//定义 UI 组件
class CountUI extends Component&#123;...&#125; //UI 组件中通过 this.props.xxx 来使用容器组件中从 redux 获取的状态和操作状态的方法

//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(...)(CountUI)</code></pre>
<h3 id="react-redux-使用的最终版"><a href="#react-redux-使用的最终版" class="headerlink" title="react-redux 使用的最终版"></a>react-redux 使用的最终版</h3><p>（1）新建 src/containers/组件名/index.js，</p>
<pre><code>import React,&#123; Component &#125; from &#39;react&#39;
import &#123; createIncrementAction &#125; from &#39;../../redux/count_action&#39;
import &#123;connect&#125; from &#39;react-redux&#39;
class Count extends Component&#123;
    add = () =&gt; &#123;
        this.props.inc(1)
    &#125;
    render(
        return(
            &lt;div&gt;
                &lt;h1&gt;&#123;this.props.num&#125;&lt;/h1&gt;
                &lt;button onClick=&#123;this.add&#125;&gt;加一&lt;/button&gt;
            &lt;/div&gt;
        )
    )
&#125;
export defualt connect(
    state =&gt; (&#123;num:state&#125;), //映射状态
    &#123;inc:createIncrementAction&#125;//映射状态的方法
)(Count)</code></pre>
<h3 id="多个组件间的数据共享"><a href="#多个组件间的数据共享" class="headerlink" title="多个组件间的数据共享"></a>多个组件间的数据共享</h3><p>假设有两个组件 Count 和 Person，且已写好两个组件相关的 action 和 reducer，Count 组件中可点击+1，Person 组件可添加一个人的信息</p>
<p>新建 src/reducers/index.js 文件用于汇总所有的 reducer 为一个总的 reducer</p>
<pre><code>import &#123;combineReducers&#125; from &#39;redux&#39;
//引入为 Count、Person 组件服务的 reducer
import count from &#39;./reducers/count&#39;
import person from &#39;./reducers/person&#39;

//汇总所有 reducer 变为一个总的 reducer
export default combineReducers(&#123; //这里传入的对象就是 store 中存的对象
    num:count,
    person:person
&#125;)</code></pre>
<p>修改 store.js 文件</p>
<pre><code>import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;
import reducer from &#39;./reducers/index.js&#39;
import thunk from &#39;redux-thunk&#39;

export default createStore(reducer,applyMiddleware(thunk)) //执行中间件 thunk 并暴露 store</code></pre>
<p>两个 reducer 进行状态传递时应进行修改，如 Count 中</p>
<pre><code>export default connect(
    state =&gt; (&#123;count:state.num,person:state.person&#125;)//注意这里不是之前的 state =&gt; (&#123;count:state&#125;)，因为之前 state 中存只是个数字，现在 state 中存的是个对象，用来存放很多组件的状态
)(Count)</code></pre>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数：只要同样的输入（实参），必定得到同样的输出（返回）</p>
<p>纯函数必须遵守以下一些约束：</p>
<pre><code>（1）不得改写参数数据，如 function func(a)&#123;a=1&#125;
（2）不会产生任何副作用，例如网络请求（可能会断网等），输入和输出设备
（3）不能调用 Date.now() 或 Math.random() 等不纯的方法</code></pre>
<p>redux 的 reducer 函数必须是一个纯函数，如</p>
<pre><code>export default function personReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action
    switch(type)&#123;
        case ADD_PERSON:
            return [data,...preState] //注意这里不能使用 preState.unshift(data)，因为这样导致 preState 被改写了，personReducer 就不是纯函数了
        default:
            return preState
    &#125;
&#125;</code></pre>
<h2 id="redux-开发者工具"><a href="#redux-开发者工具" class="headerlink" title="redux 开发者工具"></a>redux 开发者工具</h2><p>在 Chrome 浏览器中安装插件 Redux DevTools</p>
<p>在项目中下载 redux-devtools-extension</p>
<pre><code>npm install redux-devtools-extension -D</code></pre>
<p>在 src/redux/store.js 文件中添加</p>
<pre><code>//引入
import &#123;composeWithDevTools&#125; from &#39;redux-devtools-extension&#39;
//修改原先的 export default...
export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</code></pre>
<h1 id="十、项目打包运行"><a href="#十、项目打包运行" class="headerlink" title="十、项目打包运行"></a>十、项目打包运行</h1><p>执行 <code>npm run build</code> 生成文件夹 build</p>
<p>全局安装 serve 来查看打包项目的运行效果</p>
<pre><code>npm i serve -g
serve build</code></pre>
<h1 id="十一、扩展"><a href="#十一、扩展" class="headerlink" title="十一、扩展"></a>十一、扩展</h1><h2 id="setState-更新状态的两种写法"><a href="#setState-更新状态的两种写法" class="headerlink" title="setState 更新状态的两种写法"></a>setState 更新状态的两种写法</h2><p>setState 是同步的，setState 引起 React 后续更新状态的动作是异步的</p>
<p>若更改完 state 状态后要马上输出查看新的 state 要在回调函数中查看，若在外部查看输出依然是旧值</p>
<p>（1）setState(stateChange, [callback])————对象式的 setState</p>
<pre><code>stateChange 为状态改变对象（该对象可体现出状态的更改）
callback 是可选的回调函数，它在状态更新完毕、界面也更新后（render 调用后）才被调用

如 this.setState(&#123;count:count+1&#125;)</code></pre>
<p>（2）setState(updater, [callback])————函数式的 setState</p>
<pre><code>updater 为返回 stateChange 对象的函数，可接收 state 和 props
callback 是可选的回调函数，它在状态更新完毕、界面也更新后（render 调用后）才被调用

如 this.setState((state,props) =&gt; &#123;
    console.log(state,props)
    return &#123;count:state.count+1&#125;
&#125;)</code></pre>
<p>总结：对象式的 setState 是函数式的 setState 的简写方式（语法糖）</p>
<p>使用原则：</p>
<pre><code>（1）若新状态不依赖原状态————使用对象方式
（2）若新状态依赖于原状态————使用函数/对象方式
（3）若需要在 setState() 执行后获取最新状态数据，要在第二个 callback 函数中读取</code></pre>
<h2 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h2><p>做懒加载最多的是路由组件 lazyLoad</p>
<pre><code>import React, &#123; Component,lazy &#125; from &#39;react&#39;
//通过 React 的 lazy 函数配合 import() 函数动态加载路由组件 ==&gt; 路由组件代码会被分开打包
const Login = lazy(()=&gt;import(&#39;@/pages/Login&#39;))
//通过 &lt;Suspense&gt; 指定在加载得到路由打包文件前显示一个自定义 loading 界面，当网速慢时会先显示 fallback 中的东西
&lt;Suspense fallback=&#123;&lt;h1&gt;Loading...&lt;/h1&gt;&#125;&gt;
    &lt;Switch&gt;
        &lt;Route path=&quot;/xx&quot; component=&#123;Xxx&#125;&gt;
        &lt;Redirect to=&quot;/login/&quot;&gt;
    &lt;/Switch&gt;
&lt;/Suspense&gt;</code></pre>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Hook 是 React 16.8.0 版本增加的新特性/新语法，使得在函数组件中也可以使用 state 以及其他 React 特性</p>
<h3 id="三个常用的-Hook"><a href="#三个常用的-Hook" class="headerlink" title="三个常用的 Hook"></a>三个常用的 Hook</h3><h4 id="State-Hook：React-useState"><a href="#State-Hook：React-useState" class="headerlink" title="State Hook：React.useState()"></a>State Hook：React.useState()</h4><p>State Hook 让函数组件也可以有 state 状态，并进行状态数据的读写操作</p>
<p>语法：<code>const [xxx,setXxx] = React.useState(initValue)</code></p>
<p>useState() 中</p>
<pre><code>参数：第一次初始化指定的值在内部作缓存
返回值：包含 2 个元素的数组，第 1 个为内部当前状态值，第 2 个为更新状态值的函数</code></pre>
<p>setXxx() 两种写法</p>
<pre><code>setXxx(newValue)：参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值
setXxx(value =&gt; newValue)：参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</code></pre>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    function add()&#123;
        setCount(count+1)//或 setCount(count =&gt; count+1)
    &#125;
    return(
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;add&#125;&gt;加一&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h4 id="Effect-Hook：React-useEffect"><a href="#Effect-Hook：React-useEffect" class="headerlink" title="Effect Hook：React.useEffect()"></a>Effect Hook：React.useEffect()</h4><p>Effect Hook 让函数组件也可以执行副作用操作（副作用操作用于模拟类组件中的生命周期钩子）</p>
<p>React 中的副作用操作：</p>
<pre><code>发 ajax 请求数据获取
设置订阅、启动定时器
手动更改真实 DOM</code></pre>
<p>语法：</p>
<pre><code>React.useEffect(()=&gt;&#123;
    //在此可以执行任何带副作用操作
    return () =&gt; &#123; //组件卸载前执行
        //在此做一些收尾工作，如清除定时器/取消订阅
    &#125;
&#125;,[stateValue]) //第二个参数表示监测的值，若为 []，回调函数只会在第一次 render() 后执行</code></pre>
<p>可以把 useEffect Hook 看作三个函数的组合：componentDidMount、componentDidUpdate、componentWillUnmount</p>
<p>React.useEffect() 该函数相当于 componentDidMount 和 componentDidUpdate，具体是哪个取决于传入的第二个参数，若为空数组[]，则相当于 componentDidMount，若数组中有要监测变化的值[xxx]，则相当于 componentDidUpdate</p>
<p>React.useEffect() 中若返回函数，返回的函数相当于 componentWillUnmount</p>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    React.useEffect(()=&gt;&#123;
        let timer = setInterval(()=&gt;&#123;
            setCount(count =&gt; count + 1)
        &#125;,1000)
        return ()=&gt;&#123;
            clearInterval(timer)
        &#125;
    &#125;,[]) 
    function unmount()&#123;
        ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))
    &#125;
    return(
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;unmount&#125;&gt;卸载组件&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h4 id="Ref-Hook：React-useRef"><a href="#Ref-Hook：React-useRef" class="headerlink" title="Ref Hook：React.useRef()"></a>Ref Hook：React.useRef()</h4><p>Ref Hook 可在函数组件中存储/查找组件内的标签或任意其他数据</p>
<p>语法：<code>const refContainer = useRef()</code></p>
<p>作用：保存标签对象，功能与 React.createRef() 一样</p>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    const myRef = React.useRef()
    function show()&#123;
        alert(myRef.current.value)
    &#125;
    return(
        &lt;input type=&quot;text&quot; ref=&#123;myRef&#125;&gt;
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;show&#125;&gt;点击提示input中输入的数据&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>在组件中 jsx 语法一定要求只能有一个根标签，这样使得在组件嵌套后会有很多没用的根标签，而使用 Fragment 作为根标签在实际渲染时会忽略</p>
<pre><code>import React, &#123; Component,Fragment &#125; from &#39;react&#39;
export deffault clss Demo extends Component&#123;
    render(
        return(
            &lt;Fragment&gt;
                &lt;input type=&quot;text&quot;/&gt;
                &lt;input type=&quot;text&quot;/&gt;
            &lt;/Fragment&gt;
        )
    )
&#125;
&lt;Fragment&gt;&lt;/Fragment&gt;
或
&lt;&gt;&lt;/&gt;</code></pre>
<p><code>&lt;Fragment&gt;</code> 可以添加 key 属性，用于遍历</p>
<p>可以不用必须有一个真实的 DOM 跟标签了，而 <code>&lt;&gt;</code> 空标签里不能添加任何属性</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 是一种组件间通信方式，常用于【祖组件】与【后代组件】间的通信</p>
<p>使用：</p>
<p>（1）在祖孙组件都能访问到的地方创建 Context 容器对象</p>
<pre><code>const xxxContext = React.createContext()  //xxxContext 首字母需要大写，因为后面它还会作为组件标签使用</code></pre>
<p>（2）在祖组件渲染子组件时外面包裹 xxxContext.Provider，通过 value 属性给后代组件传递数据</p>
<pre><code>&lt;xxxContext.Provider value=&#123;数据&#125;&gt;
    子组件
&lt;/xxxContext.Provider&gt;</code></pre>
<p>（3）后代组件读取数据</p>
<pre><code>//方式一：仅适用于类组件
static contextType = xxxContext //声明接收 context
this.context  //读取 context 中的value 数据

//方式二：函数组件与类组件都可以
&lt;xxxContext.Consumer&gt;
    &#123;
        value =&gt; &#123;  //value 就是 context 中的 value 数据
            //要显示的内容
        &#125;
    &#125;
&lt;/xxxContext.Consumer&gt;</code></pre>
<p>注意：在应用开发中一般不用 context，一般都用它的封装 react 插件（react-redux 中的 Pr ovider）</p>
<p>例子：A 组件是 B 组件的父组件，B 是 C 的父组件，要让 C 不通过 B，直接拿到 A 的数据</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;

//创建 Context 对象
const MyContext = React.createContext()
const &#123;Provider,Consumer&#125; = MyProvider

export default class A extends Component&#123;
    state = &#123;username:&#39;xx&#39;,age:18&#125;
    render(
        const &#123;username&#125; = this.state
        return(
            &lt;div&gt;
                &lt;Provider value=&#123;&#123;username:username,age:age&#125;&#125;&gt;
                    &lt;B/&gt;
                &lt;/Provider&gt;
            &lt;/div&gt;
        )
    )
&#125;
class B extends Component&#123;
    render(
        return(
            &lt;div&gt;
                &lt;C/&gt;
            &lt;/div&gt;
        )
    )
&#125;
class C extends Component&#123;
    render(
        static contextType = MyContext
        return(
            &lt;div&gt;
                &lt;h1&gt;&#123;this.context.username&#125;&lt;/h1&gt;
            &lt;/div&gt;
        )
    )
&#125;

//若 C 是函数式组件
function C()&#123;
    return (
        &lt;div&gt;
            &lt;Consumer&gt;
                &#123;
                    value =&gt; &#123;
                        return `$&#123;value.username&#125;,$&#123;value.age&#125;`
                    &#125;
                &#125;
            &lt;/Consumer&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>Component 的 2 个问题：</p>
<pre><code>（1）只要执行 setState() 即使不改变状态数据，组件也会重新 render()
（2）只当前组件重新 render()，就会自动重新 render 子组件，就算子组件没有用到父组件的任何数据也会触发子组件重新 render，这会导致效率低</code></pre>
<p>效率高的做法：只有当组件的 state 或 props 数据发生改变时才重新 render()</p>
<p>原因：Component 的 shouldComponentUpdate() 总是返回 true</p>
<p>解决：</p>
<pre><code>办法1：重写 shouldComponentUpdate() 方法
比较新旧 state 或 props 数据，若有变化才返回 true，若没有返回 false
在父子组件中重写：
shouldComponentUpdate(nextProps,nextState)&#123;
    console.log(this.props,this.state)  //目前的 props 和 state
    console.log(nextProps,nextState)  //接下来要变化的新 props 和 state、
    return !this.state.xx === nextState.xxx
&#125;

办法2：使用 PureComponent
PureComponent 重写了 shouldComponentUpdate()，只有 state 或 props 数据有变化才返回 true
注意：只是进行 state 和 props 数据的浅比较，只有对象地址改变时返回 true，若只是数据对象内部数据变了，返回 false，所以不要直接修改 state 数据，而是要产生新数据
用法如下：
import React, &#123; PureComponent &#125; from &#39;react&#39;
class 组件 extends PureComponent&#123;...&#125;</code></pre>
<p>项目中一般使用 PureComponent 来优化</p>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>html 标签里的标签体内容能直接展示，而自定义组件中的标签体（如 <code>&lt;自定义组件&gt;xxx&lt;/自定义组件&gt;</code>）不能直接展示，而是作为 this.props.children 属性的值</p>
<p>如何想组件内部动态传入带内容的结构（标签）？</p>
<pre><code>在 Vue 中，使用 slot 技术，即通过组件标签体传入结构 &lt;A&gt;&lt;B/&gt;&lt;/A&gt;

在 React 中
    使用 children props：通过父组件标签体传入结构（子组件）
    使用 render props：通过组件标签属性传入结构，来形成父子关系，，且可携带数据，一般用 render 的函数属性</code></pre>
<p>（1）childer props</p>
<pre><code>在 A 的父组件中形成 AB 的父子关系
&lt;A&gt;
    &lt;B&gt;xxx&lt;/B&gt;
&lt;/A&gt;
在 A 组件中通过如下代码展示 B 组件
&#123;this.props.children&#125;</code></pre>
<p>但是若 B 组件需要 A 组件内的数据则做不到</p>
<p>（2）render props</p>
<pre><code>在 A 的父组件中形成 AC 的父子关系
&lt;A render=&#123;(data)=&gt;&lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;
A 组件中渲染 C 组件并给 C 传数据
&#123;this.props.render(要给 C 传的数据)&#125;
C 组件中读取 A 组件传入的数据显示 
&#123;this.props.data&#125;</code></pre>
<h2 id="ErrorBoundary-错误边界"><a href="#ErrorBoundary-错误边界" class="headerlink" title="ErrorBoundary 错误边界"></a>ErrorBoundary 错误边界</h2><p>错误边界（ErrorBoundary）用来捕获后代组件错误，渲染出备用页面</p>
<p>错误边界就是让错误控制在一定范围内不要往外扩散，子组件出错父组件依然能正常渲染</p>
<p>错误边界只适用于生产环境</p>
<p>特点：只能捕获后代组件生命周期函数中产生的错误，普通函数中不行，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<p>使用方式：getDerivedStateFromError 配合 componentDidCatch</p>
<pre><code>state = &#123;
    hasError:&#39;&#39;  //用于标识子组件是否产生错误
&#125;
//声明周期函数，一旦后代组件报错，就会触发，并携带错误信息
static getDerivedStateFromError(error)&#123;
    console.log(error)
    //在 render 之前触发
    //返回新的 state
    return &#123;hasError: true&#125;
&#125;
render()&#123;
    return(
        &lt;div&gt;
            &#123;this.state.hasError?&lt;h2&gt;当前网络不稳定，稍后再试&lt;/h2&gt;:&lt;子组件/&gt;&#125;
        &lt;/div&gt;
    )
&#125;
componentDidCatch(error,info)&#123;  //当页面中子组件出现问题时该钩子会被调用
    //统计页面的错误，发送请求发送到后台去，用于通知编码人员解决 bug
    console.log(error,info)
&#125;</code></pre>
<h1 id="十二、组件通信方式总结"><a href="#十二、组件通信方式总结" class="headerlink" title="十二、组件通信方式总结"></a>十二、组件通信方式总结</h1><p>组件间的关系：</p>
<pre><code>父子组件
兄弟组件（非嵌套组件）
祖孙组件（跨级组件）</code></pre>
<p>通信方式：</p>
<pre><code>（1）props
    children props
    render props
（2）消息订阅-发布
    pubs-sub、event（C#中用的多） 等
（3）集中式管理
    redux、dva 等
（4）conText
    生产者-消费者模式</code></pre>
<p>比较好的搭配方式：</p>
<pre><code>父子组件：props
兄弟组件：消息订阅-发布、集中式管理
祖孙组件（跨级组件）：消息订阅-发布、集中式管理、conText（开发用的少，封装插件用的多）</code></pre>
<h1 id="十三、ReactRouter-6"><a href="#十三、ReactRouter-6" class="headerlink" title="十三、ReactRouter 6"></a>十三、ReactRouter 6</h1><p>React Router 以三个不同的包发布到 npm 上，分别为：</p>
<pre><code>（1）react-router：路由的核心库，提供很多组件、钩子
（2）react-router-dom：包含 react-router 所有内容，并添加到一些专门用于 DOM 的组件，如 &lt;BrowserRouter&gt; 等
（3）react-router-native：包括 react-router 所有内容，并添加一些专门用于 ReactNative 的 API，如 &lt;NativeRouter&gt; 等</code></pre>
<h2 id="相比-ReactRouter-5-x-的变化"><a href="#相比-ReactRouter-5-x-的变化" class="headerlink" title="相比 ReactRouter 5.x 的变化"></a>相比 ReactRouter 5.x 的变化</h2><p>（1）内置组件的变化：移除 <code>&lt;Switch/&gt;</code>，新增 <code>&lt;Routes/&gt;</code> 等</p>
<p>（2）语法的变化：<code>component=&#123;组件&#125;</code> 变为 <code>element=&#123;&lt;组件名/&gt;&#125;</code> 等</p>
<p>（3）新增多个 hook：useParams、useNavigate、useMatch 等</p>
<p>（4）官方明确推荐函数式组件了</p>
<h2 id="lt-Routes-gt-与-lt-Route-gt"><a href="#lt-Routes-gt-与-lt-Route-gt" class="headerlink" title="&lt;Routes/&gt; 与 &lt;Route/&gt;"></a><code>&lt;Routes/&gt;</code> 与 <code>&lt;Route/&gt;</code></h2><p>（1）v6 版本中移除了 <code>&lt;Switch&gt;</code>，引入了替代者 <code>&lt;Routes/&gt;</code></p>
<p>（2）<code>&lt;Routes/&gt;</code> 和 <code>&lt;Route/&gt;</code> 要配合使用，且必须要用 <code>&lt;Routes/&gt;</code> 包裹 <code>&lt;Route/&gt;</code></p>
<p>（3）<code>&lt;Route/&gt;</code> 相当于一个 if 语句，若其路径与当前 URL 匹配，则程序对应组件</p>
<p>（4）<code>&lt;Route caseSensitive/&gt;</code> 属性用于指定匹配时是否区分大小写（默认为 false）</p>
<p>（5）当 URL 发生变化时，<code>&lt;Routes/&gt;</code> 都会查看其所有子 <code>&lt;Route/&gt;</code> 元素以找到最佳匹配并呈现组件</p>
<p>（6）<code>&lt;Route/&gt;</code> 也可以嵌套使用，且可配合 useRoutes() 配置“路由表”，但需要通过 <code>&lt;Outlet/&gt;</code> 组件来渲染其子路由</p>
<pre><code>import &#123;NavLink,Routes,Route,Navigate&#125; from &#39;react-router-dom&#39;

&lt;Routes&gt; &#123;/*功能和 Switch 一样（路由一旦匹配到就不继续往下匹配），但必须包裹 Routes*/&#125;
    &lt;Route path=&#39;/about&#39; element=&#123;&lt;About/&gt;&#125;&gt;
        &lt;Route path=&#39;/xx&#39; element=&#123;&lt;Xxx/&gt;&#125;&gt;  &#123;/*嵌套路由，/about/xx*/&#125;
    &lt;/Route&gt;
    &lt;Route path=&#39;/&#39; element=&#123;&lt;Navigate to=&quot;/about&quot;/&gt;&#125;/&gt; &#123;/*没有 Redirect 了，而是换成 Navigate，且 Navigate 组件一旦被渲染一定会触发视图切换*/&#125;
&lt;/Routes&gt;</code></pre>
<h2 id="lt-Navigate-gt-重定向"><a href="#lt-Navigate-gt-重定向" class="headerlink" title="&lt;Navigate/&gt; 重定向"></a><code>&lt;Navigate/&gt;</code> 重定向</h2><p>作用：只要 <code>&lt;Navigate/&gt;</code> 组件被渲染，就会修改路径，切换视图</p>
<p>replace 属性用于控制跳转模式（push 或 replace，默认是 false）</p>
<pre><code>import React,&#123;useState&#125; from &#39;react&#39;
import &#123;NavLink,Routes,Route,Navigate&#125; from &#39;react-router-dom&#39;

export default function About()&#123;
    const [sum,setSum] = useState(1)
    return(
        &lt;div&gt;
            &#123;sum === 1 ? &lt;h2&gt;xxx&lt;/h2&gt; : &lt;Navigate to=&quot;about&quot; replace=&#123;true&#125;/&gt;&#125;
            &lt;button onClick=&#123;()=&gt;setSum(2)&#125;&gt;点击后sum变为2&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="lt-NavLink-gt-高亮"><a href="#lt-NavLink-gt-高亮" class="headerlink" title="&lt;NavLink/&gt; 高亮"></a><code>&lt;NavLink/&gt;</code> 高亮</h2><p>在 v5 中高亮是使用 <code>&lt;NavLink activeClassName=&quot;xxx&quot;/&gt;</code> 来控制标签高亮</p>
<p>在 v6 中废弃了 activeClassName 属性，将要高亮的类也添加在 className 中，值为一个函数</p>
<pre><code>&lt;NavLink className=&#123;(&#123;isActive&#125;)=&gt;isActive?&#39;定义的高亮样式类&#39;:&#39;&#39;&#125; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></pre>
<p>上述方式在每个有可能高亮的组件中都要使用较多重复代码，所以可以单独定义成一个函数</p>
<pre><code>function computedClassName(&#123;isActive&#125;)&#123;
    return isActive?&#39;定义的高亮样式类&#39;:&#39;&#39;
&#125;

在 NavLink 标签中使用
&lt;NavLink className=&#123;computedClassName&#125; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></pre>
<h2 id="useRoutes-路由表"><a href="#useRoutes-路由表" class="headerlink" title="useRoutes 路由表"></a>useRoutes 路由表</h2><p>新建 src/routes/index.js</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在组件中</p>
<pre><code>import React from &#39;react&#39;
import &#123;NavLink,useRoutes&#125; from &#39;react-router-dom&#39;
import routes from &#39;./routes&#39;
export default function App()&#123;
    //根据路由表生产对应的路由规则
    const element useRoutes(routes)
    return (
        &lt;div&gt;
            &#123;element&#125;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>当 <code>&lt;Route&gt;</code> 产生嵌套时，渲染其对于的后续子路由使用 <code>&lt;Outlet /&gt;</code></p>
<p>假设 <code>&lt;News/&gt;</code> 和 <code>&lt;Message/&gt;</code> 是 <code>&lt;Home/&gt;</code> 的子组件，他们在 <code>&lt;Home/&gt;</code> 所在路由的二级路由下</p>
<p>修改 src/routes/index.js 文件</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
import News from &#39;../pages/News&#39;
import Message from &#39;../pages/Message&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;,
        children:[
            &#123;
                path:&#39;news&#39;,
                element:&lt;News/&gt;
            &#125;,
            &#123;
                path:&#39;message&#39;,
                element:&lt;Message/&gt;
            &#125;
        ]
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在 <code>&lt;Home/&gt;</code> 组件中</p>
<pre><code>import &#123;NavLink,Outlet&#125; from &#39;react-router-dom&#39;

&#123;/* 路由链接，end 属性表示若子级路由匹配上则父级路由不高亮 */&#125;
&lt;NavLink to=&quot;news&quot;&gt;News&lt;/NavLink&gt;&#123;/* News 组件对应的是 /home/news 路径，这里要么两级路由写完整，要么只写第二级且不加 /，若加 / 表示从根目录开始，或使用 ./news 表示从当前路径开始加 */&#125;
&lt;NavLink end to=&quot;message&quot;&gt;Message&lt;/NavLink&gt;
&#123;/* 指定路由组件呈现位置 */&#125;
&lt;Outlet /&gt;</code></pre>
<h2 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h2><p>在 src/routes/index.js 文件中</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
import News from &#39;../pages/News&#39;
import Message from &#39;../pages/Message&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;,
        children:[
            &#123;
                path:&#39;news&#39;,
                element:&lt;News/&gt;
            &#125;,
            &#123;
                path:&#39;message&#39;,
                element:&lt;Message/&gt;
                children:[
                    &#123;
                        path:&#39;detail/:id/:title&#39;,  //携带params 参数形式
                        element:&lt;Detail/&gt;
                    &#125;,
                    &#123;
                        path:&#39;message&#39;,
                        element:&lt;Message/&gt;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在组件中</p>
<pre><code>&lt;NavLink to=&#123;`detail/$&#123;变量1&#125;/$&#123;变量2&#125;`&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 params 路由参数的组件中（使用函数式定义的情况下）可使用 useParams 或 useMatch</p>
<pre><code>import &#123;useParams,useMatch&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    //方式一：
    const &#123;id,title&#125; = useParams()
    //方式二：
    const x = useMatch(&#39;/home/message/detail/:id/:title&#39;)
    console.log(x)
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="路由的-search-参数"><a href="#路由的-search-参数" class="headerlink" title="路由的 search 参数"></a>路由的 search 参数</h2><p>在组件中</p>
<pre><code>&lt;NavLink to=&#123;`detail?id=$&#123;变量1&#125;&amp;title=$&#123;变量2&#125;`&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 search 路由参数的组件中（使用函数式定义的情况下），可使用 useSearchParams（返回包含两个值的数组[search参数,更新search的函数]） 或 useLocation</p>
<pre><code>import &#123;useSearchParams,useLocation&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    //方式一：
    const [search,setSearch] = useSearchParams()
    const id =search.get(&#39;id&#39;)
    const title = search.get(&#39;title&#39;)
    //方式二：
    const x = useLocation()
    console.log(x)
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
            &lt;li&gt;&lt;button onClick=&#123;()=&gt;setSearch(&#39;id=111&amp;title=xxx&#39;)&#125;&gt;点击更新收到的 search 参数&lt;/button&gt;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="路由的-state-参数"><a href="#路由的-state-参数" class="headerlink" title="路由的 state 参数"></a>路由的 state 参数</h2><p>在组件中</p>
<pre><code>&lt;NavLink to=&quot;detail&quot; state=&#123;&#123;id:变量1,title:变量2&#125;&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 state 路由参数的组件中（使用函数式定义的情况下）</p>
<pre><code>import &#123;useLocation&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    const &#123;state:&#123;id,title&#125;&#125; = useLocation()
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>使用 useNavigate 实现路由跳转</p>
<pre><code>import React from &#39;react&#39;
import &#123;Link,Outlet,useNavigate&#125; from &#39;react-router-dom&#39;

export default function Message()&#123;
    const navigate = useNavigate()
    function showDetail(m)&#123;
        navigate(&#39;detail&#39;,&#123;
            replace:false,
            state:&#123;
                id:m.id, //假设 m 传来是个对象
                title:m.title
            &#125;
        &#125;) //触发showDetail函数就会发生路由跳转
    &#125;
    return (
        &lt;ul&gt;
            &lt;li&gt;&lt;button onClick=&#123;()=&gt;showDetail(数据)&#125;&gt;查看详情&lt;/button&gt;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<p>对于一般组件</p>
<pre><code>import React from &#39;react&#39;
import &#123;useNavigate&#125; from &#39;react-router-dom&#39;

export default function Header()&#123;
    const navigate = useNavigate()
    function back(m)&#123;
        navigate(-1)
    &#125;
    function forward(m)&#123;
        navigate(1)
    &#125;
    return (
        &lt;div&gt;
            &lt;button onClick=&#123;()=&gt;back(数据)&#125;&gt;后退&lt;/button&gt;
            &lt;button onClick=&#123;()=&gt;forward(数据)&#125;&gt;前进&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="一些其他较不常用的-Hooks"><a href="#一些其他较不常用的-Hooks" class="headerlink" title="一些其他较不常用的 Hooks"></a>一些其他较不常用的 Hooks</h2><p>（1）useInRouterContext()</p>
<p>作用：若组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 useInRouterContext 钩子返回 true，否则返回 false</p>
<p>（2）useNavigationType()</p>
<p>作用：返回当前的导航类型（用户是如何来到当前页面的）</p>
<p>返回值：POP、PUSH、REPLACE</p>
<p>备注：POP 是指在浏览器中直接打开了这个路由组件（是刷新当前页面）</p>
<p>（3）useOutlet()</p>
<p>作用：用来呈现当前组件中要渲染的嵌套路由组件</p>
<pre><code>const result = useOutlet()
console.log(result)
//若嵌套路由没有挂载，则 result 为 null
//若嵌套路由已经挂载，则显示嵌套的路由对象</code></pre>
<p>（4）useResolvedPath()</p>
<p>作用：给定一个 URL 值，解析其中的 path、search、hash 值</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="defaultChecked-和-checked"><a href="#defaultChecked-和-checked" class="headerlink" title="defaultChecked 和 checked"></a>defaultChecked 和 checked</h2><p>勾选框 checkbox 初始时是否勾选可使用 defaultChecked（只能在显示初始值时起作用），这样设置后可修改值</p>
<pre><code>&lt;input type=&quot;checkbox&quot; defaultChecked=xxx?true:false&gt;
第一次显示时有效，但当 xxx 变量值发生改变时，checkbox 的勾选情况不会随着改变</code></pre>
<p>或者使用 checked + onChange 来初始和监听是否勾选，这样可实时修改勾选情况</p>
<h2 id="React-中定义的一些事件"><a href="#React-中定义的一些事件" class="headerlink" title="React 中定义的一些事件"></a>React 中定义的一些事件</h2><pre><code>onClick：点击
onBlur：失去焦点
onKeyUp：键盘按下松开
event.KeyCode：按下键盘按键的编码（回车的 KeyCode 是 13）
onMouseLeave：鼠标移入
onMouseEnter：鼠标移出</code></pre>
<h2 id="id-生成"><a href="#id-生成" class="headerlink" title="id 生成"></a>id 生成</h2><p>生成数据 id，可通过 uuid 库（比较大）或 nanoid 库（较小，推荐）</p>
<pre><code>npm i nanoid
import &#123;nanoid&#125; from &#39;nanoid&#39; //暴露的 nanoid 是个函数，可生成全世界唯一的字符串
const Obj = &#123;id:nanoid(),name:&#39;xx&#39;&#125;</code></pre>
<h2 id="确认对话框"><a href="#确认对话框" class="headerlink" title="确认对话框"></a>确认对话框</h2><p>若点击按钮需要弹出确认对话框当用户点击“确定”后方可执行按钮事件可利用 window 下的 confirm 函数</p>
<pre><code>if(window.confirm(&#39;提示语句&#39;))&#123;执行相应代码&#125;</code></pre>
<h2 id="Chrome-中插件"><a href="#Chrome-中插件" class="headerlink" title="Chrome 中插件"></a>Chrome 中插件</h2><p>FeHelper 可帮助整理 json 数据缩进显示</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值</p>
<pre><code>let &#123;对象中的属性&#125; = 对象</code></pre>
<p>连续解构赋值</p>
<pre><code>let &#123;对象中的属性对象:&#123;属性对象中的属性&#125;&#125; = 对象

let obj = &#123;a:&#123;b:&#123;c:1&#125;&#125;&#125;
const &#123;a:&#123;b:&#123;c&#125;&#125;&#125; = obj
console.log(c) //输出 1</code></pre>
<p>连续解构赋值并重命名</p>
<pre><code>let &#123;对象中的属性:新名字&#125; = 对象

let obj = &#123;a:&#123;b:1&#125;&#125;
const &#123;a:&#123;b:data&#125;&#125; = obj
console.log(data)  //也能输出 1</code></pre>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/13/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="TypeScript学习笔记">
                  <i class="fa fa-chevron-left"></i> TypeScript学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Vue学习笔记">
                  Vue学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
