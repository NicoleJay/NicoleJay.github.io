<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、版本控制Git 是版本控制器，版本控制是一种记录一个或若干文件内容变化以便将来查阅特定版本修订情况的系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习笔记">
<meta property="og:url" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="一、版本控制Git 是版本控制器，版本控制是一种记录一个或若干文件内容变化以便将来查阅特定版本修订情况的系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset0.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset1.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset2.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset3.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/add%E5%90%8E.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset%E5%90%8E.png">
<meta property="article:published_time" content="2022-02-07T17:37:18.000Z">
<meta property="article:modified_time" content="2022-03-11T08:02:24.898Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%AF%B9%E8%B1%A1.png">


<link rel="canonical" href="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Git学习笔记 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">一、版本控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要使用版本控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">集中式版本控制系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">分布式版本控制系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Git"><span class="nav-number">2.</span> <span class="nav-text">二、Git</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Git-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">1、Git 安装和配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2、区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.</span> <span class="nav-text">3、对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Git-%E5%BA%95%E5%B1%82%E6%A6%82%E5%BF%B5%EF%BC%88%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">4、Git 底层概念（底层命令）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80-Linux-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.1.</span> <span class="nav-text">基础 Linux 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.2.</span> <span class="nav-text">git 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%AF%B9%E5%BA%94%E9%94%AE%E5%80%BC"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">向数据库写入内容并返回对应键值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">Git 如何存储数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%94%AE%E5%80%BC%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">根据键值拉取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">对一个文件进行简单版本控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.3.</span> <span class="nav-text">树对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">构建树对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">查看树对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">解析树对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-1"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.4.</span> <span class="nav-text">提交对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">创建提交对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">查看提交对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">提交对象的格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Git-%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C%EF%BC%88%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">5、Git 本地操作（高层命令）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">git 操作基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.2.</span> <span class="nav-text">初始化新仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93"><span class="nav-number">2.5.3.</span> <span class="nav-text">记录每次更新到仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6%EF%BC%88%E5%B0%86%E4%BF%AE%E6%94%B9%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA%EF%BC%89"><span class="nav-number">2.5.4.</span> <span class="nav-text">跟踪新文件（将修改添加到暂存区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0%EF%BC%88%E5%B0%86%E6%9A%82%E5%AD%98%E5%8C%BA%E6%8F%90%E4%BA%A4%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93%EF%BC%89"><span class="nav-number">2.5.5.</span> <span class="nav-text">提交更新（将暂存区提交到版本库）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-number">2.5.6.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E6%9A%82%E5%AD%98%E5%92%8C%E6%9C%AA%E6%9A%82%E5%AD%98%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-number">2.5.7.</span> <span class="nav-text">查看已暂存和未暂存的更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BF%87%E4%BD%BF%E7%94%A8%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="nav-number">2.5.8.</span> <span class="nav-text">跳过使用暂存区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">2.5.9.</span> <span class="nav-text">移除文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="nav-number">2.5.10.</span> <span class="nav-text">文件重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="nav-number">2.5.11.</span> <span class="nav-text">查看历史记录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Git-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9D%80%E6%89%8B%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">6、Git 分支操作（杀手功能）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="nav-number">2.6.1.</span> <span class="nav-text">创建分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF"><span class="nav-number">2.6.2.</span> <span class="nav-text">查看分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="nav-number">2.6.3.</span> <span class="nav-text">删除分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="nav-number">2.6.4.</span> <span class="nav-text">查看每个分支的最后一次提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%90%88%E5%B9%B6%E5%88%B0%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E5%88%86%E6%94%AF"><span class="nav-number">2.6.5.</span> <span class="nav-text">查看已合并到当前分支的分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%8C%85%E5%90%AB%E6%9C%AA%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%88%86%E6%94%AF"><span class="nav-number">2.6.6.</span> <span class="nav-text">查看所有包含未合并工作的分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%89%80%E6%8C%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.6.7.</span> <span class="nav-text">查看当前分支所指对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="nav-number">2.6.8.</span> <span class="nav-text">切换分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2"><span class="nav-number">2.6.9.</span> <span class="nav-text">查看项目分支历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="nav-number">2.6.10.</span> <span class="nav-text">分支合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%91%BD%E4%BB%A4%E9%85%8D%E5%88%AB%E5%90%8D"><span class="nav-number">2.6.11.</span> <span class="nav-text">给命令配别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%AE%9E%E6%88%98"><span class="nav-number">2.6.12.</span> <span class="nav-text">分支实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.6.13.</span> <span class="nav-text">分支模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86"><span class="nav-number">2.6.14.</span> <span class="nav-text">分支原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HEAD-%E5%BC%95%E7%94%A8"><span class="nav-number">2.6.14.1.</span> <span class="nav-text">HEAD 引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Git-%E5%AD%98%E5%82%A8"><span class="nav-number">2.7.</span> <span class="nav-text">7、Git 存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#git-stash-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.7.1.</span> <span class="nav-text">git stash 相关命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="nav-number">2.8.</span> <span class="nav-text">8、数据恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E9%94%80"><span class="nav-number">2.8.1.</span> <span class="nav-text">撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E5%9B%9E%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">撤回工作目录中的修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E5%9B%9E%E6%9A%82%E5%AD%98"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">撤回暂存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%92%A4%E5%9B%9E%E6%8F%90%E4%BA%A4"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">撤回提交</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE"><span class="nav-number">2.8.2.</span> <span class="nav-text">重置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reset-%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">reset 三部曲</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#checkout-%E5%92%8C-%E2%80%93hard-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.8.2.1.1.</span> <span class="nav-text">checkout 和 –hard 的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84-reset"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">路径 reset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#checkout"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">checkout</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.2.3.1.</span> <span class="nav-text">不带路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E8%B7%AF%E5%BE%84"><span class="nav-number">2.8.2.3.2.</span> <span class="nav-text">带路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.8.3.</span> <span class="nav-text">数据恢复的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E6%89%93-tag"><span class="nav-number">2.9.</span> <span class="nav-text">9、打 tag</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.1.</span> <span class="nav-text">列出标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.2.</span> <span class="nav-text">创建标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.3.</span> <span class="nav-text">查看特定标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.4.</span> <span class="nav-text">远程标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.5.</span> <span class="nav-text">删除标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">2.9.6.</span> <span class="nav-text">检出标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Git-%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">三、Git 命令整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Git-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">1、Git 底层命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Git-%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">2、Git 高层命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Git-%E7%89%B9%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">四、Git  特点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B4%E6%8E%A5%E8%AE%B0%E5%BD%95%E5%BF%AB%E7%85%A7%EF%BC%8C%E8%80%8C%E9%9D%9E%E5%B7%AE%E5%BC%82%E6%AF%94%E8%BE%83"><span class="nav-number">4.1.</span> <span class="nav-text">（1）直接记录快照，而非差异比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%91%E4%B9%8E%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E9%83%BD%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">4.2.</span> <span class="nav-text">（2）近乎所有操作都是本地执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.3.</span> <span class="nav-text">（3）时刻保持数据完整性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%A4%9A%E6%95%B0%E6%93%8D%E4%BD%9C%E4%BB%85%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">4.4.</span> <span class="nav-text">（4）多数操作仅添加数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">4.5.</span> <span class="nav-text">（5）文件的三种状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Git-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">五、Git 工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-number">6.</span> <span class="nav-text">六、代码风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Eslint"><span class="nav-number">6.1.</span> <span class="nav-text">Eslint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git-%E6%97%B6%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="nav-number">6.2.</span> <span class="nav-text">git 时忽略某些文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gitignore-%E7%9A%84%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83"><span class="nav-number">6.2.1.</span> <span class="nav-text">.gitignore 的格式规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glob-%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.2.2.</span> <span class="nav-text">glob 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Eslint"><span class="nav-number">6.3.</span> <span class="nav-text">使用 Eslint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eslint-%E7%BB%93%E5%90%88-git"><span class="nav-number">6.4.</span> <span class="nav-text">eslint 结合 git</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">七、团队协作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">7.1.</span> <span class="nav-text">远程仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%8D%8F%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">远程协作基本流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8E%A8%E9%80%81%E5%92%8C%E6%8B%89%E5%8F%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.3.</span> <span class="nav-text">正常的数据推送和拉取步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">7.4.</span> <span class="nav-text">删除远程分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pull-request-%E6%B5%81%E7%A8%8B"><span class="nav-number">7.5.</span> <span class="nav-text">pull request 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">7.5.1.</span> <span class="nav-text">基本流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">7.6.</span> <span class="nav-text">深入理解远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">7.6.1.</span> <span class="nav-text">远程跟踪分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF%EF%BC%88%E8%BF%99%E6%98%AF%E4%B8%AA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%EF%BC%89"><span class="nav-number">7.6.2.</span> <span class="nav-text">跟踪分支（这是个本地分支）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF"><span class="nav-number">7.6.3.</span> <span class="nav-text">推送其他分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%A6%82%E4%BD%95%E8%B7%9F%E8%B8%AA%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">7.6.4.</span> <span class="nav-text">本地分支如何跟踪一个远程跟踪分支</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B2%E7%AA%81"><span class="nav-number">7.7.</span> <span class="nav-text">冲突</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81SSH"><span class="nav-number">8.</span> <span class="nav-text">八、SSH</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E4%BA%94%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">九、使用频率最高的五个命令</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-08 01:37:18" itemprop="dateCreated datePublished" datetime="2022-02-08T01:37:18+08:00">2022-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、版本控制"><a href="#一、版本控制" class="headerlink" title="一、版本控制"></a>一、版本控制</h1><p>Git 是版本控制器，版本控制是一种记录一个或若干文件内容变化以便将来查阅特定版本修订情况的系统</p>
<a id="more"></a>

<p>版本控制系统分为集中式和分布式</p>
<h2 id="为什么要使用版本控制"><a href="#为什么要使用版本控制" class="headerlink" title="为什么要使用版本控制"></a>为什么要使用版本控制</h2><p>（1）软件开发中采用版本控制系统可将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间的的状态，且额外增加的工作量很少</p>
<p>（2）还可比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致问题出现的原因，又是谁在何时报告了某个功能缺陷等</p>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>集中化的版本控制系统，如  CVS，Subversion（svn） 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或提交更新。</p>
<p>svn 因为每次存的都是差异(A1、A2-A1…An-A(n-1))，需要的硬盘空间会相对小一点，可是回退的速度会很慢</p>
<p><strong>优点：</strong>代码存放在单一服务器上便于项目管理</p>
<p>每个人都可以在一定程度上看到项目中的其他人正在做些什么，而管理员也可以轻松掌控每个开发者的权限，并管理一个集中化的版本控制系统，远比在各个客户端上维护本地数据库来的轻松容易</p>
<p><strong>缺点：</strong>服务器宕机：员工写的代码得不到保障，不敢轻易修改代码；服务器炸了：整个项目历史记录都会丢失</p>
<p>中央服务器的单点故障，若服务器宕机一小时，这一小时内谁都无法提交更新也就无法协同工作。若中央服务器磁盘发生故障，且没备份或备份不及时，就会有丢失数据的风险，甚至彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来保存在本地的某些快照数据不能保证所有数据都有人事先完整提取出来过，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>在这类系统中，如 Git、BitKeeper 等客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来（每台电脑都相当于一台服务器）。这样任何一处协同工作用的服务器发生故障事后都可以用任何一个镜像出来的本地仓库恢复，因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p>
<p>许多这类系统都可以指定和若干不同的远端代码仓库进行交互，所以就可以在同一个项目中分别和不同工作小组的人相互协作</p>
<p>git 每次存的是项目完整快照(A1、A1A2…A(n-1)An)，需要的硬盘空间相对大一点，但 Git 团队对代码做了极致的压缩，最终需要的实际空间比 svn 大不了很多，可是 Git 的回滚速度很快</p>
<p>分布式版本控制系统在管理项目时，存放的不是项目版本与版本之间的差异，它存的是索引，因此所需磁盘空间很少，每个客户端都可以放下整个项目的历史记录</p>
<p>优点：分布式版本控制系统解决了集中式版本控制系统的缺陷</p>
<p>— 断网时也可以进行开发（因为版本控制是在本地进行的）</p>
<p>— 使用 github 进行团队协作，哪怕 github 挂了，每个客户端保存的也都是包含历史记录的整个完整项目</p>
<p>缺点：学习起来比 svn 陡峭</p>
<h1 id="二、Git"><a href="#二、Git" class="headerlink" title="二、Git"></a>二、Git</h1><p>Git 是目前世界上最先进的分布式版本控制系统，设计目标是分支切换速度快，容量小（压缩），完全分布式，非线性分支管理（允许上千个并行开发的分支），适合管理大项目（对速度和数据量的高要求，如有能力管理类似 Linux 内核一样的超大规模项目）</p>
<h2 id="1、Git-安装和配置"><a href="#1、Git-安装和配置" class="headerlink" title="1、Git 安装和配置"></a>1、Git 安装和配置</h2><p>在<a target="_blank" rel="noopener" href="https://git-scm.com/download/win">官网</a>下载并安装</p>
<p>Git 提供了一个叫 git config 的命令来配置或读取相应的工作环境变量，这些变量可以存放在以下三个不同地方</p>
<pre><code>/etc/gitconfig 文件：系统中所有用户都普遍适用的配置，若使用 git config 时用 --system 选项，读写的就是这个文件
~/.gitconfig 文件：用户都目录下的配置文件只适用于该用户，若使用 git config 时用 --global 选项，读写的就是这个文件
.git/config 文件：当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件），这里的配置仅针对当前项目有效</code></pre>
<p>注意每个级别的配置都会覆盖上层的相同配置（项目目录下的配置文件优先级最高）</p>
<p>安装后需要配置用户信息（用户名称和电子邮箱），每次 Git 提交时都会引用这两条信息，会随更新内容一起被永久写入历史记录</p>
<pre><code>git config --global user.name &quot;xxx&quot;
git config --global user.email xxx@xxx.com</code></pre>
<p>通过 <code>git config --list</code> 查看已有配置信息</p>
<p>注：也可通过 <code>git config --global --unset user.name</code> 或 <code>git config --global --unset user.email</code> 删除配置信息</p>
<h2 id="2、区域"><a href="#2、区域" class="headerlink" title="2、区域"></a>2、区域</h2><p>区域有三个区域：工作区、暂存区（索引区）、版本库</p>
<p>工作区就是本地代码，是个沙箱环境，在将修改提交到暂存区并记录到历史之前可以随意修改</p>
<p>暂存区可通过 <code>git ls-files -s</code> 查看暂存区当前的样子</p>
<p>版本库可通过 <code>find .git/objects -type f</code> 查看版本库中所有文件</p>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><p>对象有 Git 对象、树对象、提交对象</p>
<p>git 对象相当于文件的一个个版本</p>
<p>树对象相当于项目的一个个版本的快照</p>
<p>提交对象只是树对象的封装，提供作者等信息，提交对象是链式的</p>
<p>一个提交对象对应一个树对象，一个树对象可以对应很多个 git 对象，一个 git 对象对应一个文件，则一个提交对象可以对应很多个文件</p>
<h2 id="4、Git-底层概念（底层命令）"><a href="#4、Git-底层概念（底层命令）" class="headerlink" title="4、Git 底层概念（底层命令）"></a>4、Git 底层概念（底层命令）</h2><h3 id="基础-Linux-命令"><a href="#基础-Linux-命令" class="headerlink" title="基础 Linux 命令"></a>基础 Linux 命令</h3><p>clear：清除屏幕</p>
<p>echo ‘xxx’：往控制台输出信息</p>
<p>echo ‘xxx’ &gt; xxx.txt 往控制台输出信息并存到文件中</p>
<p>ll：将当前目录下的子文件和子目录平铺在控制台</p>
<p>find 目录名：将对应目录下的子孙文件和子孙目录平铺在控制台</p>
<p>find 目录名 -type f：将对应目录下的文件平铺在控制台</p>
<p>rm 文件名：删除文件</p>
<p>mv 源文件 重命名文件：重命名</p>
<p>cat 文件的url：查看对应文件内容</p>
<p>vim 文件的url：编辑文件，按 esc 后按 :q!（强制推出不保存）或按 :wq（保存退出）或按 :set nu（设置行号）</p>
<h3 id="git-对象"><a href="#git-对象" class="headerlink" title="git 对象"></a>git 对象</h3><p>git 对象用于存储数据内容</p>
<p>Git 对象核心部分是个简单的键值对数据库，可向数据库插入任意类型内容，返回一个键值，通过键值可在任意时刻再次检索该内容</p>
<p>Git 存储的键值对（即 Git 对象）是 blob 类型</p>
<h4 id="向数据库写入内容并返回对应键值"><a href="#向数据库写入内容并返回对应键值" class="headerlink" title="向数据库写入内容并返回对应键值"></a>向数据库写入内容并返回对应键值</h4><p><strong>将控制台内容存入文件</strong></p>
<pre><code>echo &#39;test content&#39; | git hash-object -w --stdin</code></pre>
<p>-w 选项指示 hash-object 命令存储数据对象，若不指定该选项，则该命令仅返回对应键值，不存储数据</p>
<p>–stdin （standard input）选项指示该命令从标准输入读取内容，若不指定该选项则须在命令尾部给出待存储文件的路径 <code>git hash-object -w 文件路径</code></p>
<p>该命令输出一个长度为 40 个字符的校验和（SHA-1 哈希值）</p>
<p><strong>存文件（往 git 数据库中存对象）</strong></p>
<pre><code>git hash-object -w 文件路径</code></pre>
<p><strong>返回对应文件的键值</strong></p>
<pre><code>git hash-object 文件路径</code></pre>
<h4 id="Git-如何存储数据"><a href="#Git-如何存储数据" class="headerlink" title="Git 如何存储数据"></a>Git 如何存储数据</h4><p>开始时 Git 存储内容的方式是一个文件对应一条内容，校验和的前两个字符用于命名 objects 下子目录，余下的 38 个字符用作文件名</p>
<p>如存储数据后通过命令 <code>find .git/objects -type f</code> 查看保存的文件（假设该文件哈希值为 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc），返回 .git/objects/d6/70460aaaaaaaaaaaaabbbbbbbbbbcccccccccc，该命令用于查看版本库内容</p>
<h4 id="根据键值拉取数据"><a href="#根据键值拉取数据" class="headerlink" title="根据键值拉取数据"></a>根据键值拉取数据</h4><p>下列命令返回文件内容</p>
<pre><code>git cat-file -p 完整哈希值</code></pre>
<p>-p 选项指示该命令自动判断内容的类型，并显示格式友好的内容（即不是压缩后的乱码）</p>
<p>下列命令可显示存储的任何对象的类型</p>
<pre><code>git cat-file -t 完整哈希值</code></pre>
<h4 id="对一个文件进行简单版本控制"><a href="#对一个文件进行简单版本控制" class="headerlink" title="对一个文件进行简单版本控制"></a>对一个文件进行简单版本控制</h4><p>创建一个新文件并将其内容存入数据库</p>
<pre><code>echo &#39;version 1&#39; &gt; test.txt
git hash-object -w test.txt</code></pre>
<p>返回文件哈希值</p>
<p>向文件写入新内容，并再次将其存入数据库</p>
<pre><code>echo &#39;version 2&#39; &gt; test.txt
git hash-object -w test.txt</code></pre>
<p>此时会生成新哈希值就会在 objects 中生成新目录新文件</p>
<p>注意上述所有操作当前都是对本地数据库进行操作，直接存至版本库，不涉及暂存区</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、记住文件的每个版本所对应的 SHA-1 值并不现实</p>
<p>2、在 Git 中，文件名并没有被保存，仅保存了文件内容</p>
<p><strong>解决：</strong>树对象</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object）能解决文件名保存的问题，也允许将多个文件组织到一起。</p>
<p>Git 以一种类似于 UNIX 文件系统的方式存储内容，所有内容均以树对象和数据对象（git 对象）的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象（git 对象）大致上对应文件内容</p>
<p>一个树对象包含一条或多条记录（一条记录即一个 git 对象），也可以包含另一个树对象，每条记录含有一个指向 git 对象或子树对象的 SHA-1 指针，及对应的模式、类型、文件名信息</p>
<h4 id="构建树对象"><a href="#构建树对象" class="headerlink" title="构建树对象"></a>构建树对象</h4><p>可通过 update-index、write-tree、read-tree 等命令构建树对象并塞入暂存区</p>
<p>（1）利用 update-index 命令为 git 数据库中已存在的 test.txt 文件的首个版本创建一个暂存区，让 git 对象对应上文件名，并通过 write-tree 命令生成树对象并存入版本库</p>
<pre><code>git update-index --add --cacheinfo 100644 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc test.txt
git write-tree</code></pre>
<p>其中文件模式<br>    100644 表示这是个普通文件<br>    100755 表示一个可执行文件<br>    120000 表示一个符号链接</p>
<p><code>--add</code> 选项：因为此前该文件并不在暂存区中，首次添加需要 <code>--add</code></p>
<p><code>--cacheinfo</code> 选项：因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下，所以需要 <code>--cacheinfo</code></p>
<p>（2）新增 new.txt 将 new.txt 和 test.txt 文件的第二个版本塞入暂存区，并通过 write-tree 命令生成树对象并存入版本库</p>
<pre><code>echo &#39;new file&#39; &gt; new.txt
git update-index --cacheinfo 10064 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc test.txt 此时会覆盖原先暂存区中的test.txt
git update-index --add new.txt 该命令完成两步（1）生成 git 对象存入版本库（2）将 new.txt 文件放入暂存区（执行类似上条命令，但需要加 --add，因为该文件首次加入暂存区）</code></pre>
<p>（3）将第一个树对象加入第二个树对象，使其称为新的树对象</p>
<pre><code>git read-tree --prefix=bak 第一个树对象的哈希值
git write-tree</code></pre>
<p>read-tree 命令可以把树对象读入暂存区</p>
<p>最终树对象结构如下</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%AF%B9%E8%B1%A1.png" alt="树对象"></p>
<h4 id="查看树对象"><a href="#查看树对象" class="headerlink" title="查看树对象"></a>查看树对象</h4><pre><code>git cat-file -p master^&#123;tree&#125;或是树对象的hash</code></pre>
<p>master^{tree} 语法表示 master 分支上最新提交所指向的树对象</p>
<h4 id="解析树对象"><a href="#解析树对象" class="headerlink" title="解析树对象"></a>解析树对象</h4><p>Git 给根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录某个时间段内一系列的树对象</p>
<p>其实树对象是对暂存区内操作的抽象，树对象相当于快照，当工作区有任何更改同步到暂存区时，便会调用 write-tree 命令</p>
<p>通过 write-tree 命令向暂存区内容写入一个树对象，它会根据当前暂存区状态自动创建一个新的树对象，即每一次同步都产生一个树对象，且该命令返回一个 hash 指向树对象</p>
<p>在 Git 中每个文件（数据）都对应一个 hash（blob 类型），每个树对象都对应一个 hash（tree 类型）</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>现有两个树对象分别代表想要跟踪的不同项目快照，若想宠用这些快照必须记住所有 SHA-1 哈希值，可能完全不指定谁在什么时候保存了这些快照</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>可通过调用 <code>commit-tree</code> 创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（若有的话）（第一次将暂存区做快照就没有父对象）</p>
<p>git commit-tree 不但生成提交对象，而且会将对应的快照（树对象）提交到版本库中</p>
<h4 id="创建提交对象"><a href="#创建提交对象" class="headerlink" title="创建提交对象"></a>创建提交对象</h4><pre><code>echo &#39;first commit&#39; | git commit-tree 树对象哈希值</code></pre>
<p>返回提交对象哈希值</p>
<h4 id="查看提交对象"><a href="#查看提交对象" class="headerlink" title="查看提交对象"></a>查看提交对象</h4><pre><code>git cat-file -p 提交对象哈希值</code></pre>
<h4 id="提交对象的格式"><a href="#提交对象的格式" class="headerlink" title="提交对象的格式"></a>提交对象的格式</h4><p>它先指定一个顶层树对象，代表当前项目快照，然后是作者/提交信息（依据 user.name 和 user.email 配置，外加一个时间戳），空一行，最后是提交注释</p>
<p>创建另外两个提交对象，它们分别引用各自的上一个提交作为其父对象</p>
<pre><code>echo &#39;second commit&#39; | git commit-tree 树对象哈希值 -p 第一个提交对象哈希值
echo &#39;third commit&#39; | git commit-tree 树对象哈希值 -p 上一个提交对象哈希值</code></pre>
<h2 id="5、Git-本地操作（高层命令）"><a href="#5、Git-本地操作（高层命令）" class="headerlink" title="5、Git 本地操作（高层命令）"></a>5、Git 本地操作（高层命令）</h2><h3 id="git-操作基本流程"><a href="#git-操作基本流程" class="headerlink" title="git 操作基本流程"></a>git 操作基本流程</h3><p>（1）创建工作目录，对工作目录进行修改</p>
<p>（2）git add 路径</p>
<p>（3）git commit -m “注释内容”</p>
<h3 id="初始化新仓库"><a href="#初始化新仓库" class="headerlink" title="初始化新仓库"></a>初始化新仓库</h3><p>要对现有的某个项目开始用 Git 管理，只需在此项目所在目录下执行 <code>git init</code> 初始化新仓库</p>
<p>作用：初始化后在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中</p>
<pre><code>hooks：目录包含客户端或服务端的钩子脚本
info：包含一个全局性排除的文件
logs：保存日志信息
objects：目录存储所有数据内容
refs：目录存储指向数据的提交对象的指针（即分支）
config：文件包含项目特有的配置选项
description：用来显示对仓库的描述信息
HEAD：文件指示目前所检出的分支
index：文件保存暂存区信息</code></pre>
<p>至此仅是按照既有的结构框架初始化里边所有文件和目录，还没开始跟踪管理项目中的任何一个文件</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下所有文件都不外乎两种状态：已跟踪 或 未跟踪</p>
<p><strong>已跟踪的文件</strong>指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<strong>已提交、已修改或已暂存</strong></p>
<p>所有其他文件都属于<strong>未跟踪文件</strong>，它们既没有上次更新时的快照也不在当前的暂存区域</p>
<p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为已提交，在编辑过某些文件后，Git 将这些文件标记为已修改，我们逐步把这些修改过的文件放到暂存区，最后一次性提交所有暂存文件</p>
<h3 id="跟踪新文件（将修改添加到暂存区）"><a href="#跟踪新文件（将修改添加到暂存区）" class="headerlink" title="跟踪新文件（将修改添加到暂存区）"></a>跟踪新文件（将修改添加到暂存区）</h3><pre><code>git add ./</code></pre>
<p>git add 命令是先将工作区的文件以 git 对象（几个文件就对应几个 git 对象）存储到版本库中，再存放到暂存区</p>
<p>此时这些文件受到 git 管理</p>
<p>该命令相当于底层命令中的 <code>git hash-object -w 文件名</code>（修改了多少个工作目录中的文件此命令就要被执行多少次）和 <code>git update-index ...</code></p>
<h3 id="提交更新（将暂存区提交到版本库）"><a href="#提交更新（将暂存区提交到版本库）" class="headerlink" title="提交更新（将暂存区提交到版本库）"></a>提交更新（将暂存区提交到版本库）</h3><p>方式一：</p>
<pre><code>git commit</code></pre>
<p>这种方式会启动文本编辑器以便输入提交注释，默认的注释是最后一次 git status 的输出</p>
<p>方式二：</p>
<pre><code>git commit -m &quot;注释&quot;</code></pre>
<p>执行上述两种命令进行提交，不会清空暂存区</p>
<p>该命令相当于底层命令中的 <code>git write-tree</code> 和 <code>git commit-tree</code></p>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><pre><code>git status</code></pre>
<p>查看文件当前处于什么状态</p>
<p>文件状态生命周期如下图所示</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="文件状态生命周期"></p>
<p>注意若对已经 add 但未 commit 的文件进行修改后使用 git status 查看会显示该文件有两种状态，一种是已暂存（这种状态对应最新修改前的版本），一种是已修改未暂存（这种状态对应最新修改后的版本），此时需要重新 add 后 commit 提交的才是最新版本</p>
<h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><p>git status 只是列出修改过的文件，若要查看具体修改的地方，用 git diff 命令</p>
<p>查看当前做的哪些更新还没有暂存</p>
<pre><code>git diff</code></pre>
<p>有哪些更新已经暂存还没提交</p>
<pre><code>git diff --cached
或
git diff --staged（1.6.1以上版本）</code></pre>
<h3 id="跳过使用暂存区"><a href="#跳过使用暂存区" class="headerlink" title="跳过使用暂存区"></a>跳过使用暂存区</h3><p>给 git commit 加上 -a 选项，Git 会自动把所有<strong>已跟踪的文件</strong>暂存起来一并提交，从而跳过 git add 步骤（注意只有已跟踪的文件才能用这条命令，没有跟踪过的文件还是需要先 add）</p>
<pre><code>git commit -a
或
git commit -a -m &quot;注释&quot;</code></pre>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>方式一：</p>
<p>若在工作目录中删除某文件相当于一次修改操作，依然需要 add 和 commit</p>
<p>方式二：</p>
<p>要从 Git 中移除某文件，必须从已跟踪文件清单中年注册删除（也就是在暂存区注册删除），然后提交</p>
<pre><code>git rm 文件路径和名
git status
git commit -m &quot;注释&quot;</code></pre>
<p><code>git rm</code> 删除工作目录中指定文件，再将修改添加到暂存区，这样以后就不会出现在未跟踪文件清单中</p>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><pre><code>git mv 原文件 新文件路径和名
git status</code></pre>
<p>git mv 将工作目录中的文件进行重命名，再将修改添加到暂存区</p>
<p>运行 <code>git mv</code> 相当于运行了三条命令：（1）<code>git mv 原文件 新文件</code>（2）<code>git rm 原文件</code>（3）<code>git add 新文件</code></p>
<h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><pre><code>git log</code></pre>
<p>默认不加任何参数时 git log 会按提交时间列出所有更新，最近的排在最上面，会列出哈希值、作者名、邮箱、提交时间、提交说明</p>
<pre><code>git log --pretty=oneline</code></pre>
<p>每条记录的信息排列在一行</p>
<pre><code>git log --oneline</code></pre>
<p>每条记录的信息排列在一行，且提交对象哈希值只显示前 7 位</p>
<pre><code>git reflog</code></pre>
<p>只要 HEAD 有变化，git reflog 就会记录下来</p>
<h2 id="6、Git-分支操作（杀手功能）"><a href="#6、Git-分支操作（杀手功能）" class="headerlink" title="6、Git 分支操作（杀手功能）"></a>6、Git 分支操作（杀手功能）</h2><p>几乎所有版本控制系统都以某种形式支持分支。使用分支可以把工作从开发主线上分离开来，以免影响开发主线，相当于创建一个源码目录副本，十分耗时低效，但 Git 的分支模型及其高效轻量，也是这一特性让 Git 脱颖而出</p>
<p>分支的本质是指向提交对象的可变指针，可理解为其实就是一个提交对象（相当于给提交对象取名），那个可变指针是 HEAD</p>
<p>HEAD 是个指针，默认指向 master 分支，切换分支时就是让 HEAD 指向不同分支</p>
<p>每次有新的提交时，HEAD 都会带着当前指向的分支一起往前移动</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code>git branch 分支名</code></pre>
<p>作用：在当前所在提交对象上创建一个可移动的新指针</p>
<p>注意：创建新分支后不会自动切换到新分支上</p>
<pre><code>git checkout -b 分支名</code></pre>
<p>上述命令新建一个分支并切换到该分支上</p>
<pre><code>git branch 分支名 提交对象哈希值</code></pre>
<p>上述命令新建一个分支并使分支指向对应提交对象，通过该命令可实现版本回退，想回哪里回哪里，只需在之前某版本处创建一个分支指向它即可查看该版本内容</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre><code>git branch</code></pre>
<p>得到当前所有分支的列表</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre><code>git branch -d 分支名</code></pre>
<h3 id="查看每个分支的最后一次提交"><a href="#查看每个分支的最后一次提交" class="headerlink" title="查看每个分支的最后一次提交"></a>查看每个分支的最后一次提交</h3><pre><code>git branch -v</code></pre>
<h3 id="查看已合并到当前分支的分支"><a href="#查看已合并到当前分支的分支" class="headerlink" title="查看已合并到当前分支的分支"></a>查看已合并到当前分支的分支</h3><pre><code>git branch -merged</code></pre>
<p>在这个列表中分支名且前没有 * 号的分支通常可以使用</p>
<h3 id="查看所有包含未合并工作的分支"><a href="#查看所有包含未合并工作的分支" class="headerlink" title="查看所有包含未合并工作的分支"></a>查看所有包含未合并工作的分支</h3><pre><code>git branch --no-merged</code></pre>
<p>一旦出现在这个列表中就应该观察一些是否需要合并</p>
<p>使用 git branch -d 删除在这个列表中的分支时会失败，若真要删除分支并丢掉那些工作可使用 -D 选项强制删除它</p>
<h3 id="查看当前分支所指对象"><a href="#查看当前分支所指对象" class="headerlink" title="查看当前分支所指对象"></a>查看当前分支所指对象</h3><pre><code>git log --oneline --decorate</code></pre>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code>git checkout 分支名</code></pre>
<p>即将 HEAD 指针指向切换的分支，HEAD 默认指向 master（有新版本 HEAD 带动着 master 向前移动）</p>
<p>切换分支会动三个地方：HEAD、暂存区、工作目录</p>
<p>最佳方法：每次切换分之前，当前分支一定得是干净的（已提交状态）（可通过 git status 查看是否 clean）</p>
<p>坑：在切换分支时，若当前分支上有未暂存修改或未提交的暂存，此时分支可以切换成功，但可能会污染其他分支（这种情况针对于增加某文件时，若文件已在某分支提交过只是修改，则不会有该坑，git 自己会禁止切换分支操作）</p>
<pre><code>如在分支test中新增文件但未跟踪（没有 add）或 add 了但没有 commit，此时切回 master，该文件依然存在

若在分支test中修改文件但没有 add 或 add 了但没有 commit，此时 Git 就不让切换分支</code></pre>
<p>注意：分支切换回改变工作目录中的文件，在切换分支时，一定要注意工作目录里的文件会被改变，若是切换到一个较旧的分支，工作目录会恢复到该分支最后一次提交时的样子，若 Git 不能干净利落完成这个任务将禁止切换分支</p>
<p><strong>每次在切换分支前，提交一下当前分支</strong></p>
<p>允许切换分支的情况：</p>
<pre><code>（1）分支上所有内容处于已提交状态
（2）分支上内容是初始化创建的，处于未跟踪状态，但这种情况要避免切换分支
（3）分支上内容是初始化创建的且该文件是第一次处于已暂存状态（即第一次 add 该文件，且 add 后没有修改过该文件），但这种情况要避免切换分支</code></pre>
<p>不允许切换分支的情况：</p>
<pre><code>（1）分支上所有内容处于已修改状态
（2）第二次以后的已暂存状态</code></pre>
<h3 id="查看项目分支历史"><a href="#查看项目分支历史" class="headerlink" title="查看项目分支历史"></a>查看项目分支历史</h3><pre><code>git log --oneline --decorate --graph --all</code></pre>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>先切回 master 分支，再合并分支</p>
<pre><code>git merge 分支名</code></pre>
<p>快进合并（fast-forward）：若合并两个分支时，顺着一个分支走下去能到达另一个分支，那么 Git 在合并时只会简单地将指针向前推进。快进合并没有冲突问题</p>
<p>典型合并：此时 master 不是待合并分支的直接祖先（不在一条线路上），可能两个分支上都对某文件内容进行了修改，要解决冲突就是打开有冲突的文件保留下有用代码删除无用代码后 add（该命令即可标记冲突已解决） 和 commit 提交即可</p>
<h3 id="给命令配别名"><a href="#给命令配别名" class="headerlink" title="给命令配别名"></a>给命令配别名</h3><p>Git 不会在输入部分命令时自动推断你想要的命令，若不想每次输入完整 Git 命令，可通过 git config 文件位每个命令设置一个别名，如</p>
<pre><code>git config --global alias.简称 原命令（不包含&#39;git&#39;）
或
git config --global alias.简称 &quot;原命令（不包含&#39;git&#39;）&quot;
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status</code></pre>
<p>当要输入 git commit 时只需输入 git ci</p>
<h3 id="分支实战"><a href="#分支实战" class="headerlink" title="分支实战"></a>分支实战</h3><p>如在开发某网闸时为实现某新需求创建一个分支</p>
<p>原版本中出现一个 bug 需要修复时，要先将当前分支内容 add 和 commit 提交后切换到  master 分支，然后新建一个分支完成 bug 修复</p>
<p>测试通过后切回 master 分支，合并这个修补分支，最后将改动推送到 master 上，此时可以删除修补分支</p>
<p>最后切换回最初工作的分支上继续工作</p>
<h3 id="分支模式"><a href="#分支模式" class="headerlink" title="分支模式"></a>分支模式</h3><p>长期分支（即 master）</p>
<p>特性分支（如 dev、topic功能分支）</p>
<h3 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h3><p>.git/refs 目录中保存了分支及其对应的提交对象</p>
<h4 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h4><p>当运行类似于 <code>git branch 分支名</code> 这样的命令时，Git 会取得当前所在分支最新提交对应的哈希值，并将其加入你想要创建的任何新分支中</p>
<p><strong>当执行 <code>git branch 分支名</code> 时 Git 如何直到最新提交的哈希值呢？</strong></p>
<p>答：通过 HEAD 文件，HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支，所谓符号引用意味着它不像普通引用那样包含一个 SHA-1 值，它是一个指向其他引用的指针</p>
<h2 id="7、Git-存储"><a href="#7、Git-存储" class="headerlink" title="7、Git 存储"></a>7、Git 存储</h2><p>若工作一半需要切换分支，但原工作分支上不想创建一次提交，此时可以使用 <code>git stash</code> 命令</p>
<p><code>git stash</code> 会将未完成的修改保存到一个栈上，可在任何时候通过 <code>git stash apply</code> 重新应用这些改动</p>
<h3 id="git-stash-相关命令"><a href="#git-stash-相关命令" class="headerlink" title="git stash 相关命令"></a>git stash 相关命令</h3><pre><code>git stash list： 查看存储
git stash apply stash@&#123;编号&#125;：若不指定储藏，默认是最近的储藏，注意该命令只会应用栈顶元素不会从栈里删除，应用后可搭配 git ，编号可通过 git stash list 查看
stash drop 删除该元素
git stash drop stash@&#123;编号&#125;：移除某储藏
git stash pop： 应用储藏然后立即从栈上扔掉它（即应用并从栈中删除）</code></pre>
<h2 id="8、数据恢复"><a href="#8、数据恢复" class="headerlink" title="8、数据恢复"></a>8、数据恢复</h2><p>可能因为强制删除正在工作的分支或硬重置一个分支而丢失一次提交</p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><h4 id="撤回工作目录中的修改"><a href="#撤回工作目录中的修改" class="headerlink" title="撤回工作目录中的修改"></a>撤回工作目录中的修改</h4><pre><code>git checkout -- 文件</code></pre>
<h4 id="撤回暂存"><a href="#撤回暂存" class="headerlink" title="撤回暂存"></a>撤回暂存</h4><pre><code>git reset HEAD 文件</code></pre>
<h4 id="撤回提交"><a href="#撤回提交" class="headerlink" title="撤回提交"></a>撤回提交</h4><pre><code>git commit --amend</code></pre>
<p>作用：该命令会将暂存区中的文件提交，若自上次提交以来还未做任何修改，那么快照会保持不变，修改的只是提交信息</p>
<p>若提交时注释写错了，可通过 <code>git commit --amend</code> 重新给用户一次机会改注释</p>
<p>若提交后还有需暂存的文件，或者 add 后又对文件进行修改，可使用以下命令提交新文件</p>
<pre><code>git commit -m &quot;第一次提交&quot;   对于第二种情况这里提交的是之前 add 的文件即修改前的文件
git add 新的暂存文件
git commit --amend</code></pre>
<p>第二次提交将代替第一次提交结果，最终只会有一个提交</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><h4 id="reset-三部曲"><a href="#reset-三部曲" class="headerlink" title="reset 三部曲"></a>reset 三部曲</h4><p>假设文件最初有三个版本，且 HEAD 和 master 都指向最后一次提交，如下图</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset0.png" alt="reset0"></p>
<p><strong>（1）移动 HEAD</strong></p>
<pre><code>git reset --soft HEAD~
或
git reset --soft 上一次提交对象哈希值</code></pre>
<p>上述指令与 checkout 所作的改变 HEAD 自身不同（HEAD 移动，分支不动），reset 是移动 HEAD 指向的分支</p>
<p>该命令只动 HEAD（带着分支一起移动），工作区和暂存区不变</p>
<p>本质上是撤销上一次 git commit 命令。运行 git commit 命令时 Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。当 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，不会改变索引和工作目录，此后可更新索引并再次运行 git commit 命令来完成 git commit –amend 所要做的事</p>
<p>HEAD~ 表示上一次 HEAD</p>
<p><code>git reset --soft HEAD~</code> 相当于 –amend</p>
<p>注意 <code>git reset --soft 提交对象哈希值</code> 可前进到回退之前的版本，这个哈希值可以通过 <code>git reflog</code> 查看</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset1.png" alt="reset1"></p>
<p><strong>（2）更新暂存区（索引）</strong></p>
<pre><code>git reset [--mixed] HEAD~</code></pre>
<p><code>git reset HEAD~</code> 等同于 <code>git reset --mixed HEAD~</code></p>
<p>该命令动了 HEAD（带着分支一起移动）和暂存区</p>
<p>它依然会撤销上一次提交，同时还会取消上一次暂存的所有东西，所以回滚到上一次 add 和 commit 执行之前</p>
<p>注意 <code>git reset --mixed 提交对象哈希值</code> 可前进到回退之前的版本，这个哈希值可以通过 <code>git reflog</code> 查看</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset2.png" alt="reset2"></p>
<p><strong>（3）更新工作目录</strong></p>
<pre><code>git reset --hard HEAD~</code></pre>
<p>撤销了最后的提交、add、commit 以及工作目录中的所有工作</p>
<p>该命令动了 HEAD（带着分支一起移动）、暂存区和工作区</p>
<p>该命令和 chechout 很像，都动了 HEAD、暂存区和工作区，但唯一区别是 checkout 中分支位置没变（即 master 没有跟着 HEAD 移动）</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset3.png" alt="reset3"></p>
<p>注意：–hard 是 reset 命令唯一的危险用法，也是 Git 会真正销毁数据的仅有的几个操作之一，其他任何形式的 reset 都可以轻松撤销，但 –hard 选项不能，因为它强制覆盖了工作目录中的文件</p>
<p>在这种情况下，Git 数据库中的一个提交内还留有该文件的最新版（file.txt v3），可通过 reflog 找回它，但若该文件还未提交，Git 仍会覆盖它从而导致无法恢复</p>
<h5 id="checkout-和-–hard-的区别"><a href="#checkout-和-–hard-的区别" class="headerlink" title="checkout 和 –hard 的区别"></a>checkout 和 –hard 的区别</h5><p><code>git checkout 提交对象哈希值</code> 和 <code>git reset --hard 提交对象哈希值</code> 的区别为</p>
<p>（1）checkout 只动 HEAD，–hard 动 HEAD 且带着分支一起走</p>
<p>（2）checkout 对工作目录是安全的（就算在某分支有没有提交的文件，在切换分支后该文件依然在工作区中），–hard 是强制覆盖工作目录</p>
<h4 id="路径-reset"><a href="#路径-reset" class="headerlink" title="路径 reset"></a>路径 reset</h4><pre><code>git reset [--mixed] HEAD </code></pre>
<p>在 reset 命令中若指定一个路径，reset 将会跳过第 1 步，即该命令只动暂存区，并将它的作用范围限定为指定文件或文件集合。这是因为 HEAD 只是个指针，无法让它同时指向两个提交中各自的一部分，但索引（即暂存区）和工作目录可以部分更新，所以重置会继续进行第 2、3 步</p>
<p>例子</p>
<p>如修改 file.txt 且 add 但没有 commit</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/add%E5%90%8E.png" alt="add后"></p>
<p>然后运行</p>
<pre><code>git reset file.txt
其实是 git reset --mixed HEAD file.txt 的简写</code></pre>
<p>其中 HEAD 指向上一次提交内容，上一次提交内容即为上一次暂存区中的内容，因此相当于用上一次暂存区覆盖当前暂存区，本质上就是一次重置操作</p>
<p>它会移动 HEAD 分支的指向</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset%E5%90%8E.png" alt="reset后"></p>
<h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><h5 id="不带路径"><a href="#不带路径" class="headerlink" title="不带路径"></a>不带路径</h5><pre><code>git checkout [分支名]</code></pre>
<p>运行该命令与运行 <code>git reset --hard [分支名]</code> 非常相似，它会更新三者使其看起来像要切换的分支，不过有两点重要区别</p>
<pre><code>区别1：不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢，而 reset --hard 会不做检查就全面替换所有东西
区别2：如何更新 HEAD。reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支

如：在 dev 分支运行 git reset master，则 dev 自身会和 master 指向同一个提交，而若运行 git checkout，dev 不会移动，HEAD 自身会移动，现在 HEAD 会指向 master</code></pre>
<h5 id="带路径"><a href="#带路径" class="headerlink" title="带路径"></a>带路径</h5><p>方式一：</p>
<pre><code>git checkout 提交对象哈希值 文件</code></pre>
<p>若指定一个文件路径，则会像 reset 一样不会移动 HEAD，就像 <code>git reset --hard [分支名] 文件</code> </p>
<p>这样对工作目录不安全，会跳过第 1 步，更新暂存区和工作目录</p>
<p>方式二：</p>
<pre><code>git checkout -- 文件</code></pre>
<p>相比于 <code>git checkout 提交对象哈希值 文件</code>，上述命令第 1、2 步都没做，即 HEAD 和暂存区都没动，只会动工作目录</p>
<h3 id="数据恢复的方式"><a href="#数据恢复的方式" class="headerlink" title="数据恢复的方式"></a>数据恢复的方式</h3><p>方式一：找到对应提交对象的哈希值再使用 reset –hard 硬重置</p>
<p>方式二：    在对应提交对象上创建一个分支</p>
<pre><code>git branch 分支名 提交对象哈希值</code></pre>
<h2 id="9、打-tag"><a href="#9、打-tag" class="headerlink" title="9、打 tag"></a>9、打 tag</h2><p>Git 可以给历史中的某个提交打上标签，一般会用这个功能标记发布结点（v1.0 等）</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><pre><code>git tag
git -l &#39;v1.2.3*&#39; 会列出 v1.2.3 开头的标签</code></pre>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签和附注标签</p>
<p>轻量标签像是一个不会改变的分支，它只是一个特定提交的引用，轻量标签如下</p>
<pre><code>git tag v1.2
git tag v1.2 提交对象哈希值</code></pre>
<p>附注标签是存储在 Git 数据库中的一个完整对象，它可以有哈希值，其中包含打标签者的名字、邮箱、日期时间、标签信息。附注标签如下</p>
<pre><code>git tag -a v1.2
git tag -a v1.2 提交对象哈希值
git tag -a v1.2 提交对象哈希值 -m &quot;注释&quot;</code></pre>
<h3 id="查看特定标签"><a href="#查看特定标签" class="headerlink" title="查看特定标签"></a>查看特定标签</h3><pre><code>git show 标签名</code></pre>
<p>git show 可显示任意类型对象（git 对象、树对象、提交对象、tag 对象）</p>
<h3 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h3><p>默认情况下，git push 命令不会传送标签到远程仓库服务器上，创建完标签后必须显式推送标签到共享服务器上</p>
<pre><code>git push origin [标签名]</code></pre>
<p>若要一次性推送很多标签也可使用 –tags 选项，会把所有不在远程仓库服务器上的标签都推送到那里</p>
<pre><code>git push origin --tags</code></pre>
<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><pre><code>git tag -d 标签名</code></pre>
<p>上述命令可删除本地仓库上的标签，但不会从任何远程库中移除该标签，必须使用如下命令更新远程仓库</p>
<pre><code>git push origin :refs/tags/v1.2</code></pre>
<h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>查看某个标签所指向的文件版本并创建新分支指向它：</p>
<pre><code>git checkout 标签名
git checkout -b 分支名</code></pre>
<p>虽说这会使仓库处于 “分离头指针（detached HEAD）” 状态（即 HEAD 并没有指向哪个分支，而是指向了标签对应的提交版本），在该状态下，若做某些更改并提交，标签不会发生变化，但新提交将不属于任何分支，并将无法访问，除非访问确切的提交对象哈希值，因此若需要进行更改，如修复旧版本的错误，通常要创建一个新分支</p>
<h1 id="三、Git-命令整理"><a href="#三、Git-命令整理" class="headerlink" title="三、Git 命令整理"></a>三、Git 命令整理</h1><h2 id="1、Git-底层命令"><a href="#1、Git-底层命令" class="headerlink" title="1、Git 底层命令"></a>1、Git 底层命令</h2><p><strong>git 对象</strong></p>
<pre><code>git hash-object -w 文件路径
上传一个 key(hash值):val(压缩后的文件内容)存到 .git/objects</code></pre>
<p><strong>tree 对象</strong></p>
<pre><code>git update-index --add --cacheinfo 文件模式 哈希值 文件名
往暂存区添加一条记录（让 git 对象对应上文件名）存到 .git/index
git write-tree
生成树对象</code></pre>
<p><strong>commit 对象</strong></p>
<pre><code>echo &#39;xxxxxx&#39; | git commit-tree 树对象哈希值
生成一个提交对象</code></pre>
<p><strong>对以上对象的查询</strong></p>
<pre><code>git cat-file -p 哈希值
拿到对应对象的内容
git cat-file -t 哈希值
拿到对应对象的类型</code></pre>
<p><strong>查看暂存区</strong></p>
<pre><code>git ls-files -s</code></pre>
<h2 id="2、Git-高层命令"><a href="#2、Git-高层命令" class="headerlink" title="2、Git 高层命令"></a>2、Git 高层命令</h2><p><strong>安装</strong></p>
<pre><code>git --version</code></pre>
<p><strong>初始化配置</strong></p>
<pre><code>git config --global user.name &quot;名字&quot;
git config --gloabal user.email 邮箱
git config --list</code></pre>
<p><strong>初始化仓库</strong></p>
<pre><code>git init</code></pre>
<p><strong>C（新增）</strong></p>
<pre><code>在工作目录新增文件
git status
git add ./
git commit -m &quot;注释&quot;</code></pre>
<p><strong>U（修改）</strong></p>
<pre><code>在工作目录修改文件
git status
git add ./
git commit -m &quot;注释&quot;</code></pre>
<p><strong>D（删除 &amp; 重命名）</strong></p>
<pre><code>git rm 文件路径
git status
git commit -m &quot;注释&quot;

git mv 老文件 新文件
git status
git commit -m &quot;注释&quot;</code></pre>
<p><strong>R（查询）</strong></p>
<pre><code>git status 查看工作目录文件状态
git diff
git diff --cache
git log --oneline
git log --oneline --decorate --graph --all</code></pre>
<p><strong>分支</strong></p>
<pre><code>git log --oneline --decorate --graph --all
查看整个项目的分支图
git branch
查看分支列表
git branch -v
查看分支指向的最新的提交
git branch 分支名
在当前提交对象上创建新分支
git branch 分支名 提交对象哈希值
在指定提交对象上创建新的分支
git checkout 分支名
切换分支
git checkout -b 分支名
创建并切换分支
git branch 分支名 提交对象哈希值
版本穿梭（时光机）
git branch -d 分支名
删除空的分支（即该分支上没有做过任何提交）/删除已经被合并的分支
git branch -D 分支名
强制删除分支
git merge 分支名
合并分支
    快进合并 -- 不会产生冲突
    典型合并 -- 有可能产生冲突
    解决冲突：打开冲突文件进行修改然后 add、commit
git branch --merged
查看合并到当前分支的分支列表，一旦出现在这个列表就应该删除
git branch --no-merged
查看没有合并到当前分支的分支列表，一旦出现在这个列表就应该观察是否需要合并
git stash 将现有做一半的工作存储到栈中
git stash apply 将栈顶工作内容还原，不出栈
git stash drop 删除栈顶
git stash pop 相当于 apply 和 drop 两步操作
git stash list 查看存储</code></pre>
<p><strong>后悔药</strong></p>
<pre><code>git checkout -- 文件名：撤销工作目录的修改
git reset HEAD 文件名：撤销暂存区的修改
git commit --amend： 撤销提交    </code></pre>
<p><strong>reset 三部曲</strong></p>
<pre><code>git reset --soft 提交对象哈希值：用对应提交对象内容重置 HEAD 内容（可对应后悔药中的撤销提交）
git reset [--mixed] 提交对象哈希值：用对应提交对象内容重置 HEAD 内容、重置暂存区（可对应后悔药中的撤销暂存区的修改）
git reset --hard 提交对象哈希值：用对应提交对象内容重置 HEAD 内容、重置暂存区、重置工作目录（可对应后悔药中的撤销工作目录的修改）</code></pre>
<p>三部曲和后悔药其实是一一对应的</p>
<p><strong>路径 reset</strong></p>
<pre><code>所有的路径 reset 都要省略第一步
第一步是重置 HEAD 内容（HEAD 本质指向一个分支，分支的本质是个提交对象，提交对象指向一个树对象，树对象可能指向多个 git 对象，一个 git 对象代表一个文件）
HEAD 可代表一系列文件的状态

git reset [--mixed] 提交对象哈希值 文件
用对应提交对象中的文件的内容重置暂存区</code></pre>
<p><strong>checkout 深入理解</strong></p>
<p>‘git checkout 分支名’ 和 ‘git reset –hard 提交对象哈希值’很像</p>
<p>共同点：</p>
<pre><code>都需要重置 HEAD、暂存区、工作目录</code></pre>
<p>区别：</p>
<pre><code>checkout 对工作目录是安全的，reset --hard 是强制覆盖
checkout 动 HEAD 不会带着分支走，而是切换分支
reset --hard 是带着分支走</code></pre>
<p>checkout + 路径</p>
<pre><code>git checkout 提交对象哈希值 文件
重置暂存区、工作目录
git checkout -- 文件
重置工作目录</code></pre>
<h1 id="四、Git-特点"><a href="#四、Git-特点" class="headerlink" title="四、Git  特点"></a>四、Git  特点</h1><h2 id="（1）直接记录快照，而非差异比较"><a href="#（1）直接记录快照，而非差异比较" class="headerlink" title="（1）直接记录快照，而非差异比较"></a>（1）直接记录快照，而非差异比较</h2><p>Git 和其他版本控制系统的主要差别在于 Git 只关心数据的整体是否发生变化，而大多数其他系统（如 CVS、Subversion、Perforce、Bazaar 等）则只关心文件内容的具体差异，这类系统每次记录哪些文件做了更新以及更新了哪些行什么内容</p>
<h2 id="（2）近乎所有操作都是本地执行"><a href="#（2）近乎所有操作都是本地执行" class="headerlink" title="（2）近乎所有操作都是本地执行"></a>（2）近乎所有操作都是本地执行</h2><p>Git 中绝大多数操作都只需要访问本地文件和资源，不用连网。但若使用 CVCS 的话几乎所有操作都需连网，因为 Git 在本地磁盘上保存着所有当前项目的历史更新，所以处理起来速度飞快</p>
<h2 id="（3）时刻保持数据完整性"><a href="#（3）时刻保持数据完整性" class="headerlink" title="（3）时刻保持数据完整性"></a>（3）时刻保持数据完整性</h2><p>在保存到 Git 之前，所有数据都要进行内容的校验和计算，并将此结果作为数据的唯一标识和索引。索引在文件传输时变得不完整或磁盘损坏导致文件数据缺失，Git 都能立即察觉、</p>
<p>Git 使用 SHA-1 算法计算数据的校验，通过对文件内容或目录结构计算出一个 SHA-1 哈希值作为指纹字符串，由 40 个十六进制字符组成。Git 的工作完全依赖于这类指纹字符串</p>
<h2 id="（4）多数操作仅添加数据"><a href="#（4）多数操作仅添加数据" class="headerlink" title="（4）多数操作仅添加数据"></a>（4）多数操作仅添加数据</h2><p>因为任何一种不可逆的操作，如删除数据，都会使回退或重现历史版本变得困难重重。</p>
<p>在 VCS 中若还未提交更新就有可能丢失或混淆一些修改内容，但在 Git 里一旦提交快照后就完全不用担心丢失数据</p>
<h2 id="（5）文件的三种状态"><a href="#（5）文件的三种状态" class="headerlink" title="（5）文件的三种状态"></a>（5）文件的三种状态</h2><p>对于任何一个文件，在 Git 内部只有三种状态（Git 外的状态就是一个普通文件）：</p>
<p>已提交（committed）：表示该文件已经被安全保存在本地数据库中</p>
<p>已修改（modified）：表示修改了某文件但还没提交保存</p>
<p>已暂存（staged）：表示把已修改的文件放在下次提交时要保存的清单中</p>
<h1 id="五、Git-工作流程"><a href="#五、Git-工作流程" class="headerlink" title="五、Git 工作流程"></a>五、Git 工作流程</h1><p>每个项目都有个 Git 目录（.git），它是 Git 用来保存元数据和对象数据库的地方。每次克隆镜像仓库时，实际拷贝的就是这个目录里的数据</p>
<p>1、在工作目录中修改某些文件</p>
<p>从项目中去除某个版本的所有文件和目录（工作目录），这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的。接下来可在工作目录中编辑文件</p>
<p>2、保存到暂存区，对暂存区做快照</p>
<p>暂存区只不过是个简单的文件，也叫索引文件，一般都放在 Git 目录中</p>
<p>3、提交更新，将保存在暂存区的文件快照永久转储到本地数据库（Git 目录）中</p>
<p>可以从文件所处位置判断状态：</p>
<p>—若是 Git 目录中保存着的特定版本文件，就属于已提交状态</p>
<p>— 若做了修改并已放入暂存区，就属于已暂存状态</p>
<p>— 若自上次取出后，做了修改但还没放到暂存区，就是已修改状态</p>
<h1 id="六、代码风格"><a href="#六、代码风格" class="headerlink" title="六、代码风格"></a>六、代码风格</h1><h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><p>Eslint 是个开源的 JavaScript 代码检查工具，由 Nicholas C.Zakas 于 2013 年 6 月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或代码，并且不依赖于具体的编码风格，一般编译程序会内置检查工具</p>
<p>JavaScript 是个动态的弱类型语言，在开发中较易出错，因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。ESLin 可让程序员在编码过程中发现问题而不是在执行过程中</p>
<p>ESLint 初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他插件没有什么区别，规则本身和测试可依赖于同样的模式。为了便于使用，ESLint 内置了一些规则，也可在使用过程中自定义规则</p>
<p>ESLint 使用 Node.js 编写，这样既有一个快速的运行环境也便于安装</p>
<p>Lint 是检验代码格式工具的统称，具体的工具由 Jslint、Eslint 等</p>
<h2 id="git-时忽略某些文件"><a href="#git-时忽略某些文件" class="headerlink" title="git 时忽略某些文件"></a>git 时忽略某些文件</h2><p>一些自动生成的文件如日志文件、编译过程中创建的临时文件等无需纳入 Git 管理</p>
<p>可创建一个 .gitignore 文件列出要忽略的文件模式，如</p>
<pre><code>*.[oa] 忽略以 .o 或 .a 结尾的文件
*~ 忽略以 ~ 结尾的文件</code></pre>
<h3 id="gitignore-的格式规范"><a href="#gitignore-的格式规范" class="headerlink" title=".gitignore 的格式规范"></a>.gitignore 的格式规范</h3><p>所有空行或以注释符号 # 开头的行都会被 Git 忽略</p>
<p>可使用标准的 glob 模式匹配</p>
<pre><code>* 代表匹配任意个字符
? 代表匹配任意一个字符
** 代表匹配多级目录
匹配模式前跟反斜杠（/）代表项目根目录
匹配模式最后跟反斜杠（/）说明要忽略的是目录
在模式前加感叹号（!）取反表示忽略指定模式以外的文件或目录</code></pre>
<p>.gitignore 文件一般内容如下：</p>
<pre><code>.DS_Store
node_modules/
/dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
# 编辑器的目录和文件
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln</code></pre>
<p>在 GitHub 有一个针对数十种项目及语言的<a target="_blank" rel="noopener" href="https://github.com/github/gitignore">.gitignore 文件列表</a>，可找到对应的 .gitignore 文件进行使用</p>
<h3 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h3><p>glob 模式指 shell 所使用的简化了的正则表达式</p>
<h2 id="使用-Eslint"><a href="#使用-Eslint" class="headerlink" title="使用 Eslint"></a>使用 Eslint</h2><p>（1）安装 node 和 npm 环境</p>
<p>（2）创建项目</p>
<pre><code>npm init</code></pre>
<p>（3）本地安装 eslint</p>
<pre><code>npm i eslint --save-dev</code></pre>
<p>（4）设置 package.json 文件</p>
<pre><code>&quot;scripts&quot;&#123;
    &quot;lint&quot;: &quot;eslint ./src&quot;
    &quot;lint:create&quot;: &quot;eslint --init&quot;
&#125;</code></pre>
<p>（5）生成 .eslintrc.js 文件，提供编码规则</p>
<pre><code>npm run lint:create</code></pre>
<p>（6）校验代码，自动检验 src 目录下所有的 .js 文件</p>
<pre><code>npm run lint</code></pre>
<p>注意（4）（5）（6）也可以换成 <code>npx eslint --init</code> 和 <code>npx eslint 目录名</code></p>
<h2 id="eslint-结合-git"><a href="#eslint-结合-git" class="headerlink" title="eslint 结合 git"></a>eslint 结合 git</h2><p>husky 帮助自动注册很多 git 的钩子，为 git 仓库设置钩子程序</p>
<p>要先有 git 仓库再安装 husky</p>
<pre><code>git init
npm i husky --save-dev</code></pre>
<p>在 package.json 中添加如下配置</p>
<pre><code>&quot;husky&quot;: &#123;
    &quot;hooks&quot;: &#123;
        &quot;pre-commit&quot;: &quot;npm run lint&quot;, //表示在 git commit 之前要通过 npm run lint，不通过不让提交
        &quot;pre-push&quot;: &quot;npm test&quot;,
        &quot;...&quot;: &quot;...&quot;
    &#125;
&#125;</code></pre>
<h1 id="七、团队协作"><a href="#七、团队协作" class="headerlink" title="七、团队协作"></a>七、团队协作</h1><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>为了能在任意Git 项目上团队协作，远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</p>
<p>管理远程仓库包括添加远程仓库、移除无效远程仓库、管理不同的远程分支并定义它们是否被跟踪等</p>
<h2 id="远程协作基本流程"><a href="#远程协作基本流程" class="headerlink" title="远程协作基本流程"></a>远程协作基本流程</h2><p>GitHub 是最大的 Git 版本库托管商，大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其他事情</p>
<p>（1）项目经理创建远程仓库</p>
<p>在 github 中创建一个未初始化的空仓库</p>
<p>（2）项目经理创建本地库</p>
<pre><code>git init</code></pre>
<p>（3）项目经理为远程仓库配置别名与用户信息</p>
<pre><code>git remote add 简称 远程仓库的https路径</code></pre>
<p>添加一个新的远程 Git 仓库，同时指定一个简称</p>
<pre><code>git config user.name &quot;xxx&quot;
git config user.email &quot;xxx@xxx.com&quot;</code></pre>
<p>配置用户信息</p>
<pre><code>git remote -v </code></pre>
<p>显式远程仓库使用的 Git 别名与其对应的 URL</p>
<pre><code>git remote show 远程仓库名</code></pre>
<p>查看某个远程仓库的更多信息</p>
<pre><code>git remote rename pb 新名字</code></pre>
<p>重命名</p>
<pre><code>git remote rm 远程仓库名</code></pre>
<p>移除某个远程仓库</p>
<p>（4）项目经理推送本地项目到远程仓库</p>
<p>初始化一个本地仓库并清理 Windows 凭据，然后</p>
<pre><code>git push 远程仓库名 分支名</code></pre>
<p>推完后会附带生成远程跟踪分支</p>
<p>（5）成员克隆远程仓库到本地</p>
<pre><code>git clone 远程仓库的https路径</code></pre>
<p>克隆后在本地生成 .git 文件，默认克隆时为远程仓库起的别名为 origin，并且默认主分支有对应的远程跟踪分支</p>
<pre><code>git clone -o 别名</code></pre>
<p>默认的远程仓库别名为自定义</p>
<p><strong>注意：只有在克隆时本地分支 master 和远程跟踪分支 别名/master 是有同步关系的，即后续在本地该分支 push 时即使不指定远程分支也能准确 push 到对应远程分支上</strong></p>
<p>（6）项目经理邀请成员加入团队</p>
<p>在 GitHub 项目仓库的 ‘Settings’ –&gt; ‘Collaborators’ 中设置</p>
<p>（7）成员推送提交到远程仓库</p>
<pre><code>git push 远程仓库名 分支名</code></pre>
<p>此处 push 后也会附带生成远程跟踪分支</p>
<p>（8）项目经理更新成员提交的内容</p>
<pre><code>git fetch 远程仓库名</code></pre>
<p>该命令会访问远程仓库，从中拉取所有你还没有的数据，将修改同步到远程跟踪分支上，执行完后，将拥有那个远程仓库中所有分支的引用，可随时合并或查看</p>
<pre><code>git merge 远程跟踪分支</code></pre>
<p>git fetch 会将数据拉取到本地仓库，它不会自动合并或修改当前工作，需手动将其合并入你的工作</p>
<p>上述 fetch + merge 也可以使用 pull 代替（前提是本地分支需要关联远程跟踪分支才能直接使用 git pull）</p>
<h2 id="正常的数据推送和拉取步骤"><a href="#正常的数据推送和拉取步骤" class="headerlink" title="正常的数据推送和拉取步骤"></a>正常的数据推送和拉取步骤</h2><p>（1）确保本地分支已经跟踪了远程跟踪分支（远程跟踪分支和远程分支间的关系在 push 时已自动建立好了）</p>
<p>（2）拉取数据：git pull</p>
<p>（3）上传数据：git push</p>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>删除远程分支</p>
<pre><code>git push origin --delete 分支</code></pre>
<p>列出仍在远程跟踪但远程已被删除的无用分支</p>
<pre><code>git remote prune origin --dry-run</code></pre>
<p>清除上面命令列出来的远程跟踪</p>
<pre><code>git remote prune origin</code></pre>
<h2 id="pull-request-流程"><a href="#pull-request-流程" class="headerlink" title="pull request 流程"></a>pull request 流程</h2><p>派生（Fork）指 GitHub 将在你的空间中创建一个完全属于你的项目副本，且对其有推送权限</p>
<p>当想参与某个项目但没有推送权限时可对该项目进行 “派生”    </p>
<p>派生项目后将修改推送到派生处的项目副本中，并通过创建合并请求（pull request）来让改动进入源版本库</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>（1）从 master 分支中创建一个新分支（自己 fork 的项目）</p>
<p>（2）提交一些修改来改进项目（自己 fork 的项目）</p>
<p>（3）将这个分支推送到 GitHub 上（自己 fork 的项目）</p>
<p>（4）创建一个合并请求</p>
<p>（5）讨论，根据实际情况继续修改</p>
<p>（6）项目的拥有者合并或关闭你的合并请求</p>
<p>注意：每次再发起新的 pull request 时，要去拉取最新的源仓库的代码，而不是自己 fork 的那个仓库</p>
<pre><code>git remote add 源仓库简称 源仓库路径
git fetch 远程仓库名字
git merge 对应的远程跟踪分支</code></pre>
<h2 id="深入理解远程仓库"><a href="#深入理解远程仓库" class="headerlink" title="深入理解远程仓库"></a>深入理解远程仓库</h2><h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p>远程跟踪分支是远程分支状态的引用，它们是不能移动的本地分支，当做任何网络通信操作时，它们会自动移动</p>
<p>它们以（remote）/（branch）形式命名，例如若要看最后一次与远程仓库 orgin 通信时 master 分支的状态，可查看 origin/master 分支</p>
<p>在 push 时会产生远程跟踪分支</p>
<p><strong>当克隆一个仓库时，它通常会自动创建一个跟踪 origin/master 的 master 分支（这是个本地分支）</strong></p>
<p>如</p>
<pre><code>从网络 Git 服务器中克隆一个仓库会自动命名为 origin，拉取它的所有数据，并创建一个指向它的 master 分支的指针，
并在本地将其命名为 origin/master。
Git 也会给你一个与 origin/master 分支指向同一个地方的本地的 master 分支，这样就有工作的基础</code></pre>
<h3 id="跟踪分支（这是个本地分支）"><a href="#跟踪分支（这是个本地分支）" class="headerlink" title="跟踪分支（这是个本地分支）"></a>跟踪分支（这是个本地分支）</h3><p>跟踪分支是与远程分支有直接关系的本地分支，若在一个跟踪分支上输入 <code>git pull</code>，Git 能自动识别去哪个服务器上抓取、合并到哪个分支</p>
<p>从一个远程跟踪分支（origin/master）检出一个本地分支会自动创建一个叫作跟踪分支（也称上游分支 master）</p>
<p>只有主分支并且在克隆时才会自动创建跟踪分支</p>
<pre><code>git checkout -b 分支名 远程仓库/远程分支
或
git checkout --track 远程仓库/远程分支</code></pre>
<p>上述命令可设置跟踪分支关联远程跟踪分支，但第二种命令方式创建的本地分支与远程分支同名，若要不同命则使用第一种命令方式</p>
<p>若已有本地分支，想设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或想修改正在跟踪的跟踪分支，可在任意时间使用 -u 选项运行 git branch 来显式地设置，如下</p>
<pre><code>git branch -u 远程仓库/远程分支
-u 相当于 --set-uptream-to</code></pre>
<p>查看设置的所有跟踪分支：</p>
<pre><code>git branch -vv</code></pre>
<h3 id="推送其他分支"><a href="#推送其他分支" class="headerlink" title="推送其他分支"></a>推送其他分支</h3><p>本地分支并不会自动与远程仓库同步，必须显式地推送想要分享的分支</p>
<pre><code>git push origin 本地分支名</code></pre>
<p>这里 Git 自动将本地分支名展开为 refs/heads/本地分支名:refs/heads/远程分支名，也可运行 git push origin 本地分支:远程分支</p>
<pre><code>git fetch origin</code></pre>
<p>抓取数据，注意当抓取到新的远程跟踪分支时，本地不会自动生成一个对应分支，只有一个不可修改的 origin/远程分支 指针</p>
<p>因此需要将抓取到的合并到当前所在本地分支</p>
<pre><code>git merge origin/远程分支</code></pre>
<p>若想要在自己的本地分支上工作，可建立在远程跟踪分支之上</p>
<pre><code>git checkout -b 本地分支 origin/远程分支</code></pre>
<p>注意：上述的 origin 可以换成对应的远程仓库名</p>
<h3 id="本地分支如何跟踪一个远程跟踪分支"><a href="#本地分支如何跟踪一个远程跟踪分支" class="headerlink" title="本地分支如何跟踪一个远程跟踪分支"></a>本地分支如何跟踪一个远程跟踪分支</h3><p>1、当克隆时会自动生成一个 master 本地分支（已经跟踪了对应的远程跟踪分支）</p>
<p>2、在新建其他分支的同时可指定想要跟踪的远程跟踪分支</p>
<pre><code>git checkout -b 本地分支名 远程跟踪分支
或
git checkout --track 远程跟踪分支</code></pre>
<p>3、将一个已经存在的本地分支改成一个跟踪分支来对应远程跟踪分支</p>
<pre><code>git branch -u 远程跟踪分支</code></pre>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 push 时有冲突，需要先 git pull，修改冲突文件后 add 和 commit，然后再 git push</p>
<h1 id="八、SSH"><a href="#八、SSH" class="headerlink" title="八、SSH"></a>八、SSH</h1><p>SSH 协议是 GitHub 自己的协议，https 和 SSH 都是用于验证是哪个用户</p>
<p>使用 https 协议时每次访问远程仓库都要去找到 Windows 凭据，凭据里代表了是哪个用户，而 SSH 协议不用填用户名和密码，和 GitHub 账户是无关联的</p>
<p>在 GitHub 账户中配置公私钥方法：</p>
<p>（1）生成公私钥</p>
<pre><code>ssh-keygen -t rsa -C 邮箱</code></pre>
<p>（2）在 C:\Users\Administrator.ssh 会生成公钥 id_rsa.pub 和公钥 id_rsa</p>
<p>（3）在 GitHub 的 ‘Personal settings’ –&gt; ‘SSH and GPG keys’ 中新增一个 SSH key，把公钥 id_rsa 中的内容复制粘贴进去</p>
<p>测试公私钥是否已经配对</p>
<pre><code>ssh -T git@github.com</code></pre>
<p>之后的克隆需要使用 SSH 协议而不是 https 协议</p>
<h1 id="九、使用频率最高的五个命令"><a href="#九、使用频率最高的五个命令" class="headerlink" title="九、使用频率最高的五个命令"></a>九、使用频率最高的五个命令</h1><pre><code>git status
git add
git commit
git push
git pull</code></pre>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Webpack学习笔记">
                  <i class="fa fa-chevron-left"></i> Webpack学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/13/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="TypeScript学习笔记">
                  TypeScript学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
