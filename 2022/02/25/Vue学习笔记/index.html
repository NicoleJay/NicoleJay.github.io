<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、VueVue 是一套用于构建用户界面的渐进式 JavaScript 框架 渐进式指 Vue 是可以自底向上逐层递进的应用，即在简单应用中只需一个轻量小巧的核心库，若要构建复杂应用只需在这基础上引入各式各样 Vue 插件">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue学习笔记">
<meta property="og:url" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="一、VueVue 是一套用于构建用户界面的渐进式 JavaScript 框架 渐进式指 Vue 是可以自底向上逐层递进的应用，即在简单应用中只需一个轻量小巧的核心库，若要构建复杂应用只需在这基础上引入各式各样 Vue 插件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MVVM.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index%E4%BD%9C%E4%B8%BAkey.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/id%E4%BD%9C%E4%B8%BAkey.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E7%94%BB.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vuex.png">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg">
<meta property="og:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cookie%E5%9B%BE%E7%A4%BA.png">
<meta property="article:published_time" content="2022-02-25T13:01:15.000Z">
<meta property="article:modified_time" content="2022-03-13T15:07:32.354Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MVVM.png">


<link rel="canonical" href="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Vue学习笔记 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Vue"><span class="nav-number">1.</span> <span class="nav-text">一、Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">Vue 特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Vue-%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">创建 Vue 的基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World"><span class="nav-number">1.3.</span> <span class="nav-text">Hello World</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Vue-%E6%A0%B8%E5%BF%83"><span class="nav-number">2.</span> <span class="nav-text">二、Vue 核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">模板语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.</span> <span class="nav-text">数据绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.1.</span> <span class="nav-text">单向数据绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">双向数据绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#el-%E5%92%8C-data-%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">el 和 data 的两种写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM"><span class="nav-number">2.4.</span> <span class="nav-text">MVVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">数据代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.5.1.</span> <span class="nav-text">数据代理的基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">数据代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="nav-number">2.5.3.</span> <span class="nav-text">Vue 中的数据代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86-1"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">Vue 中的数据代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">Vue 中数据代理的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">基本原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">2.6.</span> <span class="nav-text">事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.1.</span> <span class="nav-text">事件的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.6.2.</span> <span class="nav-text">事件修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.6.3.</span> <span class="nav-text">键盘事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed"><span class="nav-number">2.7.</span> <span class="nav-text">计算属性 computed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E8%A7%86-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7-watch"><span class="nav-number">2.8.</span> <span class="nav-text">监视&#x2F;侦听属性 watch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="nav-number">2.8.1.</span> <span class="nav-text">监视的两种写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86"><span class="nav-number">2.8.2.</span> <span class="nav-text">深度监视</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E7%9A%84%E7%AE%80%E5%86%99"><span class="nav-number">2.8.3.</span> <span class="nav-text">监视的简写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-computed-%E5%92%8C-watch"><span class="nav-number">2.9.</span> <span class="nav-text">对比 computed 和 watch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%88%99"><span class="nav-number">2.9.2.</span> <span class="nav-text">原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F-class-%E5%92%8C-style"><span class="nav-number">2.10.</span> <span class="nav-text">绑定样式 class 和 style</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#class-%E7%BB%91%E5%AE%9A"><span class="nav-number">2.10.1.</span> <span class="nav-text">class 绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#style-%E7%BB%91%E5%AE%9A"><span class="nav-number">2.10.2.</span> <span class="nav-text">style 绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93-v-if-%E4%B8%8E-v-show"><span class="nav-number">2.11.</span> <span class="nav-text">条件渲染 v-if 与 v-show</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-v-if-%E4%B8%8E-v-show"><span class="nav-number">2.11.1.</span> <span class="nav-text">比较 v-if 与 v-show</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93-v-for"><span class="nav-number">2.12.</span> <span class="nav-text">列表渲染 v-for</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-for-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.12.1.</span> <span class="nav-text">v-for 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.12.2.</span> <span class="nav-text">key 的作用与原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#react%E3%80%81vue-%E4%B8%AD%E7%9A%84-key-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88key-%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%89"><span class="nav-number">2.12.2.1.</span> <span class="nav-text">react、vue 中的 key 的作用？（key 的内部原理）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E8%BF%87%E6%BB%A4"><span class="nav-number">2.13.</span> <span class="nav-text">列表过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">2.14.</span> <span class="nav-text">列表排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9B%91%E6%B5%8B%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">2.15.</span> <span class="nav-text">Vue 监测数据改变的底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B"><span class="nav-number">2.15.1.</span> <span class="nav-text">对象更新检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B"><span class="nav-number">2.15.2.</span> <span class="nav-text">数组更新检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-set-%E6%88%96-vm-set"><span class="nav-number">2.16.</span> <span class="nav-text">Vue.set() 或 vm.$set()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81"><span class="nav-number">2.17.</span> <span class="nav-text">数据劫持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="nav-number">2.18.</span> <span class="nav-text">收集表单数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-model-%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.18.1.</span> <span class="nav-text">v-model 的修饰符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.19.</span> <span class="nav-text">过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.20.</span> <span class="nav-text">&amp;#123;&amp;#123;time|timeFormater(&#39;YYYY_MM_DD&#39;)&amp;#125;&amp;#125;&lt;&#x2F;h2&gt;
&lt;h2&gt;&amp;#123;&amp;#123;time|timeFormater(&#39;YYYY_MM_DD&#39;)|mySlice&amp;#125;&amp;#125;&lt;&#x2F;h2&gt;
这里会把 time 作为参数传给 timeFormater，得到返回值作为参数传给 mySlice，得到返回值后替换掉 &amp;#123;&amp;#123;&amp;#125;&amp;#125; 中的内容
	局部过滤器：在 vm 实例对象中定义过滤器
	filters:&amp;#123;
		timeFormater(value,str&#x3D;&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&amp;#123;
			return dayjs(value).format(str)
		&amp;#125;,
		mySlice(value)&amp;#123;
			return value.slice(0,4)
		&amp;#125;
	&amp;#125;

	全局过滤器：在 new Vue 之前写定义过滤器
	Vue.filter(&#39;mySlice1&#39;,function(value)&amp;#123;
		return value.slice(0,4)
	&amp;#125;)


## 内置指令

	v-bind：单向绑定解析表达式可用冒号 : 来简写
	v-model：双向数据绑定
	v-for：遍历数字&#x2F;对象&#x2F;字符串
	v-on：绑定事件监听，可简写为 @
	v-if：条件渲染（动态控制节点是否存在）
	v-else：条件渲染（动态控制节点是否存在）
	v-show：条件渲染（动态控制节点是否显示）

### v-text

作用：向其所在的节点中渲染文本内容

v-text 不支持结构解析，即内容中的标签不能解析，只是当成字符串

	
	相当于 &amp;#123;&amp;#123;变量&amp;#125;&amp;#125;&lt;&#x2F;div&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#v-html"><span class="nav-number">2.20.1.</span> <span class="nav-text">v-html</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-cloak"><span class="nav-number">2.20.2.</span> <span class="nav-text">v-cloak</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-once"><span class="nav-number">2.20.3.</span> <span class="nav-text">v-once</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-pre"><span class="nav-number">2.20.4.</span> <span class="nav-text">v-pre</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">2.20.5.</span> <span class="nav-text">自定义指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.21.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Vue-%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">三、Vue 组件化编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BB%84%E4%BB%B6%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">模块与组件、模块化与组件化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">3.1.2.</span> <span class="nav-text">组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">3.1.3.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">3.1.4.</span> <span class="nav-text">组件化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">Vue 中使用组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%90%8D"><span class="nav-number">3.2.1.</span> <span class="nav-text">组件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE"><span class="nav-number">3.2.2.</span> <span class="nav-text">组件标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.3.</span> <span class="nav-text">三大步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">定义组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">注册组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">编写组件标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">非单文件组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">3.4.</span> <span class="nav-text">单文件组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97"><span class="nav-number">3.5.</span> <span class="nav-text">组件嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VueComponent"><span class="nav-number">3.6.</span> <span class="nav-text">VueComponent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-this-%E6%8C%87%E5%90%91"><span class="nav-number">3.7.</span> <span class="nav-text">关于 this 指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%AE%9E%E4%BE%8B%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.8.</span> <span class="nav-text">Vue 实例与组件实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB"><span class="nav-number">3.9.</span> <span class="nav-text">一个重要的内置关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Vue-%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">四、Vue 脚手架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-js-%E4%B8%AD%E7%9A%84-render-%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">main.js 中的 render 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%84%9A%E6%89%8B%E6%9E%B6%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="nav-number">4.3.</span> <span class="nav-text">修改脚手架默认配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-%E5%B1%9E%E6%80%A7"><span class="nav-number">4.4.</span> <span class="nav-text">ref 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props-%E9%85%8D%E7%BD%AE"><span class="nav-number">4.5.</span> <span class="nav-text">props 配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mixin-%E6%B7%B7%E5%85%A5"><span class="nav-number">4.6.</span> <span class="nav-text">mixin 混入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#plugins-%E6%8F%92%E4%BB%B6"><span class="nav-number">4.7.</span> <span class="nav-text">plugins 插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scoped-%E6%A0%B7%E5%BC%8F"><span class="nav-number">4.8.</span> <span class="nav-text">scoped 样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="nav-number">4.9.</span> <span class="nav-text">组件化编码流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.10.</span> <span class="nav-text">组件自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.10.1.</span> <span class="nav-text">绑定自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%BB%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.10.2.</span> <span class="nav-text">解绑自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">4.10.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="nav-number">4.11.</span> <span class="nav-text">全局事件总线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="nav-number">4.12.</span> <span class="nav-text">消息订阅与发布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB"><span class="nav-number">4.13.</span> <span class="nav-text">Vue 封装的过度与动画</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C"><span class="nav-number">4.13.1.</span> <span class="nav-text">动画效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E5%BA%A6%E6%95%88%E6%9E%9C"><span class="nav-number">4.13.2.</span> <span class="nav-text">过度效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8A%A8%E7%94%BB"><span class="nav-number">4.13.3.</span> <span class="nav-text">集成第三方动画</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-Vue-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A7%E5%A6%99%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">4.14.</span> <span class="nav-text">利用 Vue 脚手架巧妙解决跨域问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.14.1.</span> <span class="nav-text">解决跨域的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-Vue-%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-number">4.14.2.</span> <span class="nav-text">利用 Vue 脚手架开启代理服务器解决跨域问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81-ajax-%E8%AF%B7%E6%B1%82%EF%BC%88vue-resource%EF%BC%89"><span class="nav-number">4.15.</span> <span class="nav-text">发送 ajax 请求（vue-resource）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slot-%E6%8F%92%E6%A7%BD"><span class="nav-number">4.16.</span> <span class="nav-text">slot 插槽</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="nav-number">4.16.1.</span> <span class="nav-text">默认插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="nav-number">4.16.2.</span> <span class="nav-text">具名插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="nav-number">4.16.3.</span> <span class="nav-text">作用域插槽</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">5.</span> <span class="nav-text">五、组件间通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Vuex"><span class="nav-number">6.</span> <span class="nav-text">六、Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.1.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.3.</span> <span class="nav-text">Vuex 的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">6.4.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">6.5.</span> <span class="nav-text">vuex 模块化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-webStorage"><span class="nav-number">7.</span> <span class="nav-text">七、浏览器本地存储 webStorage</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E8%B7%AF%E7%94%B1"><span class="nav-number">8.</span> <span class="nav-text">八、路由</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%88%86%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">路由分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router"><span class="nav-number">8.2.</span> <span class="nav-text">vue-router</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">8.2.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%EF%BC%88%E5%A4%9A%E7%BA%A7%EF%BC%89%E8%B7%AF%E7%94%B1"><span class="nav-number">8.3.</span> <span class="nav-text">嵌套（多级）路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-query-%E5%8F%82%E6%95%B0"><span class="nav-number">8.4.</span> <span class="nav-text">路由的 query 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="nav-number">8.5.</span> <span class="nav-text">命名路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-params-%E5%8F%82%E6%95%B0"><span class="nav-number">8.6.</span> <span class="nav-text">路由的 params 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84-props-%E9%85%8D%E7%BD%AE"><span class="nav-number">8.7.</span> <span class="nav-text">路由的 props 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E4%B8%AD-props-%E5%80%BC%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.7.1.</span> <span class="nav-text">写法一：路由规则中 props 值为对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E4%B8%AD%E5%80%BC%E4%B8%BA%E5%B8%83%E5%B0%94%E5%80%BC"><span class="nav-number">8.7.2.</span> <span class="nav-text">写法二：路由规则中值为布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%B3%95%E4%B8%89%EF%BC%9A%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E4%B8%AD%E5%80%BC%E4%B8%BA%E5%87%BD%E6%95%B0"><span class="nav-number">8.7.3.</span> <span class="nav-text">写法三：路由规则中值为函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#router-link-%E7%9A%84-replace-%E5%B1%9E%E6%80%A7"><span class="nav-number">8.8.</span> <span class="nav-text">router-link 的 replace 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="nav-number">8.9.</span> <span class="nav-text">编程式路由导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6"><span class="nav-number">8.10.</span> <span class="nav-text">缓存路由组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E7%8B%AC%E6%9C%89%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">8.11.</span> <span class="nav-text">路由组件独有的两个新的生命周期钩子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">8.12.</span> <span class="nav-text">路由守卫</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">8.12.1.</span> <span class="nav-text">全局前置路由守卫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">8.12.2.</span> <span class="nav-text">全局后置路由守卫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E4%BA%AB%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">8.12.3.</span> <span class="nav-text">独享路由守卫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="nav-number">8.12.4.</span> <span class="nav-text">组件内路由守卫</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#history-%E6%A8%A1%E5%BC%8F%E5%92%8C-hash-%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.13.</span> <span class="nav-text">history 模式和 hash 模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81Vue-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="nav-number">9.</span> <span class="nav-text">九、Vue UI 组件库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81Vue-3"><span class="nav-number">10.</span> <span class="nav-text">十、Vue 3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-3-%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">10.1.</span> <span class="nav-text">Vue 3 带来了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA-Vue3-%E5%B7%A5%E7%A8%8B"><span class="nav-number">10.2.</span> <span class="nav-text">使用 vue-cli 创建 Vue3 工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-vite-%E5%88%9B%E5%BB%BA"><span class="nav-number">10.3.</span> <span class="nav-text">使用 vite 创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84"><span class="nav-number">10.4.</span> <span class="nav-text">分析工程结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-Composition-API%EF%BC%88%E7%BB%84%E5%90%88-API%EF%BC%89"><span class="nav-number">10.5.</span> <span class="nav-text">常用的 Composition API（组合 API）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setup"><span class="nav-number">10.5.1.</span> <span class="nav-text">setup</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">11.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">12.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">12.0.1.</span> <span class="nav-text">ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reactive-%E5%87%BD%E6%95%B0"><span class="nav-number">12.0.2.</span> <span class="nav-text">reactive 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">12.1.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue2-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="nav-number">12.1.1.</span> <span class="nav-text">Vue2 的响应式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue3-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="nav-number">12.1.2.</span> <span class="nav-text">Vue3 的响应式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-computed-1"><span class="nav-number">12.2.</span> <span class="nav-text">计算属性 computed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%91%E8%A7%86-watch"><span class="nav-number">12.3.</span> <span class="nav-text">数据监视 watch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#watchEffect-%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.</span> <span class="nav-text">watchEffect 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">12.5.</span> <span class="nav-text">Vue3 生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-hook"><span class="nav-number">12.6.</span> <span class="nav-text">自定义 hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toRef"><span class="nav-number">12.7.</span> <span class="nav-text">toRef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-Composition-API"><span class="nav-number">12.8.</span> <span class="nav-text">其他 Composition API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shallowReactive-%E4%B8%8E-shallowRef"><span class="nav-number">12.8.1.</span> <span class="nav-text">shallowReactive 与 shallowRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#readonly-%E4%B8%8E-shallowReadonly"><span class="nav-number">12.8.2.</span> <span class="nav-text">readonly 与 shallowReadonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toRaw-%E4%B8%8E-markRaw"><span class="nav-number">12.8.3.</span> <span class="nav-text">toRaw 与 markRaw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#customRef"><span class="nav-number">12.8.4.</span> <span class="nav-text">customRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#provide-%E4%B8%8E-inject"><span class="nav-number">12.8.5.</span> <span class="nav-text">provide 与 inject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD-API"><span class="nav-number">12.8.6.</span> <span class="nav-text">响应式数据的判断 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">12.9.</span> <span class="nav-text">Composition API 的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">12.10.</span> <span class="nav-text">新组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragment"><span class="nav-number">12.10.1.</span> <span class="nav-text">Fragment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Teleport"><span class="nav-number">12.10.2.</span> <span class="nav-text">Teleport</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Suspense"><span class="nav-number">12.10.3.</span> <span class="nav-text">Suspense</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80-API-%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="nav-number">12.11.</span> <span class="nav-text">全局 API 的转移</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">13.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C-js-%E4%BB%A3%E7%A0%81-%E8%AF%AD%E5%8F%A5"><span class="nav-number">13.1.</span> <span class="nav-text">js 表达式和 js 代码&#x2F;语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vscode-%E4%B8%AD-vue-%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6"><span class="nav-number">13.2.</span> <span class="nav-text">vscode 中 vue 相关插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie"><span class="nav-number">13.3.</span> <span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model"><span class="nav-number">13.4.</span> <span class="nav-text">v-model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#props"><span class="nav-number">13.5.</span> <span class="nav-text">props</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick"><span class="nav-number">13.6.</span> <span class="nav-text">$nextTick</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">13.7.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vue学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 21:01:15" itemprop="dateCreated datePublished" datetime="2022-02-25T21:01:15+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、Vue"><a href="#一、Vue" class="headerlink" title="一、Vue"></a>一、Vue</h1><p>Vue 是一套用于构建用户界面的<strong>渐进式</strong> JavaScript 框架</p>
<p>渐进式指 Vue 是可以自底向上逐层递进的应用，即在简单应用中只需一个轻量小巧的核心库，若要构建复杂应用只需在这基础上引入各式各样 Vue 插件</p>
<a id="more"></a>

<h2 id="Vue-特点"><a href="#Vue-特点" class="headerlink" title="Vue 特点"></a>Vue 特点</h2><p>（1）采用<strong>组件化</strong>模式，提高代码复用率、且让代码更好维护（.vue 文件中包含 html、css、js）</p>
<p>（2）<strong>声明式编码</strong>，让编码人员无需直接操作 DOM 提高开发效率（如原生js中命令式编码需要 forEach 遍历、document.getElementById 获取 DOM 元素，而声明式编码中只需 <code>&lt;li v-for&gt;</code> 即可）</p>
<p>（3）使用<strong>虚拟 DOM</strong> + 优秀的 <strong>Diff 算法</strong>，尽量复用 DOM 节点</p>
<p>（4）遵循 MVVM 模式</p>
<p>（5）编码简化，体积小，运行效率高，适合移动/PC端开发</p>
<p>（6）它本身只关注 UI，也可以引入其他第三方库开发项目</p>
<h2 id="创建-Vue-的基础"><a href="#创建-Vue-的基础" class="headerlink" title="创建 Vue 的基础"></a>创建 Vue 的基础</h2><p>（1）想让 Vue 工作，就必须创建一个 Vue 实例，且要传入一个配置对象</p>
<p>（2）root 容器里的代码依然符合 html 规范，只不过混入了一些特殊的 Vue 语法，如 <code>&#123;&#123;表达式或vue的data中的数据&#125;&#125;</code></p>
<p>（3）root 容器里的代码被称为【Vue 模板】</p>
<p>（4）Vue 实例和容器是一一对应的，一个 Vue 实例只能对应一个容器，一个容器只能对应一个 Vue 实例</p>
<p>（5）真实开发中只有一个 Vue 实例，并会配合组件一起使用</p>
<p>（6）一旦 data 中的数据发生改变，页面中用到该数据的地方也会自动更新</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>引入 Vue</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>html 部分</p>
<pre><code>&lt;!--准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const x = new Vue(&#123;
        el:&#39;#root&#39;, //el 用于指定当前 Vue 实例为哪个容器入伍，值通常为 css 选择器字符串，这里 &#39;#root&#39; 也可用 document.getElementById(&#39;root&#39;)
        data:&#123;  //data 中用于存储数据，数据供 el 指定的容器去使用，值这里暂时写成一个对象
            name:&#39;xxx&#39;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<h1 id="二、Vue-核心"><a href="#二、Vue-核心" class="headerlink" title="二、Vue 核心"></a>二、Vue 核心</h1><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>模板语法即 html 中包含了一些 js 语法代码，Vue 模板语法分为两类</p>
<p>（1）插值语法 <code>&#123;&#123;表达式&#125;&#125;</code></p>
<p>功能：用于解析标签体内容</p>
<p>（2）指令（以 v- 开头）</p>
<p>功能：用于解析标签（包括标签属性、标签体内容、绑定事件…）</p>
<p>如：v-bind:href=”表达式” 或 :href=”表达式”</p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="单向数据绑定"><a href="#单向数据绑定" class="headerlink" title="单向数据绑定"></a>单向数据绑定</h3><p>单项绑定（v-bind）：数据只能从 data 流向页面</p>
<p>当 data 中数据发生变化时，页面上使用该数据的地方也会发生相应变化</p>
<pre><code>&lt;input type=&quot;text&quot; v-bind:value=&quot;xxx&quot;&gt;</code></pre>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>双向绑定（v-model）：数据不仅能从 data 流向页面，还可以从页面流向 data</p>
<p>当 data 中数据发生变化时，页面上使用该数据的地方也会发生相应变化；同时，当页面上用户改变了该数据，则 data 中对应存储的该数据的值也会变</p>
<p>注意：v-model 只能应用在表单类元素（或输入元素）上，如 input、单选框、多选框、select、多行输入</p>
<pre><code>&lt;input type=&quot;text&quot; v-model:value=&quot;xxx&quot;&gt;</code></pre>
<p>注意：v-model:value 可简写为 v-model，因为 v-model 默认收集的就是 value 值</p>
<h2 id="el-和-data-的两种写法"><a href="#el-和-data-的两种写法" class="headerlink" title="el 和 data 的两种写法"></a>el 和 data 的两种写法</h2><p><strong>el 的两种写法：</strong></p>
<p>（1）new Vue 时配置 el 属性</p>
<p>（2）先创建 Vue 实例，再通过 vm.$mount(‘#root’) 指定 el 的值</p>
<pre><code>const vm = new Vue(&#123;
    //el:&#39;#root&#39;, //第一种写法
    data:&#123;
        name:&#39;xxx&#39;
    &#125;
&#125;)
vm.$mount(&#39;#root&#39;) //第二种写法</code></pre>
<p><strong>data 的两种写法：</strong></p>
<p>（1）对象式</p>
<p>（2）函数式</p>
<p>在组件中 data 必须使用函数式，否则会报错</p>
<pre><code>//对象式写法
const vm = new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        name:&#39;xxx&#39;
    &#125;
&#125;)
//函数式写法，必须返回一个对象，组件中必须使用函数式写法
const vm = new Vue(&#123;
    el:&#39;#root&#39;,
    data:function()&#123; //注意这里可简写成 data()&#123;...&#125;，但不能写成箭头函数
        console.log(this) //此处的 this 是 Vue 实例对象
        return&#123;
            name:&#39;xxx&#39;
        &#125;
    &#125;
&#125;)</code></pre>
<p>注意：由 Vue 管理的函数，一定不要写箭头函数，一旦写了箭头函数，this 就不再是 Vue 实例了，而会去外部找</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M：模型（Model），对应 data 中的数据</p>
<p>V：视图（View），模板</p>
<p>VM：视图模型（ViewModel），Vue 实例对象</p>
<p>data 中所有的属性，最后都出现在 vm 身上</p>
<p>vm 身上所有的属性及 Vue 原型上所有属性在 Vue 模板中都可以直接使用</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MVVM.png" alt="MVVM"></p>
<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><h3 id="数据代理的基础知识"><a href="#数据代理的基础知识" class="headerlink" title="数据代理的基础知识"></a>数据代理的基础知识</h3><p>Object.defineProperty(对象,’属性名’,{配置项}) 方法给一个对象添加/定义一个属性名（ES 6 的语法）</p>
<p>通过该方法添加的属性默认是不能被枚举的（即不能被遍历，如 Object.keys(对象) 不能获取到那个属性），且添加的属性不可被修改、删除</p>
<p>通过添加配置 enumerable:true 后可被枚举</p>
<p>通过添加配置 writable:true 后可被修改</p>
<p>通过添加配置 configurable:true  后可被删除</p>
<pre><code>let person = &#123;
    name:&#39;xx&#39;,
    sex:&#39;男&#39;
&#125;
Object.defineProperty(person,&#39;age&#39;,&#123;
    value:18,
    enumerable:true,  //控制属性是否可被枚举，默认是 false
    writable:true, //控制属性是否可被修改，默认是 false
    configurable:true //控制属性是否可被删除，默认是 false
&#125;)</code></pre>
<p>通过 getter 使得属性和变量绑定，变量值改变则属性值也改变</p>
<p>通过 setter 改变属性的值</p>
<pre><code>let number = 18
let person = &#123;
    name:&#39;xx&#39;,
    sex:&#39;男&#39;
&#125;
Object.defineProperty(person,&#39;age&#39;,&#123;
    get:function()&#123;  //当读取 person 的 age 属性时（person.age），get 函数（getter）就会被调用，且返回值就是 age 的值
        return number
    &#125;,
    set(value)&#123;  //当修改 person 的 age 属性时（如 person.age = 19），set 函数（setter）就会被调用，且会收到修改的具体值
        number = value  //因为 getter 中 age 属性和 number 关联所以这里要修改 number 的值才行
    &#125;
&#125;)</code></pre>
<h3 id="数据代理-1"><a href="#数据代理-1" class="headerlink" title="数据代理"></a>数据代理</h3><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p>
<pre><code>let obj = &#123;x:100&#125;
let obj2 = &#123;y:100&#125;
//通过 obj2 操作 obj 中的 x
Object.defineProperty(obj2,&#39;x&#39;,&#123;
    get:function()&#123;
        return obj.x
    &#125;,
    set(value)&#123;
        obj.x = value
    &#125;
&#125;)</code></pre>
<h3 id="Vue-中的数据代理"><a href="#Vue-中的数据代理" class="headerlink" title="Vue 中的数据代理"></a>Vue 中的数据代理</h3><h4 id="Vue-中的数据代理-1"><a href="#Vue-中的数据代理-1" class="headerlink" title="Vue 中的数据代理"></a>Vue 中的数据代理</h4><p>Vue 中通过 vm 对象来代理 data 对象中属性的操作（读/写）</p>
<p>读取 vm 中属性时：ViewModel 中属性 —getter —&gt; data 中的属性</p>
<p>修改 vm 中属性时：ViewModel 中属性 —setter —&gt; data 中的属性</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.png" alt="数据代理"></p>
<p>上图中后边的橙色和紫色线就是 Vue 做的数据代理</p>
<p>Vue 把 data 中数据放到 vm 的 _data 属性中，即 vm._data = data（所以直接 vm.data 是 undefined），但这时要在模板（即视图 View ）中显示数据需要 <code>&#123;&#123;_data.name&#125;&#125;</code>，通过数据代理把数据放到 vm 上，这里还会做数据代理，就可以通过 <code>&#123;&#123;name&#125;&#125;</code> 来获取使用数据</p>
<h4 id="Vue-中数据代理的好处"><a href="#Vue-中数据代理的好处" class="headerlink" title="Vue 中数据代理的好处"></a>Vue 中数据代理的好处</h4><p>更加方便地操作 data 中数据</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>通过 Object.defineProperty 把 data 对象中所有属性添加到 vm 上</p>
<p>为每个添加到 vm 上的属性都指定一个 getter/setter</p>
<p>在 getter/setter 内部去操作（读/写）data 中对应的属性</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件的基本使用"><a href="#事件的基本使用" class="headerlink" title="事件的基本使用"></a>事件的基本使用</h3><p>（1）使用 <code>v-on:事件名</code> 或 <code>@事件名</code> 绑定事件</p>
<pre><code>@click：鼠标点击事件
@scroll：滚动条滚动事件
@wheel：鼠标滚轮滚动事件
@keydown：键盘按下
@keyup：键盘松开</code></pre>
<p>（2）事件的回调需要配置在 methods 对象中，最终会在 vm 上</p>
<p>（3）methods 中配置的函数不要用箭头函数，否则 this 就不是 vm 了</p>
<p>（4）methods 中配置的函数都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象</p>
<p>（5）@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参，$event 是 event 的占位符</p>
<p>（6）@事件名=”xxx” 其中 xxx 可以是简单的语句，但注意只能是对 vm 上有的东西进行操作，vm 上没有的不能进行操作，如 alert 语句就不行，因为 alert 在 window 上，vm 上没有 window，所以 vm 上没有 alert 方法，</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;button v-on:click=&quot;show&quot;&gt;不传参&lt;/button&gt;
        &lt;button @click=&quot;show2($event,123)&quot;&gt;传参&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;xxx&#39;
        &#125;,
        methods:&#123;
            show(event)&#123;
                console.log(event.target.innerText)
                console.log(this)  //此处的 this 是 vm（Vue 实例对象）
            &#125;
            show1:(event)=&gt;&#123;
                console.log(this)  //此处的 this 是 window
            &#125;
            show2(event,number)=&gt;&#123;
                console.log(event,number)
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<p>注意：受 Vue 管理的函数最好都写成普通函数，不要写箭头函数，因为 this 的问题</p>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>prevent：阻止默认事件，如 <code>&lt;a href=&quot;http://www.xxx.com&quot; @click.prevent=&quot;xxx&quot;&gt;</code> 这样点击后不会跳转，相当于在事件回调函数中写 event.preventDefault()</p>
<p>stop：给子元素添加，阻止事件冒泡，相当于在事件回调函数中写 event.stopPropagation()</p>
<p>once：事件只触发一次</p>
<p>capture：给父元素添加，使用事件的捕获模式，事件触发时是先捕获后冒泡所以子元素事件先响应后响应父元素事件，而给父元素添加 .capture 使得事件在捕获阶段就开始处理，即先响应父元素事件后响应子元素事件</p>
<p>self：只有 event.target 是当前操作的元素时才触发事件</p>
<p>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</p>
<p>注意：修饰符可以连续写</p>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>Vue 中常用的按键别名，使用方式 <code>@键盘事件.别名=&quot;回调函数&quot;</code>，如 <code>@keyup.enter=&quot;xxx&quot;</code> 表示按下回车时触发回调函数</p>
<pre><code>回车：enter
删除：delete（捕获“删除”和“退格”键）
退出：esc
空格：space
换行：tab（必须配合 keydown 使用）
上：up
下：down
左：left
右：right</code></pre>
<p>Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（短横线命名，如 caps-lock）</p>
<p>系统修饰键（ctrl、alt、shift、meta（win键））用法特殊</p>
<pre><code>（1）配合 keyup 使用：先按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发
（2）配合 keydown 使用：正常触发事件</code></pre>
<p>注意：系统修饰符可以连续写，如 <code>@keyup.ctrl.=&quot;xxx&quot;</code> 表示按下 ctrl + y</p>
<p>不推荐使用 keyCode（event.keyCode）去指定具体的按键，如 <code>@keyup.13=&quot;xxx&quot;</code></p>
<p>定制按键别名：<code>Vue.config.keyCodes.自定义键名 = 键码</code></p>
<h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>当模板中要显示的数据需要进行一些处理时若使用 <code>&#123;&#123;函数()&#125;&#125;</code>，则数据一改变，Vue 会重新解析模板，而插值中的函数会被重新调用，这导致效率低 </p>
<p>Vue 认为 data 中的数据就是属性，计算属性就是对属性进行处理，计算属性存放在 <code>computed:&#123;&#125;</code> 中</p>
<p><strong>计算属性：</strong>要显示的数据不存在，要通过计算已有<strong>属性</strong>（注意不是变量）计算得来</p>
<p><strong>原理：</strong>底层借助了 Object.defineproperty 方法提供的 getter 和 setter</p>
<p><strong>用法：</strong>（1）在 computed 对象中定义计算属性，计算属性必须写 get()（2）在页面中使用 <code>&#123;&#123;计算属性&#125;&#125;</code> 来显示计算的结果</p>
<p><strong>计算属性的优势：</strong>与 methods 来实现相比，计算属性内部有缓存机制（复用），当数据没有改变时直接读缓存，效率更高，调式方便</p>
<p>注意：计算属性最终会出现在 vm 上，直接读取使用即可，不用显式调用 .get()</p>
<p>若计算属性要被修改，则必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变</p>
<pre><code>data:&#123;
    firstName:&#39;xx&#39;,
    lastName:&#39;xxx&#39;
&#125;,
computed:&#123;
    fullName:&#123;
        get()&#123; //读取 fullName 时，get 就会被调用，且返回值作为 fullName 的值
        //get 被调用的时机：（1）初次读取 fullName 时（2）所依赖的数据发生变化时
            console.log(this) //此处 this 是 vm
            return this.firstName + &#39;-&#39; + this.lastName
        &#125;
        set(value)&#123; //修改 fullName 时，set 就会被调用
            ...
            this.firstName = xxx
            this.lastName = xxx
        &#125;
    &#125;
&#125;</code></pre>
<p>当计算属性<strong>只读不改时</strong>可简写如下</p>
<pre><code>data:&#123;
    firstName:&#39;xx&#39;,
    lastName:&#39;xxx&#39;
&#125;,
computed:&#123;
    fullName()&#123;  //这个函数可当计算属性的 getter 用
        return this.firstName + &#39;-&#39; + this.lastName
    &#125;
&#125;</code></pre>
<h2 id="监视-侦听属性-watch"><a href="#监视-侦听属性-watch" class="headerlink" title="监视/侦听属性 watch"></a>监视/侦听属性 watch</h2><p>监视属性可通过 vm 对象的 $watch() 或 watch 配置来监视指定的属性，当属性变化时，回调函数自动调用，在函数内部进行计算</p>
<p>监视属性必须存在才能进行监视</p>
<h3 id="监视的两种写法"><a href="#监视的两种写法" class="headerlink" title="监视的两种写法"></a>监视的两种写法</h3><p>方式一：在 new Vue 时传入 watch 配置，即在 vm 对象中使用 watch</p>
<pre><code>watch:&#123;
    isHot:&#123;
        immedeiate:true, //为 true 时使得初始化时让 handler 调用以下，默认时 false
        handler(newValue,oldValue)&#123; //当 isHot 发生改变时 handler 函数被调用
            console.log(newValue,oldValue)
        &#125;
    &#125;
&#125;</code></pre>
<p>方式二：通过 vm.$watch 监视</p>
<pre><code>vm.$watch(&#39;isHot&#39;,&#123;
    immedeiate:true, //为 true 时使得初始化时让 handler 调用以下，默认时 false
    handler(newValue,oldValue)&#123; //当 isHot 发生改变时 handler 函数被调用
        console.log(newValue,oldValue)
    &#125;
&#125;)</code></pre>
<h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h3><p>Vue 中 watch 默认不会监视对象内部值的改变（只监视一层）</p>
<p>配置 deep:true 可监视对象内部值的改变（监视多层）</p>
<p>注意：Vue 自身是可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以</p>
<p>考虑到性能效率问题，使用 watch 时根据数据的具体结构决定是否采用深度监视</p>
<pre><code>data:&#123;
    numbers:&#123;
        a:1,
        b:1
    &#125;
&#125;
watch:&#123;
    &#39;number.a&#39;:&#123; //监视多级结构中某个属性的变化，需要加上引号
        handler()&#123;
            console.log(&#39;a变了&#39;)
        &#125;
    &#125;
    numbers:&#123;
        deep:true, //监视多级结构中所有属性的变化，若不开启这个，则监视的是 numbers，不会监视 numbers 中的属性，而 numbers 是个对象，其中属性变化但该对象地址值不变所以 numbers 也被认为没变
        handler()&#123;
            console.log(&#39;numbers变了&#39;)
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="监视的简写"><a href="#监视的简写" class="headerlink" title="监视的简写"></a>监视的简写</h3><p>当 watch 配置项中只有 handler 时才能简写，使用简写就不能配置 immedeiate 和 deep 了</p>
<pre><code>watch:&#123;
    isHot(newValue,oldValue)&#123;
        console.log(newValue,oldValue,this) //这里 this 是 vm 对象，这里不能写箭头函数，若写箭头函数则 this 是 window
    &#125;
&#125;

vm.$watch(&#39;isHot&#39;,function(newValue,oldValue)&#123;
        console.log(newValue,oldValue,this) //这里 this 是 vm 对象，这里不能写箭头函数，若写箭头函数则 this 是 window
    &#125;
&#125;)</code></pre>
<h2 id="对比-computed-和-watch"><a href="#对比-computed-和-watch" class="headerlink" title="对比 computed 和 watch"></a>对比 computed 和 watch</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）computed 能完成的功能 watch 都可以完成</p>
<p>（2）watch 能完成的功能 computed 不一定能完成，如 watch 可以进行异步操作（如定时器等）</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>（1）所有被 Vue 管理的函数最好都写成普通函数，这样 this 才是指向 vm 或组件实例对象</p>
<p>（2）所有不被 Vue 管理的函数（如定时器的回调函数、ajax 的回调函数、Promise 的回调函数等）最好写成箭头函数，这样在这些回调函数中 this 的指向才是 vm 或组件实例对象</p>
<pre><code>watch:&#123;
    firstName(val)&#123;
        setTimeout(()=&gt;&#123;
            console.log(this) //写成箭头函数后就没有 this 了，会去外部找，这样 this 才是 vm 实例对象，若写普通函数，回调函数由 JS 引擎调用，this 就是 window
        &#125;,1000)
    &#125;
&#125;</code></pre>
<h2 id="绑定样式-class-和-style"><a href="#绑定样式-class-和-style" class="headerlink" title="绑定样式 class 和 style"></a>绑定样式 class 和 style</h2><p>当样式是动态变化时，class/style 绑定就是专门用来实现动态样式效果的技术</p>
<h3 id="class-绑定"><a href="#class-绑定" class="headerlink" title="class 绑定"></a>class 绑定</h3><p>class 样式写法：<code>class=&quot;xxx&quot;</code>，xxx 可以是字符串、对象、数组</p>
<p>（1）字符串写法<code>:class=&#39;data中定义的样式类字符串&#39;</code>适用于样式的类名不确定，需要动态指定的情况</p>
<p>（2）表达式是对象：<code>&#123;classA:isA,classB:isB&#125;</code>，适用于要绑定的样式个数、名字确定，但要动态决定用不用</p>
<pre><code>&lt;div :class=&quot;classObj&quot; @click=&quot;changeMood&quot;&gt;&lt;/div&gt;
//在 vm 中
data:&#123;
    classObj:&#123;
        classA:true,
        classB:false
    &#125;
&#125;
methods:&#123;
    changeMood()&#123;
        //修改 this.classArr
    &#125;
&#125;</code></pre>
<p>（3）表达式是数组：<code>[&#39;classA&#39;,&#39;classB&#39;]</code>，适用于要绑定的样式个数、名字不确定</p>
<pre><code>&lt;div :class=&quot;classArr&quot; @click=&quot;changeMood&quot;&gt;&lt;/div&gt;
//在 vm 中
data:&#123;
    classArr:[&#39;classA&#39;,&#39;classB&#39;]
&#125;
methods:&#123;
    changeMood()&#123;
        //修改 this.classArr
    &#125;
&#125;</code></pre>
<h3 id="style-绑定"><a href="#style-绑定" class="headerlink" title="style 绑定"></a>style 绑定</h3><p>（1）<code>:style=&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;</code></p>
<p>（2）对象写法：<code>:style=&quot;styleObj&quot;</code></p>
<p>在 data 中定义 <code>styleObj:&#123;fontSize:&#39;40px&#39;&#125;</code></p>
<p>（3）数组写法1：<code>:style=&quot;[styleObj1,styleObj2]&quot;</code></p>
<p>在 data 中定义 <code>styleObj1:&#123;fontSize:&#39;40px&#39;&#125;,styleObj2:&#123;color:&#39;red&#39;&#125;</code></p>
<p>（4）数组写法2<code>:style=&quot;styleArr&quot;</code></p>
<p>在 data 中定义 <code>styleArr:[&#123;fontSize:&#39;40px&#39;&#125;,&#123;color:&#39;red&#39;&#125;]</code></p>
<h2 id="条件渲染-v-if-与-v-show"><a href="#条件渲染-v-if-与-v-show" class="headerlink" title="条件渲染 v-if 与 v-show"></a>条件渲染 v-if 与 v-show</h2><p>条件渲染指令</p>
<pre><code>（1）v-if 与 v-else、v-else-if，如&lt;div v-if=&quot;表达式&quot;&gt;x&lt;/div&gt;，而 v-else 后无需写判断
v-if 当不渲染时节点在 html 中不存在
v-if 与 v-else、v-else-if 节点需要连在一起写
（2）v-show，如&lt;div v-show=&quot;n===1&quot;&gt;x&lt;/div&gt;
v-show 实现时其实调整的是 display 属性，当不渲染时节点还在</code></pre>
<h3 id="比较-v-if-与-v-show"><a href="#比较-v-if-与-v-show" class="headerlink" title="比较 v-if 与 v-show"></a>比较 v-if 与 v-show</h3><pre><code>（1）v-if 不展示的 DOM 元素直接被移除，v-show 不展示的 DOM 元素未被移除，仅仅使用 display 样式隐藏掉，所以使用 v-if 的元素可能无法获取，而使用 v-show 一定可以获取到
（2）若要频繁切换 v-show 较好，因为 v-show 无论是否渲染，节点都在，只是通过 display 来控制是否显示，而若使用 v-if 就是不断向 DOM 中添加或删除节点，效率较低
（3）当条件不成立时，v-if 的所有子节点不会解析（在项目中使用）
（4）当 v-if 中成立时，v-else、v-else-if 中就不再判断直接掠过
（5）&lt;template&gt; 只能和 v-if 搭配，不能和 v-show 搭配（&lt;template&gt;在真正渲染时不会出现这一层）
&lt;template v-if=&quot;n===1&quot;&gt;
    &lt;h2&gt;a&lt;/h2&gt;
    &lt;h2&gt;b&lt;/h2&gt;
    &lt;h2&gt;c&lt;/h2&gt;
&lt;/template&gt;</code></pre>
<h2 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染 v-for"></a>列表渲染 v-for</h2><p>可使用 v-for 指令用于展示列表数据</p>
<p>v-for 可遍历数组、对象、字符串、指定次数</p>
<h3 id="v-for-的使用"><a href="#v-for-的使用" class="headerlink" title="v-for 的使用"></a>v-for 的使用</h3><p>遍历数组时 <code>v-for=&quot;(元素,index) in 数组&quot;</code></p>
<p>遍历对象时 <code>v-for=&quot;(value,key) in 对象&quot;</code></p>
<p>遍历字符串时 <code>v-for=&quot;(char,index) in 字符串&quot;</code></p>
<p>遍历对象时 <code>v-for=&quot;(number,index) in 数字&quot;</code></p>
<pre><code>&lt;ul&gt;
    &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;
        &#123;&#123;p.name&#125;&#125;,&#123;&#123;p.age&#125;&#125;
    &lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>注意：key 会在虚拟 DOM 中出现，在真实 DOM 中没有</p>
<h3 id="key-的作用与原理"><a href="#key-的作用与原理" class="headerlink" title="key 的作用与原理"></a>key 的作用与原理</h3><h4 id="react、vue-中的-key-的作用？（key-的内部原理）"><a href="#react、vue-中的-key-的作用？（key-的内部原理）" class="headerlink" title="react、vue 中的 key 的作用？（key 的内部原理）"></a>react、vue 中的 key 的作用？（key 的内部原理）</h4><p>在虚拟 DOM 中 key 的作用：</p>
<pre><code>key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】，
随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较</code></pre>
<p>【新虚拟 DOM】与【旧虚拟 DOM】的差异比较规则：</p>
<pre><code>（1）旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：
    a）若虚拟 DOM 中内容没变，直接使用之前的真实 DOM
    b）若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM
（2）旧虚拟 DOM 未找到与新虚拟 DOM 相同的 key，则创建新的真实 DOM，随后渲染到页面</code></pre>
<p>用 index 作为 key 可能会依法的问题：</p>
<pre><code>（1）若对数据进行逆序添加、逆序删除等破坏顺序操作会产生没必要的真实 DOM 更新，这样界面效果没问题但效率低
（2）若结构中包含输入类的 DOM，则会产生错误 DOM 更新，导致界面有问题</code></pre>
<p>当使用 index 作为 key 时</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index%E4%BD%9C%E4%B8%BAkey.png" alt="index作为key"></p>
<p>当使用 id 作为 key 时</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/id%E4%BD%9C%E4%B8%BAkey.png" alt="id作为key"></p>
<p>开发中如何选择 key：</p>
<pre><code>（1）最好使用每条数据的唯一标识作为 key，如 id、手机号、身份证号、学号等唯一值
（2）若不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，那么使用 index 作为 key 是没问题的</code></pre>
<h2 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h2><p>computed 和 watch 都能实现，列表过滤一般用 computed 更省事，因为 watch 还需在 data 中定义一个要显示的数据的数组</p>
<pre><code>data:&#123;
    keyword:&#39;&#39;,
    persons:[&#123;id:&#39;001&#39;,name:&#39;aaa&#39;&#125;,&#123;id:&#39;002&#39;,name:&#39;bbb&#39;&#125;],
    filper:[]  //为使用 watch 定义的数组
&#125;,
computed:&#123;
    filtPersons()&#123;
        return this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(this.keyword)!==-1
        &#125;)
    &#125;
&#125;,
/*watch:&#123;
    keyword(val)&#123;
        this.filper = this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(val)!==-1
        &#125;)
    &#125;
&#125;*/</code></pre>
<h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><pre><code>data:&#123;
    keyword:&#39;&#39;,
    sortType:0, //0 原顺序，1 降序，2 升序
    persons:[&#123;id:&#39;001&#39;,name:&#39;aaa&#39;,age:17&#125;,&#123;id:&#39;002&#39;,name:&#39;bbb&#39;,age:18&#125;],
&#125;,
computed:&#123;
    filtPersons()&#123;
        const arr = this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(this.keyword)!==-1
        &#125;)
        if(this.sortType)&#123;
            arr.sort((p1,p2)=&gt;&#123; //sort 函数改变原数组
                return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
            &#125;)
        &#125;
        return arr
    &#125;
&#125;,</code></pre>
<h2 id="Vue-监测数据改变的底层原理"><a href="#Vue-监测数据改变的底层原理" class="headerlink" title="Vue 监测数据改变的底层原理"></a>Vue 监测数据改变的底层原理</h2><p>Vue 会监视 data 中所有层次的数据</p>
<h3 id="对象更新检测"><a href="#对象更新检测" class="headerlink" title="对象更新检测"></a>对象更新检测</h3><p>如何监测对象中的数据？</p>
<pre><code>通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据
（1）对象中后追加的属性，Vue 默认不做响应式处理
（2）如需给后添加的属性做响应式，要使用如下 API
    Vue.set(目标对象,要添加的属性名,属性值)
    this.$set(目标对象,要添加的属性名,属性值)</code></pre>
<p>若不是响应式的数据，该数据的添加和修改都不会引起 Vue 的重新解析模板</p>
<p>Vue 监测对象改变的原理类似如下，这里简化成对象只有一层，即对象的属性不为对象，Vue 真正工作时会逐层递归一直找下去找到所有对象</p>
<pre><code>let data = &#123;
    name:&#39;xx&#39;,
    address:&#39;北京&#39;
&#125;
//创建一个监视的实例对象，用于监视 data 中属性的变化
const obs = new Observer(data)
//准备一个 vm 实例对象
let vm = &#123;&#125;
vm._data = data = obs
function Observer(obj)&#123;
    //汇总对象中所有的属性形成一个数组
    const keys = Object.keys(obj)
    keys.forEach((k)=&gt;&#123;
        get()&#123;
            return obj[k]
        &#125;
        set(val)&#123;
            console.log(`$&#123;k&#125;被改了，这里会去解析模板，生成虚拟 DOM 等一些列工作...`)
            obj[k] = val
        &#125;
    &#125;)
&#125;</code></pre>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>如何监测对象中的数据？</p>
<pre><code>通过包裹数组更新元素的方法来实现，本质就是做了两件事
（1）调用原生对应的方法（如 push、pop、splice 等）对数组进行更新
（2）重新解析模板，进而更新页面</code></pre>
<p>在 Vue 修改数组中的元素一定要用如下方法</p>
<pre><code>（1）使用 API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()
（2）Vue.set(数组,索引,属性值) 或 this.$set(数组,索引,属性值)</code></pre>
<p>对于 data 中的数组（如 arr），若在代码中使用 arr[0]=xxx 来修改 arr 数组中的元素不奏效，在页面中对应显示的数据不更新，需要通过 <code>arr.splice(0,1,xxx)</code> 或 <code>Vue.set(arr,0,xxx)</code> 或 <code>this.$set(arr,0,xxx)</code> 来更新第一个元素</p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们将会触发视图更新，被包裹的方法包括：</p>
<pre><code>push()
pop()
shift()
unshift()
splice()
sort()
reverse()</code></pre>
<h2 id="Vue-set-或-vm-set"><a href="#Vue-set-或-vm-set" class="headerlink" title="Vue.set() 或 vm.$set()"></a>Vue.set() 或 vm.$set()</h2><p><code>Vue.set(目标对象,要添加的属性名,属性值)</code> 或 <code>vm.$set(目标对象,要添加的属性名,属性值)</code> 向响应式对象（即每个属性有 getter 和 setter）中添加一个属性（向 data 中的对象添加属性），并确保这个新的属性也是响应式的，且触发视图更新</p>
<p><code>Vue.set(数组,索引,属性值)</code> 或 <code>vm.$set(数组,索引,属性值)</code> 可修改数组中的元素</p>
<p><strong>注意：参数中目标对象不能是 Vue 实例或 Vue 实例的根对象（即 data 本身）</strong></p>
<pre><code>data:&#123;
    student:&#123;
        name:&#39;xx&#39;,
        age:18
    &#125;
&#125;
methods:&#123;
    addSex()&#123;
        this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
        //或 Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
    &#125;
&#125;</code></pre>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>数据劫持即给对象加上 getter 和 setter，若修改对象，对象上的 setter 劫持到数据变化后会更新数据然后重新解析 DOM 进行后续一系列操作</p>
<p>数据劫持的原理和数据代理一样也是依赖于 Object.defineProperty</p>
<p>数据劫持是响应式的根基</p>
<h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p><strong>单行输入 text / 密码 password：</strong>v-model 收集的是 value 值，用户输入的就是 value 值</p>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;account&quot;/&gt;
在 data 中需设置
account:&#39;&#39;</code></pre>
<p><strong>单选 radio：</strong>v-model 收集的是 value 值，所以要给标签配置 value</p>
<pre><code>男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;male&quot;&gt;
女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;female&quot;&gt;
这里要写 value，否则 v-model 默认监听 checked，这样导致一个选中其他也会选中
在 data 中需设置
sex:&#39;female&#39;  //初始默认选女</code></pre>
<p><strong>多选 checkbox：</strong></p>
<p>当没有配置 input 的 value 属性时，收集的是 checked（是否勾选，布尔值），通过 v-model 的值可控制 checked</p>
<p>当配置了 input 的 value 属性时，收集的是 value 组成的数组</p>
<pre><code>学习&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;study&quot;&gt;
吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;eat&quot;&gt;
在 data 中需设置
hobby:[]

若只需知道是否勾选
&lt;input type=&quot;checkbox&quot; v-model=&quot;agree&quot;&gt;
在 data 中需设置
agree:&#39;&#39;</code></pre>
<p><strong>下拉框 select</strong></p>
<pre><code>&lt;select v-model=&quot;city&quot;&gt;
    &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;
    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
&lt;/select&gt;
在 data 中需设置
city:&#39;&#39;</code></pre>
<p><strong>多行输入</strong></p>
<pre><code>&lt;textarea v-model=&quot;other&quot;&gt;&lt;/textarea&gt;
在 data 中需设置
other:&#39;&#39;</code></pre>
<p><strong>表单提交</strong></p>
<pre><code>&lt;form @submit.prevent=&quot;handlerSubmit&quot;&gt;...&lt;/form&gt;

methods:&#123;
    handlerSubmit()&#123; //在表单提交时触发
        console.log(JSON.stringfy(this.useInfo))
    &#125;
&#125;</code></pre>
<p><strong>输入的类型限制</strong></p>
<pre><code>&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt;
其中 type=&quot;number&quot; 是原生的控制，使得用户在输入框中不能输入字母等，v-model.number 使得用户输入后 data 中的 age 为数字不为字符串，否则会默认用户输入的东西都存为字符串</code></pre>
<h3 id="v-model-的修饰符"><a href="#v-model-的修饰符" class="headerlink" title="v-model 的修饰符"></a>v-model 的修饰符</h3><p>v-model.number：输入字符串转为有效的数字</p>
<p>v-model.lazy：当输入框失去焦点时才更新 data 中的数据</p>
<p>v-model.trim：获取到的数据去除前后的空格</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器可对要显示的数据进行特定格式化后再显示，适用于一些简单逻辑的处理，过滤器的本质是函数</p>
<p>语法：</p>
<pre><code>注册过滤器：Vue.filter(过滤器名,回调函数) 或 new Vue&#123;filters:&#123;...&#125;&#125;
使用过滤器：&#123;&#123;数据名 | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;数据名 | 过滤器名&quot;</code></pre>
<p>过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>注意：过滤后并没有改变原本的数据，而是产生新的对应的数据</p>
<pre><code>&lt;h2&gt;&#123;&#123;time|timeFormater&#125;&#125;&lt;/h2&gt;
这里会把 time 作为参数传给 timeFormater，得到返回值后替换掉 &#123;&#123;&#125;&#125; 中的内容
	<h2>&#123;&#123;time|timeFormater('YYYY_MM_DD')&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;time|timeFormater('YYYY_MM_DD')|mySlice&#125;&#125;&lt;/h2&gt;
这里会把 time 作为参数传给 timeFormater，得到返回值作为参数传给 mySlice，得到返回值后替换掉 &#123;&#123;&#125;&#125; 中的内容
	局部过滤器：在 vm 实例对象中定义过滤器
	filters:&#123;
		timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss')&#123;
			return dayjs(value).format(str)
		&#125;,
		mySlice(value)&#123;
			return value.slice(0,4)
		&#125;
	&#125;

	全局过滤器：在 new Vue 之前写定义过滤器
	Vue.filter('mySlice1',function(value)&#123;
		return value.slice(0,4)
	&#125;)


## 内置指令

	v-bind：单向绑定解析表达式可用冒号 : 来简写
	v-model：双向数据绑定
	v-for：遍历数字/对象/字符串
	v-on：绑定事件监听，可简写为 @
	v-if：条件渲染（动态控制节点是否存在）
	v-else：条件渲染（动态控制节点是否存在）
	v-show：条件渲染（动态控制节点是否显示）

### v-text

作用：向其所在的节点中渲染文本内容

v-text 不支持结构解析，即内容中的标签不能解析，只是当成字符串

	<div v-text="变量"></div>
	相当于 <div>&#123;&#123;变量&#125;&#125;&lt;/div&gt;</div></h2></code></pre>
<p>与插值语法的区别：v-text 会替换掉节点中的内容，而 <code>&#123;&#123;xx&#125;&#125;</code> 则不会，一般还是用插值语法更灵活</p>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>作用：向指定节点中渲染包含 html 结构的内容</p>
<p>v-html 支持结构解析，即内容中的标签可以解析</p>
<pre><code>&lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;
data:&#123;
    str:&#39;&lt;h2&gt;xxx&lt;/h2&gt;&#39;
&#125;
页面上能识别 h2 标签</code></pre>
<p>与插值语法的区别：</p>
<pre><code>（1）v-html 会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125; 则不会
（2）v-html 可以识别 html 结构</code></pre>
<p>注意：v-html 有安全性问题</p>
<pre><code>（1）在网站上动态渲染任意 html 是非常危险的，容易导致 XSS（冒充用户值守，即盗走用户的 cookie 就可以冒充用户）攻击
（2）一定要在可信的内容上使用 v-html，永远不用用在用户提交的内容上</code></pre>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>v-cloak 指令没有值，本质是一个特殊属性，Vue 实例创建完毕并接管容器后会删掉 v-loak 属性</p>
<p>使用 css 配置 v-cloak 可解决网速慢时页面展示出 <code>&#123;&#123;xxx&#125;&#125;</code> 的问题</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        [v-cloak]&#123;
            display:none;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;xxxxx&quot;&gt;&lt;/script&gt; &lt;!--假设网速慢该资源请求很慢--&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue(&#123;...&#125;)
&lt;/script&gt;</code></pre>
<p>上述代码中若没有加 v-cloak，当请求资源的网速慢时，会先渲染没有经过 Vue 解析的 html，页面会显示 <code>&#123;&#123;name&#125;&#125;</code>，当请求的资源返回后才会创建 Vue 实例然后解析模板重新渲染，而加了 v-cloak，当请求的资源还没返回时，根据 css 中的设置，页面不会先渲染 <code>&#123;&#123;name&#125;&#125;</code>，这样用户体验更好</p>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>v-once 所在节点在初次动态渲染后就视为静态内容了，以后数据的改变不会引起 v-once 所在节点的更新，可以用于优化性能</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-once&gt;初始化的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;当前的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;</code></pre>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>v-pre 指令能跳过所在节点的编译过程（即 Vue 不会再去看该节点里有没有插值、指令等），可利用它跳过没有使用指令语法、插值语法的节点，会加快编译</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-pre&gt;这是个字符串&lt;/h2&gt;
    &lt;h2&gt;当前的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;</code></pre>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>定义语法：</p>
<pre><code>（1）局部指令
    new Vue(&#123;
        directives:&#123;指令名:配置对象&#125;
    &#125;)
    或
    new Vue(&#123;
        directives()&#123;指令名:回调函数&#125;
    &#125;)
（2）全局指令
    Vue.directive(指令名,配置对象)
    或
    Vue.directive(指令名,回调函数)</code></pre>
<p>配置对象中常用的 3 个回调</p>
<pre><code>（1）.bind：指令与元素成功绑定时调用
（2）.inserted：指令所在元素被插入页面时调用
（3）.update：指令所在模板结构被重新解析时调用</code></pre>
<p>注意：指令定义时不加 v-，使用时要加 v-</p>
<p>指令名若是多个单词，使用时用 kebab-case 命名方式（如 v-big-number），不要用 camelCase 命名，定义时可直接拼一起加引号（如 ‘bignumber’）</p>
<p>例子1：定义一个 v-big 指令，和 v-text 功能类似，但会把绑定的数值放大 10 倍</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;当前的 n 值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;h2&gt;放大 10 倍后的 n 值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;

new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        n:1
    &#125;,
    directives:&#123;
        //big 函数被调用的时机：（1）当指令与元素成功绑定时 big 函数会被调用（注意此时元素还没放入页面）（2）指令所在的模板被重新解析时
        big(element,binding)&#123; //第1个参数为 DOM 元素，第2个参数为绑定对象，将元素和指令进行绑定
            console.log(this) //这里的 this 是 window
            element.innerText = binding.value * 10
        &#125;
    &#125;
&#125;)</code></pre>
<p>例子2：定义一个 v-fbind 指令，和 v-bind 功能类似，但会把绑定的 input 元素默认获取焦点</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;

new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        n:1
    &#125;,
    directives:&#123;
        fbind:&#123;
            //指令与元素成功绑定时（一上来，还没放到页面）
            bind(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.value = binding.value
            &#125;
        &#125;
    &#125;
&#125;)</code></pre>
<p>注意：上面两个例子定义的指令是局部指令，只能在当前 Vue 实例中使用</p>
<p>例子3：全局指令</p>
<pre><code>Vue.directive(&#39;big&#39;,function(element,binding)&#123;
    element.innerText = binding.value * 10
&#125;)

Vue.directive(&#39;fbind&#39;,&#123;
    //指令与元素成功绑定时（一上来，还没放到页面）
    bind(element,binding)&#123;
        element.value = binding.value
    &#125;,
    //指令所在元素被插入页面时
    inserted(element,binding)&#123;
        element.focus()
    &#125;,
    //指令所在的模板被重新解析时
    update(element,binding)&#123;
        element.value = binding.value
    &#125;
&#125;)</code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期又称为生命周期回调函数、生命周期函数、生命周期钩子，是 Vue 在关键时刻调用的一些特殊名称的函数</p>
<p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</p>
<p>生命周期函数中的 this 指向是 vm 或 组件实例对象</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" alt="生命周期1"></p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" alt="生命周期2"></p>
<p>beforeCreate()：将要创建，是指数据监测、数据代理创建之前，即还没有 _data</p>
<p>created()：创建完毕</p>
<p>beforeMount()：将要挂载</p>
<p>mounted()：挂载完毕，Vue 完成模板解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted，mounted 函数中的 this 为 Vue 实例对象（vm）或 组件实例对象，在 mounted 中完成发生 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作</p>
<p>beforeUpdate()：将要更新</p>
<p>Updated()：更新完毕</p>
<p>beforeDestroy()：将要销毁，在这完成如清除定时器、解绑自定义事件、取消订阅消息等收尾工作</p>
<p>destroyed()：销毁完毕</p>
<p>vm.$destroy()：用于完全销毁一个实例，清理它与其他实例的连接，解绑它的全部指令及自定义事件的监听器（注意不会解绑原生 DOM 事件，如 click 等），触发 beforeDestroy 和 Destroy 的钩子。一般不用 vm.$destroy 方法，最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期</p>
<p>关于销毁 Vue 实例：</p>
<pre><code>（1）销毁后借助 Vue 开发者工具看不到任何信息
（2）销毁后自定义事件会失效，但原生 DOM 事件依然有效（如 click，继续点击依然会触发，但数据、页面不更新）
（3）一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了</code></pre>
<h1 id="三、Vue-组件化编程"><a href="#三、Vue-组件化编程" class="headerlink" title="三、Vue 组件化编程"></a>三、Vue 组件化编程</h1><h2 id="模块与组件、模块化与组件化"><a href="#模块与组件、模块化与组件化" class="headerlink" title="模块与组件、模块化与组件化"></a>模块与组件、模块化与组件化</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块向外提供特定功能的 js 程序，一般就是一个 js 文件</p>
<p>作用：由于 js 文件很多很复杂所以通过模块化可复用 js，简化 js 的编写，提高 js 运行效率</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是用来实现局部特定功能效果的代码和资源的集合（如 html、css、js、image 等）</p>
<p>作用：由于一个界面的功能很复杂，通过组件可复用编码，简化项目编码，提高运行效率</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当应用中的 js 都以模块来编写的，这个应用就是一个模块化的应用</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>当应用中的功能都是多组件的方式来编写的，这个应用就是一个组件化的应用</p>
<h2 id="Vue-中使用组件"><a href="#Vue-中使用组件" class="headerlink" title="Vue 中使用组件"></a>Vue 中使用组件</h2><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>一个单词时的两种写法</p>
<pre><code>（1）首字母小写
（2）首字母大写</code></pre>
<p>多个单词时的两种写法</p>
<pre><code>（1）kebab-case 命名，如 my-school
（2）CamelCase 命名，如 MySchool（需要 Vue 脚手架）</code></pre>
<p>组件名尽可能回避 html 中已有的元素名称</p>
<p>可再定义组件时使用 name 配置项指定组件在开发者工具中呈现的名字</p>
<h3 id="组件标签"><a href="#组件标签" class="headerlink" title="组件标签"></a>组件标签</h3><p>两种写法</p>
<pre><code>（1）&lt;school&gt;&lt;/school&gt;
（2）&lt;school/&gt;</code></pre>
<p>不使用脚手架时 <code>&lt;school/&gt;</code> 会导致后续组件不能渲染</p>
<h3 id="三大步骤"><a href="#三大步骤" class="headerlink" title="三大步骤"></a>三大步骤</h3><p>（1）定义组件（创建）</p>
<p>（2）注册组件</p>
<p>（3）使用组件（写组件标签）</p>
<h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4><p>使用 <code>const xxx = Vue.extend(options)</code> 或简写 <code>const xxx = options</code> 创建，其中 options 和 new Vue(options) 时传入的那个 options 几乎一样，但也有区别如下：</p>
<p>（1）el 不要写，因为最终所有的组件都要经过一个 vm 管理，由 vm 中的 el 决定服务哪个容器</p>
<p>（2）data 必须写成函数，因为避免组件被复用时，数据存在引用关系（即一个组件中数据变量另一个也变）</p>
<p>备注：使用 template 可以配置组件结构</p>
<h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><p>（1）局部注册：靠 new Vue 的时候传入 components 选项</p>
<p>（2）全局注册：靠 Vue.component(‘组件名’,组件)</p>
<h4 id="编写组件标签"><a href="#编写组件标签" class="headerlink" title="编写组件标签"></a>编写组件标签</h4><p>如</p>
<pre><code>&lt;school&gt;&lt;/school&gt;</code></pre>
<h2 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h2><p>非单文件组件即一个文件中包含有 n 个组件</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;school&gt;&lt;/school&gt;
&lt;/div&gt;

//创建组件
const school = Vue.extend(&#123;
    //组件定义时，一定不要定义 el 配置项，因为最终所有的组件都要被一个 vm 管理，由 vm 决定服务于哪个容器
    template:`
        &lt;div&gt;&#123;&#123;schoolName&#125;&#125;&lt;/div&gt;
    `,
    data()&#123;  //data 一定要用函数式，避免使用对象式导致当前组件改变数据后复用的组件中数据也被改变
        return &#123;
            schoolName:&#39;xxx&#39;
        &#125;
    &#125;,
    methods:&#123;
        showName()&#123;
            console.log(xxx)
        &#125;
    &#125;
&#125;)
const student = Vue.extend(&#123;...&#125;)
//全局注册组件
Vue.component(&#39;student&#39;,student)
//创建 vm
new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        msg:&#39;hello&#39;
    &#125;,
    //注册组件（局部注册），这种方式用的多
    components:&#123;
        school:school
    &#125;
&#125;)</code></pre>
<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>单文件组件即一个文件中只包含有 1 个组件，单文件组件后缀都是 .vue</p>
<pre><code>&lt;template&gt;
    &lt;!--组件的结构--&gt;
    &lt;div class=&quot;xxx&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    //组件交互相关的代码（data、methods 等）
    export default&#123;
        name:&#39;xx&#39;,
        data()&#123;return&#123;...&#125;&#125;
    &#125;
&lt;/script&gt;
&lt;style&gt;
    /*组件的样式*/
    .xxx&#123;...&#125;
&lt;/style&gt;</code></pre>
<p>在 App.vue 中</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;xxx&gt;&lt;/xxx&gt;
        &lt;xxxx&gt;&lt;/xxxx&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import xxx from &#39;./xxx.vue&#39;
    import xxxx from &#39;./xxxx.vue&#39;
    export default&#123;
        name:&#39;xx&#39;,
        components:&#123;xxx,xxxx&#125;
    &#125;
&lt;/script&gt;</code></pre>
<p>在 main.js 文件中</p>
<pre><code>import App from &#39;./App.vue&#39;

new Vue(&#123;
    el:&#39;#root&#39;,
    template:`&lt;App&gt;&lt;/App&gt;`,
    components:&#123;App&#125;
&#125;)</code></pre>
<p>在 html 文件中</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; </code></pre>
<h2 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h2><p>在组件定义中可使用 components 配置项添加子组件</p>
<pre><code>const child = Vue.extend(&#123;...&#125;)
const father = Vue.extend(&#123;
    name:&#39;father&#39;,
    template:`&lt;child&gt;&lt;/child&gt;`,
    data()&#123;return &#123;...&#125;&#125;,
    components:&#123;child&#125;
&#125;)</code></pre>
<p>在开发中一般会定义一个 app 组件用于管理所有组件，即作为所有组件的祖先，一人之下（vm 之下）万人之上（其他组件）</p>
<h2 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h2><p>school <strong>组件的本质是</strong>一个名为 VueComponent 的<strong>构造函数</strong>，且不是程序员定义的，是 Vue.extend 生成的</p>
<p>只需要写 <code>&lt;school&gt;&lt;/school&gt;</code> 或 <code>&lt;school/&gt;</code>，Vue  解析时会创建 school 组件的实例对象，即 Vue 会自动执行 <code>new VueComponent(options)</code><br>注意每次调用 Vue.extend 返回的都是一个全新的 VueComponent</p>
<h2 id="关于-this-指向"><a href="#关于-this-指向" class="headerlink" title="关于 this 指向"></a>关于 this 指向</h2><p>组件配置中</p>
<pre><code>data函数、methods中的函数、watch中的函数、computed中的函数，它们的 this 都是【VueComponent 实例对象】</code></pre>
<p>new Vue(options) 配置中</p>
<pre><code>data函数、methods中的函数、watch中的函数、computed中的函数，它们的 this 都是【Vue 实例对象】</code></pre>
<p>VueComponent 的实例对象即为组件实例对象，本文简称vc，Vue 的实例对象，本文简称 vm</p>
<h2 id="Vue-实例与组件实例"><a href="#Vue-实例与组件实例" class="headerlink" title="Vue 实例与组件实例"></a>Vue 实例与组件实例</h2><p>组件是可复用的 Vue 实例，因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，如 data、computed、watch、methods 以及生命周期钩子等</p>
<p>仅有的例外是 el 是 Vue 实例特有的选项，且组件中 data 必须是一个函数，因此每个实例可维护一份被返回对象的独立的拷贝</p>
<h2 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h2><p>一个重要的内置:</p>
<pre><code>VueComponent.prototype.__proto__ === Vue.prototype</code></pre>
<p>为什么要由这个关系：让组件实例对象（vc）可访问到 Vue 原型上的属性、方法</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB.png" alt="重要的内置关系"></p>
<p>上图中 VueComponent.prototype.<strong>proto</strong> 本应指向 Object 的原型对象上，但 Vue 中把它指向了 Vue 的原型对象，这就是 VueComponent.prototype.<strong>proto</strong> === Vue.prototype</p>
<h1 id="四、Vue-脚手架"><a href="#四、Vue-脚手架" class="headerlink" title="四、Vue 脚手架"></a>四、Vue 脚手架</h1><p>Vue 脚手架（Vue CLI，Vue command line interface）是 Vue 官方提供的标准化开发工具（开发平台）</p>
<p>Vue 脚手架隐藏了所有 webpack 相关的配置，若项查看具体的 webpack 配置可执行 <code>vue inspect &gt; output.js</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>全局安装 <code>npm install -g @vue/cli</code></p>
<p>切换到要创建项目的目录后</p>
<p>创建 Vue 项目 <code>vue create xxx</code></p>
<p>启动项目 <code>npm run serve</code></p>
<p>执行 <code>npm run serve</code> 后先去执行项目的入口文件 main.js </p>
<h2 id="main-js-中的-render-函数"><a href="#main-js-中的-render-函数" class="headerlink" title="main.js 中的 render 函数"></a>main.js 中的 render 函数</h2><p>vue.js 与 vue.runtime.xxx.js 的区别：</p>
<pre><code>（1）vue.js 是完整版的 Vue，包含核心功能 + 模板解析器
（2）vue.runtime.xxx.js 是运行版的 Vue，只包含核心功能，没有模板解析器</code></pre>
<p>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容</p>
<p>因此 Vue 2 中的 main.js </p>
<pre><code>new Vue(&#123;
    el:&#39;#app&#39;,
    render: h =&gt; h(App)
&#125;)</code></pre>
<p>在 main.js 中 <code>import Vue form &#39;vue&#39;</code> 引入的 Vue 根据 node_modules/vue/package.json 中 module 配置，引入的是 node_modules/vue/dist/vue.runtime.esm.js，这是个残缺的 vue，完整的 vue 在 vue.js 中，该文件包含 vue 核心和模板解析器</p>
<p>其中 <code>render: h =&gt; h(App)</code> 即</p>
<pre><code>render(createElement)&#123;
    return createElement(&#39;h1&#39;,&#39;hello&#39;)
&#125;</code></pre>
<h2 id="修改脚手架默认配置"><a href="#修改脚手架默认配置" class="headerlink" title="修改脚手架默认配置"></a>修改脚手架默认配置</h2><pre><code>vue inspect &gt; output.js</code></pre>
<p>上述命令可输出 vue 脚手架的默认配置到 output.js 文件，但只是输出给程序查看，修改 output.js 文件无效</p>
<p>可通过 vue.config.js 文件自定义脚手架配置，该文件需要创建在和 package.json 同级的目录下，该文件会被 @vue/cli-service 自动加载，详情可见<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/config/">官方文档</a></p>
<pre><code>module.exports = &#123;
    pages:&#123;
        index:&#123;
            //入口文件
            entry:&#39;src/main.js&#39;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><p>ref 属性被用来给元素或子组件注册引用信息（id 的替代者）</p>
<p>ref 属性应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</p>
<pre><code>&lt;h1 ref=&quot;xxx&quot;&gt;xxx&lt;/h1&gt;
&lt;组件 ref=&quot;xxxx&quot;&gt;&lt;/组件&gt;

通过 this.$refs.xxx 来获取，相当于原生中 document.getElementById(&#39;xxx&#39;)</code></pre>
<h2 id="props-配置"><a href="#props-配置" class="headerlink" title="props 配置"></a>props 配置</h2><p>props 让组件接收外部传来的数据</p>
<p>props 是只读的，Vue 底层会监测对 props 值的修改，若进行了修改就会发出警告</p>
<p>若确实需要修改，则需赋值 props 的内容到 data 中（Vue 底层实现时先接收到 props 数据后定义 data，若有重名也是 props 优先级高于 data，虽然这不允许控制台会报错），如在 data 中定义 <code>name:this.name</code>，后者的 name 就是 props 接收到的 name，然后去修改 data 中的数据</p>
<p><strong>传递数据：</strong></p>
<p>在父组件中使用子组件</p>
<pre><code>&lt;子组件 name=&quot;xxx&quot; sex=&quot;女&quot; :age=&quot;18&quot;&gt;</code></pre>
<p><strong>接收数据：</strong></p>
<p>在子组件中</p>
<pre><code>&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;sex&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;age+1&#125;&#125;&lt;/h2&gt;

//简单声明接收
props:[&#39;name&#39;,sex&#39;,&#39;age&#39;]
//接收的同时对数据进行类型限制
props:&#123;
    name:String,
    sex:String,
    age:Number
&#125;
//接收的同时对数据进行类型限制 + 默认值的指定 + 必要性的限制
props:&#123;
    name:&#123;
        type:String, //name 的类型是字符串
        required:true  //name 是必要的
    &#125;,
    sex:&#123;
        type:String,
        required:true
    &#125;,
    age:&#123;
        type:Number, //name 的类型是字符串
        default:100
    &#125;
&#125;</code></pre>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h2><p>mixin（混入）可以把多个组件共用的配置提取成一个混入对象</p>
<p>使用方式：</p>
<p>（1）定义混合</p>
<pre><code>&#123;
    data()&#123;...&#125;
    methods:&#123;...&#125;
&#125;</code></pre>
<p>（2）使用混入</p>
<pre><code>1）全局混入：在 main.js 中添加 
import &#123;xxx&#125; from &#39;../mixin.js&#39;
Vue.mixin(xxx)
2）局部混入：在组件中添加
import &#123;xxx&#125; from &#39;../mixin.js&#39;
mixins:[&#39;xxx&#39;]</code></pre>
<p>创建 src/mixin.js 文件</p>
<pre><code>export const mixin = &#123;
    methods:&#123;
        showName()&#123;
            console.log(this.name)
        &#125;
    &#125;,
    mounted()&#123;
        console.log(&#39;hello&#39;)
    &#125;
&#125;
export const mixin2 = &#123;
    data()&#123;return&#123;...&#125;&#125;
&#125;</code></pre>
<p>在组件中</p>
<pre><code>import &#123;mixin,mixin2&#125; from &#39;../mixin.js&#39;

export default&#123;
    name:&#39;组件名&#39;,
    data()&#123;return&#123;...&#125;&#125;
    mixins:[mixin,mixin2]
&#125;</code></pre>
<p>组件中和混入中都有定义的东西会合并起来使用（若 data 或 methods 等重名了以组件中定义的为主），而同一生命周期函数两者定义的都会调用，且混合中定义的先调用</p>
<h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件用于增强 Vue</p>
<p>Vue 的插件本质是个对象，并且该对象中必须包含 install，install 的第一个参数是 Vue 构造函数，第二个及之后的参数是插件使用者传递的数据</p>
<p>新建文件 src/plugins.js 定义插件</p>
<pre><code>export default &#123;
    install(Vue,a,b,c)&#123; //第一个参数是 Vue 构造函数
        console.log(a,b,c)
        //全局过滤器
        Vue.filter(&#39;xxx&#39;,function(value)&#123;...&#125;)
        //定义全局指令
        Vue.directive(&#39;xxx&#39;,&#123;...&#125;)
        //定义混入
        Vue.mixin(&#123;...&#125;)
        //给 Vue 原型上添加一个方法（vm 和 vc 就都能用了）
        Vue.prototype.xxx = () =&gt; &#123;...&#125;
        Vue.prototype.$myMethod = function()&#123;...&#125;
        Vue.prototype.$myProperty = xxx
    &#125;
&#125;</code></pre>
<p>在 main.js 文件中使用插件</p>
<pre><code>import plugins from &#39;./plugins.js&#39;
//应用/使用插件
Vue.use(plugins,1,2,3)</code></pre>
<p>在组件中可直接使用插件中定义的东西</p>
<h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><p>scoped 样式让样式在局部生效，即在组件内部生效，防止各组件间样式的冲突</p>
<pre><code>&lt;style scoped&gt;&lt;/style&gt;</code></pre>
<h2 id="组件化编码流程"><a href="#组件化编码流程" class="headerlink" title="组件化编码流程"></a>组件化编码流程</h2><p>（1）拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突</p>
<p>（2）实现动态组件：考虑好数据的存放位置</p>
<pre><code>数据若是一个组件在用：放在组件自身即可
数据若是多个组件再用：放在它们共同的父组件上（状态提升）</code></pre>
<p>（3）实现交互：从绑定事件开始</p>
<h2 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h2><p>组件的自定义事件是一种组件间通信的方式，适用于子组件给父组件传数据</p>
<p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据就要在 A 中给 B 绑定自定义事件（事件的回调在 A 中），在 B 中触发该事件</p>
<h3 id="绑定自定义事件"><a href="#绑定自定义事件" class="headerlink" title="绑定自定义事件"></a>绑定自定义事件</h3><p>通过父组件给子组件传递函数类型的 props 实现子给父传递数据</p>
<pre><code>在父组件中
&lt;子组件 :参数名=&quot;父组件中的函数&quot;/&gt;
父组件中的函数(xxx)&#123;&#125;

在子组件中
props:[&#39;收到的参数名&#39;]
this.收到的参数名(xxx) //调用父组件函数来给父组件传数据</code></pre>
<p>通过父组件给子组件绑定一个自定义事件实现子给父传递数据（第一种写法，使用 @ 或 v-on）</p>
<pre><code>在父组件中绑定自定义事件
&lt;子组件 @自定义事件名=&quot;父组件中的函数&quot;/&gt;
//若想只触发一次:
//&lt;子组件 @自定义事件名.once=&quot;父组件中的函数&quot;/&gt;
父组件中的函数(xxx)&#123;&#125;

在子组件中触发自定义事件
this.$emit(&#39;父组件自定义的事件名&#39;,数据) //作为点击等事件的回调函数使用，就会触发父组件中自定义的事件从而执行父组件中的函数</code></pre>
<p>通过父组件给子组件绑定一个自定义事件实现子给父传递数据（第二种写法，使用 ref）</p>
<pre><code>在父组件中绑定自定义事件
&lt;子组件 ref=&quot;子组件别名&quot;/&gt;
mounted()&#123;
    this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,this.父组件中的函数)
    //若想只触发一次：
    //this.$refs.子组件.$once(&#39;父组件自定义的事件名&#39;,this.父组件中的函数)
    //this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,function(xx)&#123;...//这里的 this 是触发事件的子组件实例对象&#125;)
    //this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,(xx)=&gt;&#123;...//这里的 this 是父组件实例对象&#125;)
&#125;</code></pre>
<p>父组件中的函数若要接收多个数据 <code>父组件中的函数(name,...param)&#123;...&#125;</code>，params 中就是第一个参数之后的所有参数都在 params 数组中</p>
<p>组件上也可以绑定原生 DOM 事件，需要使用 native 修饰符</p>
<p>通过 <code>this.$refs.子组件.$on(&#39;xxx&#39;,回调)</code> 绑定自定义事件时，回调要么在 methods 中，要么用箭头函数，否则 this 指向会出问题</p>
<h3 id="解绑自定义事件"><a href="#解绑自定义事件" class="headerlink" title="解绑自定义事件"></a>解绑自定义事件</h3><p>解绑一个自定义事件</p>
<pre><code>在子组件中
this.$off(&#39;父组件自定义的事件名&#39;)</code></pre>
<p>解绑多个自定义事件</p>
<pre><code>在子组件中
this.$off([&#39;父组件自定义的事件名1&#39;,&#39;父组件自定义的事件名2&#39;])</code></pre>
<p>解绑所有自定义事件</p>
<pre><code>在子组件中
this.$off()</code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、若在组件中 <code>this.$destroy()</code> 销毁当前组件实例，销毁后所有该实例自定义事件全都不奏效</p>
<p>2、若在子组件上绑定 click 事件 <code>&lt;子组件 @click=&quot;xxx&quot;&gt;</code> 不会触发原生 click 事件，而是会把 click 看成自定义事件，需要在子组件中使用 <code>this.$emit(&#39;click&#39;)</code> 才能触发点击事件</p>
<p>3、若要给子组件绑定原生 click 事件可添加 .native，即 <code>&lt;子组件 @click.native=&quot;xxx&quot;&gt;</code> 即可直接触发点击事件无需使用 $emit 触发</p>
<h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>全局事件总线是一种组件间通信的方式，适用于任意组件间通信</p>
<p>（1）安装全局事件总线：在 main.js 中</p>
<pre><code>new Vue(&#123;
    beforeCreate()&#123;
        Vue.prototype.$bus = this //安装全局事件总线
    &#125;
&#125;)</code></pre>
<p>（2）若组件1想接收数据，在组件1中绑定自定义事件到 $bus 组件实例对象上，事件的回调写在组件1自身</p>
<pre><code>mounted()&#123;
    this.$bus.$on(&#39;自定义事件名&#39;,(data)=&gt;&#123;
        console.log(&#39;组件1收到数据&#39;,data)
    &#125;)
&#125;

或
methods()&#123;
    demo(data)&#123;...&#125;
&#125;
mounted()&#123;
    this.$bus.$on(&#39;自定义事件名&#39;,this.demo)
&#125;</code></pre>
<p>（3）在组件2中触发自定义事件给组件1传数据</p>
<pre><code>this.$bus.$emit(&#39;自定义事件名&#39;,数据)</code></pre>
<p>（4）在组件1组件实例销毁之前解绑当前组件用到的自定义事件</p>
<pre><code>beforeDestroy()&#123;
    this.$bus.$off(&#39;自定义事件名&#39;)
&#125;</code></pre>
<h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>消息订阅与发布是一种组件间通信的方式，适用于任意组件间通信</p>
<p>消息订阅与发布借助于 pubsub-js 库</p>
<p>安装 <code>npm install i pubsub-js -D</code></p>
<p>在接收数据的组件中订阅消息</p>
<pre><code>import pubsub from &#39;pubsub-js&#39;

mounted()&#123;
    const pubId = pubsub.subscribe(&#39;消息名&#39;,(msgName,data)=&gt;&#123; //第一个参数是消息名，第二个参数是数据
        consoe.log(this) //这里 this 是组件实例对象
    &#125;)
&#125;

或
methods()&#123;
    demo(msgName,data)&#123;...&#125;
&#125;
mounted()&#123;
    const pubId = pubsub.subscribe(&#39;消息名&#39;,this.demo)
&#125;</code></pre>
<p>在发送数据的组件中发送数据</p>
<pre><code>import pubsub from &#39;pubsub-js&#39;
mounted()&#123;
    pubsub.publish(&#39;消息名&#39;,数据)
&#125;</code></pre>
<p>在接收数据的组件中取消订阅</p>
<pre><code>beforeDestroy()&#123;
    pubsub.unsubscribe(this.pubId)
&#125;</code></pre>
<h2 id="Vue-封装的过度与动画"><a href="#Vue-封装的过度与动画" class="headerlink" title="Vue 封装的过度与动画"></a>Vue 封装的过度与动画</h2><p>过度与动画的作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E7%94%BB.png" alt="动画"></p>
<p>写法：</p>
<p>（1）准备好样式</p>
<pre><code>元素进入的样式
v-enter：进入的起点
v-enter-acitve：进入过程中
v-enter-to：进入的终点

元素离开的样式
v-leave：离开的起点
v-leave-acitve：离开过程中
v-leave-to：离开的终点</code></pre>
<p>（2）使用 <code>&lt;transition&gt;</code> 包裹要过度的元素，并配置 name 属性</p>
<p>（3）若有多个元素需要过度，则使用 <code>&lt;transition-group&gt;</code>，且每个元素都要指定 key 值 </p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>例子：实现组件相左滑动离开页面以及从页面外向右滑动进来</p>
<p>方式一：使用 css 实现</p>
<pre><code>@keyframes xxx&#123;
    from&#123;
        transform: translateX(-100%);
    &#125;
    to&#123;
        transform: translateY(0px);
    &#125;
&#125;
.come&#123;
    animation: xxx 1s;
&#125;
.go&#123;
    animation: xxx 1s reverse;
&#125;</code></pre>
<p>方式二：在 Vue 中实现</p>
<pre><code>&lt;transition appear&gt; &lt;!--若添加 appear 属性则页面一渲染就会自动播放动画，真实 DOM 中没有 transition--&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;hello&lt;/h1&gt;
&lt;/transition&gt;

@keyframes xxx&#123;
    from&#123;
        transform: translateX(-100%);
    &#125;
    to&#123;
        transform: translateY(0px);
    &#125;
&#125;
//进入的过程
.v-enter-active&#123; //若在 &lt;transition&gt; 中设置了 name 属性为 xxxx，这里的类需要写成 .xxxx-enter-active
    animation: xxx 1s;
&#125;
//离开的过程
.v-leave-active&#123; //若在 &lt;transition&gt; 中设置了 name 属性为 xxxx，这里的类需要写成 .xxxx-leave-active
    animation: xxx 1s reverse;
&#125;</code></pre>
<h3 id="过度效果"><a href="#过度效果" class="headerlink" title="过度效果"></a>过度效果</h3><pre><code>&lt;transition name=&quot;demo&quot; appear&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;hello&lt;/h1&gt;
&lt;/transition&gt;

h1&#123;
    transition: 1s linear;
&#125;
//进入的起点
.demo-enter&#123;
    transform: translateX(-100%);
&#125;
//进入的终点
.demo-enter-to&#123;
    transform: translateX(0);
&#125;
//离开的起点
.demo-leave&#123;
    transform: translateX(0);
&#125;
//离开的终点
.demo-leave-to&#123;
    transform: translateX(-100%);
&#125;</code></pre>
<p>上述样式可简写为</p>
<pre><code>//进入的起点、离开的终点
.demo-enter,.demo-leave-to&#123;
    transform: translateX(-100%);
&#125;
//进入的终点、离开的起点
.demo-enter-to,.demo-leave&#123;
    transform: translateX(0);
&#125;
.demo-enter-active,.demo-leave-active&#123;
    transition: 1s linear;
&#125;</code></pre>
<p>若多个元素有同样的过度效果</p>
<pre><code>&lt;transition-group name=&quot;demo&quot; appear&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;hello&lt;/h1&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;world&lt;/h1&gt;
&lt;/transition-group&gt;</code></pre>
<h3 id="集成第三方动画"><a href="#集成第三方动画" class="headerlink" title="集成第三方动画"></a>集成第三方动画</h3><p>如第三方动画库 animate.css，<a target="_blank" rel="noopener" href="https://animate.style/">官网</a></p>
<p>安装 <code>npm install animate.css -D</code></p>
<p>引入</p>
<pre><code>import &#39;animate.css&#39;</code></pre>
<p>使用</p>
<pre><code>&lt;transition-group 
    appear
    name=&quot;animate__animated animate__bounce&quot;
    enter-active-class=&quot;animate__swing&quot;
    leave-active-class=&quot;animate__backOutRight&quot;
&gt; &lt;!--name 值是固定的，在 enter-active-class 中设置进入动画，在 leave-active-class 中设置离开动画，具体动画效果可在官网查看--&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;hello&lt;/h1&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;world&lt;/h1&gt;
&lt;/transition-group&gt;</code></pre>
<h2 id="利用-Vue-脚手架巧妙解决跨域问题"><a href="#利用-Vue-脚手架巧妙解决跨域问题" class="headerlink" title="利用 Vue 脚手架巧妙解决跨域问题"></a>利用 Vue 脚手架巧妙解决跨域问题</h2><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><pre><code>（1）CORS：后端中在响应头中配置 CORS 来解决跨域问题，但这种方式不安全，使得所有人都能访问服务器
（2）jsonp：利用 script 标签中的 src 在引入资源时不用遵循同源策略，这种方式需要前端后端配合，但这种方法在开发中用的少
（3）代理服务器：借助一台与前端地址同源的代理服务器，前端向代理服务器发送请求，代理服务器转发给服务器，服务器响应数据给代理服务器再转发至前端，因为服务器与服务器之间的通信没有什么同源策略，ajax 只有在前端中才有
    开启代理服务器的方式：（1）nginx（2）借助 vue-cli</code></pre>
<h3 id="利用-Vue-脚手架开启代理服务器解决跨域问题"><a href="#利用-Vue-脚手架开启代理服务器解决跨域问题" class="headerlink" title="利用 Vue 脚手架开启代理服务器解决跨域问题"></a>利用 Vue 脚手架开启代理服务器解决跨域问题</h3><p><strong>方式一</strong></p>
<p>在 vue.config.js 文件中配置如下</p>
<pre><code>devServer:&#123;
    proxy:&#39;http://localhost:3000&#39;, //目标服务器地址
&#125;</code></pre>
<p>在代码中发送请求时写的请求地址和前端同源，path 后缀和服务器接口一致即可，如前端在 <a href="http://localhost:8080，要访问服务器的">http://localhost:8080，要访问服务器的</a> <a target="_blank" rel="noopener" href="http://localhost:3000/xxx%EF%BC%8C%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%A6%81%E5%86%99%E6%88%90">http://localhost:3000/xxx，在代码要写成</a> <a target="_blank" rel="noopener" href="http://localhost:8080/xxx">http://localhost:8080/xxx</a></p>
<p>注意：代理服务器不是把所有请求都转发给服务器，当请求的资源在代理服务器有的时候就不转发给服务器，代理服务器的根路径就是 public 文件夹所在位置</p>
<p><strong>优点：</strong>配置简单，请求资源时直接发给前端即可</p>
<p><strong>缺点：</strong>上面这种方式中不能配置多个代理，并且不能灵活地控制走不走代理（工作方式：只有当代理服务器中没有所要资源时转发给服务器（优先匹配前端资源））</p>
<p><strong>方式二</strong></p>
<p>在 vue.config.js 文件中配置如下</p>
<pre><code>devServer:&#123;
    proxy:&#123;
        &#39;/api&#39;:&#123;
            target:&#39;http://localhost:3000&#39;, //目标服务器地址
            pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125;,
            ws:true,  //用于支持 websocket
            changeOrigin: true //用于控制请求头中的 host 值，即若为 false，服务器显示收到的请求来自 http://localhost:8080，若为 true 显示的是来自 http://localhost:3000
            //changeOrigin 默认是 true
        &#125;,
        &#39;/demo&#39;:&#123;
            target:&#39;http://localhost:3001&#39;,
            pathRewrite:&#123;&#39;^/demo&#39;:&#39;&#39;&#125;,
        &#125;
    &#125;
&#125;</code></pre>
<p>如前端在 <a href="http://localhost:8080，要访问服务器的">http://localhost:8080，要访问服务器的</a> <a target="_blank" rel="noopener" href="http://localhost:3000/xxx%EF%BC%8C%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%A6%81%E5%86%99%E6%88%90">http://localhost:3000/xxx，在代码要写成</a> <a target="_blank" rel="noopener" href="http://localhost:8080/api/xxx%EF%BC%8C%E8%8B%A5%E5%90%91%E8%AE%BF%E9%97%AE%E5%89%8D%E7%AB%AF%E7%9A%84">http://localhost:8080/api/xxx，若向访问前端的</a> xxx 资源则是要不加 /api 就可以不走代理服务器</p>
<p><strong>优点：</strong>可以配置多个代理，且可以灵活控制请求是否走代理</p>
<p><strong>缺点：</strong>配置略微繁琐，请求资源时必须加前缀</p>
<h2 id="发送-ajax-请求（vue-resource）"><a href="#发送-ajax-请求（vue-resource）" class="headerlink" title="发送 ajax 请求（vue-resource）"></a>发送 ajax 请求（vue-resource）</h2><p>发送 ajax 请求的方式有 xhr、jQuery、axios、fetch，其中 jQuery 和 axios 都是对 xhr 的二次封装，fetch 是和 xhr 平级的</p>
<p>在 Vue 中还可以借助 vue-resource 插件库发送 ajax 请求，在 Vue 1.0 中用的多，官方已不维护。vue-resource 也是对 xhr 的封装</p>
<p>安装 <code>npm i vue-resource -D</code></p>
<p>在 main.js 文件中</p>
<pre><code>import vueResource from &#39;vue-resource&#39;
Vue.use(vueResource)  //使用 vue-resource 插件库后 vm 和 vc 上都会出现 $http</code></pre>
<p>在组件代码中使用 vue-resource，用法和 axios 相同</p>
<pre><code>this.$http.get(&#39;url地址&#39;).then(
    response=&gt;&#123;...&#125;,
    error=&gt;&#123;...&#125;
)</code></pre>
<h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h2><p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于父组件向子组件传结构</p>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
&lt;div&gt;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;h2&gt;xxx&lt;/h2&gt; &lt;!--这部分内容会替换子组件中 slot 的位置--&gt;
&lt;/子组件&gt;</code></pre>
<p>插槽中的样式可在父组件中定义（解析好父组件后把带样式的结构替换子组件中的 slot）也可在子组件中定义（解析后把结构传入子组件中的 slot 然后再付上样式）</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>当需要在一个组件中定义多个插槽，则需要给每个 slot 加上 name 属性</p>
<p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot name=&quot;aaa&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
    &lt;slot name=&quot;bbb&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
&lt;div&gt;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;h2 slot=&quot;aaa&quot;&gt;xxx&lt;/h2&gt;
    &lt;a slot=&quot;bbb&quot; href=&quot;xxxxx&quot;&gt;xx&lt;/a&gt;
&lt;/子组件&gt;</code></pre>
<p>注意若父组件中要放在 slot 中有多个元素可使用 <code>&lt;template&gt;</code> 把这些元素包裹起来，并且指定插槽时可使用 <code>v-slot:aaa</code> 来代替 <code>slot=&quot;aaa&quot;</code></p>
<pre><code>&lt;子组件&gt;
    &lt;template v-slot:aaa&gt;
        &lt;h2&gt;xxx&lt;/h2&gt;
        &lt;h2&gt;xxx&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;</code></pre>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>当数据在设置了插槽的子组件中，使用该组件的父组件若要用到这些数据就可以使用作用域插槽</p>
<p>即数据在组件自身，但根据数据生成的结构需要组件的使用者来决定</p>
<p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot :data1=&quot;data1&quot; msg=&quot;hello&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值，这里也可以设置 name，在父组件中相应的使用 slot=&quot;xx&quot;&lt;/slot&gt;
&lt;div&gt;

data()&#123;
    return&#123;
        data1:xxx
    &#125;
&#125;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;template scope=&quot;somedata&quot;&gt;
        &lt;h2&gt;&#123;&#123;somedata.data1&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;&#123;somedata.msg&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;

&lt;子组件&gt;
    &lt;template scope=&quot;&#123;data1&#125;&quot;&gt;
        &lt;h2&gt;&#123;&#123;data1&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;

&lt;子组件&gt;
    &lt;template slot-scope=&quot;&#123;data1&#125;&quot;&gt;
        &lt;h2&gt;&#123;&#123;data1&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;</code></pre>
<h1 id="五、组件间通信"><a href="#五、组件间通信" class="headerlink" title="五、组件间通信"></a>五、组件间通信</h1><p>（1）父子组件：props</p>
<p>父传子数据</p>
<pre><code>父组件中
`&lt;子组件 变量名=&quot;值&quot;&gt;`
子组件中
props:[&#39;变量名&#39;]</code></pre>
<p>子传父</p>
<pre><code>父组件中
`&lt;子组件 变量名=&quot;函数名&quot;&gt;`
子组件中
props:[&#39;变量名&#39;]
调用函数来修改父组件中的数据</code></pre>
<p>（2）绑定自定义事件：$emit（多用于父子间子给父）</p>
<p>（3）全局事件总线（基于自定义事件）（任意组件间通信）这种方式用得比消息订阅发布的方式多</p>
<p>（4）消息订阅与发布（任意组件间通信）</p>
<p>（5）插槽（父给子传 html 结构）、作用域插槽（子中的数据父需要使用）</p>
<p>（6）Vue3 中祖与后代组件间通信的 provide 与 inject</p>
<h1 id="六、Vuex"><a href="#六、Vuex" class="headerlink" title="六、Vuex"></a>六、Vuex</h1><p>vuex 是专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，</p>
<p>vuex 对 vue 应用中多个组件的共享状态进行集中式的管理（读/写）</p>
<p>vuex 也是一种组件间通信的方式，且适用于任意组件间的通信</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>（1）多个组件依赖于同一状态</p>
<p>（2）来自不同组件的行为需要变更同一状态</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vuex.png" alt="vuex"></p>
<h2 id="Vuex-的使用"><a href="#Vuex-的使用" class="headerlink" title="Vuex 的使用"></a>Vuex 的使用</h2><p>（1）安装 <code>npm i vuex@3</code></p>
<p>注意：vue2 只能使用 vuex3，vuex4 只能用在 vue3，这里先以 vue2 + vuex3 为例</p>
<p>（2）引入</p>
<p>在 main.js 中</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import store from &#39;./store/index.js&#39;

new Vue(&#123;
    el:&#39;#app&#39;,
    render: h=&gt;h(App),
    store,
    beforeCreate()&#123;
        Vue.prototype.$bus = this
    &#125;
&#125;)</code></pre>
<p>（3）创建 store</p>
<p>创建 src/store/index.js 文件用于创建 Vuex 中最核心的 store</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
//使用 Vuex 插件
Vue.use(Vuex)

//准备 actions 用于响应组件的动作
const actions = &#123;&#125;
//准备 mutations 用于操作 state 数据
const mutations = &#123;&#125;
//准备 state 用于存储数据
const state = &#123;&#125;
//准备 getters 用于将 state 中的数据进行加工
const getters = &#123;&#125;

//创建并暴露 store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
    getters
&#125;)</code></pre>
<p>当 state 中的数据需要经过加工后再使用时，可使用 getters 加工（优点类似 computed）</p>
<p>（4）组件中读取/修改 vuex 数据</p>
<p>组件中读取 vuex 数据：<code>this.$store.state.sum</code> 和 <code>this.$store.getters.sum</code>，若在模板中读就不加 this</p>
<p>组件中修改 vuex 中的数据：<code>this.$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>this.$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<p>（5）组件中使用 mapState/mapGetters/mapMutations/mapActions</p>
<p>借助 mapState/mapGetters 生成计算属性，从 state/getters 中读取数据</p>
<p>借助 mapMutations/mapGetters 生成对应方法，方法中会调用 commit/dispatch 去联系 mutations/actions</p>
<p>注意：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写 dispatch，直接写 commit</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在 store.js 文件中</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)

const actions = &#123;
    inc(context,value)&#123; //第一个参数是上下文对象，该对象上有 $commit、$dispatch 等方法以及 state，第二个参数是 dispatch 传来的值
        console.log(context.state.sum)
        context.commit(&#39;INC&#39;,value) //会调用 mutations 中的 INC 函数
    &#125;
&#125;
const mutations = &#123;
    INC(state,value)&#123;
        state.sum += value
    &#125;
&#125;
const state = &#123;
    sum:0
&#125;
const getters = &#123;
    bigSum(state)&#123;
        return state.sum * 10
    &#125;
&#125;

export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
    getters
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;h1&gt;&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;
&lt;h1&gt;&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;/h1&gt;

methods:&#123;
    increment()&#123;
        console.log(this.$store.state.sum)
        this.$store.dispatch(&#39;inc&#39;,this.n) //会调用 actions 中的 inc 函数
    &#125;
&#125;</code></pre>
<p>由于在 actions 中没有特别的业务逻辑，所以可以直接跳过 actions（不用 dispatch），由组件直接使用 commit 调用 mutation 里的函数，所以上述代码可简写为</p>
<p>在 store.js 文件中</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)

const actions = &#123;
&#125;
const mutations = &#123;
    INC(state,value)&#123;
        state.sum += value
    &#125;
&#125;
const state = &#123;
    sum:0
&#125;

export default new Vuex.Store(&#123;
    actions,
    mutations,
    state
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;h1&gt;&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;

methods:&#123;
    increment()&#123;
        console.log(this.$store.state.sum)
        this.$store.commit(&#39;INC&#39;,this.n) //会调用 actions 中的 inc 函数
    &#125;
&#125;</code></pre>
<p>在组件里用上 mapState/mapGetters/mapMutations/mapActions</p>
<pre><code>&lt;button @click=&quot;&#123;&#123;increment(n)&#125;&#125;&quot;&gt;&#123;&#123;sum&#125;&#125;&lt;/button&gt;

import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#39;vuex&#39;

computed:&#123;
    ...mapState(&#123;sum:&#39;sum&#39;,xxx:&#39;xx&#39;&#125;) //对象写法，键为本组件中使用的名字，值为 state 中的变量名
    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;)
    //或
    //...mapState([&#39;sum&#39;,&#39;xxx&#39;]) //当组件中使用的名字和 state 中的变量名一致时可使用数组写法
    //...mapGetters([&#39;bigSum&#39;])
    //上述 mapState 写法相当于
    /*sum()&#123;
        return this.$store.state.sum
    &#125;
    xxx()&#123;
        return this.$store.state.xxx
    &#125;*/

    ...mapMutations(&#123;increment:&#39;INC&#39;,decrement:&#39;DEC&#39;&#125;) //对象写法
    //或
    //...mapMutations([&#39;INC&#39;]) //对数组写法，此时在 @click 中应使用 INC 方法
    //上述 mapMutations 写法相当于
    /*increment()&#123;
        return this.$store.commit(&#39;INC&#39;,this.n)
    &#125;*/

    ...mapActions(&#123;increment1:&#39;INC1&#39;,decrement1:&#39;DEC1&#39;&#125;) //对象写法
    //或
    ...mapActions([&#39;INC1&#39;]) //数组写法
    //上述 mapMutations 写法相当于
    /*increment1()&#123;
        return this.$store.dispatch(&#39;INC1&#39;,this.n)
    &#125;*/
&#125;</code></pre>
<h2 id="vuex-模块化"><a href="#vuex-模块化" class="headerlink" title="vuex 模块化"></a>vuex 模块化</h2><p>在 store/index.js 中根据按功能将 actions、mutations、state、getters 包起来，也可以按功能将这些东西放到不同 js 文件中，然后在 store/index.js 中引入</p>
<pre><code>const countOptions = &#123;
    namespace:true,
    actions:&#123;...&#125;,
    mutations&#123;...&#125;,
    state:&#123;...&#125;,
    getters:&#123;...&#125;
&#125;
const persionsOptions = &#123;
    namespace:true,
    actions:&#123;...&#125;,
    mutations&#123;...&#125;,
    state:&#123;...&#125;,
    getters:&#123;...&#125;
&#125;
export default new Vuex.Store(&#123;
    modules:&#123;
        countAbout:countOptions,
        personAbout:persionsOptions
    &#125;
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;button @click=&quot;&#123;&#123;increment(n)&#125;&#125;&quot;&gt;&#123;&#123;sum&#125;&#125;&lt;/button&gt;
&lt;h1&gt;&#123;&#123;sum&#125;&#125;&lt;/h1&gt;

...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;xxx&#39;])
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
...mapMutations(&#39;countAbout&#39;,[&#39;INC&#39;])

this.$store.getters[&#39;countAbout/bigSum&#39;]
this.$store.dispatch(&#39;countAbout/XXX&#39;,this.n)
this.$store.commit(&#39;countAbout/INC&#39;,this.n)</code></pre>
<h1 id="七、浏览器本地存储-webStorage"><a href="#七、浏览器本地存储-webStorage" class="headerlink" title="七、浏览器本地存储 webStorage"></a>七、浏览器本地存储 webStorage</h1><p>webStorage 存储内容大小一般支持 5MB 左右（不同浏览器可能不一样）</p>
<p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制</p>
<pre><code>xxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)
该方法接收一个键和值作为参数，会把键值对添加到存储中，若键名存在，则更新其对应的值
xxxStorage.getItem(&#39;key&#39;)
该方法接收一个键名作为参数，返回键名对应的值
xxxStorage.removeItem(&#39;key&#39;)
该方法接收一个键名作为参数，并把该键名从存储中删除
xxxStorage.clear()
该方法会清空存储中的所有数据</code></pre>
<p>sessionStorage 存储的内容会随着浏览器窗口关闭而消失</p>
<p>localStorage 存储的内容需要手动清除才会消失</p>
<p>xxxStorage.getItem(‘key’) 若 key 对应的 value 获取不到返回的是 null</p>
<p>Json.parse(null) 的结果依然是 null，不是 undefined</p>
<h1 id="八、路由"><a href="#八、路由" class="headerlink" title="八、路由"></a>八、路由</h1><p>路由就是一组 key（路径）-value（function 或 component） 的对应关系，多个路由需要经过路由器管理</p>
<h2 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h2><p>（1）后端路由</p>
<p>后端路由中 value 是 function，用于处理客户端提交的请求</p>
<p>工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据</p>
<p>（2）前端路由</p>
<p>前端路由中 value 是 component，用于展示页面内容</p>
<p>工作过程：当浏览器的路径改变时，对应的组件就会显示</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>vue-router 是 vue 的一个插件库，专门用来实现 SPA 单页面应用</p>
<p>单页 Web 应用中整个应用只有一个完整的页面，点击页面中的导航链接不会刷新页面，只会做页面的局部更新，数据需要通过 ajax 请求获取</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹</p>
<p>通过切换，“隐藏”了的路由组件默认是被销毁掉的，需要的时候再去挂载</p>
<p>每个组件都有自己的 $route 属性，里面存储着自己的路由信息</p>
<p>整个应用只有一个 router，可通过组件的 $router 属性获取到</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>安装 <code>npm i vue-router@3 -D</code></p>
<p>注意：vue2 只能使用 vue-router3，vue-router 4 只能用在 vue3 中使用，这里先以 vue2 + vuex3 为例，所以安装 vue-router 3</p>
<p>引入，在 main.js 中</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import VueRouter from &#39;vue-router&#39;
import router from &#39;./router/index.js&#39;
import store from &#39;./store/index.js&#39;
Vue.use(VueRouter)
new Vue(&#123;
    el:&#39;#app&#39;,
    render: h=&gt;h(App),
    router
    store,
    beforeCreate()&#123;
        Vue.prototype.$bus = this
    &#125;
&#125;)</code></pre>
<p>创建 src/router/index.js 文件专门用于创建整个应用的路由器</p>
<pre><code>import VueRouter from &#39;vue-router&#39;
import About from &#39;./components/about.vue&#39;
import Home from &#39;./components/home.vue&#39;
//创建并暴露一个路由器
export default new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home
        &#125;
    ]
&#125;)</code></pre>
<p>组件中使用 <code>&lt;router-link&gt;</code> 实现路由的切换（通过 active-class 配置高亮样式），使用 <code>&lt;router-view&gt;</code> 指定不同路由下组件的呈现位置</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;

&lt;router-view&gt;&lt;/router-view&gt;</code></pre>
<h2 id="嵌套（多级）路由"><a href="#嵌套（多级）路由" class="headerlink" title="嵌套（多级）路由"></a>嵌套（多级）路由</h2><p>修改 src/router/index.js 文件</p>
<pre><code>import VueRouter from &#39;vue-router&#39;
import About from &#39;./components/about.vue&#39;
import Home from &#39;./components/home.vue&#39;
import News from &#39;./components/news.vue&#39;
import Message from &#39;./components/message.vue&#39;
//创建并暴露一个路由器
export default new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home,
            children:[
                &#123;
                    path:&#39;news&#39;, //子路由不加 /，这里相当于 /home/news
                    component:News
                &#125;,
                &#123;
                    path:&#39;message&#39;,
                    component:Message
                &#125;
            ]
        &#125;
    ]
&#125;)</code></pre>
<p>在 Home 路由组件中</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
&lt;router-link active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;  &lt;!--这里得写完整路径--&gt;

&lt;router-view&gt;&lt;/router-view&gt;</code></pre>
<h2 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h2><p>跳转路由携带 query 参数</p>
<pre><code>&lt;!to 的字符串写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;

&lt;!to 的对象写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    path:&#39;/home/message/detail&#39;,
    query:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>接收参数</p>
<pre><code>this.$route.query.id
this.$route.query.title</code></pre>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail&#39;,
    component:Detail
&#125;</code></pre>
<p>组件中</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    name:&#39;ddd&#39;,
    query:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>在没有 query 参数的组件中使用命名路由</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;name:&#39;xxx&#39;&#125;&quot;&gt;About&lt;/router-link&gt;</code></pre>
<h2 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h2><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail
&#125;</code></pre>
<p>组件中</p>
<pre><code>&lt;!to 的字符串写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;/home/message/detail/$&#123;id&#125;/$&#123;title&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;

&lt;!to 的对象写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    name:&#39;ddd&#39;, //注意这里只能用 name，不能用 path
    params:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>接收参数</p>
<pre><code>this.$route.params.id
this.$route.params.title</code></pre>
<p><strong>注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置</strong></p>
<h2 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h2><p>路由的 props 配置让路由组件更方便的收到参数</p>
<h3 id="写法一：路由规则中-props-值为对象"><a href="#写法一：路由规则中-props-值为对象" class="headerlink" title="写法一：路由规则中 props 值为对象"></a>写法一：路由规则中 props 值为对象</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail,
    //写法一：值为 对象，该对象中的所有 key-value 都会以 props 的形式给 Detail 组件（这种写法用的少，因为写的都死数据）
    props:&#123;a:1,b:&#39;xxx&#39;&#125;
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;a&#39;,&#39;b&#39;]</code></pre>
<h3 id="写法二：路由规则中值为布尔值"><a href="#写法二：路由规则中值为布尔值" class="headerlink" title="写法二：路由规则中值为布尔值"></a>写法二：路由规则中值为布尔值</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail,

    //写法二：值为布尔值，若为真就会把该路由组就收到的所有 params 参数以 props 的形式传给 Detail 组件
    props:true
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;id&#39;,&#39;title&#39;]</code></pre>
<h3 id="写法三：路由规则中值为函数"><a href="#写法三：路由规则中值为函数" class="headerlink" title="写法三：路由规则中值为函数"></a>写法三：路由规则中值为函数</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail&#39;,
    component:Detail,

    //写法三：值为函数，该函数返回的对象中每一组 key-value 都会通过 props 传给 Detail 组件
    props($route)&#123;
        return &#123;id:$route.query.id,title:$route.query.title&#125;
    &#125;
    //或直接解构赋值
    /*props(&#123;query:&#123;id,title&#125;&#125;)&#123;
        return &#123;id,title&#125;
    &#125;*/
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;id&#39;,&#39;title&#39;]</code></pre>
<h2 id="router-link-的-replace-属性"><a href="#router-link-的-replace-属性" class="headerlink" title="router-link 的 replace 属性"></a>router-link 的 replace 属性</h2><p>作用：控制路由跳转时操作浏览器历史记录的模式</p>
<p>浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录，默认是 push</p>
<p>开启 replace 模式的方式：</p>
<pre><code>&lt;router-link replace&gt;xxx&lt;/router-link&gt;</code></pre>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>由于 <code>&lt;router-link&gt;</code> 解析后都是以 a 标签的形式显示在页面中，若想要通过点击按钮来实现跳转则无法使用 <code>&lt;router-link&gt;</code> 来实现，又如要过一段时间后自动跳转路由也无法通过 <code>&lt;router-link&gt;</code> 实现</p>
<p>编程式路由导航作用：不借助 <code>&lt;router-link&gt;</code>  实现路由跳转，让路由跳转更加灵活</p>
<pre><code>this.$router.push(&#123;
    name:&#39;ddd&#39;,
    query:&#123;  //也可以是 params
        id:&#39;xx&#39;,
        title:&#39;xxx&#39;
    &#125;
&#125;)

this.$router.replace(&#123;
    name:&#39;ddd&#39;,
    query:&#123;  //也可以是 params
        id:&#39;xx&#39;,
        title:&#39;xxx&#39;
    &#125;
&#125;)

this.$router.back() //后退

this.$router.forward() //前进

this.$router.go(整整)  //正整数前进 n 步，负整数后退 n 步</code></pre>
<h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><p>当某个组件中有用户输入的数据，当路由跳转后当前组件被销毁，用户输入的数据也消失了</p>
<p>缓存路由组件作用：让不展示的路由组件保持挂载不被销毁，通过在 <code>&lt;router-view&gt;</code> 外包裹 <code>&lt;keep-alive&gt;</code></p>
<p>所有都缓存时</p>
<pre><code>&lt;keep-alive&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<p>缓存一个组件时</p>
<pre><code>&lt;keep-alive include=&quot;要缓存的组件名1&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<p>缓存多个组件时</p>
<pre><code>&lt;keep-alive :include=&quot;[&#39;要缓存的组件名1&#39;,&#39;要缓存的组件名2&#39;]&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<h2 id="路由组件独有的两个新的生命周期钩子"><a href="#路由组件独有的两个新的生命周期钩子" class="headerlink" title="路由组件独有的两个新的生命周期钩子"></a>路由组件独有的两个新的生命周期钩子</h2><p>若在被缓存的组件中开启定时器，当路由跳转时该定时器依然在运行</p>
<p>路由组件独有的两个新的生命周期钩子可用于捕获路由组件的激活状态</p>
<pre><code>activated()&#123; //组件从无到有时被激活触发
    this.timer = setInterval(()=&gt;&#123;
        ...
    &#125;,1000)
&#125;,
deactivated()&#123; //当路由跳转时被失活触发
    clearInterval(this.timer)
&#125;</code></pre>
<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由守卫控制路由的权限</p>
<h3 id="全局前置路由守卫"><a href="#全局前置路由守卫" class="headerlink" title="全局前置路由守卫"></a>全局前置路由守卫</h3><p>在 src/router/index.js 中添加</p>
<pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false&#125; //在 meta 中配置自定义属性
&#125;

//初始化时被调用，每次路由切换之前被调用
router.beforeEach((to,from,next)=&gt;&#123;
    //做一些判断是否允许路由正常跳转
    if(to.meta.isAuth)&#123;
        if(...)&#123;
            next() //正常跳转
        &#125;else&#123;...&#125;
    &#125;else&#123;
        next() //正常跳转
    &#125;
&#125;)</code></pre>
<h3 id="全局后置路由守卫"><a href="#全局后置路由守卫" class="headerlink" title="全局后置路由守卫"></a>全局后置路由守卫</h3><pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false,title:&#39;xxx&#39;&#125; //在 meta 中配置自定义属性
&#125;

//初始化时被调用，每次路由切换之后被调用
router.afterEach((to,from)=&gt;&#123;
    document.title = to.meta.title || &#39;默认&#39;  //修改页签
&#125;)</code></pre>
<h3 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h3><p>独享路由守卫即某个路由独享的路由守卫</p>
<pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false,title:&#39;xxx&#39;&#125;
    beforeEnter:(to,from,next)=&gt;&#123;
        //这里可以完成如前置路由守卫中的逻辑
    &#125;
&#125;</code></pre>
<p>注意：没有 afterEnter</p>
<h3 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h3><p>在组件中</p>
<pre><code>//通过路由规则进入该组件时被调用（不是在页面中直接展示组件的方式进入组件）
beforeRouteEnter(to,from,next)&#123;
    //这里可以完成如前置路由守卫中的逻辑
    next() //允许进入
&#125;,
//通过路由规则离开该组件时被调用
beforeRouteLeave(to,from,next)&#123;
    next() //允许离开
&#125;</code></pre>
<h2 id="history-模式和-hash-模式"><a href="#history-模式和-hash-模式" class="headerlink" title="history 模式和 hash 模式"></a>history 模式和 hash 模式</h2><p>对于 url 来说 # 及其后面的内容就是 hash 值</p>
<p>hash 值不会包含在 HTTP 请求中，即 hash 值不会带给服务器</p>
<p>hash 模式：</p>
<pre><code>（1）地址中永远带着 # 号，不美观
（2）若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法
（3）兼容性较好</code></pre>
<p>history 模式：</p>
<pre><code>（1）地址干净美观
（2）兼容性和 hash 模式相比略差
（3）应用部署上线时需要后端人员支持，解决刷新页面服务器端 404 的问题</code></pre>
<p>Vue 脚手架应用中默认是用 hash 模式</p>
<p>若要启用 history 模式，在 router/index.js 创建路由器时添加 <code>mode:&#39;history&#39;</code></p>
<h1 id="九、Vue-UI-组件库"><a href="#九、Vue-UI-组件库" class="headerlink" title="九、Vue UI 组件库"></a>九、Vue UI 组件库</h1><p>移动端常用 UI 组件库：<a target="_blank" rel="noopener" href="https://youzan.github.io/vant">Vant</a>、<a target="_blank" rel="noopener" href="https://didi.github.io/cube-ui">Cube UI</a>、<a target="_blank" rel="noopener" href="http://mint-ui.github.io/">Mint UI</a></p>
<p>PC 端常用 UI 组件库：<a target="_blank" rel="noopener" href="https://element.eleme.cn/">Element UI</a>、<a target="_blank" rel="noopener" href="https://www.iviewui.com/">IView UI</a></p>
<p>注意：使用 Element UI 时按照文档中的按需引入配置会报错，其中安装完 babel-plugin-component 后，修改 babel.config.js 为</p>
<pre><code>&#123;
  &quot;presets&quot;: [[&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      &#123;
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      &#125;
    ]
  ]
&#125;</code></pre>
<h1 id="十、Vue-3"><a href="#十、Vue-3" class="headerlink" title="十、Vue 3"></a>十、Vue 3</h1><p>Vue3 在 2020 年 9 月发布正式版，Vue3 支持大多数的 Vue2 特性</p>
<h2 id="Vue-3-带来了什么"><a href="#Vue-3-带来了什么" class="headerlink" title="Vue 3 带来了什么"></a>Vue 3 带来了什么</h2><p>（1）性能的提升</p>
<p>打包大小减少 41%</p>
<p>初次渲染快 55%，更新渲染快 133%</p>
<p>内存减少 54%</p>
<p>……</p>
<p>（2）源码升级</p>
<p><strong>使用 Proxy 配合 Reflect 代替 Vue2 中 defineProperty 实现响应式</strong></p>
<p>重写虚拟 DOM 的实现和 Tree-Shaking</p>
<p>……</p>
<p>（3）拥抱 TypeScript</p>
<p>Vue 3 可以更好的支持 TypeScript</p>
<p>（4）新的特性</p>
<p>— 1） Composition API（组合 API）</p>
<pre><code>setup 配置
ref 与 reactive
watch 与 watchEffect
provide 与 inject
......</code></pre>
<p>—2）新的内置组件</p>
<pre><code>Fragment
Teleport
Suspense</code></pre>
<p>—3）其他改变</p>
<pre><code>新的生命周期钩子
data 选项应始终被声明为一个函数
移除 keyCode 支持作为 v-on 的修饰符
......</code></pre>
<h2 id="使用-vue-cli-创建-Vue3-工程"><a href="#使用-vue-cli-创建-Vue3-工程" class="headerlink" title="使用 vue-cli 创建 Vue3 工程"></a>使用 vue-cli 创建 Vue3 工程</h2><p>要创建 Vue3 项目，则 vue-cli 的版本必须在 4.5.0 以上</p>
<p>安装 <code>npm install -g @vue/cli</code></p>
<p>创建项目 <code>vue create 项目名</code></p>
<p>在项目文件夹下启动 <code>npm run serve</code></p>
<h2 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h2><p>vite 是新一代前端构建工具，当前一般使用 webpack</p>
<p>vite 优势：</p>
<pre><code>开发环境中，无需打包操作，可快速的冷启动
轻量快速的热重载（HMR）
真正的按需编译，不再等待整个应用编译完成</code></pre>
<p>vite 与 webpack 区别：webpack 首先看入口文件，分析路由，然后分析各模块，再将所有东西进行一次打包形成一台准备好的服务器；而 vite 是先准备好空壳服务器，当发起 http 请求时从入口文件进入找到相应路由，然后分析该路由对应的那些模块，这样启动速度更快，东西现用现分析，动态引入和代码分割</p>
<p>创建 Vue3 项目：</p>
<p>创建工程 <code>npm init vite-app 项目名</code></p>
<p>进入工程目录后安装依赖 <code>npm install</code></p>
<p>运行 <code>npm run dev</code></p>
<h2 id="分析工程结构"><a href="#分析工程结构" class="headerlink" title="分析工程结构"></a>分析工程结构</h2><p>在入口文件 main.js 中</p>
<pre><code>//引入的不再是 Vue 构造函数了（构造函数首字母大写，需要通过 new 去调用），而是一个名为 createApp 的工厂函数（工厂函数无需通过 new 去调用）
import &#123;createApp&#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
createApp(App).mount(&#39;#app&#39;)
//上行代码相当于
//const app = createApp(App) //创建应用实例对象 app，类似于 Vue2 中的 vm，但 app 比 vm 更轻，身上没有那么多函数
//app.mount(&#39;#app&#39;) //挂载</code></pre>
<p>Vue3 组件中的结构可以没有根标签</p>
<h2 id="常用的-Composition-API（组合-API）"><a href="#常用的-Composition-API（组合-API）" class="headerlink" title="常用的 Composition API（组合 API）"></a>常用的 Composition API（组合 API）</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup 是 Vue3 中一个新的配置项，值为一个函数</p>
<p>setup 是所有 Composition API 的“表演舞台”</p>
<p>setup 函数的两种返回值</p>
<pre><code>（1）若返回一个对象，则对象中的属性、方法在模板中共均可直接使用
（2）若返回一个渲染函数，则可以自定义渲染内容</code></pre>
<p>注意：尽量不要与 Vue2 配置混用，Vue2 配置（data、methods、computed…）中可以访问到 setup 中的属性、方法，但 setup 中不能访问 Vue2 配置，如有重名，setup 优先</p>
<p>setup 不能是一个 async 函数，因为若加上 async 后返回值不再是 return 的对象，而是 promise，模板看不到 return 对象中的属性（注意：后期也可以返回一个 Promise 实例，但需要 Suspense 和 异步组件的配合）</p>
<p>例子<br>    <template><br>        <h1></h1><br>        <h1></h1><br>        &lt;button @click=”sayHello”&gt;xxx<br>    </template></p>
<pre><code>//import &#123;h&#125; from &#39;vue&#39; //当 setup 要返回渲染函数时需要引入
export default&#123;
    name:&#39;App&#39;,
    //此处暂时不考虑响应式问题
    setup()&#123;
        let name = &#39;xx&#39;
        let age = 18
        function sayHello()&#123;
            console.log(name,age)
        &#125;
        //返回一个对象
        return &#123;
            name,
            age,
            sayHello
        &#125;
        //也可以返回一个渲染函数
        //return ()=&gt;h(&#39;h1&#39;,&#39;hello&#39;)
    &#125;
&#125;</code></pre>
<p>setup 执行的时机：在 beforeCreate 之前执行一次，this 是 undefined</p>
<p>setup 的参数：</p>
<pre><code>props：值为对象，包含组件外部传递过来且组件内部声明接收了的属性
context：上下文对象
    context.attrs：值为对象，包含组件外部传递过来但没有在 props 配置中声明的属性，相当于 Vue2 中 this.$attrs
    context.slots：收到的插槽内容，相当于 this.$slots
    context.emit：分发自定义事件的函数，需要在触发父组件传来自定义事件的子组件中通过 emits:[&#39;事件名&#39;] 来接收，并通过 context.emit(&#39;事件名&#39;,数据) 来触发，相当于 this.$emit</code></pre>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 函数作用：定义一个<strong>（对象类型/基本类型）响应式的数据</strong></p>
<p>语法：<code>const xxx = ref(初始值)</code>，创建一个包含响应式数据的引用对象（即 reference 对象，简称 ref 对象）</p>
<p>操作数据时：<code>xxx.value</code></p>
<p>模板中读取数据时不需要 .value，直接使用 <code>&#123;&#123;xxx&#125;&#125;</code></p>
<p>接收的数据可以是基本类型，也可以是对象类型</p>
<p>基本类型的数据：响应式依然是靠 Object.defineProperty() 的 get 与 set 完成的</p>
<p>对象类型的数据：内部求助了 Vue3 的新函数 reactive 函数</p>
<pre><code>&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;!--自动读取 value 值--&gt;
&lt;h1&gt;&#123;&#123;age&#125;&#125;&lt;/h1&gt;

import &#123;ref&#125; from &#39;vue&#39;
export default&#123;
    name:&#39;App&#39;,
    setup()&#123;
        let name = ref(&#39;xx&#39;) //ref 返回引用实现（implement）的实例对象（RefImpl），变成响应式（通过 getter 和 setter 实现的响应式），name.value 是 Proxy 类型
        let age = ref(18)
        let job = ref(&#123;//对传入的对象加工后变成 Proxy 类型，这封装在了 reactive 函数中
            type:&#39;前端&#39;,
            salary:&#39;100&#39;
        &#125;)
        function changeInfo()&#123;
            name.value = &#39;xxx&#39;,
            age.value = 20,
            job.value.type = &#39;工程师&#39;
            job.value.salary = &#39;200&#39;
        &#125;
        return &#123;
            name,
            age,
            changeInfo
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="reactive-函数"><a href="#reactive-函数" class="headerlink" title="reactive 函数"></a>reactive 函数</h3><p>作用：定义一个<strong>对象类型的响应式数据</strong>（基本类型别用它，用 ref 函数）</p>
<p>语法：<code>const 代理对象 = reactive(Object源对象)</code> 接收一个对象或数组，返回一个代理器对象（Proxy 的实例对象，简称 proxy 对象）</p>
<p>reactive 定义的响应式数据是深层次的（即对象中可有对象）</p>
<p>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据，这种操作都能被 Vue 捕获到（即数据劫持），都是响应式的</p>
<pre><code>import &#123;ref,reactive&#125; from &#39;vue&#39;
export default&#123;
    name:&#39;App&#39;,
    setup()&#123;
        let name = ref(&#39;xx&#39;)
        let age = ref(18)
        let job = reactive(&#123; //reactive 返回 Proxy 类型数据变成响应式
            type:&#39;前端&#39;,
            salary:&#39;100&#39;
        &#125;)
        function changeInfo()&#123;
            name.value = &#39;xxx&#39;,
            age.value = 20,
            job.type = &#39;工程师&#39; //使用 reactive 就不用 job.value.type 了
            job.salary = &#39;200&#39;
        &#125;
        return &#123;
            name,
            age,
            changeInfo
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="Vue2-的响应式"><a href="#Vue2-的响应式" class="headerlink" title="Vue2 的响应式"></a>Vue2 的响应式</h3><p><strong>实现原理：</strong></p>
<p>— 对象类型：通过 <code>Object.defineProperty()</code> 对属性的读取、修改进行拦截（数据劫持）</p>
<p>— 数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹，如 Vue 中对数组 push 先使用原生 js 的 push 修改数组，然后对页面进行更新）</p>
<pre><code>//Vue2 中实现响应式
Object.defineProperty(person,&#39;name&#39;,&#123;
    get()&#123; 
        configurable:true, //配置后就可以 delete parson.name 来删除 name
        return person.name
    &#125;,
    set(value)&#123;
        person.name = value
    &#125;
&#125;)
Object.defineProperty(person,&#39;age&#39;,&#123;
    get()&#123;
        return person.age
    &#125;,
    set(value)&#123;
        person.age = value
    &#125;
&#125;)
但上面只能读取和修改属性，无法捕获删除和添加属性</code></pre>
<p><strong>存在的问题（这些问题在 Vue3 中不存在）：</strong></p>
<p>— 新增属性、删除属性时界面不会更新，如不能用 <code>对象.新属性 = 值</code> 添加属性，也不能用 <code>delete 对象.属性</code></p>
<p>— 直接通过下标修改数组，界面不会自动更新，如不能用 <code>数组[下标] = 值</code> 修改数组中的元素</p>
<p><strong>解决：</strong></p>
<pre><code>增加属性时
this.$set(要添加属性的对象,&#39;新属性名&#39;,属性值)
//或 Vue.set(要添加属性的对象,&#39;新属性名&#39;,属性值)
删除属性时
this.$delete(要删除属性的对象,&#39;属性名&#39;)
//或 Vue.delete(要删除属性的对象,&#39;属性名&#39;)
修改数组时
this.$set(要修改的数组,下标索引,新值)
//或 Vue.set(要修改的数组,下标索引,新值)
//或 要修改的数组.splice(下标索引,1,新值)</code></pre>
<h3 id="Vue3-的响应式"><a href="#Vue3-的响应式" class="headerlink" title="Vue3 的响应式"></a>Vue3 的响应式</h3><p><strong>实现原理：</strong></p>
<p>— 通过 Proxy（代理）：这是 window 上的内置对象，拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等</p>
<p>— 通过 Reflect（反射）：这是 window 上的内置对象，对被代理对象（即源对象）的属性进行操作</p>
<pre><code>let person = &#123;
    name:&#39;xx&#39;,
    age:18
&#125;
const p = new Proxy(person,&#123;  //让 p 映射 person，对 p 进行操作能被捕获到并更新 person
    //拦截读取属性值
    //读取 p 的某个属性时调用
    get(target,propName)&#123; //第一个参数 target 即源对象 person，第二个参数是属性名
        return Reflect.get(target,propName) //相当于target[propName]
    &#125;,
    //拦截设置属性值或添加新属性
    //修改或添加 p 的某个属性时调用
    set(target,propName,value)&#123;
        Reflect.set(target,propName,value) //相当于target[propName] = value
    &#125;,
    //拦截删除属性
    //删除 p 的某个属性时调用
    deleteProperty(target,propName)&#123;
        return Reflect.deleteProperty(target,propName) //相当于delete target[propName]
    &#125;
&#125;)
p.sex = &#39;女&#39; //给 person 添加 sex 属性</code></pre>
<p>MDN 文档中描述的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 与 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a></p>
<p><strong>Vue3 中的添加、删除、修改对象或数组元素：</strong></p>
<pre><code>let person = reactive(&#123;
    name:&#39;xxx&#39;,
    hobby:[&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;]
&#125;)

person.sex = &#39;女&#39;
delete person.name
person.hobby[0] = &#39;dd&#39;</code></pre>
<p><strong>对比 reactive 与 ref：</strong></p>
<p>（1）从定义数据角度对比</p>
<pre><code>ref 用来定义基本类型数据
reactive 用来定义对象或数组类型数据
ref 也可以用来定义对象或数组类型数据，它内部会自动通过 reactive 转为代理对象（即 Proxy 实例对象）</code></pre>
<p>（2）从原理角度对比</p>
<pre><code>ref 通过 Object.defineProperty() 的 get 与 set 来实现响应式（数据劫持）
reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过 Reflect 操作源对象内部的数据</code></pre>
<p>（3）从使用角度对比</p>
<pre><code>ref 定义的数据：操作数据需要 .value，读取数据时模板中直接读取不需要 .value
reactive 定义的数据：操作数据与读取数据均不需要 .value</code></pre>
<h2 id="计算属性-computed-1"><a href="#计算属性-computed-1" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>Vue3 与 Vue2 中的 computed 配置功能一致</p>
<pre><code>import &#123;reactive,computed&#125; form &#39;vue&#39;
setup()&#123;
    let person = reactive(&#123;
        firstName: &#39;x&#39;,
        lastName: &#39;xx&#39;
    &#125;)
    //计算属性简写————没有考虑计算属性被修改的情况
    /*person.fullName = computed(()=&gt;&#123;
        return person.firstName + &#39;-&#39; + person.lastName
    &#125;)*/
    //计算属性完整版————考虑读和写
    person.fullName = computed(&#123;
        get()&#123;
            return person.firstName + &#39;-&#39; + person.lastName
        &#125;,
        set(value)&#123;
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        &#125;
    &#125;)
    return &#123;
        person
    &#125;
&#125; </code></pre>
<h2 id="数据监视-watch"><a href="#数据监视-watch" class="headerlink" title="数据监视 watch"></a>数据监视 watch</h2><p>Vue3 与 Vue2 中的 watch 配置功能一致</p>
<p>首先要 <code>import &#123;watch&#125; from &#39;vue&#39;</code>，把 <code>watch(...)</code> 写在 setup 里</p>
<p>情况一：监视 ref 定义的一个响应式数据</p>
<pre><code>watch(sum,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true&#125;)</code></pre>
<p>情况二：监视多个 ref 定义的响应式数据</p>
<pre><code>watch([sum,msg],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum 或 msg，newValue,oldValue 是数组，包含了 sum 和 msg 的值&#39;,newValue,oldValue)
&#125;,&#123;immediate:true&#125;)</code></pre>
<p>情况三：监视 ref 定义的对象类型的响应式数据</p>
<p>对象类型一般通过 reactive 定义，但若使用 ref 定义，则需使用如下两种方式的一种进行监视</p>
<pre><code>watch(person.value,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;)  //通过 person.value 获取到的是 Proxy 类型的对象，而 Proxy 类型对象通过 reactive 生成，所以此时相当于监视一个 reactive 定义的响应式数据 person.value

watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;)</code></pre>
<p>情况三：监视 reactive 定义的响应式数据</p>
<p>若 watch 监视的是 reactive 定义的响应式数据，则无法正确获得 oldValue，并且会强制开启深度监视（即对象中嵌套的对象中属性改变也能监测到）</p>
<pre><code>watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:false&#125;) //此处的 deep 配置不再奏效</code></pre>
<p>情况四：监视 reactive 定义的响应式数据中的某个属性</p>
<pre><code>watch(()=&gt;person.age,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true&#125;) //此处能拿到 oldValue

watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;) //此处由于监视的是 reactive 定义的对象中的属性，所以 deep 配置有效，并且此处无法拿到 oldValue，因为 job 也是 reactive 定义的</code></pre>
<p>情况五：监视 reactive 定义的响应式数据中的某些属性</p>
<pre><code>watch([()=&gt;person.name,()=&gt;person.age,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;)</code></pre>
<p>注意：监视 reactive 定义的响应式数据时，oldValue 无法正确获取，并强制开启了深度监视（deep 配置失效）</p>
<p>监视 reactive 定义的响应式数据中某个属性时 deep 配置有效，但是只有属性依然是 reactive 定义的时配置 deep 才有意义，当监视的是基本数据时无需配置 deep</p>
<h2 id="watchEffect-函数"><a href="#watchEffect-函数" class="headerlink" title="watchEffect 函数"></a>watchEffect 函数</h2><p>watch 的套路是既要指明监视的属性，也要指明监视的回调</p>
<p>watchEffect 的套路是不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</p>
<p>watchEffect 有点类似于 computed，但 computed 注重的是计算出来的值（回调函数的返回值），所以必须要写返回值；而 watchEffect 更注重过程（回调函数的函数体），所以不再写返回值</p>
<p>首先要 <code>import &#123;watchEffect&#125; from &#39;vue&#39;</code>，把 <code>watchEffect(...)</code> 写在 setup 里</p>
<pre><code>//watchEffect 所指定的回调中用到的数据只要发生变化，则直接重新执行回调
watchEffect(()=&gt;&#123;
    const x1 = sum.value //监视 sum
    const x2 = person.age //监视 person.age
&#125;)</code></pre>
<h2 id="Vue3-生命周期"><a href="#Vue3-生命周期" class="headerlink" title="Vue3 生命周期"></a>Vue3 生命周期</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="Vue3生命周期"></p>
<p>Vue3 中可继续使用 Vue2 中的生命周期钩子，但有两个被更名：<br>    beforeDestory 改名为 beforeUnmount<br>    destroyed 改名为 unmounted</p>
<p>Vue3 也提供了 Composition API 形式的生命周期钩子（注意用之前需要 import 引入），与 Vue2 中钩子的对应关系如下</p>
<pre><code>beforeCreate ===&gt; setup() 若通过配置项写 beforeCreate，则 setup 在 beforeCreate 之前执行，但若要用组合 API 的形式（即放到 setup 中），则 beforeCreate 被 setup 代替，无需写 beforeCreate
created ===&gt; setup() //即 setup 相当于 created
beforeMount ===&gt; onBeforeMount
mounted ===&gt; onMounted
beforeUpdate ===&gt; onBeforeUpdate
updated ===&gt; onUpdated
beforeUnmount ===&gt; onBeforeUnmount
unmounted ===&gt; onUnmounted</code></pre>
<p>这些组合 API 在 setup 中使用，并且需要传入一个回调函数，如</p>
<pre><code>import &#123;onBeforeMount&#125; from &#39;vue&#39;

setup()&#123;
    onBeforeMount(()=&gt;&#123;&#125;)
&#125;</code></pre>
<p>若既写配置项中的生命周期也用组合式 API 的生命周期，则对应同一时期的钩子组合式 API 比配置项中的先执行</p>
<h2 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h2><p>hook 本质是一个函数，对 setup 函数中使用的 Composition API 进行了封装，类似于 Vue2 中的 mixin</p>
<p>自定义 hook 的优势：复用代码，让 setup 中的逻辑更清除易懂</p>
<p>新建 src/hooks/useXxx.js</p>
<pre><code>import &#123;reactive,onMounted,beforeUnmount&#125;
export default function()&#123;
    let xxx = ref(..)
    let xxxx = reactive(...)
    function xxxxx()&#123;...&#125;
    //生命周期钩子，如
    onMounted(()=&gt;&#123;...&#125;)
    beforeUnmount(()=&gt;&#123;...&#125;)
    return xxx
&#125;</code></pre>
<p>在组件中只需引入就可以复用该功能</p>
<pre><code>import useXxx from &#39;../hooks/useXxx&#39;
然后可直接使用 useXxx</code></pre>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><p>作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性值</p>
<p>语法：</p>
<pre><code>import toRef from &#39;vue&#39;
const name = toRef(person,&#39;name&#39;) //此时若修改 person 中的 name 属性，则变量 name 的值也跟着变；若是直接赋值 const name = persom.name 则当 person.name 修改时变量 name 不变</code></pre>
<p>应用：要将响应式对象中的某个属性单独提供给外部使用时</p>
<p>扩展：toRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法 <code>toRefs(person)</code></p>
<p>当暴露数据时</p>
<pre><code>&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;

setup()&#123;
    retun &#123;
        person,
        name:toRef(person,&#39;name&#39;), //把 person 里常用的一些属性单独暴露出来方便使用
        age:toRef(person,&#39;age&#39;),
        salary:toRef(person.job,&#39;salary&#39;)
        //上述代码也可用 toRefs 替代，批量暴露
        //...toRefs(person)
    &#125;
&#125;</code></pre>
<h2 id="其他-Composition-API"><a href="#其他-Composition-API" class="headerlink" title="其他 Composition API"></a>其他 Composition API</h2><h3 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h3><p>shallowReactive 只处理对象最外层属性的响应式（浅响应式），而 reactive 可处理深层次的对象</p>
<p>shallowRef 只处理基本数据类型的响应式，不进行对象的响应式处理，若传入对象，则 value 是 Object 类型，不是 Proxy 类型，而 Ref 可处理基本数据类型或对象</p>
<p>使用场景：</p>
<pre><code>若有一个对象数据，结构比较深，但变化时只是外层属性变化 ===&gt; shallowReactive
若有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===&gt; shallowRef</code></pre>
<h3 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h3><p>readonly 让一个响应式数据变为只读的（深只读）</p>
<p>shallowReadonly 让一个响应式数据变为只读的（浅只读，即只有对象的第一层数据不能改，但对象中的对象的属性可改）</p>
<p>应用场景：不希望数据被修改时</p>
<pre><code>import &#123;ref,reactive,readonly,shallowReadonly&#125; from &#39;vue&#39;
let sum = ref(0)
let person = reactive(&#123;...&#125;)
person = readonly(person)
sum = readonly(sum)
//person = shallowReadonly(person)</code></pre>
<h3 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h3><p><strong>toRaw：</strong></p>
<p>作用：将一个由 reactive 生成的响应式对象转为普通对象，不能转 ref 定义的基本数据类型，否则会返回 undefined</p>
<p>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作不会引起页面更新</p>
<pre><code>import &#123;toRaw&#125; from &#39;vue&#39;

const p = toRaw(person)</code></pre>
<p><strong>markRaw：</strong></p>
<p>作用：标记一个对象，使其永远不会再成为响应式对象</p>
<p>应用场景：</p>
<pre><code>（1）有些值不应该被设置为响应式的，例如复杂的第三方类库等
（2）当渲染具有不可变数据源的大列表时，跳过响应式转换可提高性能</code></pre>
<p>如</p>
<pre><code>import &#123;markRaw&#125; from &#39;vue&#39;
let car = &#123;name:&#39;xx&#39;,price:50&#125;
person.car = markRaw(car) //若直接追加属性 person.car 为 car 对象，则改属性自动为响应式，若无需响应式则加上 markRaw</code></pre>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</p>
<p>customRef 中需传入一个回调函数，且回调函数必须返回一个对象</p>
<p>实现防抖效果：</p>
<pre><code>import &#123;customRef&#125; from &#39;vue&#39;

setup()&#123;
    ler keyWord = myRef(&#39;hello&#39;,1000)
    function myRef(value,delay)&#123;
        let timer,
        return customRef((track,trigger)=&gt;&#123;
            return &#123;
                get()&#123; //当从 myRef 容器中读取数据时调用
                    track() //通知 Vue 追踪 value 的变化
                    return value
                &#125;,
                set(newValue)&#123;  //当修改 myRef 容器中的数据时调用
                    clearTimeout(timer)
                    timer = setTimeout(()=&gt;&#123;
                        value = newValue
                        trigger() //通知 Vue 去重新解析模板，这样会再次 get 获得值
                    &#125;,delay)

                &#125;
            &#125;
        &#125;)
    &#125;
&#125;</code></pre>
<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><p>作用：实现祖与后代组件间通信</p>
<p>套路：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据</p>
<p>祖组件中</p>
<pre><code>import &#123;reactive,toRefs,provide&#125; from &#39;vue&#39;
setup()&#123;
    ...
    let car = reactive(&#123;name:&#39;xx&#39;,price:50&#125;)
    provide(&#39;car&#39;,car)
    ...
    return &#123;...toRefs(car)&#125;
&#125;</code></pre>
<p>后代组件中</p>
<pre><code>import &#123;inject&#125; from &#39;vue&#39;
setup(props,context)&#123;
    ...
    const car = inject(&#39;car&#39;)
    return &#123;car&#125;
&#125;</code></pre>
<h3 id="响应式数据的判断-API"><a href="#响应式数据的判断-API" class="headerlink" title="响应式数据的判断 API"></a>响应式数据的判断 API</h3><p>isRef：检查一个值是否为一个 ref 对象</p>
<p>isReactive：检查一个对象是否是由 reactive 创建的响应式代理</p>
<p>isReadonly：检查一个对象是否是由 readonly 创建的只读代理</p>
<p>isProxy：检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</p>
<h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p><strong>Options API （Vue2 中所使用的方式）存在的问题：</strong></p>
<p>使用传统 Options API 中，新增或者修改一个需求，就需要分别在 data、methods、computed 里修改</p>
<p><strong>Composition API 的优势：</strong></p>
<p>利用组合式 API 可以更加优雅的组织我们的代码、函数，让相关功能的代码更加有序的组织在一起（结合 hooks）</p>
<h2 id="新组件"><a href="#新组件" class="headerlink" title="新组件"></a>新组件</h2><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>在 Vue2 中组件必须有一个根标签</p>
<p>在 Vue3 中组件可以没有根标签，内部会自动将多个标签包含在一个 Fragment 虚拟元素中</p>
<p>好处：减少标签层级，减小内存占用</p>
<h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Teleport 是一种能够将组件 html 结构移动到指定位置的技术</p>
<pre><code>&lt;Teleport to=&quot;内部要显示在的标签如 html、body、#id 等&quot;&gt;
    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
        &lt;div class=&quot;dialog&quot;&gt;
            &lt;h3&gt;一个弹窗&lt;/h3&gt;
            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/Teleport&gt;</code></pre>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
<p>若使用普通 import 静态引入组件则若子孙组件未加载完成则祖组件也都不会渲染，直到内部组件加载完成后一起渲染</p>
<p>而动态/异步引入则当内部组件未加载完成时可先渲染外部组件</p>
<p>使用步骤：</p>
<p>（1）异步引入组件</p>
<pre><code>import &#123;defineAsyncComponent&#125; from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;)) //动态/异步引入组件</code></pre>
<p>（2）使用 Suspense 包裹组件，并配置好 default 与 fallback</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;xxx&lt;/h1&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt; &lt;!--真正要展示的内容--&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt; &lt;!--当真正要展示的内容加载不出来时显示--&gt;
                &lt;h1&gt;加载中...&lt;/h1&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;    
    &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>注意：当使用了 Suspense 和异步引入后 setup 返回值就可以是一个 Promise 对象</p>
<p>在异步引入的组件中</p>
<pre><code>async setup()&#123;
    let p = new Promise((resolve,reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#123;sum&#125;)
        &#125;,1000)
    &#125;)
    return await p
&#125;</code></pre>
<h2 id="全局-API-的转移"><a href="#全局-API-的转移" class="headerlink" title="全局 API 的转移"></a>全局 API 的转移</h2><p>Vue2 有许多全局 API 和配置，如：注册全局组件、注册全局指令等</p>
<pre><code>//注册全局组件
Vue.component(&#39;xx&#39;,&#123;
    data:()=&gt;(&#123;
        count:0
    &#125;),
    template:&#39;&lt;button @click=&quot;count++&quot;&gt;xx&lt;/button&gt;&#39;
&#125;)
//注册全局指令
Vue.directive(&#39;focus&#39;,&#123;
    inserted:el =&gt; el.focus()
&#125;)</code></pre>
<p>Vue3 中对这些 API 做出了调整，将全局 API，即 Vue.xxx 调整到应用实例（即 createApp 生成的 app）上</p>
<table>
<thead>
<tr>
<th>Vue2 全局 API（在 Vue 上）</th>
<th>Vue3 实例 API（在 app 上）</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxx</td>
<td>app.config.xxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
<p>其他改变：</p>
<p>data 选项应是始终被声明为一个函数</p>
<p>过度类名的更改</p>
<pre><code>Vue2 写法
.v-enter,.v-leave-to&#123;
    opacity:0;
&#125;
.v-leave,.v-enter-to&#123;
    opacity:1;
&#125;

Vue3 写法
.v-enter-from,.v-leave-to&#123;
    opacity:0;
&#125;
.v-leave-from,.v-enter-to&#123;
    opacity:1;
&#125;</code></pre>
<p>移除 keyCode 作为 v-on 的修饰符，同时不再支持 config.keyCodes</p>
<pre><code>Vue2 中
@keyup.13 标识按下回车
Vue.config.keyCodes.huiche = 13 //定义别名按键</code></pre>
<p>移除 v-on.native 修饰符</p>
<pre><code>父组件中绑定事件
&lt;子组件 v-on:close=&quot;函数&quot; v-on:click=&quot;函数&quot;/&gt;

子组件中声明自定义事件
export default&#123;
    emits:[&#39;close&#39;] //此处没声明 click则父组件中给子组件绑定的 click 为原生事件
&#125;</code></pre>
<p>移除过滤器：过滤器需要一个自定义语法，打破大括号内表达式是“只是 JavaScript” 的假设，有学习成本和实现成本，建议用方法调用或计算属性替换过滤器</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="js-表达式和-js-代码-语句"><a href="#js-表达式和-js-代码-语句" class="headerlink" title="js 表达式和 js 代码/语句"></a>js 表达式和 js 代码/语句</h2><p>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如</p>
<pre><code>a
a+b
demo(1)
x === y ? &#39;a&#39; : &#39;b&#39;</code></pre>
<p>代码/语句，如</p>
<pre><code>if(...)&#123;...&#125;
for(...)&#123;...&#125;</code></pre>
<p>表达式是一种特殊的语句</p>
<h2 id="vscode-中-vue-相关插件"><a href="#vscode-中-vue-相关插件" class="headerlink" title="vscode 中 vue 相关插件"></a>vscode 中 vue 相关插件</h2><p>Vue 3 Snippets 会提示代码</p>
<p>Vetur 对符合 Vue 的代码有高亮</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cookie%E5%9B%BE%E7%A4%BA.png" alt="cookie图示"></p>
<p>在设置 cookie 时重要的 cookie 要设置 HttpOnly，这样就不能通过 document.cookie 获取</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>注意使用 v-model 绑定的值不能是 props 传来的值，因为 props 是不可以修改的</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props 传来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做，因为 Vue 主要监视的是对象值的地址是否发生变化 </p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>$nextTick 的回调会在 DOM 更新后再执行</p>
<pre><code>this.$nextTick(function()&#123;...&#125;)</code></pre>
<p>作用：$nextTick 在下一次 DOM 更新结束后执行其指定的回调</p>
<p>适用场景：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 $nextTick 所指定的回调函数中执行</p>
<p>如原本 xxx DOM 元素的 v-show 为 false，即不在页面上显示，在某函数中将 v-show 改为 true 并获取该 DOM 元素焦点，但是 Vue 会在函数执行完后才会重新解析模板重新渲染，所以函数中对 DOM 元素获取焦点的操作无效，因为那时页面中并没有相应 DOM 元素，因此可以借助 $nextTick 的回调使得当 v-show 改为 true 页面重新渲染， DOM 元素出现在页面中后再执行对它获取焦点的操作</p>
<p>当然 $nextTick 也可以通过利用不指定时间定时器来代替该函数</p>
<pre><code>setTimeout(()=&gt;&#123;...&#125;)</code></pre>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>插值语法中可以展示 data、props、computed 中的数据</p>
<p>Vue3 + TS 相关笔记可参考<a target="_blank" rel="noopener" href="https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html">尚硅谷的课程笔记</a></p>
<p>Vue 中数据代理、数据劫持、计算属性的原理都用到 Object.defineproperty</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="React学习笔记">
                  <i class="fa fa-chevron-left"></i> React学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/14/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Promise学习笔记">
                  Promise学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
