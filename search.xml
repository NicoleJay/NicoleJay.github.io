<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++学习笔记</title>
    <url>/2021/10/04/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>面向对象编程（OOP）本质是设计并扩展自己的数据类型</p>
<a id="more"></a>

<p>C++对大小写敏感</p>
<p>在C++程序中包含C语言，只需加入头文件<code>&lt;stdio.h&gt;</code></p>
<p><code>#include</code> 预处理器编译指令</p>
<p><code>using namespace xxx</code> 编译指令</p>
<p><code>main()</code> 由启动代码调用，启动代码链接程序与操作系统由编译器添加到程序中</p>
<p>独立的C++程序必须由 <code>main()</code> 函数，运行时通常从 <code>main()</code> 函数开始执行</p>
<p>C中的头文件以.h为扩展名，而在C++中省去扩展名，并使用名称空间</p>
<p>名称空间是为了当组合多个程序时，多个程序中包含相同函数名的函数时，使编译器辨别所使用的函数来自哪个程序。</p>
<p>当使用 <code>#include&lt;iostream&gt;</code> 时，cin、cout、endl等都在std名称空间中，应使用如std::cout来表示</p>
<p>使用 <code>#include&lt;iostream.h&gt;</code> 与 cout 等价于 使用 <code>#include&lt;iostream&gt;</code> 与 std::cout</p>
<p>为了简化编程，可使用using编译指令 <code>using namespace std</code> 来允许程序使用std名称空间中的所有名称，若该 using 编译指令放在函数中则作用范围为相应函数，也可放在多个函数外且在函数前，则多个函数均可使用该名称空间中的对象。但对于大型程序，仅在使用时加上名称空间更好</p>
<p>cin 和 cout 分别时 istream 和 ostream 类的对象，通过重新定义插入运算符 &gt;&gt; 和 &lt;&lt; 将字符插入输入流或输出流中</p>
<p><strong>函数原型与函数定义</strong></p>
<p>函数原型：函数接口</p>
<p>函数定义：包括函数头、函数体等，即函数的具体执行流程</p>
<p>C++程序中使用的每个函数都需要有原型，如 <code>double sqrt(double);</code> （注意分号），原型可以在程序中给出，也可以在头文件中给出并在程序中包含头文件。若在 main 函数中使用用户自定义函数，应把函数原型放在 main 函数之前，可将自定义函数的源码放在 main 之后。C++不能在一个函数定义嵌套在另一个函数定义中</p>
<p>main函数的返回 <code>return 0</code> 是返回给操作系统</p>
<p><strong>函数特性：</strong>函数头和函数体+参数+返回值+原型</p>
<p>C++中整型包括short、int、long、long long（与C不同之处），这些整型都是有符号的</p>
<p><climits>或&lt;limits.h&gt;文件中定义了一些符号常量，如CHAR_BIT（字节的位数）</climits></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客</title>
    <url>/2021/08/05/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>进入hexo安装的根目录</p>
<a id="more"></a>

<p><strong>新建博客：</strong><code>hexo n “博客名字”</code></p>
<p><strong>本地查看：</strong><code>hexo s</code></p>
<p><strong>清除缓存：</strong><code>hexo clean</code></p>
<p><strong>博客生成：</strong><code>hexo g</code></p>
<p><strong>部署到github：</strong><code>hexo d</code></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2021/11/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="廖雪峰的-JavaScript-教程笔记"><a href="#廖雪峰的-JavaScript-教程笔记" class="headerlink" title="廖雪峰的 JavaScript 教程笔记"></a>廖雪峰的 JavaScript 教程笔记</h1><a id="more"></a>

<h2 id="一些背景知识"><a href="#一些背景知识" class="headerlink" title="一些背景知识"></a>一些背景知识</h2><p>只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互</p>
<p>Node.js把JavaScript引入到了服务器端</p>
<p>JavaScript（对ECMAScript标准的一种实现）又称ECMAScript（一种语言标准）、ES6（ECMAScript 6）、ES2015（ECMAScript 2015）</p>
<p>Babel 是 JavaScript 转译器（也称源代码编译器），将使用了 ECMAScript 语言特性的 JavaScript 转换为只使用广泛支持的 ES5（ECMAScript 2009） 特性的等价代码。如Node.js使用的是 CommonJS 模块的 require 语法，之前不支持 import（不支持原生的ES6模块），则要用 babel 转译 js 模块为 CommonJS 模块</p>
<p>Webpack、Browserify 等打包工具主要是将 ES6 代码转译为 ES5 的 js 文件生成传统的代码包</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1、原始数据类型：数、字符串、布尔值、Symbol（ES6）、null、undefined</p>
<p>2、派生数据类型：对象（如：函数、数组、正则表达式）</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript严格区分大小写</p>
<p>JavaScript不区分整数和浮点数，统一用Number表示</p>
<p><strong>== 和 === 的区别</strong>：== 会自动转换数据类型再比较，有时会得到奇怪的结果；=== 不会自动转换数据类型，若数据类型不一致，返回false，若一致，再比较。（JavaScript的设计缺陷，一般使用 === ）</p>
<p>在 == 比较中，遇到比较的一方有数，则全部自动 toNumber(x) 转为数后比较，其中 toNumber(包含字母字符串) -&gt; NaN，toNumber(undefined) -&gt; NaN，toNumber(null) -&gt; +0；</p>
<p>若比较的一方中有布尔值，则布尔值先被 toNumber(x) 转为数；</p>
<p>若比较的一方中有对象，则对象会被 toPrimitive(x) 转为字符串或数</p>
<p>在 === 比较中，类型相同则正常比较（除 NaN 外），类型不同则为 false，不同对象比较也为 false</p>
<pre><code>//判断是否为NaN
NaN === NaN; // false
isNaN(NaN); // true（唯一判断NaN的方法）

null == undefined; //true

//浮点数比较
1 / 3 === (1 - 2 / 3); // false（因为计算机无法精确表示无限循环小数，浮点数运算时会产生误差）
Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true（只能计算浮点数之差的绝对值是否小于某阈值来比较两浮点数是否相等）</code></pre>
<p><strong>null 和 undefined：</strong>null 为空值，undefined 为未定义，一般用 null，undefined 仅在判断函数参数是否传递的情况下有用</p>
<p>JavaScript的一个数组中可以包含多种类型</p>
<p>JavaScript是变量本身类型不固定的动态语言，而静态语言（强类型语言）在定义变量时必须指定变量类型，如Java</p>
<p><strong>变量是否用 var 声明：</strong>通过 var 声明的变量作用域为该变量被申明的函数体内。如果一个变量没有通过 var 申明就被使用，则该变量自动被申明为全局变量，这导致不同js文件中未通过 var 声明的同名变量间会相互影响（JavaScript设计缺陷）————解决：在代码第一行写上 <code>&#39;use strict&#39;;</code> 启用strict模式,在strict模式下运行的JavaScript代码，强制通过 var 声明变量，使用未通过 var 声明的变量会报错</p>
<p><strong>let 和 var：</strong>在同一作用域内重复声明变量，let会报错，var不会报错</p>
<p><strong>const：</strong>const声明的变量是只读变量，若对 const 声明的变量重新用 let 或 var 声明会报错。且对于非对象类型（如数、布尔值、字符串）不可改变其值，但对于 const 声明的对象可改变其属性值，但不可对对象整体重新赋值（即变量本身的引用（内存中的引用地址）不可改）。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>引号：</strong>字符串中包含单引号、双引号前面加转义符 <code>\</code> ，多行字符串用用 <code>\n</code> 表示（较早）或用反引号 `` （ES6）</p>
<p><strong>模板字符串：</strong>用反引号括起来，其中用 <code>$&#123;变量名&#125;</code> 来表示相应值（ES6）</p>
<p><strong>索引：</strong>字符串可以像数组一样通过索引取值，但不可通过索引赋值</p>
<p><strong>部分方法：（调用时不改变原字符串，而是返回一新字符串）</strong></p>
<pre><code>toUpperCase()     //变大写，str.toUpperCase()
toLowerCase()     //变小写，str.toLowerCase()
indexOf()     //搜索指定字符串出现的位置，空格也占一位置，str.indexOf(&#39;xxx&#39;);
substring(开始索引，结束索引) 或 substring(开始索引)     //返回指定索引区间的子串，左闭右开，str.substring(0, 5);</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>长度：</strong><code>数组.length</code>，给 length 属性赋值会改变原数组大小，并且若通过数组索引赋值时索引超出原大小也会改变数组大小</p>
<p><strong>部分方法：</strong></p>
<pre><code>indexOf()     //搜索指定的元素的位置，arr.indexOf(xxx)
slice() 或 slice(开始索引，结束索引)     //返回指定索引区间元素，左闭右开，返回一个新数组，若无参则包含所有元素（可用于复制数组）
push(元素1,元素2,...)     //在末尾添加元素，可加多个
pop()     //返回并删除末尾元素，空数组 pop 不报错，返回 undefined
unshift(元素1,元素2,...)     //在头部添加元素，可加多个
shift()     //返回并删除头部元素
sort()     //排序，直接改变原数组，arr.sort()
reverse()     //倒序，直接改变原数组，arr.reverse()
splice(删除和添加的开始索引, 删除个数, 添加元素1, 添加元素2, ...)     //删除和添加元素
concat()     //连接数组，返回新数组，arr1.concat(arr2)
join(用于连接的字符)     //数组连成字符串</code></pre>
<p><strong>展开运算符：</strong>在ES5中可用 <code>apply()</code> 把数组转为参数，ES6中可直接用 <code>...数组名</code></p>
<p>JavaScript 中数组是可修改对象，若添加元素，它就会动态增长</p>
<p>JavaScript 只支持一维数组，不支持矩阵，可通过数组嵌套数组来实现矩阵</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>ES5创建</p>
<pre><code>function 类名(变量1,...,变量n)&#123;
    this.属性1=变量1
    this.属性n=变量n
&#125;
类名.prototype.方法名 = function()&#123;xxxxx&#125;</code></pre>
<p>ES6创建</p>
<pre><code>class 类名&#123;
    constructor(变量1,...,变量n)&#123;
        this.属性1=变量1
        this.属性n=变量n
    &#125;
    方法名()&#123;xxxxx&#125;
&#125;</code></pre>
<p>继承</p>
<pre><code>class 子类名 extends 父类 &#123;
    constructor(变量1,...,变量n)&#123;
        super(变量1,...,变量n-1)  //调用父类构造函数
        this.属性n=变量n
    &#125;
    方法名()&#123;xxxxx&#125;
&#125;</code></pre>
<p>js 的面向对象编程还是基于原型实现的，ES6的类是基于原型语法的语法糖</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是类的实例</p>
<p>特殊属性名声明时用 <code>&#39;&#39;</code> 括起来，访问它时不用 <code>对象.属性</code>，而用 <code>对象[&#39;属性&#39;]</code></p>
<p>访问不存在的属性返回 undefined</p>
<p>删除属性 <code>delete 对象.属性</code> 或 ``</p>
<h2 id="真假值"><a href="#真假值" class="headerlink" title="真假值"></a>真假值</h2><p>null、undefined、false、+0、-0、NaN、空字符串、不存在的对象属性为假，其余正常变量（如：1、-1）或对象（如：new String(‘’)、new Boolean(false)）为真</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>箭头函数可省略关键字 function，若函数体只有一行还可省略 {} 和 return（ES6）</p>
<p>函数的参数可设置默认值（ES6）</p>
<p>函数中有一个内置对象 <code>arguments</code>（数组），包含函数被调用时传入的参数</p>
<p>可用展开运算符代替 arguments 来表示剩余参数，如 <code>function a(x,y,...剩余参数整体的名字)</code></p>
<h2 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h2><p>1、用 let 和 const 声明变量替代 var，作用域行为</p>
<p>2、模板字面量</p>
<p>3、解构：（1）一次初始化多个变量 <code>let &#123;x,y&#125;=&#123;&#39;a&#39;,&#39;b&#39;&#125;</code>（2）互换值 <code>[x,y]=[y,x]</code>（3）属性简写（给属性同名变量赋值后即可表示对象）</p>
<p>4、展开运算符：（1）数组展开（2）表示剩余函数参数</p>
<p>5、箭头函数</p>
<p>6、函数可设置参数默认值</p>
<p>7、类</p>
<p>8、模块：使用 <code>export &#123;函数1，变量1，函数n&#125;</code> 导出，<code>import &#123;函数1，变量1，函数n&#125; from 文件</code> 导入</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>1、相比于放在 <head> 标签里或使用 include 语句，在关闭 </head><body> 标签前引入 js 代码使得浏览器在加载脚本前解析和显示 HTML，有利于提升页面性能</body></p>
<p>2、在类中声明函数时，可使用 prototype 方法来节约内存和降低实例化的开销。因为在类中声明函数时若通过 <code>类.prototype.方法 = function () &#123;xxxxx&#125;</code> 则函数只会被创建一次并在所有实例中共享；而通过在类定义里声明函数，则每个实例都会创建一个函数副本</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 是开源的、渐进式包含类型的 JavaScript 超集，它为 JavaScript 变量提供类型支持，TypeScript 会被编译为简单的 JavaScript 代码。虽然 TypeScript 在编译时会进行类型和错误检查，但错误不会阻止编译器生成 JavaScript 代码</p>
<p><strong>定义变量</strong></p>
<pre><code>let a: tring = &#39;x&#39;
let a: number = 10
let a: boolean</code></pre>
<p><strong>接口</strong></p>
<p>第一种：自定义一种数据类型</p>
<p>第二种：与面向对象编程相关</p>
<pre><code>interface 接口 &#123;
    函数1(参数): 类型
&#125;
class 类 implements 接口 &#123;
    变量: 类型
    函数1(参数): 类型&#123;xxx&#125;
&#125;</code></pre>
<p><strong>泛型</strong>：指定函数的参数类型</p>
<pre><code>interface 接口 &lt;参数类型&gt; &#123;
    函数1(参数): 类型
&#125;
class 类 implements 接口 &#123;
    变量: 类型
    函数1(参数:参数类型): 类型&#123;xxx&#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL数据库的安装和配置</title>
    <url>/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="下载MySQL安装包"><a href="#下载MySQL安装包" class="headerlink" title="下载MySQL安装包"></a>下载MySQL安装包</h1><p>进入<a href="https://dev.mysql.com/downloads/">官网</a>，选择 <code>MySQL Community Server</code>，再选择下载.zip压缩包。若选择下载 <code>MYSQL Installer for Windows</code> 则是得到一个.msi文件</p>
<a id="more"></a>

<p>点击 <code>No thanks, just start my download.</code> 开始下载，下载完成后解压zip压缩包</p>
<p>将解压后 bin 文件夹所在的路径添加到电脑环境变量的系统变量中</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/systemvariable.png" alt="添加系统变量"></p>
<h1 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h1><p>在解压后的 <code>mysql-5.7.26-winx64</code> 文件夹中新建 <code>my.ini</code> 文件，文件中贴入如下代码</p>
<pre><code>[client]
port=3306
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld] 
#设置3306端口 
port = 3306 
# 设置mysql的安装目录 
basedir=D:\MySQL\mysql-5.7.26-winx64
# 设置mysql数据库的数据的存放目录 
datadir=D:\MySQL\mysql-5.7.26-winx64\data
# 允许最大连接数 
max_connections=200 
# 服务端使用的字符集默认为8比特编码的latin1字符集 
character-set-server=utf8 
# 创建新表时将使用的默认存储引擎 
default-storage-engine=INNODB</code></pre>
<p><strong>初始化配置：</strong>使用命令 <code>mysqld --initialize --console</code> 初始化 mysql ，此时会根据配置生成 mysql 数据库的数据的存放目录</p>
<p><strong>安装mysql：</strong>使用命令 <code>mysqld -install</code> 安装 mysql</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p><strong>以管理员身份运行</strong></p>
<p><strong>启动 mysql 服务器：</strong><code>net start mysql</code></p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/startmysql.png" alt="启动 mysql 服务器"></p>
<p><strong>登录 mysql 服务器：</strong>在安装 mysql 的 bin 目录下输入 <code>mysql -u root -p</code> 回车并输入密码（其中root是指用户名，可以是其他用户名，-p是指使用密码）</p>
<p><strong>停止 mysql 服务：</strong><code>net stop mysql</code></p>
<p><strong>忘记或修改密码：</strong></p>
<p>首先输入 <code>mysql -u root</code> 不使用密码登录 mysql</p>
<p>输入 <code>set password for 用户名@localhost = password(&#39;新密码&#39;);</code> 修改密码</p>
<p>输入 <code>exit</code> 或 <code>quit</code> 退出 mysql</p>
<p>使用 <code>mysql -u root -p</code> 回车并输入密码重新登录 mysql 即可</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/resetpwd.png" alt="修改密码"></p>
<h1 id="MySQL可视化工具"><a href="#MySQL可视化工具" class="headerlink" title="MySQL可视化工具"></a>MySQL可视化工具</h1><p>可以使用 <strong>Navicat for MySQL</strong> 作为 MySQL 的可视化工具</p>
<p>点击 <code>连接</code> ，或 <code>文件-&gt;新建连接</code> ，取个连接名，输入密码后点击连接测试，弹出连接成功字样然后点击确定即可</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/connect.png" alt="Navicat连接"></p>
<p>一个连接下可以添加多个数据库，双击数据库即可看到数据库下的表，如下图所示，这里是之前已添加过多个数据库</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/db.png" alt="Navicat可视化"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>PC端Chrome调试安卓手机WebView</title>
    <url>/2021/09/15/PC%E7%AB%AFChrome%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAWebView/</url>
    <content><![CDATA[<h1 id="安卓手机端："><a href="#安卓手机端：" class="headerlink" title="安卓手机端："></a>安卓手机端：</h1><p>1、进入开发者模式</p>
<a id="more"></a>

<p>不同手机进入开发者模式的方式不同，以华为手机为例，设置-&gt;点击“关于本机”-&gt;多次连续点击版本号</p>
<p>2、允许USB调试</p>
<p>以华为手机为例，设置-&gt;“系统”-&gt;“开发者选项”-&gt;打开允许USB调试</p>
<p>3、连接电脑</p>
<p>通过数据线将手机连接电脑，在弹出的窗口中选择“传输文件”或“传输照片”模式</p>
<h1 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h1><p>在Chrome浏览器中输入chrome://inspect/#devices可查看当前连接的设备以及在手机端访问的网页，点击“inspect”即可对该网页进行调试</p>
<p><img src="/2021/09/15/PC%E7%AB%AFChrome%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAWebView/inspect.png" alt="inspect"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3+Django+MySQL搭建项目</title>
    <url>/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="一、创建Django项目"><a href="#一、创建Django项目" class="headerlink" title="一、创建Django项目"></a>一、创建Django项目</h1><a id="more"></a>

<h2 id="1-1-安装Django"><a href="#1-1-安装Django" class="headerlink" title="1.1 安装Django"></a>1.1 安装Django</h2><p>在 pycharm 中新建一个项目，确保该项目所使用的 python 解释器已安装 django。若没有则安装 django</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/installdjango.png" alt="installdjango"></p>
<p>若没有使用 IDE 可以通过 <code>pip install django</code> 进行安装</p>
<p>在终端输入 <code>django-admin</code>，出现如下输出则安装成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/django-admin.png" alt="django-admin"></p>
<h2 id="1-2-创建Django项目"><a href="#1-2-创建Django项目" class="headerlink" title="1.2 创建Django项目"></a>1.2 创建Django项目</h2><p>选择一个文件夹位置作为根目录，创建一个新项目 <code>django-admin startproject 项目名</code><br>会生成如下目录结构</p>
<pre><code>-根目录
 --django项目
  ---django项目同名文件夹
  ---manage.py</code></pre>
<p>这里我把 项目同名文件夹 和 manage.py 都移到根目录下，这一步不是必须的，看个人习惯。新的目录结构如下</p>
<pre><code>-根目录
 --django项目
 --manage.py</code></pre>
<p><strong>提示：下面的所有操作是基于新目录结构下的操作</strong></p>
<h2 id="1-3-启动Django项目"><a href="#1-3-启动Django项目" class="headerlink" title="1.3 启动Django项目"></a>1.3 启动Django项目</h2><p>在 manage.py 文件所在目录下使用 <code>python manage.py runserver</code> 运行</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/runserver.png" alt="runserver"></p>
<p>在浏览器中打开相应网址 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> （一般默认在8000端口）出现如下页面，则 django 项目启动成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8000-1.png" alt="8000-1"></p>
<h1 id="二、创建Vue项目"><a href="#二、创建Vue项目" class="headerlink" title="二、创建Vue项目"></a>二、创建Vue项目</h1><p>搭建vue项目需要nodejs+npm+vue</p>
<h2 id="2-1-安装-nodejs-npm"><a href="#2-1-安装-nodejs-npm" class="headerlink" title="2.1 安装 nodejs+npm"></a>2.1 安装 nodejs+npm</h2><p>可参考<a href="https://www.beingjay.com/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/">前面的博客</a>安装 nodejs</p>
<p>安装后使用命令 <code>node -v</code> 检查 nodejs 是否安装成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/node-v.png" alt="node-v"></p>
<p>使用 <code>npm -v</code> 查看 npm 版本</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/npm-v.png" alt="npm-v"></p>
<h2 id="2-2-安装Vue"><a href="#2-2-安装Vue" class="headerlink" title="2.2 安装Vue"></a>2.2 安装Vue</h2><p>在终端使用 <code>npm install vue-cli -g</code> 或 <code>npm install @vue/cli -g</code> 全局安装vue</p>
<p>其中第一条命令安装的是3.0以前的版本，第二条命令是安装3.0以后的最新版本。或使用 <code>npm install @vue/cli@x.x.x -g</code> 安装指定版本</p>
<p>（可使用命令 <code>npm uninstall vue-cli -g</code> 卸载已安装的vue）</p>
<p>全局安装Vue后，使用命令 <code>vue --version</code> 或 <code>vue -V</code> 查看版本从而检查是否安装成功</p>
<h2 id="2-3-创建一个Vue项目"><a href="#2-3-创建一个Vue项目" class="headerlink" title="2.3 创建一个Vue项目"></a>2.3 创建一个Vue项目</h2><p><strong>在manage.py同级目录下</strong>，对于Vue3.0以后的版本使用命令 <code>vue create 项目名</code> 来创建一个新的vue项目</p>
<p>创建时会出现如下三个选项，分别是默认的vue2相关依赖、vue3相关依赖、手动选择相关依赖</p>
<pre><code>Default （[Vue 2] babel，eslint）
Default （[Vue 3]）（[Vue 3] babel，eslint）
Manually select features</code></pre>
<p>可按需求自行选择，（若不太懂可以选择 Default（Vue 3） 安装），也可选择第三项自定义安装所需依赖，我的选择如下，</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vue_manually.png" alt="vue_manually"></p>
<p>Babel是负责编译、Router负责路由管理、VueX负责状态存储和数据流通、Linter/Formatter负责对语法和代码格式进行检查</p>
<p>其他选项根据提示也进行按需选择</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vue_setting.png" alt="vue_setting"></p>
<p>此时目录结构已变为</p>
<pre><code>-根目录
 --django项目
 --manage.py
 --vue项目</code></pre>
<h2 id="2-4-Vue项目启动"><a href="#2-4-Vue项目启动" class="headerlink" title="2.4 Vue项目启动"></a>2.4 Vue项目启动</h2><p>创建好后需要进入Vue项目文件夹，在Vue项目根目录下使用 <code>npm run serve</code> 启动项目</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/runserve.png" alt="runserve"></p>
<h2 id="2-5-浏览器查看"><a href="#2-5-浏览器查看" class="headerlink" title="2.5 浏览器查看"></a>2.5 浏览器查看</h2><h3 id="2-5-1-PC端"><a href="#2-5-1-PC端" class="headerlink" title="2.5.1 PC端"></a>2.5.1 PC端</h3><p>在本机浏览器中输入 Local 或 Network 中的网址可查看（一般默认在8080端口）</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8080.png" alt="8080"></p>
<h3 id="2-5-2-移动端"><a href="#2-5-2-移动端" class="headerlink" title="2.5.2 移动端"></a>2.5.2 移动端</h3><p>在手机上输入 Network 的网址也可进行查看，前提是手机与运行项目的主机在同一局域网内。</p>
<p>若不在一个局域网内，则现在终端使用命令 <code>ipconfig</code> 查看主机地址，然后通过 IP 访问</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/ipconfig.png" alt="ipconfig"></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8080-mobile.png" alt="8080-mobile"></p>
<h1 id="三、安装MySQL"><a href="#三、安装MySQL" class="headerlink" title="三、安装MySQL"></a>三、安装MySQL</h1><p>可参考<a href="https://www.beingjay.com/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">前面的博客</a>安装 MySQL</p>
<h1 id="四、Vue-Django连接"><a href="#四、Vue-Django连接" class="headerlink" title="四、Vue+Django连接"></a>四、Vue+Django连接</h1><h2 id="4-1-Vue配置"><a href="#4-1-Vue配置" class="headerlink" title="4.1 Vue配置"></a>4.1 Vue配置</h2><p>由于Vue3在打包项目后生成的 dist 文件夹中不会生成 static 子文件夹，而 django 项目查找静态资源时只会查找 static 文件夹，因此在Vue项目目录下新建一个 <strong>vue.config.js</strong> 文件，文件中添加如下代码</p>
<pre><code>module.exports = &#123;
    // 输出目录
    assetsDir: &#39;static&#39;,
&#125;;</code></pre>
<p>这样在使用 <code>npm run build</code> 进行项目打包时生成的 dist 文件夹下包含 static 文件夹，静态资源都存放在 static 文件夹中</p>
<h2 id="4-2-Django配置"><a href="#4-2-Django配置" class="headerlink" title="4.2 Django配置"></a>4.2 Django配置</h2><h3 id="（1）前端资源路径配置"><a href="#（1）前端资源路径配置" class="headerlink" title="（1）前端资源路径配置"></a>（1）前端资源路径配置</h3><p>在 django项目-&gt;settings.py 文件里的 DIRS 一项中添加打包后的Vue项目所在路径，这里是 <code>&#39;vue项目名/dist&#39;</code>,</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/templates.png" alt="templates"></p>
<h3 id="（2）前端入口文件路径配置"><a href="#（2）前端入口文件路径配置" class="headerlink" title="（2）前端入口文件路径配置"></a>（2）前端入口文件路径配置</h3><p>在 django项目-&gt;url.py 文件中添加Vue项目入口文件 index.html 作为后端启动页</p>
<pre><code>from django.contrib import admin
from django.urls import path
from django.views.generic import TemplateView

urlpatterns = [
    path(&#39;admin/&#39;, admin.site.urls),
    path(&#39;&#39;, TemplateView.as_view(template_name=&quot;index.html&quot;)),  #添加入口文件
]</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/urlpatterns.png" alt="urlpatterns"></p>
<h3 id="（3）静态资源路径配置"><a href="#（3）静态资源路径配置" class="headerlink" title="（3）静态资源路径配置"></a>（3）静态资源路径配置</h3><p>同样是在 setting.py 文件中添加静态资源引用地址</p>
<pre><code>FRONTEND_ROOT = &#39;vue项目名/dist&#39;
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, FRONTEND_ROOT),
    os.path.join(BASE_DIR, FRONTEND_ROOT + &#39;/static/&#39;),
)</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/staticfiles.png" alt="staticfiles"></p>
<h2 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h2><p>同时运行 Vue 项目（非必须，但前提是vue项目以打包生成dist文件夹）和 django 项目，在浏览器<a href="http://127.0.0.1:8000/%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%88%E5%8D%B3django%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%B5%E4%B8%AD%E6%98%BE%E7%A4%BAVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%89%EF%BC%8C%E6%AD%A4%E6%97%B6vue%E9%A1%B9%E7%9B%AE%E5%92%8Cdjango%E9%A1%B9%E7%9B%AE%E5%85%B3%E8%81%94%E6%88%90%E5%8A%9F">http://127.0.0.1:8000/路径下看到如下页面（即django项目的启动页中显示Vue项目的内容），此时vue项目和django项目关联成功</a></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8000-2.png" alt="8000-2"></p>
<p>单独 vue 项目默认会运行在 8080 端口下，单独 django 项目默认会运行在 8000 端口下，当 django 项目和 vue 项目没有关联之前，运行 django 项目时会在 8000 端口看到 django 项目的默认页面，当关联后，vue项目打包后，此时运行 django 项目会在 8000 端口看到 vue 项目的页面</p>
<h1 id="五、Django-MySQL连接"><a href="#五、Django-MySQL连接" class="headerlink" title="五、Django+MySQL连接"></a>五、Django+MySQL连接</h1><h2 id="5-1-创建项目数据库"><a href="#5-1-创建项目数据库" class="headerlink" title="5.1 创建项目数据库"></a>5.1 创建项目数据库</h2><p>首先以管理员身份运行终端，输入 <code>net start mysql</code> 启动 mysql 服务器</p>
<p>并在 mysql 安装的 bin 目录下输入 <code>mysql -u root -p</code> 并回车后输入密码来登录 mysql 服务器</p>
<p>并使用 SQL 语句创建一个数据库 <code>create database 数据库名称 default charset=utf8;</code> </p>
<p>使用 <code>show databases;</code> 命令查看是否成功创建</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/database.png" alt="database"></p>
<h2 id="5-2-Django配置"><a href="#5-2-Django配置" class="headerlink" title="5.2 Django配置"></a>5.2 Django配置</h2><h3 id="（1）安装所需依赖"><a href="#（1）安装所需依赖" class="headerlink" title="（1）安装所需依赖"></a>（1）安装所需依赖</h3><p>在 django 项目所用的 python 解释器中安装 pymysql 驱动</p>
<h3 id="（2）配置数据库连接信息"><a href="#（2）配置数据库连接信息" class="headerlink" title="（2）配置数据库连接信息"></a>（2）配置数据库连接信息</h3><p>在 django项目-&gt;setting.py 文件中的 DATABASES 一项更换为如下配置</p>
<pre><code>&#39;default&#39;:
&#123;
    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,  # 数据库引擎
    &#39;NAME&#39;: &#39;ssm&#39;,  # 数据库名称
    &#39;HOST&#39;: &#39;127.0.0.1&#39;, # 数据库地址，本机 ip 地址 127.0.0.1
    &#39;PORT&#39;: 3306,  # 端口
    &#39;USER&#39;: &#39;root&#39;,  # 数据库用户名
    &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  # 数据库密码
&#125;</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/databases.png" alt="databases"></p>
<p>在 django项目-&gt;<strong>init</strong>.py 文件中添加如下代码</p>
<pre><code>import pymysql
pymysql.install_as_MySQLdb()</code></pre>
<h3 id="（3）创建一个app"><a href="#（3）创建一个app" class="headerlink" title="（3）创建一个app"></a>（3）创建一个app</h3><p>Django 规定，如果要使用模型，必须要创建一个 app，使用命令 <code>django-admin startapp app名称</code> 进行创建</p>
<p>然后在 django项目-&gt;setting.py 文件里的 INSTALLED_APPS 一项中添加app名称</p>
<p>此时目录结构已变为</p>
<pre><code>-根目录
 --django项目
 --manage.py
 --vue项目
 --项目app</code></pre>
<p>在 app 里的 models.py 文件中可以类的形式表示数据库中的表，然后在终端运行 <code>python manage.py makemigrations app名称</code> 和 <code>python manage.py migrate app名称</code> 让 Django 知道模型有一些变更，并创建表结构</p>
<h3 id="（4）-Django中操作数据库"><a href="#（4）-Django中操作数据库" class="headerlink" title="（4） Django中操作数据库"></a>（4） Django中操作数据库</h3><p>接着可以在django项目下添加py文件（如testdb.py）进行数据库操作，并在 django项目-&gt;urls.py 文件里 urlpatterns 中添加接口路径和文件</p>
<p>如 <code>path(&#39;test/&#39;, testdb.testdb)</code> ，第一个 testdb 指 testdb.py 文件，第二个 testdb 指 testdb.py 文件中的 testdb 函数</p>
<h1 id="六、遇到的一些问题"><a href="#六、遇到的一些问题" class="headerlink" title="六、遇到的一些问题"></a>六、遇到的一些问题</h1><h2 id="6-1-跨域问题"><a href="#6-1-跨域问题" class="headerlink" title="6.1 跨域问题"></a>6.1 跨域问题</h2><p>在前端向后端发送请求时会发生如下报错</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png" alt="跨域问题"></p>
<p><strong>解决：</strong></p>
<p>在后端python虚拟环境中安装 django-cors-headers 依赖</p>
<p>在 django项目-&gt;setting.py 文件中 MIDDLEWARE 配置里<br>在’django.contrib.sessions.middleware.SessionMiddleware’,<br>和’django.middleware.common.CommonMiddleware’,<br>中间添加’corsheaders.middleware.CorsMiddleware’,</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/middleware.png" alt="middleware"></p>
<p>同样是在 django项目-&gt;setting.py 文件里，在 INSTALLED_APPS 一项中添加 <code>&#39;corsheaders&#39;,</code> </p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/installedapps.png" alt="installedapps"></p>
<p>并在 django项目-&gt;settings.py 文件中添加 <code>CORS_ORIGIN_ALLOW_ALL = True</code> </p>
<h2 id="6-2-403报错"><a href="#6-2-403报错" class="headerlink" title="6.2 403报错"></a>6.2 403报错</h2><p>前端向后端发送post请求后出现403错误</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/403.png" alt="403"></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/CSRF.png" alt="CSRF"></p>
<p>CSRF是为了防止跨站请求伪造</p>
<p><strong>解决：</strong></p>
<p>可以引入 <code>from django.views.decorators.csrf import csrf_exempt</code> ，并在函数前添加 <code>@csrf_exempt</code> </p>
<p>或在 django项目-&gt;settings.py 文件中 MIDDLEWARE 一项里注释掉’django.middleware.csrf.CsrfViewMiddleware’</p>
<p>第一种方法对某一接口起作用，而第二种方法针对全局有效</p>
<h2 id="6-3-更改后端IP"><a href="#6-3-更改后端IP" class="headerlink" title="6.3 更改后端IP"></a>6.3 更改后端IP</h2><p>djang项目默认后端运行在 127.0.0.1 本机 IP 上</p>
<p>若要更改，在django项目-&gt;settings.py 文件里的 ALLOWED_HOSTS 中添加新 IP</p>
<p>并在 manage.py 文件所在目录下使用 <code>python manage.py runserver 新IP:端口</code> 启动后端服务</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>一些废话</title>
    <url>/2021/01/20/%E4%B8%80%E4%BA%9B%E5%BA%9F%E8%AF%9D/</url>
    <content><![CDATA[<p>欢迎来到我的个人博客！下面要说一些废话，可以忽略hhh</p>
<a id="more"></a>

<p>放假了终于把写博客的事提上日程了，之前本科时候心血来潮用学生优惠租过一台服务器搭博客，结果自从搭上后没几天就没怎么问津过了。。。然后就就就到期了，真是浪费资源啊。这次决定重新开始写博客记录记录平时学习过程，我就是只菜菜鸟，博客里的内容仅代表个人理解，有理解不到位、不正确的地方还请多多指教哈~</p>
<p>立个flag，这次我一定经常来，哈哈哈</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>关于Web App的个人理解</title>
    <url>/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="App的类型"><a href="#App的类型" class="headerlink" title="App的类型"></a>App的类型</h1><p>App主要分为三类，分别是Native App（原生应用程序）、Web App（Web应用程序）、Hybrid App（混合型应用程序）</p>
<a id="more"></a>

<br>

<p><img src="/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/1.png" alt="App的类型"></p>
<br>

<ul>
<li><p><strong>Native App</strong></p>
<p>  原生App是运行在设备操作系统上的应用程序，例如安装在电脑、手机上的各种软件。</p>
<p>  对于不同的操作系统（如Windows、IOS、安卓等）需要使用不同的语言进行独立开发，这使得它的开发速度较慢、开发成本较高。同时，对于不同操作系统的App进行独立维护，这增加了维护总成本。并且原生App要发布上线、供用户下载使用前需要经过一系列的审核流程，因此从开发到上线还需要一定的时间。</p>
<p>  但是原生App一般将资源放置在用户的设备本地，因此用户获取资源更加便捷。并且原生App可调用的终端硬件设备，如麦克风、摄像头等，从而实现更丰富的功能。交互性、用户体验度最好。</p>
</li>
<li><p><strong>Web App</strong></p>
<p>  Web App是运行在浏览器上的应用程序，是一个轻量级App。只需打开浏览器并输入相应网址即可访问。</p>
<p>  由于Web App不依赖于操作系统，因此对于不同的操作系统而言无需单独开发一套应用程序，通过一次开发，即可让不同设备的用户访问到该应用程序，开发时只需考虑浏览器的兼容问题，使得开发效率提高，开发成本降低。从而只需专注在一套代码程序的优化和维护上，也大大降低了维护成本。<br>  其资源一般存储在云端，使得用户可以实时访问到最新数据。并且用户可最快获取最新功能或版本。  </p>
<p>  Web App也可调用终端的硬件设备，但其可调用的硬件设备功能相较于原生App来说受到一些限制。</p>
</li>
<li><p><strong>Hybrid App</strong></p>
<p>  混合型App是一个相当于在原生程序中伪造了浏览器，并运行Web App的半原生应用程序，运行在操作系统上。</p>
<p>  其资源可放置在本地或云端。交互性和用户体验度次于原生App。</p>
</li>
</ul>
<h1 id="Web-App工作过程"><a href="#Web-App工作过程" class="headerlink" title="Web App工作过程"></a>Web App工作过程</h1><p>Web APP是B/S架构的软件，其运行主要涉及的终端设备、客户终端的浏览器以及服务器。用户访问App，并获取相应返回数据的过程如下图所示：</p>
<br>

<p><img src="/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/2.png" alt="Web App工作过程"></p>
<br>

<p>①访问网址：用户在终端浏览器中栏输入URL路径向相应的服务器请求页面</p>
<p>②连接过程：Web服务器与浏览器间建立连接</p>
<p>③请求过程：浏览器用http协议描述，并封装为TCP/IP数据包寻址，发送http请求</p>
<p>④应答过程：服务器接收和分析http请求，按照用户请求内容执行相应处理，生成返回的HTML页面，并将结果打包成HTTP响应</p>
<p>⑤显示输出：浏览器在客户端屏幕上渲染服务器处理后返回的HTML页面</p>
<p>⑥关闭连接：Web服务器和浏览器间断开连接</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>关于前端框架React的个人理解</title>
    <url>/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>一个Web App的开发主要包括前端和后端两部分，在Web App运行时用户在浏览器端发生点击、输入、表单提交等事件，发生这些交互事件时浏览器端向后端发送http请求，后端服务器接收到前端发来的请求以及数据后执行相应脚本对用户请求进行处理，必要时向数据库查询或更新数据，服务器再将处理结果生成<a id="more"></a>HTML页面返回至浏览器进行渲染。在这个过程中，浏览器端的显示以及事务处理属于前端部分，而服务器端和数据库的程序开发属于后端部分。</p>
<br>

<p><img src="/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/1.png" alt="前后端"></p>
<br>

<p>前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。[来自百度百科]进行前端开发需要掌握的基本知识包括HTML、CSS、JavaScript。</p>
<ul>
<li><p>HTML：超文本标记语言 （Hyper Text Markup Language）——页面结构、内容<br>负责定义页面的组成，例如标题、段落、图片、链接等。</p>
</li>
<li><p>CSS：级联样式表（Cascading Style Sheet）——样式<br>负责定义页面各组成部分的布局和样式，例如所处位置、大小、颜色等。</p>
</li>
<li><p>JavaScript：面向对象的客户端脚本语言——控制HTML中的各元素、处理事务逻辑<br>负责处理用户的鼠标点击、滑动所触发的事件的部分事务逻辑，部分事务逻辑可由后端处理。</p>
</li>
</ul>
<h1 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h1><p>可以通过自行创建HTML文件、定义CSS、编写JS来搭建前端，但这样的开发效率较低，且代码杂乱、冗余，难以维护。因此大家都倾向于利用前端框架搭建前端，在前端框架中页面需要重复使用的部分可封装为组件，从而能方便地引用，且各个组件定义自己的js逻辑和样式，使得各部分代码清晰明了且整洁。<br>通过使用前端框架，程序猿可更专注于网页内容的开发，而数据缓存、数据安全校验等由框架来实现。<br>此外，虽然各前端框架的内部实现机制不同，但相比原生态的前端页面开发而言，前端框架在实现机制上进行了性能优化来提高网页速度。<br>而且在前端框架中有许多已封装好的第三方组件可直接调用，使开发效率提升、页面更加美观。<br>如今前端框架层出不穷，下图展示了部分较为流行的前端框架：<br><br></p>
<p><img src="/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/2.png" alt="前端框架"></p>
<br>
其中Vue、React、Angular是当前较主流的三个前端框架，此外还有Twitter推出的Bootstrap，饿了么团队推出的基于Vue的桌面端前端框架Element UI和移动端前端框架Mint UI，京东团队推出的可适配微信小程序的Taro UI前端框架，腾讯出品的QMUI，以及基于Vue的UI组件库iview和基于React的UI组件库Antd Design等。

<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>前端小方法杂记</title>
    <url>/2021/05/21/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%96%B9%E6%B3%95%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、HTML与CSS"><a href="#一、HTML与CSS" class="headerlink" title="一、HTML与CSS"></a>一、HTML与CSS</h1><h2 id="关于居中"><a href="#关于居中" class="headerlink" title="关于居中"></a>关于居中</h2><p><strong>问题1：</strong><code>&lt;div&gt;</code>子元素在父元素中垂直居中</p>
<a id="more"></a>

<p><strong>方法一：</strong>子元素设置<code>display:inline-block;vertical-align:middle;</code></p>
<p><strong>方法二：</strong>父元素设置<code>display:flex;</code>搭配子元素<code>align-self:center;</code></p>
<p><strong>方法三：</strong>父元素设置<code>display:table;</code>搭配子元素<code>display: table-cell;vertical-align: middle;</code></p>
<p><strong>问题2：</strong>在没有设置<code>&lt;div&gt;</code>宽度时的水平居中</p>
<p><strong>方法：</strong>CSS3支持使用<code>width:-moz-fit-content;  width:fit-content;  margin:0 auto;</code>实现水平居中，且仅谷歌与火狐浏览器支持</p>
<h2 id="关于刷新"><a href="#关于刷新" class="headerlink" title="关于刷新"></a>关于刷新</h2><p><strong>问题：</strong>点击<code>&lt;a&gt;</code>标签后页面总会自动刷新</p>
<p><strong>方法：</strong>可添加属性<code>href=&quot;javascript:;&quot;</code>阻止页面刷新</p>
<h2 id="关于大小、高度不一"><a href="#关于大小、高度不一" class="headerlink" title="关于大小、高度不一"></a>关于大小、高度不一</h2><p><strong>问题1：</strong><code>&lt;input&gt;</code>标签中 text 类型和 submit 类型设置相同的高度，显示出来却不同</p>
<p><strong>原因：</strong>因为text类型的<code>&lt;input&gt;</code>标签显示的宽度和高度包含 border</p>
<p><strong>方法：</strong>可在 submit 类型的<code>&lt;input&gt;</code>标签中设置<code>box-sizing: content-box;</code></p>
<p><strong>问题2：</strong>当在子元素中使用<code>display:inline-block</code>使多个子元素并排时，各子元素高度不一</p>
<p><strong>方法：</strong>可在子元素中添加<code>letter-spacing: 0;vertical-align: top;</code>来解决</p>
<h2 id="关于元素样式作用对象"><a href="#关于元素样式作用对象" class="headerlink" title="关于元素样式作用对象"></a>关于元素样式作用对象</h2><p><strong>问题：</strong><code>&lt;div&gt;</code>子元素设置 margin 后会作用于父元素</p>
<p><strong>方法一：</strong>对父元素添加<code>overflow: hidden;</code></p>
<p><strong>方法二：</strong>给父元素增加透明边框<code>border: 1px solid transparent;</code>或<code>border-top: 1px solid transparent;</code></p>
<p><strong>方法三：</strong>为父元素设置<code>padding</code></p>
<h2 id="关于样式"><a href="#关于样式" class="headerlink" title="关于样式"></a>关于样式</h2><p><strong>问题：</strong>去除<code>&lt;button&gt;</code>一些默认样式</p>
<p><strong>方法：</strong>去除边框<code>border:none;</code>&nbsp;&nbsp;&nbsp;去除点击时的边框<code>outline: none;</code></p>
<h1 id="二、JS"><a href="#二、JS" class="headerlink" title="二、JS"></a>二、JS</h1><h2 id="关于多个重叠-lt-div-gt-的点击"><a href="#关于多个重叠-lt-div-gt-的点击" class="headerlink" title="关于多个重叠&lt;div&gt;的点击"></a>关于多个重叠<code>&lt;div&gt;</code>的点击</h2><p><strong>问题1：</strong>上层<code>&lt;div&gt;</code>遮挡下层<code>&lt;div&gt;</code>后，点击重叠部分无法触发下层<code>&lt;div&gt;</code>的函数</p>
<p><strong>方法：</strong>可通过<code>pointer-events:none;</code>解决</p>
<p><strong>问题2：</strong>点击子<code>&lt;div&gt;</code>不触发父<code>&lt;div&gt;</code>的函数</p>
<p><strong>方法：</strong>在子<code>&lt;div&gt;</code>点击时阻止冒泡事件，即在函数中添加<code>event.stopPropagation()</code></p>
<h2 id="关于-lt-input-gt-值不变"><a href="#关于-lt-input-gt-值不变" class="headerlink" title="关于&lt;input&gt;值不变"></a>关于<code>&lt;input&gt;</code>值不变</h2><p><strong>问题：</strong>修改<code>&lt;input&gt;</code>的输入内容，获取到的值不变</p>
<p><strong>方法：</strong><code>&lt;input&gt;</code>标签可通过 value 属性设置默认值，若要可修改需要添加<code>onChange</code>监听函数才行</p>
<h1 id="三、针对React"><a href="#三、针对React" class="headerlink" title="三、针对React"></a>三、针对React</h1><h2 id="关于背景"><a href="#关于背景" class="headerlink" title="关于背景"></a>关于背景</h2><p><strong>问题：</strong>react 中给<code>&lt;div&gt;</code>添加背景图片时背景图片过大</p>
<p><strong>方法：</strong>可设置<code>webkitBackgroundSize: &#39;100% 100%&#39;</code></p>
<h2 id="关于带参数的函数"><a href="#关于带参数的函数" class="headerlink" title="关于带参数的函数"></a>关于带参数的函数</h2><p><strong>问题：</strong>react 中定义带参数的函数</p>
<p><strong>方法：</strong>在标签的 onClick 属性中使用<code>this.函数名.bind(this,参数)</code>，</p>
<p>在 constructor() 构造器中使用<code>this.函数名=this.函数名.bind(this)</code>，</p>
<p>在定义函数时参数为 (参数名,event)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>双系统下重装Ubuntu系统</title>
    <url>/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>前情提要：原主机中已安装 Windows10 和 Ubuntu 16.04 双系统，想重新安装 Ubuntu 系统，改为 Ubuntu 20.04 版本</p>
<a id="more"></a>

<h1 id="一、下载-Ubuntu-20-04-镜像"><a href="#一、下载-Ubuntu-20-04-镜像" class="headerlink" title="一、下载 Ubuntu 20.04 镜像"></a>一、下载 Ubuntu 20.04 镜像</h1><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/">清华镜像网站</a>上下载 .iso 镜像文件，我这里选择 ubuntu-20.04.3-desktop-amd64.iso 进行下载</p>
<h1 id="二、制作启动-U-盘"><a href="#二、制作启动-U-盘" class="headerlink" title="二、制作启动 U 盘"></a>二、制作启动 U 盘</h1><p>1、安装 UltralSO 软件</p>
<p>2、清空已作为启动盘的 U 盘</p>
<p>已管理员身份打开 UltralSO 软件，点击菜单栏中“启动 -&gt; 写入硬盘映像”</p>
<p>选择硬盘驱动器、映像文件（空白）、写入方式后点击“写入”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-deleteU1.png" alt="deleteU"></p>
<p>3、制作启动盘</p>
<p>已管理员身份打开 UltralSO 软件，点击菜单栏“文件 -&gt; 打开”或在界面下方“本地目录”中找到下载好的 Ubuntu 20.04 系统镜像文件 ubuntu-20.04.3-desktop-amd64.iso 并双击文件</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-write.png" alt="ultraiso-write"></p>
<p>再点击菜单栏中“启动 -&gt; 写入硬盘映像”，选择硬盘驱动器（U盘）、映像文件（ubuntu-20.04.3-desktop-amd64.iso）、写入方式（USB-HDD+）后点击“写入”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-write1.png" alt="ultraiso-write1"></p>
<h1 id="三、删除-Ubuntu-系统"><a href="#三、删除-Ubuntu-系统" class="headerlink" title="三、删除 Ubuntu 系统"></a>三、删除 Ubuntu 系统</h1><p>进入 Windows 系统，右键“此电脑” -&gt; 点击“管理” -&gt; 选择“磁盘管理” -&gt; 选择非系统盘的磁盘中属于原 Ubuntu 系统的分区右键选择“删除卷”，使这些区域成为“可用空间”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9Fdeletepartition.png" alt="deletepartition"></p>
<p>键盘按住 Win + R，输入 <code>diskpart</code> 进入相应命令行，输入 <code>list disk</code> 查看所有磁盘，并输入 <code>select disk 系统盘编号</code> 选择 Windows 的系统盘， 输入 <code>list partition</code> 查看该盘所有分区，并选择“系统”分区 <code>select partition 分区编号</code>，输入 <code>assign letter=字母</code> 分配成一个独立磁盘（磁盘字母随意只要不和现有磁盘冲突即可）</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/listdisk.png" alt="listdisk"></p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/selectdisk.png" alt="selectdisk"></p>
<h1 id="四、删除-Ubuntu-系统启动项"><a href="#四、删除-Ubuntu-系统启动项" class="headerlink" title="四、删除 Ubuntu 系统启动项"></a>四、删除 Ubuntu 系统启动项</h1><p>1、以管理员身份打开“记事本”，点击菜单栏“文件 -&gt; 打开”，选择刚刚创建的磁盘，打开其中文件夹“EFI”，并选择该目录下的“ubuntu”文件夹右键删除</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/deleteubuntu.png" alt="deleteubuntu"></p>
<p>2、并在第 4 步命令行中输入 <code>remove letter=磁盘字母</code> 删除创建的磁盘</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/removedisk.png" alt="removedisk"></p>
<p>3、在<a href="https://easyuefi.en.softonic.com/">官网</a>下载 EasyUEFI，安装后运行该软件，进入“管理EFI启动项”，选择原 Ubuntu 系统涉及的启动项并删除</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/easyuefi.png" alt="easyuefi"></p>
<h1 id="五、安装新-Ubuntu-系统"><a href="#五、安装新-Ubuntu-系统" class="headerlink" title="五、安装新 Ubuntu 系统"></a>五、安装新 Ubuntu 系统</h1><p>1、将 U 盘插入电脑，重启电脑，进入“BIOS”，选择 U 盘启动项</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/bios.jpg" alt="bios"></p>
<p>2、接着按照提示按照新 Ubuntu 系统，下面是部分需要注意的地方</p>
<p>（1）安装类型选择“其他选项”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/installtype.jpg" alt="installtype"></p>
<p>（2）利用空闲空间进行分区，分区可分为两个（‘/’、‘/home’）、四个（‘swap’、‘/’、‘/boot’、‘/home’）或五个（‘swap’、‘/’、‘/boot’、‘/usr’、‘/home’）区，根据自身存储空间选择</p>
<p>‘/boot’是用于启动ubuntu系统的启动器，类型：逻辑分区，用于：Ext4日志文件系统，大约需400M，这里我分配了1G</p>
<p>‘swap’是虚拟内存，类型：逻辑分区，用于：交换空间，可以分固态硬盘的区，大小约为内存大小，这里我分配了32G</p>
<p>‘/’是用于存放系统文件相当于Windows的C盘，类型：逻辑分区，用于：Ext4日志文件系统，这里我分配了115G</p>
<p>‘/usr’是所有程序安装的位置,本地安装的程序在/usr/local下，类型：逻辑分区，用于：Ext4日志文件系统，这里我分配了200G</p>
<p>‘/home’供用户存放文件等数据，相当于Windows系统盘之外的其它盘，类型：逻辑分区，用于：Ext4日志文件系统，这里我把剩余所有空间分配给它</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/bootpartition.jpg" alt="bootpartition"></p>
<p>（3）分配完各分区空间后，在“安装启动引导的设备”处选择“/boot”所在分区</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/partitions.jpg" alt="partitions"></p>
<h1 id="六、可能遇到的问题"><a href="#六、可能遇到的问题" class="headerlink" title="六、可能遇到的问题"></a>六、可能遇到的问题</h1><p><strong>问题：</strong>若没删除干净，或首选启动项无法启动时，重启会出现如下界面</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/rebooterror.jpg" alt="rebooterror"></p>
<p><strong>解决：</strong>在重启时进入“BIOS”，选择可启动项启动，在 EasyUEFI 软件中管理启动项时把可用启动项置于最顶</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>安装构建并运行React项目</title>
    <url>/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>构建一个React项目需要安装Nodejs、Webpack以及React相关包。</p>
<a id="more"></a>

<p>每个脚本都需要解析器，即构建一个运行时环境，而nodejs就是为js脚本提供一个运行时环境。对于JavaScript，在前端html中的js是由浏览器进行解析，主要是对DOM的操作，而nodejs解析的js脚本主要是对磁盘文件等进行操作，搭建起一个服务。</p>
<p>webpack是一个模块管理工具，将项目各文件进行打包，在项目部署时可通过直接调用打包后生成的资源文件，方便快捷。</p>
<h1 id="一、安装Nodejs"><a href="#一、安装Nodejs" class="headerlink" title="一、安装Nodejs"></a>一、安装Nodejs</h1><p>在<a href="https://nodejs.org/zh-cn/">官网</a>根据自己的系统选择对应版本进行下载</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/nodejs.png" alt="nodejs"></p>
<p>下载完成后开始安装，可自定义所要安装的位置，其他选项按照默认即可。<br>打开命令行，输入 <code>node -v</code> 并回车，查看是否安装成功，若出现nodejs版本表示已成功安装。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/node-v.png" alt="node-v"></p>
<h1 id="二、npm初始化"><a href="#二、npm初始化" class="headerlink" title="二、npm初始化"></a>二、npm初始化</h1><p>npm是包管理器，在开发过程中，通过 <code>npm install 包名称</code> 命令安装所需的包，即可使用别人已写好的模块，省去下载源码解压安装等繁琐步骤。npm包管理器集成在nodejs中，当上一步nodejs安装成功后，在命令行输入 <code>npm -v</code> ，显示npm的版本号，表示npm也已成功安装。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/npm-v.png" alt="npm-v"></p>
<p>新建一个React项目的文件夹（这里我命名为test），打开命令行，进入该文件夹，使用命令 <code>npm init</code> 初始化项目，初始化过程中可按提示输入项目名称、版本、描述、入口文件、启动命令等信息，也可选择一路回车。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/npminit.png" alt="npm init"></p>
<p>此时会在该文件夹下生成一个package.json文件，该文件中记录的是刚才项目初始化时所输入的项目相关信息。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagejson.png" alt="packagejson"></p>
<h1 id="三、安装Webpack"><a href="#三、安装Webpack" class="headerlink" title="三、安装Webpack"></a>三、安装Webpack</h1><p>在项目文件夹下使用命令 <code>npm install webpack webpack-cli webpack-dev-server --save-dev</code> 安装webpack和webpack-dev-sever。</p>
<p>其中webpack负责打包工作，方便文件管理，把所有静态文件打包成一个bundle.js资源文件，当项目部署时只需项目入口文件和打包好的bundle.js文件即可。最新版本的webpack需要搭配webpack-cli使用，要编译成功还必须安装webpage-cli。</p>
<p>安装webpack-dev-server包是为了方便在本地实时预览页面，是一个小型的nodejs Express服务器，为静态文件提供web服务，实现热加载，即当更改并保存前端代码后，webpack自动编译，并在浏览器中自动刷新显示最新页面，从而实时预览更改后的页面状态。webpack-dev-sever在本地开发时非常方便，在项目部署到服务器后的生产环境中不需要用到，因此在安装命令中使用–save-dev表示把包安装在dev节点上。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installwebpack.png" alt="installwebpack"></p>
<p>安装完成后，在项目文件夹下生成node_modules文件夹和package-lock.json文件，其中node_modules文件夹中存放的就是项目开发过程中安装的各种模块。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagelockjson.png" alt="package-lock.json"></p>
<p>在项目文件夹下手动创建一个webpack.config.js文件，在该文件中配置项目的入口文件、打包后的文件存放位置等信息。配置如下：</p>
<pre><code>var path = require(&quot;path&quot;);
var webpack = require(&#39;webpack&#39;);
module.exports = &#123;
    entry: &#123; app: [&#39;./src/main.js&#39;] &#125;,  //前端入口文件
    output: &#123;
    path: path.resolve(__dirname, &quot;./build&quot;), //打包后文件的存放位置
    publicPath: &quot;/build/&quot;,   //打包后访问资源时加的路径前缀
    filename: &quot;bundle.js&quot;    //打包生成的文件名
    &#125;,
    resolve: &#123;
    extensions: [&#39;*&#39;,&#39;.js&#39;,&#39;.jsx&#39;]  //当代码中引入模块时若找不到指定文件，则添加这些后缀
    &#125;,  
    devServer: &#123;
    historyApiFallback: true,
    host:&#39;0.0.0.0&#39;,
    hot: true,
    inline: true,
    progress: true,
    port:5000
    &#125;,
    plugins: [
    new webpack.DefinePlugin(&#123;
      &#39;process.env.NODE.ENV&#39;:&quot;development&quot;
    &#125;),
    new webpack.HotModuleReplacementPlugin()
    ]
&#125;;</code></pre>
<h1 id="四、安装React"><a href="#四、安装React" class="headerlink" title="四、安装React"></a>四、安装React</h1><p>在项目文件夹下使用命令 <code>npm install react react-dom --save-dev</code> 命令安装react和react-dom模块。</p>
<p>其中react模块时react的核心库，react-dom模块提供关于DOM的相关操作，将react的虚拟DOM进行编译更新DOM。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installreact.png" alt="install react"></p>
<p>由于在react中支持JSX格式代码，即可以在js中直接写html标签，因此在react中各组件文件以js或jsx后缀都可以，若要把jsx文件转为js文件需要安装jsx-loader包。此外，要把react框架中编写的代码使用webpack打包后还需要使用babel包对其进行编译，</p>
<p>因此使用命令 <code>npm install jsx-loader babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev</code> 安装所需这些包，babel-core是babel的核心库，babel-preset-react可把react的语法转换为ES5规范。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installbabel.png" alt="install babel"></p>
<p>在webpack.config.js文件中添加如下配置:</p>
<pre><code>module: &#123;
  loaders: [
    &#123;test:/\.jsx$/, loaders:[&#39;jsx?harmony&#39;]&#125;
  ],
   loaders:[
    &#123;
      test: /\.jsx?$/,
      loader: &#39;babel-loader&#39;,
      include: path.resolve(__dirname),
      query: &#123;
        presets: [&#39;es2015&#39;, &#39;react&#39;]
      &#125;
    &#125;,
  ]
&#125;,</code></pre>
<p>安装好这些包后查看package.json文件中的“devDependencies”一项记录了在dev节点安装的所有模块。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagejson1.png" alt="package.json"></p>
<p>打开package.json文件，修改“scripts”节点，在该节点中可自定义不同命令，并为不同命令赋予含义。在该节点中添加</p>
<pre><code>&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,
&quot;start&quot;: &quot;webpack-dev-server --inline&quot;</code></pre>
<p>表示使用npm run build命令时将依据webpack.config.js文件中的配置对项目进行编译打包。使用npm run start命令时将启动nodejs小型服务器，开启本地预览。</p>
<h1 id="五、测试react项目"><a href="#五、测试react项目" class="headerlink" title="五、测试react项目"></a>五、测试react项目</h1><p>新建build文件夹，并在该文件夹下新建main.js文件index.html作为页面入口。在index.html文件中编写如下代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot; /&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;page&quot;&gt;&lt;/div&gt;    
&lt;/body&gt;
&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>新建src文件夹，并在该文件夹下新建main.js文件作为前端文件入口。可自定义入口文件位置，只需与webpack.config.js文件中的设置一致即可。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/mainjsposition.png" alt="main.js position"></p>
<p>在main.js文件中编写如下代码：</p>
<pre><code>import React from &#39;react&#39;;  //引入react核心库
import ReactDOM from &#39;react-dom&#39;;   //引入react-dom

ReactDOM.render(&lt;h1&gt;Hello World!&lt;/h1&gt;, document.getElementById(&#39;page&#39;)); //定义所要渲染的内容</code></pre>
<p>在项目文件夹目录下打开命令行，使用命令npm run build打包文件，此时会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/webpackversionerror.png" alt="webpack version error"></p>
<p>在packge.json文件中可以看到安装的webpack和webpack-cli版本</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/webpackversion.png" alt="webpack version"></p>
<p>因此报错原因是在webpack 4以后的版本中将webpack本身和webpack-cli分开来更好地管理它们，而在webpack 3中，两者在同一个包中，所以可以通过降级来解决。</p>
<p>首先使用 <code>npm uninstall webpack webpack-cli</code> 命令将原先安装的webapck和webpack-cli包移除，再使用 <code>npm install webpack@3.8.0 webpack-cli@3.3.12 --save-dev</code></p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newwebpackversion.png" alt="new webpack version"></p>
<p>再次使用 <code>npm run build</code> 命令，此时又会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/babelversionerror.png" alt="babel version error"></p>
<p>原因是babel-loader的版本不匹配，若想用babel-core 6的版本需要使用babel-loader 7的版本，而通过查看package.json文件可以看到安装的babel-core版本为6.26.3，而babel-loader的版本为8.2.2，同样可以通过给babel-loader降级来解决。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/babelversion.png" alt="babel version"></p>
<p>使用 <code>npm uninstall babel-loader</code> 移除原先安装的babel-loader，再使用 <code>npm install babel-loader@7.1.5 --save-dev</code> 重新安装</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newbabelversion.png" alt="new babel version"></p>
<p>此时再执行 <code>npm run build</code> ，成功编译打包</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/runbuild.png" alt="npm run build"></p>
<p>在build目录下生成打包后的bundle.js文件</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/bundle.png" alt="bundle"></p>
<p>使用命令 <code>npm run start</code> 启动服务，此时又会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/devservererror.png" alt="devserver error"></p>
<p>因为之前对webpack和webpack-cli进行降级后，最新版的webpack-dev-server与它们不匹配了，同样需要对webpack-dev-server进行降级。</p>
<p>使用 <code>npm uninstall webpack-dev-server</code> 移除原先安装的babel-loader，再使用 <code>npm install webpack-dev-server@2.9.7 --save-dev</code> 重新安装</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newdevserverversion.png" alt="new devserver version"></p>
<p>使用命令 <code>npm run start</code> 启动服务</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/runstart.png" alt="npm run start"></p>
<p>打开浏览器，输入 <code>127.0.0.1:5000/build</code> 进行查看</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/html.png" alt="html"></p>
<p>如上图所示浏览器成功渲染页面，至此完成react项目的搭建。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>服务器的配置和使用</title>
    <url>/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>深度学习环境配置包括 <strong>显卡驱动 + anaconda + cuda + cudnn + pytorch/tensorflow（GPU版）</strong></p>
<a id="more"></a>

<p>它们之间的关系如下：</p>
<p><strong>cuda版本与显卡驱动有关</strong>，在<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">这里</a>可查看二者的版本关系</p>
<p><strong>cudnn与cuda版本有关</strong>，在<a href="https://developer.nvidia.com/rdp/cudnn-archive">这里</a>可查看二者的版本关系</p>
<p><strong>pytorch与cuda版本有关</strong>，在<a href="https://pytorch.org/get-started/previous-versions/">这里</a>可查看二者的版本关系</p>
<p><strong>tensorflow和gcc、cuda版本有关</strong>，在<a href="https://www.tensorflow.org/install/source#tested_build_configurations">这里</a>可查看它们的版本关系</p>
<p>因为实验室的服务器已经有同学在使用所以基本环境都已装好，只需在anaconda中创建一个新的虚拟环境安装pytorch/tensorflow即可，这样更方便更安全，避免和其他同学的环境产生冲突。所以这里也只记录了在显卡驱动、anaconda、cuda、cudnn都已装好的服务器中，第一次使用前所需要做的准备。</p>
<p>（由于笔记本使用win10系统，实验室台式机使用Linux系统，所以文中图片可能会出现两种系统下的截图，但两种系统下的方法是一样的）。在Windows系统中使用xshell远程连接服务器，Linux系统在终端或VsCode中可远程连接服务器。</p>
<h1 id="一、了解服务器基本信息"><a href="#一、了解服务器基本信息" class="headerlink" title="一、了解服务器基本信息"></a>一、了解服务器基本信息</h1><h2 id="1、硬盘大小及剩余容量"><a href="#1、硬盘大小及剩余容量" class="headerlink" title="1、硬盘大小及剩余容量"></a>1、硬盘大小及剩余容量</h2><p><code>df -lh</code></p>
<h2 id="2、显卡信息"><a href="#2、显卡信息" class="headerlink" title="2、显卡信息"></a>2、显卡信息</h2><p><code>lspci | grep -i nvidia</code> 或 <code>lspci | grep -i vga</code></p>
<h2 id="3、显卡驱动"><a href="#3、显卡驱动" class="headerlink" title="3、显卡驱动"></a>3、显卡驱动</h2><p><code>nvidia-smi</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nvidia-smi.png" alt="nvidia-smi"></p>
<h2 id="4、查看cuda版本"><a href="#4、查看cuda版本" class="headerlink" title="4、查看cuda版本"></a>4、查看cuda版本</h2><p><code>nvcc -V</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nvcc.png" alt="nvcc"></p>
<h2 id="5、查看cudnn版本"><a href="#5、查看cudnn版本" class="headerlink" title="5、查看cudnn版本"></a>5、查看cudnn版本</h2><p><code>cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</code></p>
<h2 id="6、查看gcc版本"><a href="#6、查看gcc版本" class="headerlink" title="6、查看gcc版本"></a>6、查看gcc版本</h2><p><code>gcc -v</code></p>
<h1 id="二、在Anaconda中创建个人环境"><a href="#二、在Anaconda中创建个人环境" class="headerlink" title="二、在Anaconda中创建个人环境"></a>二、在Anaconda中创建个人环境</h1><h2 id="1、创建新环境"><a href="#1、创建新环境" class="headerlink" title="1、创建新环境"></a>1、创建新环境</h2><p><code>conda create -n xwj_pytorch python=3.6</code></p>
<h2 id="2、进入环境"><a href="#2、进入环境" class="headerlink" title="2、进入环境"></a>2、进入环境</h2><p><code>conda activate xwj_pytorch</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/activate.png" alt="activate"></p>
<h2 id="3、在虚拟环境中安装pytorch"><a href="#3、在虚拟环境中安装pytorch" class="headerlink" title="3、在虚拟环境中安装pytorch"></a>3、在虚拟环境中安装pytorch</h2><p>在<a href="https://pytorch.org/get-started/previous-versions/">官网</a>查找对应cuda的pytorch版本</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/pytorch.png" alt="pytorch"></p>
<p>复制命令在终端执行，即可完成安装</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/installpytorch.png" alt="installpytorch"></p>
<p>进入虚拟环境中的python，检查pytorch是否安装成功是否可用</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/checkpytorch.png" alt="checkpytorch"></p>
<p>pytorch中可通过如下代码查看可用显卡的数量和信息</p>
<pre><code>import torch
print([torch.cuda.get_device_properties(i) for i in range(torch.cuda.device_count())])</code></pre>
<p>pytorch中设置可用显卡</p>
<pre><code>import os
os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0,1&#39;</code></pre>
<h2 id="4、安装tensorflow"><a href="#4、安装tensorflow" class="headerlink" title="4、安装tensorflow"></a>4、安装tensorflow</h2><p>查看gcc版本 <code>gcc -v</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/gcc.png" alt="gcc"></p>
<p>在<a href="https://www.tensorflow.org/install/source#tested_build_configurations">tensorflow官网</a>查看版本匹配</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/tfversion.png" alt="tfversion"></p>
<p>为了避免和其他环境中的模块版本产生冲突，可按照1、2步骤重新创建一个新的虚拟环境，并进入该虚拟环境</p>
<p>创建环境 <code>conda create -n xwj_tensorflow python=3.6</code></p>
<p>进入环境 <code>conda activate xwj_tensorflow</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/activatetf.png" alt="activatetf"></p>
<p>安装GPU版tensorflow <code>conda install tensorflow-gpu==2.0.0</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/installtf.png" alt="installtf"></p>
<p>参照3中的方法进入虚拟环境的python，检查tensorflow是否安装成功，是否可用</p>
<h1 id="三、VsCode的使用"><a href="#三、VsCode的使用" class="headerlink" title="三、VsCode的使用"></a>三、VsCode的使用</h1><p>可以使用Pycharm或Vscode作为本地的python代码编辑器。因为还要远程连接服务器，而Pycharm中只有pro版有此功能，虽然可以使用学生身份申请免费使用pro版，但是为了方便这里直接用vscode。下面列出了使用vscode时遇到的一些问题。</p>
<h2 id="1、在vscode中使用anaconda环境里的python解释器无效"><a href="#1、在vscode中使用anaconda环境里的python解释器无效" class="headerlink" title="1、在vscode中使用anaconda环境里的python解释器无效"></a>1、在vscode中使用anaconda环境里的python解释器无效</h2><p>vscode中可点击左下角选择python解释器。在确保已前面步骤都正确，但是选择anaconda中已安装好的pytorch虚拟环境里的python解释器后，运行代码时仍出现如下报错 </p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nomodule.png" alt="nomodule"></p>
<p><strong>解决：</strong>在setting.json文件中注释掉原来的 <code>python.pythonPath</code>，添加如下代码，其中第七项 <code>“python”</code> 更改为anaconda中虚拟环境里python的路径</p>
<pre><code>&#123;
    // &quot;python.pythonPath&quot;: &quot;/home/lab406/anaconda3/envs/pytorch/bin/python&quot;
    &quot;code-runner.executorMap&quot;: &#123;
        &quot;javascript&quot;: &quot;node&quot;,
        &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,
        &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; gcc -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;php&quot;: &quot;php&quot;,
        &quot;python&quot;: &quot;~/anaconda3/envs/pytorch/bin/python&quot;,
        &quot;perl&quot;: &quot;perl&quot;,
        &quot;perl6&quot;: &quot;perl6&quot;,
        &quot;ruby&quot;: &quot;ruby&quot;,
        &quot;go&quot;: &quot;go run&quot;,
        &quot;lua&quot;: &quot;lua&quot;,
        &quot;groovy&quot;: &quot;groovy&quot;,
        &quot;powershell&quot;: &quot;powershell -ExecutionPolicy ByPass -File&quot;,
        &quot;bat&quot;: &quot;cmd /c&quot;,
        &quot;shellscript&quot;: &quot;bash&quot;,
        &quot;fsharp&quot;: &quot;fsi&quot;,
        &quot;csharp&quot;: &quot;scriptcs&quot;,
        &quot;vbscript&quot;: &quot;cscript //Nologo&quot;,
        &quot;typescript&quot;: &quot;ts-node&quot;,
        &quot;coffeescript&quot;: &quot;coffee&quot;,
        &quot;scala&quot;: &quot;scala&quot;,
        &quot;swift&quot;: &quot;swift&quot;,
        &quot;julia&quot;: &quot;julia&quot;,
        &quot;crystal&quot;: &quot;crystal&quot;,
        &quot;ocaml&quot;: &quot;ocaml&quot;,
        &quot;r&quot;: &quot;Rscript&quot;,
        &quot;applescript&quot;: &quot;osascript&quot;,
        &quot;clojure&quot;: &quot;lein exec&quot;,
        &quot;haxe&quot;: &quot;haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt&quot;,
        &quot;rust&quot;: &quot;cd $dir &amp;&amp; rustc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;racket&quot;: &quot;racket&quot;,
        &quot;scheme&quot;: &quot;csi -script&quot;,
        &quot;ahk&quot;: &quot;autohotkey&quot;,
        &quot;autoit&quot;: &quot;autoit3&quot;,
        &quot;dart&quot;: &quot;dart&quot;,
        &quot;pascal&quot;: &quot;cd $dir &amp;&amp; fpc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;d&quot;: &quot;cd $dir &amp;&amp; dmd $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;haskell&quot;: &quot;runhaskell&quot;,
        &quot;nim&quot;: &quot;nim compile --verbosity:0 --hints:off --run&quot;,
        &quot;lisp&quot;: &quot;sbcl --script&quot;,
        &quot;kit&quot;: &quot;kitc --run&quot;,
        &quot;v&quot;: &quot;v run&quot;,
        &quot;sass&quot;: &quot;sass --style expanded&quot;,
        &quot;scss&quot;: &quot;scss --style expanded&quot;
    &#125;,
    &quot;code-runner.runInTerminal&quot;: false
&#125;</code></pre>
<p>保存后再次运行如下代码</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/checkvscode.png" alt="checkvscode"></p>
<p>可正常使用了（若依然无法使用则重新启动VsCode即可）</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/vscodenormal.png" alt="vscodenormal"></p>
<h2 id="2、在vscode中远程连接服务器"><a href="#2、在vscode中远程连接服务器" class="headerlink" title="2、在vscode中远程连接服务器"></a>2、在vscode中远程连接服务器</h2><p>首先在vscode中安装 Remote - SSH 插件</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/remotessh.png" alt="remotessh"></p>
<p>点击Configure图标，选择ssh配置</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/configssh.png" alt="configssh"></p>
<p>输入主机名称（自定义）、主机IP、用户名、端口号（可选）</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sshinfo.png" alt="sshinfo"></p>
<p>点击该主机名，右键可选择在当前窗口或新窗口连接服务器</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/connecthost.png" alt="connecthost"></p>
<p>然后输入密码登录服务器</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/hostpassword.png" alt="hostpassword"></p>
<h2 id="3、同步本地代码到服务器"><a href="#3、同步本地代码到服务器" class="headerlink" title="3、同步本地代码到服务器"></a>3、同步本地代码到服务器</h2><h3 id="（1）安装SFTP插件"><a href="#（1）安装SFTP插件" class="headerlink" title="（1）安装SFTP插件"></a>（1）安装SFTP插件</h3><p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sftp.png" alt="sftp"></p>
<h3 id="（2）配置"><a href="#（2）配置" class="headerlink" title="（2）配置"></a>（2）配置</h3><p>输入 <code>ctrl+shift+p</code>打开输入框输入 <code>SFTP:Config</code>，此时会在 .vscode 目录下生成 sftp.json 文件，配置主机名称、IP、协议、端口、用户名、远程同步地址、本地保存时是否同步上传到服务器（不包括重命名和删除操作）、上传时忽略的文件 </p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sftpjson.png" alt="sftpjson"></p>
<h3 id="（3）上传"><a href="#（3）上传" class="headerlink" title="（3）上传"></a>（3）上传</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>输入 <code>ctrl+shift+p</code>打开输入框输入 <code>SFTP:Upload Project</code>，然后选择要上传的项目文件夹，再输入服务器密码即可</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>在命令行中</p>
<p>上传文件夹 <code>scp -r xxx/xxx/文件夹/ 用户名@IP地址:/home/xxx/存放文件夹的目录</code></p>
<p>上传文件夹中所有文件 <code>scp xxx/xxx/文件夹/* 用户名@IP地址:/home/xxx/存放文件的目录</code></p>
<p>上传文件 <code>scp 文件1 文件2 文件n 用户名@IP地址:/home/xxx/存放文件的目录</code></p>
<p><strong>遇到的问题：</strong>在上传时，若遇到服务器文件夹为 root 用户创建则无法写入，会出现 “Permission denied, please try again”错误。</p>
<p><strong>解决：</strong>在服务器上为文件夹授权， <code>chmod 777 由root创建的文件夹</code></p>
<p>然后可在xshell登录服务器或在vscode中连接登录服务器打开文件夹，进入虚拟环境，运行代码</p>
<h2 id="4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError-No-module-named-‘xxx’"><a href="#4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError-No-module-named-‘xxx’" class="headerlink" title="4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError: No module named ‘xxx’"></a>4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError: No module named ‘xxx’</h2><p>假设文件目录为</p>
<pre><code>-project
  --dir1
    ---file1.py
  --dir2
    ---file2.py</code></pre>
<p>在file2.py中使用<code>from dir1.file1 import xxx</code>导入file1.py里定义的变量或函数时出现报错 ModuleNotFoundError: No module named ‘dir1’</p>
<p><strong>解决：</strong>在import之前将文件目录所在路径添加到搜索路径中</p>
<pre><code>import os
import sys 
sys.path.insert(0,os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from dir1.file1 import xxx</code></pre>
<p>这里是把项目 project 的绝对路径插入搜索路径中的第一个位置</p>
<p>其中<code>os.path.abspath(__file__)</code>表示 file2.py 所在的绝对路径</p>
<p><code>os.path.dirname(os.path.abspath(__file__))</code>为 dir2 目录的绝对路径</p>
<p><code>os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</code>为项目 project 的绝对路径</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习包的使用杂记</title>
    <url>/2021/07/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Numpy"><a href="#一、Numpy" class="headerlink" title="一、Numpy"></a>一、Numpy</h1><h2 id="向量、矩阵点乘与叉乘"><a href="#向量、矩阵点乘与叉乘" class="headerlink" title="向量、矩阵点乘与叉乘"></a>向量、矩阵点乘与叉乘</h2><h3 id="点乘：内积、数量积，两向量若垂直点积为0，-a-b-cos-theta"><a href="#点乘：内积、数量积，两向量若垂直点积为0，-a-b-cos-theta" class="headerlink" title="点乘：内积、数量积，两向量若垂直点积为0，|a||b|cos(theta)"></a>点乘：内积、数量积，两向量若垂直点积为0，|a||b|cos(theta)</h3><p>向量：<code>np.dot</code>——相同位置元素相乘后求和——结果是标量，<code>*</code>——相同位置元素相乘——结果与原向量大小相同</p>
<a id="more"></a>

<p>矩阵：<code>*</code>或<code>np.multiply</code>——相同位置元素相乘——结果是矩阵，与原矩阵大小相同</p>
<h3 id="叉乘：向量积、外积，两向量若平行叉积为0，-a-b-sin-theta"><a href="#叉乘：向量积、外积，两向量若平行叉积为0，-a-b-sin-theta" class="headerlink" title="叉乘：向量积、外积，两向量若平行叉积为0，|a||b|sin(theta)"></a>叉乘：向量积、外积，两向量若平行叉积为0，|a||b|sin(theta)</h3><p>向量：<code>np.cross</code>——二维平面向量叉乘结果的长度为组成的四边形面积，多维向量叉乘得到法向量</p>
<p>矩阵：<code>np.dot</code>——矩阵1每行与矩阵2每列相乘</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu系统下搭建深度学习环境</title>
    <url>/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>重装了系统又要重新搭建深度学习环境包括安装 显卡驱动 + anaconda + cuda + cudnn + pytorch/tensorflow（GPU版）</p>
<a id="more"></a>

<h1 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h1><p>查看主机上是否有显卡 <code>lspci | grep -i nvidia</code></p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvidia.png" alt="nvidia"></p>
<p>在<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">NVIDIA官网</a>上选择与电脑显卡相匹配的驱动并下载</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvidiadriver.png" alt="nvidiadriver"></p>
<p><strong>禁用自带的驱动</strong></p>
<p>在禁用前查看自带驱动 <code>lsmod | grep nouveau</code></p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/lsmod.png" alt="lsmod"></p>
<p>打开文件 <code>sudo gedit /etc/modprobe.d/blacklist.conf</code></p>
<p>在文件末尾添加如下内容并保存后退出</p>
<pre><code>blacklist nouveau
options nouveau modeset=0</code></pre>
<p>更新修改 <code>sudo update-initramfs -u</code>，并重启电脑</p>
<p>禁用后查看驱动 <code>lsmod | grep nouveau</code> 将不会有任何信息</p>
<p>安装ligntdm <code>sudo apt install -y lightdm</code></p>
<p>关闭系统图形化界面 <code>sudo service lightdm stop</code>，若未能关闭则重启在登录界面按“ctrl+alt+F1”</p>
<p>查看是否安装gcc <code>gcc --version</code></p>
<p>若未安装则先安装 gcc <code>sudo apt install gcc</code>，再安装 make <code>sudo apt install make</code>，否则安装驱动时会报错</p>
<p>cd 进入存放下载的驱动文件位置</p>
<p>给驱动文件赋予权限 <code>sudo chmod a+x 驱动文件名</code></p>
<p>安装驱动 <code>sudo ./驱动文件名 -no-x-check -no-nouveau-check -no-opengl-files</code></p>
<p>安装时会遇到如下选择</p>
<pre><code>“Install NVDIA‘s 32-bit compatibility libraries？”
————可选择“No”

“Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up.”
————选择“Yes”</code></pre>
<p>查看显卡驱动是否安装成功 <code>nvidia-smi</code></p>
<p>安装完成后重新打开系统图像界面  <code>sudo service lightdm start</code></p>
<p>重启电脑 <code>sudo reboot</code></p>
<h1 id="安装-CUDA"><a href="#安装-CUDA" class="headerlink" title="安装 CUDA"></a>安装 CUDA</h1><p>根据<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">CUDA 与显卡驱动版本间的关系</a> ，在<a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA DEVELOPER网站</a>上选择相应 CUDA 版本进行下载，这里我选择 CUDA 10.2</p>
<p>由于安装最新驱动 470.74，和 gcc 9.3.0</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/gcc9.png" alt="gcc9"></p>
<p>而根据<a href="https://docs.nvidia.com/cuda/archive/10.2/cuda-installation-guide-linux/index.html">CUDA 10.2的Versioned Online Documentation-Installation Guide Linux</a>中的表格可以看到与 CUDA 10.2匹配的 gcc 版本为7.x.x，而后续安装 tensorflow 时 2.0.0 以上版本匹配的 gcc 版本为7.3.1，所以需要对 gcc 进行降级，并安装 g++ 7</p>
<pre><code>sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 1
sudo update-alternatives --display gcc</code></pre>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/gcc7.png" alt="gcc7"></p>
<p>可以看到 gcc 9的优先级为1，gcc 7的优先级为9</p>
<p>如果系统已安装 g++，同样也要设置 g++ 7为更高的优先级（把上述后三条命令中“gcc”改为“g++”即可）</p>
<p>在<a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA DEVELOPER网站</a>上根据自己的系统选择相应 CUDA 版本进行下载，虽然我的 Ubuntu 系统为20.04，这里只要选择 18.04 即可，按照网页下方给的命令进行下载和安装</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudadownload.png" alt="cudadownload"></p>
<p>安装时会遇到如下选择</p>
<pre><code>“Do you accept the above EULA?”
————输入 accept

“CUDA Installer”
————回车去掉“Driver”前的“X”，再选择“Install”回车</code></pre>
<p>配置环境 CUDA 变量</p>
<p>打开环境变量配置文件 <code>gedit ~/.bashrc</code></p>
<p>在该文件末尾添加如下内容后保存并退出</p>
<pre><code>export PATH=/usr/local/cuda-前两位版本号/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;
export LD_LIBRARY_PATH=/usr/local/cuda-前两位版本号/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</code></pre>
<p>更新生效配置 <code>source ~/.bashrc</code></p>
<p>此时输入 <code>nvcc -V</code> 可以看到输出对应 CUDA 版本，表示安装成功</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvcc.png" alt="nvcc"></p>
<h1 id="安装-cuDNN"><a href="#安装-cuDNN" class="headerlink" title="安装 cuDNN"></a>安装 cuDNN</h1><p>在<a href="https://developer.nvidia.com/rdp/cudnn-archive">官网</a>下载与 CUDA 版本匹配的 cuDNN，选择其中的“cuDNN Library for Linux”下载</p>
<p>解压压缩包 <code>tar -xzvf 压缩包</code></p>
<p>拷贝文件</p>
<pre><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/
sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code></pre>
<p>文件权限授权</p>
<pre><code>sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</code></pre>
<p>接着测试，进入“/home/NVIDIA_CUDA-版本号_Samples”，执行 <code>make</code> 进行编译</p>
<p>进入“/home/NVIDIA_CUDA-版本号_Samples/1_Utilities/deviceQuery”执行 <code>./deviceQuer</code>，看到“Result = PASS”结果即为成功</p>
<p>进入“/home/NVIDIA_CUDA-版本号_Samples/1_Utilities/bandwidthTest”执行 <code>./bandwidthTest</code>，看到“Result = PASS”结果即为成功</p>
<h1 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h1><p>在<a href="https://www.anaconda.com/products/individual#download-section">官网</a>或<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&O=D">清华大学开源软件镜像站</a>下载 .sh 安装脚本</p>
<p>执行该 .sh 安装脚本 <code>bash Anaconda3-2021.05-Linux-x86_64.sh</code></p>
<p>安装时会出现“Do you wish the installer to initialize Anaconda3 by running conda init？”，选择“yes”将会自动添加环境变量配置</p>
<p>并输入 <code>source ~/.bashrc</code> 更新配置使其生效</p>
<h1 id="安装-Pytorch、tensorflow"><a href="#安装-Pytorch、tensorflow" class="headerlink" title="安装 Pytorch、tensorflow"></a>安装 Pytorch、tensorflow</h1><p>根据我的<a href="https://beingjay.com/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#more">这篇博客</a>在 anaconda 中创建个人环境并安装即可</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p><strong>问题1：</strong>如果安装 CUDA 时一次没有成功，第二次安装会报如下错误</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudainstallfailed.png" alt="cudainstallfailed"></p>
<p><strong>解决：</strong>将官方给的安装命令 <code>sudo sh cuda_10.2.89_440.33.01_linux.run</code> 更改为 <code>sudo sh cuda_10.2.89_440.33.01_linux.run ----librarypath=/usr/local/cuda-10.2</code></p>
<p><strong>问题2：</strong>在安装完 cuDNN 后进行测试时，执行 <code>make</code> 进行编译可能会出现如下错误，这是由于CUDA 10.2 toolkit中包含的cudaNvSci sample需要一个新的NvStreams开发包，目前为还未发布</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudnnmakeerror.png" alt="cudnnmakeerror"></p>
<p><strong>解决：</strong>换用 <code>make -k</code> 忽略该错误进行编译</p>
<h1 id="卸载-Anaconda-的方法（做个记录）"><a href="#卸载-Anaconda-的方法（做个记录）" class="headerlink" title="卸载 Anaconda 的方法（做个记录）"></a>卸载 Anaconda 的方法（做个记录）</h1><p>删除“anaconda3”文件夹，并删除“~/.bashrc”环境变量配置文件末尾的 anaconda 路径配置</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记1</title>
    <url>/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>JavaScript 在1995年由网景公司发明，1996年生成 ECMAScript 标准，不同浏览器对该标准的实现不同，如 FireFox 使用 SpiderMonkey 引擎，Chrome 使用 v8 引擎（Nodejs也是）</p>
<a id="more"></a>

<h1 id="一、JavaScript组成"><a href="#一、JavaScript组成" class="headerlink" title="一、JavaScript组成"></a>一、JavaScript组成</h1><h2 id="1、JS的组成"><a href="#1、JS的组成" class="headerlink" title="1、JS的组成"></a>1、JS的组成</h2><p>JavaScript 包含三部分：ECMAScript（标准）+ DOM（文档对象模型）+BOM（浏览器对象模型）</p>
<h2 id="2、JS的特点"><a href="#2、JS的特点" class="headerlink" title="2、JS的特点"></a>2、JS的特点</h2><p>（1）解释型语言，无需编译</p>
<p>（2）类似 C 和 Java 的语法结构</p>
<p>（3）动态语言</p>
<p>（4）基于原型的面向对象</p>
<p>注意：JS 中严格区分大小写</p>
<h2 id="3、在网页中使用-JS"><a href="#3、在网页中使用-JS" class="headerlink" title="3、在网页中使用 JS"></a>3、在网页中使用 JS</h2><p>（1）可将 JS 代码编写到标签的 <code>onclick</code> 属性中，如 <code>&lt;button onclick=&quot;alert(&quot;xxxx&quot;);&quot;&gt;按钮&lt;/button&gt;</code></p>
<p>（2）可将 JS 代码写在超链接的 <code>href</code> 属性中，点击超链接时会执行 JS 代码，如 <code>&lt;a href=&quot;javascript:alert(&quot;xxxx&quot;);&quot;&gt;超链接&lt;/a&gt;</code></p>
<p>（3）通过 <code>&lt;script&gt;</code> 标签中写 JS 代码， 如<code>&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;xxxx&quot;);&lt;/script&gt;</code></p>
<p>（4）通过 <code>&lt;script&gt;</code> 标签引入外部 JS 文件，<code>&lt;script type=&quot;text/javascript&quot; src=&quot;./xxx.js&quot;&gt;&lt;/script&gt;</code></p>
<p>注意1：第一、二种方法把 JS 写在标签的书中属于结构与行为耦合，不方便维护，而把 JS 写到外部文件中可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>注意2：一个 <code>&lt;script&gt;</code> 标签一旦用于引入外部文件，就不能在其中编写 JS 代码了，即使写了浏览器也会忽略，但若再创建一个 <code>&lt;script&gt;</code> 标签其中的内部 JS 代码可执行</p>
<h1 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h1><h2 id="1、输出与输入"><a href="#1、输出与输入" class="headerlink" title="1、输出与输入"></a>1、输出与输入</h2><p>alert(“xxxxxx”);  //控制浏览器弹出警告框</p>
<p>document.write(“xxxx”);  //向 body 中输出内容，当要换行时不能用 document.write(“xxxx”+”\n”); 而要用 document.write(“xxxx”+”<br>“); </p>
<p>console.log(“xxx”);   //向控制台输出内容</p>
<p>prompt(“提示文字”);   //用户可输入字符串，用户输入内容会以 String 类型作为函数返回值返回</p>
<p>通过类型转换 +prompt(“提示文字”); 会把字符串转为 Number，可用于输入数字</p>
<h2 id="2、字面量和变量"><a href="#2、字面量和变量" class="headerlink" title="2、字面量和变量"></a>2、字面量和变量</h2><h3 id="（1）字面量"><a href="#（1）字面量" class="headerlink" title="（1）字面量"></a>（1）字面量</h3><p>字面量是一些不可改变的值，字面量都是可直接使用的（但一般不会直接使用，而是通过变量）</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>字面量类型（数据类型）六种：
    String     字符串
    Number     数值
    Boolean    布尔值
    Null       空值，专门用来表示一个为空的对象，typeof 检查一个 null 值会返回 object
    Undefined  未定义，typeof 检查一个 null 值会返回 undefined
    Object     对象
    Symbol     ES6 中引入的新类型
其中 String、Number、Boolean、Null、Undefined 是基本数据类型，Object 属于引用数据类型</code></pre>
<p>可利用 <code>typeof 变量名</code>来查看变量的数据类型，它会将变量的类型以字符串形式返回</p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><pre><code>Number.MAX_VALUE  数字的最大值，若数字超过最大值，会返回
Number.MIN_VALUE  最小的正值，大于 0 的最小值
Infinity   表示正无穷
Infinity   正无穷，也属于数字类型
-Infinity  负无穷
NaN        表示 Not A Number，也属于数字类型</code></pre>
<p>在 JS 中整数运算基本可保证精确，但浮点数运算可能得到不精确结果，因此不要用 JS 进行对精确度要求较高的运算</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><h6 id="1-转换为字符串-String"><a href="#1-转换为字符串-String" class="headerlink" title="1. 转换为字符串 String"></a>1. 转换为字符串 String</h6><p><strong>方式一：</strong>调用 <code>变量.toString()</code>，该方法不会影响原变量，会将转换的结果返回，且 <strong>null 和 undefined 没有 toString() 方法</strong>，若调用会报错</p>
<p><strong>方式二：</strong>调用 <code>String(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回，且<strong>该方式对 null 和 undefined 有效</strong></p>
<p><strong>方式三：</strong>隐式类型转换，将任意数据类型 + 一个 <code>&quot;&quot;</code>，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>String()</code> 函数</p>
<h6 id="2-转换为数字-Number"><a href="#2-转换为数字-Number" class="headerlink" title="2. 转换为数字 Number"></a>2. 转换为数字 Number</h6><p><strong>方式一：</strong>使用 <code>Number(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p>— 若字符串中有非数字内容则转为 NaN，若字符串为空串或是全为空格的字符串会转为 0</p>
<p>— 对于布尔值，true 转为 1，false 转为 0</p>
<p>— null 会转为 0</p>
<p>— undefined 会转为 NaN</p>
<p><strong>方式二：</strong>针对字符串</p>
<p><code>parseInt(变量,进制)</code>可将字符串中的有效整数内容取出并转为 Number，第二个参数可不写，如 “123px” 会转为 123，“123a567” 会转为 123</p>
<p><code>parseFloat(变量)</code>可将字符串中的有效小数内容取出并转为 Number，如 “123.456.789px” 会转为 123.456</p>
<p>若对非 String 使用 <code>parseInt()</code> 或 <code>parseFloat()</code>会先将其转为 String 然后再操作</p>
<p><strong>方式三：</strong>隐式类型转换，可通过一个值 <code>-0</code> 或 <code>*1</code> 或 <code>/1</code> 来将其转为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<p><strong>方式四：</strong>隐式类型转换，将任意数据类型使用 <code>+</code> 来将其转换为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<h6 id="3-转换为布尔-Boolean"><a href="#3-转换为布尔-Boolean" class="headerlink" title="3. 转换为布尔 Boolean"></a>3. 转换为布尔 Boolean</h6><p><strong>方式一：</strong>调用 <code>Boolean(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p><strong>方式二：</strong>隐式类型转换，可通过为任意数据类型取两次反来将其转为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Boolean()</code> 函数</p>
<p>对于数字 —&gt; 布尔，除了 0 和 NaN，其余都是 true</p>
<p>对于字符串 —&gt; 布尔，除了空串，其余都是 true</p>
<p>null 和 undefined 都会转为 false</p>
<p>对象也会转换为 true</p>
<h4 id="其他进制数字"><a href="#其他进制数字" class="headerlink" title="其他进制数字"></a>其他进制数字</h4><p>JS 中十六进制数字需以 <code>0x</code> 开头，八进制数字需以 <code>0</code> 开头，二进制需以 <code>0b</code> 开头（二进制表示方法浏览器兼容性不好）</p>
<p>注意 <code>a=070</code> 表示八进制，而字符串 <code>a=&quot;070&quot;</code> 转为数字时有些浏览器会当八进制，有些会当十进制转换，可在 <code>parseInt(变量,进制)</code> 中传递进制参数来解决</p>
<h3 id="（2）变量"><a href="#（2）变量" class="headerlink" title="（2）变量"></a>（2）变量</h3><p>变量可用来保存和描述字面量，且变量值可任意改变</p>
<h2 id="3、标识符"><a href="#3、标识符" class="headerlink" title="3、标识符"></a>3、标识符</h2><p>所有可自主命名的都是标识符，如变量名、函数名、属性名</p>
<p>规则：（1）可含有字母、数字、_、$</p>
<p>（2）不能以数字开头</p>
<p>（3）不能是 JS 中的关键字或保留字，如下图</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97.png" alt="关键字和保留字"></p>
<p>（4）一般都采用驼峰命名法：首字母小写，每个单词开头字母大写，其余字母小写</p>
<p>除了（4），其他都是强制要求</p>
<p><strong>注意：JS 底层保存标识符时是采用 Unicode 编码，所以理论上所有 utf-8 中含有的内容都可以作为标识符</strong></p>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="（1）二元运算符"><a href="#（1）二元运算符" class="headerlink" title="（1）二元运算符 + - * /"></a>（1）二元运算符 + - * /</h3><p>当对非 Number 类型的值进行运算时，会先将这些值转换为 Number 再运算（除了 Number 和字符串做<strong>加法</strong>以外），Number 和 字符串做减法/乘法等都是转换为 Number</p>
<p>任何值和 NaN 做运算结果都为 NaN</p>
<p>若对两个字符串作假发，则会把两个字符串拼接为一个字符串</p>
<p>任何值和字符串做加法，都会先转换为字符串，然后再和字符串作拼串操作（可用于 String 强制类型转换）</p>
<p>注意<br>    result = 1 + 2 + “3”;   //结果是“33”<br>    result = “1” + 2 + 3;   //结果是“123”</p>
<p>任何值做 - * / 都会自动转换为 Number（可用于 Number 强制类型转换）</p>
<h3 id="（2）一元运算符"><a href="#（2）一元运算符" class="headerlink" title="（2）一元运算符"></a>（2）一元运算符</h3><p><code>+</code> 正号不会对数字产生影响，<code>-</code> 负号可以对数字取反</p>
<p>对于非 Number 类型的值，会将其先转换为 Number 再运算（可用于 Number 强制类型转换）</p>
<pre><code>result = 1 + &quot;2&quot; + 3;   //结果是“123”
result = 1 + +&quot;2&quot; + 3;   //结果是6</code></pre>
<p>自增/减分为两种：后++（a++）或后–（a–）和前++（++a）或前–（–a），两种值不同</p>
<p>— <code>a++</code>和<code>a--</code>的值等于原变量的值（自增/减前的值）</p>
<p>— <code>++a</code>和<code>--a</code>的值等于原变量新值（自增/减后的值）</p>
<pre><code>var a = 20;
console.log(a++ + ++a + a);  //结果为 20 + 22 + 22
var b = 20;
b = b++;   //结果为 20，因为 b++ 的值为 20</code></pre>
<h3 id="（3）条件（三元）运算符"><a href="#（3）条件（三元）运算符" class="headerlink" title="（3）条件（三元）运算符"></a>（3）条件（三元）运算符</h3><p>语法 <code>条件表达式 ? 语句1 : 语句2;</code>，若条件表达式是非布尔值，则会将其转换为布尔值再比较</p>
<h3 id="（4）逻辑运算符"><a href="#（4）逻辑运算符" class="headerlink" title="（4）逻辑运算符"></a>（4）逻辑运算符</h3><p><code>!</code> 对非布尔值进行运算都会将其转换为布尔值，然后再取反（可用于 Boolean 强制类型转换）</p>
<p>JS 中的 “与&amp;&amp;” 属于短路的 “与”，（即若第一个值为 false 则不会再检查第二个）</p>
<p>JS 中的 “或||” 属于短路的 “或”，（即若第一个值为 true 则不会再检查第二个）</p>
<p>对于非布尔值进行与或运算都会将其转换为布尔值，并返回转换前的值</p>
<p>与运算：若两个值都为 true，则返回后面的值，若两个值中有 false，则返回靠前的 false（即若第一个值为 true 则必然返回第二个值，若第一个值为 false 则直接返回第一个值）</p>
<p>或运算：若两个值都为 false，则返回后面的值，若两个值中有 true，则返回靠前的 true（即若第一个值为 false 则必然返回第二个值，若第一个值为 true 则直接返回第一个值）</p>
<h3 id="（5）关系运算符"><a href="#（5）关系运算符" class="headerlink" title="（5）关系运算符"></a>（5）关系运算符</h3><p>对于非数值进行 &gt; &gt;= &lt; &lt;= 比较时，会将其转换为数字然后再比较</p>
<p>若比较符号两侧都是字符串时不会将其转换为数字，而会分别比较字符串中字符的 Unicode 编码，比较字符编码时是一位一位比较，若两位一样则比较下一位，否则直接返回比较结果（可利用该特性对英文进行排序，比较中文没有意义）</p>
<p>在比较两个字符串型的数字时，一定要转型，转型后比较的就是数字大小，否则会一位一位比较字符串编码</p>
<p>任何值和 NaN 做任何比较都是 false</p>
<pre><code>1 &gt; true     //false
1 &gt;= true     //true
10 &gt; null     //true
10 &gt; &quot;hello&quot;  //false 相当于比较 10 &gt; NaN</code></pre>
<h3 id="（6）相等运算符"><a href="#（6）相等运算符" class="headerlink" title="（6）相等运算符"></a>（6）相等运算符</h3><p>当使用 <code>==</code> 或 <code>!=</code> 比较时若值的类型不同，则会自动进行类型转换，将其转换为相同类型后再比较</p>
<p>undefined 衍生自 null，所以这两个值做相等判断时会返回 true</p>
<p>NaN 不和任何值相等，包括它本身，通过 <code>isNaN()</code> 函数判断一个值是否是 NaN</p>
<pre><code>&quot;1&quot; == 1      //true，转为 Number 比较
true == &quot;1&quot;   //true，二者都转为 Number
null == 0     //false 注意
undefined == null  //true
Nan == Nan    //false</code></pre>
<p><code>===</code> 全等，和 <code>==</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 false；<code>!==</code> 不全等，和 <code>!=</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 true</p>
<pre><code>undefined === null  //false</code></pre>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>使用 <code>,</code> 可同时声明多个变量并赋值，如<code>var a=1,b=2,c=3</code></p>
<h2 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h2><p>运算符优先如下图，越靠上优先级越高</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p>
<h2 id="6、代码块"><a href="#6、代码块" class="headerlink" title="6、代码块"></a>6、代码块</h2><p>JS 中可使用 <code>&#123;&#125;</code> 为语句分组，同一个 <code>&#123;&#125;</code> 中的语句称为一个代码块，要么都执行，要么都不执行</p>
<p>JS 中的代码块只有分组的作用，没有其他用途，代码块内部的内容在外部是完全可见的</p>
<p>代码块后不用写 <code>;</code></p>
<h2 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h2><p>语句分类：条件判断语句、条件分支语句、循环语句</p>
<p>switch…case 语句中的条件判断是采用全等</p>
<p>for 循环中 <code>()</code> 内三个部分都可以省略，也可以写在外部，若在 for 循环中不写任何表达式，只写两个 <code>;</code> 是个死循环，慎用</p>
<p>可为循环语句创建一个 label，来标识当前循环，用法为 <code>标签名:循环语句</code>，使用 break 或 continue 语句时，可在 break 或 continue 后跟着一个 label，此时 break 将会结束指定的循环，或 continue 将会跳过当前的指定循环，而不是最近的循环</p>
<pre><code>outer:
for(var i=0;i&lt;5;i++)&#123;
    语句...
    for(var j=0;j&lt;5;j++)&#123;
        break outer;  //此时 break 结束的是外层循环
    &#125;
&#125;</code></pre>
<h2 id="8、对象"><a href="#8、对象" class="headerlink" title="8、对象"></a>8、对象</h2><p>基本数据类型创建的变量都是独立的，不饿能成为一个整体</p>
<p>对象不是基本数据类型，而是引用数据类型，是复合数据类型</p>
<p>除了基本数据类型外一切都是对象，网页中看到的所有都是对象</p>
<h3 id="（1）对象的分类"><a href="#（1）对象的分类" class="headerlink" title="（1）对象的分类"></a>（1）对象的分类</h3><p><strong>内建对象</strong></p>
<p>由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用，如 Math、String、Number、Boolean、Function、Object 等</p>
<p><strong>宿主对象</strong></p>
<p>由 JS 的运行环境提供的对象，主要指由浏览器提供的对象，如 BOM、DOM，这是两组对象，由许多对象组成，如 console、document 都是由浏览器创建提供的，是宿主对象</p>
<p><strong>自定义对象</strong></p>
<p>由开发人员自己创建的对象</p>
<h3 id="（2）创建对象"><a href="#（2）创建对象" class="headerlink" title="（2）创建对象"></a>（2）创建对象</h3><p>使用 <code>new</code> 关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数</p>
<p>使用 <code>typeof</code> 检查一个对象时，会返回 object</p>
<h4 id="使用工厂方法创建对象"><a href="#使用工厂方法创建对象" class="headerlink" title="使用工厂方法创建对象"></a>使用工厂方法创建对象</h4><pre><code>function createPerson(name,age,gender)&#123;
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    obj.sayName = function()&#123;
        alert(this.name);
    &#125;
    return obj;
&#125;
var obj1 = createPerson(&quot;xxx&quot;,18,&quot;男&quot;); </code></pre>
<h4 id="创建构造函数来创建对象"><a href="#创建构造函数来创建对象" class="headerlink" title="创建构造函数来创建对象"></a>创建构造函数来创建对象</h4><p>使用同一个构造函数创建的对象称为一类对象，也将一个构造函数称为一个类，将通过构造函数创建的对象称为该类的实例</p>
<p>使用 <code>instanceof</code> 可检查一个对象是否是一个类的实例，<code>对象 instanceof 构造函数</code> 返回布尔值，所有对象都是 Object 的后代，所以任何对象和 Object 做 instanceof 检查时都会返回 true</p>
<p>构造函数就是一个普通函数，不同的是构造函数习惯上首字母大写。</p>
<p><strong>构造函数和普通函数的区别：</strong>普通函数直接调用，而构造函数需要使用 new 关键字调用</p>
<p><strong>构造函数执行流程：</strong></p>
<ol>
<li><p>立刻创建一个新的对象</p>
</li>
<li><p>将新建的对象设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象</p>
</li>
<li><p>逐行执行函数中的代码</p>
</li>
<li><p>将新建的对象作为返回值返回 </p>
<p> function Person(name,age,gender){</p>
<pre><code> this.name = name;
 this.age = age;
 this.gender = gender;
 this.sayName = function()&#123;
     alert(this.name);
 &#125;</code></pre>
<p> }<br> var per = new Person(“xxx”,18,”男”); </p>
</li>
</ol>
<p><strong>构造函数的方法定义</strong></p>
<p>在构造函数内部创建的方法，每执行一次构造函数就会创建一个新的相同方法，所有实例的该方法都是唯一的，这没有必要，所以可使所有对象共享同一个方法</p>
<p>方式一：将方法定义到全局作用域中</p>
<p>但是将函数定义到全局作用域中会污染了全局作用域的命名空间，并且也很不安全，容易被另一个程序猿覆盖</p>
<p>方式二：使用原型对象</p>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><p><code>var 对象名 = new Object();</code> 或 <code>var 对象名 = &#123;&quot;属性名1&quot;:属性值,属性名n:属性值&#125;;</code> 创建对象，第二种方式的对象也叫对象字面量，对象字面量的属性名可加引号也可不加，但若使用一些特殊名字时必须加引号</p>
<p><code>对象.属性名 = 属性值;</code> 向对象添加属性，对象的属性名不强制要求遵守标识符的规范，但尽量按照标识符的规范</p>
<p><code>对象[&quot;属性名&quot;] = 属性值;</code> 向对象添加属性，对于使用特殊的属性名时，不能采用 <code>.</code> 的方式操作</p>
<p><code>对象.属性名;</code> 读取对象中的属性，若读取对象中没有的属性不会报错，而会返回 undefined</p>
<p><code>对象[&quot;属性名&quot;]</code> 读取对象中的属性，这种方式更灵活，因为 <code>[]</code> 中可以传变量，而 <code>.</code> 的方式操作属性会需要准确的属性名。此外，对于使用 <code>对象[&quot;属性名&quot;] = 属性值;</code> 赋值的属性只能用这种方式读取属性</p>
<p><code>对象.属性名 = 新值;</code> 修改对象的属性值</p>
<p><code>delete 对象.属性名;</code> 删除对象的属性</p>
<p><code>&quot;属性名&quot; in 对象</code> 检查对象或其原型中是否含有某属性</p>
<p><code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查对象自身是否含有某属性</p>
<p>枚举对象的属性</p>
<pre><code>for(var 变量 in 对象)&#123;xxx&#125;
对象中有几个属性循环体就会执行几次，其中每次执行时就把对象中的一个属性名赋值给变量</code></pre>
<p>JS 对象的属性值可以是任意的数据类型，甚至也可以是一个对象（如函数）</p>
<p>若函数作为一个对象的属性，则称该函数是这个对象的方法，调用该函数称为调用对象的方法</p>
<h2 id="9、基本数据类型和引用数据类型"><a href="#9、基本数据类型和引用数据类型" class="headerlink" title="9、基本数据类型和引用数据类型"></a>9、基本数据类型和引用数据类型</h2><p>JS 中的变量都是保存到栈内存中，基本数据类型直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量</p>
<p>对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新空间，而变量保存的是对象的内存地址（对象的引用），若两个变量保存的是同一个对象引用，当通过一个变量修改该对象属性时，另一个也会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="基本数据类型和引用数据类型"></p>
<p>但是当两个变量表示同一个对象时，把其中一个变量值设为 null 后另一个变量依然指向对象不会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="基本数据类型和引用数据类型1"></p>
<p>当比较两个基本数据类型时就是比较它们的值，而比较两个引用数据类型时比较的是内存地址，即使两个对象内容一样，但地址不同依然会返回 false</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="基本数据类型和引用数据类型2"></p>
<h2 id="10、函数"><a href="#10、函数" class="headerlink" title="10、函数"></a>10、函数</h2><p>函数也是一个对象，是一个具有功能的对象，使用 <code>typeof</code> 检查一个函数对象时会返回 function</p>
<p><code>var 变量名 = new Function();</code> 使用构造函数创建函数对象，可将要封装的代码以字符串的形式传递给构造函数，如 <code>var fun = new Function(&quot;console.log(&#39;hello world&#39;)&quot;);</code>，但开发中很少使用构造函数来创建一个函数对象</p>
<p><code>function 函数名([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数声明创建一个函数</p>
<p><code>var 函数名 = function([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数表达式创建函数，相当于声明一个匿名函数并赋值给变量</p>
<p><code>函数对象();</code> 调用函数</p>
<p><code>(function([形参1,形参n])&#123;xxx&#125;)([形参1,形参n])</code> 匿名函数定义完立即被调用，这种函数称为立即执行函数，立即执行函数往往只会执行一次</p>
<p>函数声明中的形参相当于在函数内部声明了相应变量</p>
<p><strong>调用函数时解析器不会检查实参的类型</strong>，所以要注意是否有可能会接收到非法参数，若有可能则需要对参数进行类型检查</p>
<p><strong>调用函数时解析器不会检查实参的数量</strong>，多余的参数不会被赋值，若实参的数量少于形参的数量，则没有对应实参的形参将是 undefined</p>
<p>函数中的参数可以是另一个函数，当实参中的函数是 <code>函数名()</code> 表示调用函数，使用的是函数的返回值，当实参中的函数是 <code>函数名</code> 表示函数对象，相当于直接使用函数对象</p>
<p>若函数的 return 可以返回任意类型的值，若 return 语句后不跟任何值或不写 return 语句，相当于返回 undefined</p>
<h1 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h1><p>JS 中有两种作用域：全局作用域、函数作用域</p>
<h2 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h2><p>直接编写在 <code>&lt;script&gt;</code> 标签中的 JS 代码都在全局作用域，全局作用域中的变量都是全局变量，在页面任意部分都能访问到</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁</p>
<p>全局作用域中有一个全局对象 window，代表一个浏览器的窗口，由浏览器创建可直接使用</p>
<p>在全局作用域中创建的变量都会作为 window 对象的属性保存，创建的函数都会作为 window 对象的方法</p>
<p><strong>变量声明提前：</strong>使用 var 关键字声明的变量，会在所有代码执行之前被声明（但不一定会赋值），但若声明变量时不使用 var 关键字，则变量不会被声明提前</p>
<pre><code>console.log(a);
var a = 123;  //改行对变量 a 的声明实际上会在最开头，只是在这一行被赋值</code></pre>
<p><strong>函数声明提前：</strong>使用函数声明形式 <code>function 函数()&#123;&#125;</code> 创建的函数会在所有代码执行之前被创建，所以可以在函数声明前调用。但是使用函数表达式 <code>var 变量 = function()&#123;&#125;</code> 创建的函数不会被声明提前，所以不能在声明前调用</p>
<h2 id="2、函数作用域"><a href="#2、函数作用域" class="headerlink" title="2、函数作用域"></a>2、函数作用域</h2><p>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，它们之间相互独立</p>
<p>当在函数作用域中操作一个变量时会先在自身作用域中寻找，若有就直接使用，若没有则向上一级作用域中寻找，直到找到全局作用域，若全局作用域中依然没有找到，则会报错 ReferenceError</p>
<p>在函数中要访问全局变量可使用 window 对象，<code>window.变量名</code></p>
<p>在函数作用域中也有声明提前的特性，使用 var 关键字声明的变量会在函数中所有代码执行之前被声明。函数声明也会在函数中所有代码执行之前执行。定义形参相当于在函数作用域中声明了变量</p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    var c = 10;
&#125;
func();  //此时会输出 “undefined”，因为在 func 函数中var c 变量会声明提前，但是执行到 console 语句时函数作用域中的 c 变量还未被赋值</code></pre>
<p>在函数中不适用 var 声明的变量都会成为全局变量 </p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    c = 10;
&#125;
func();  //此时会输出 1，因为函数中 c 没有使用 var 关键字所以不会提前声明，所以向上一级中找 c</code></pre>
<h1 id="四、this"><a href="#四、this" class="headerlink" title="四、this"></a>四、this</h1><p>解析器在调用函数每次都会向函数内部传递一个隐含的参数 this</p>
<p>this 指向一个对象，这个对象称为函数执行的上下文对象</p>
<p>根据函数<strong>调用方式</strong>的不同，this 会指向不同的对象</p>
<p>— 以函数的形式（<code>函数名()</code>，也相当于 <code>window.函数名()</code>）调用时，this 永远是 window</p>
<p>— 以方法的形式（<code>对象.方法名()</code>）调用时，this 就是调用方法所属的那个对象</p>
<p>— 在构造函数中调用时，this 就是新创建的那个对象</p>
<p>— 使用 call 和 apply 调用时，this 是指定的那个对象</p>
<p>— 在事件响应函数中，this 指向响应函数所绑定的对象（普通情况下）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— addEventListener() 中 this 指向绑定事件的对象</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— attachEvent() 中 this 指向 window</p>
<h1 id="五、原型对象"><a href="#五、原型对象" class="headerlink" title="五、原型对象"></a>五、原型对象</h1><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>创建的每个函数，解析器都会向函数中添加一个属性 prototype，这个属性对应着一个原型对象</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>若函数作为普通函数调用 prototype 没有任何作用，但当以构造函数形式调用时，它所实例化的对象都会有个隐含属性指向该构造函数的原型对象，可通过 <strong>proto</strong> 来访问该属性</p>
<h2 id="原型对象中的属性、方法"><a href="#原型对象中的属性、方法" class="headerlink" title="原型对象中的属性、方法"></a>原型对象中的属性、方法</h2><p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，可将对象中共有的内容（属性、方法）统一设置到原型对象中</p>
<p>当访问对象的属性或方法时会先在对象自身中寻找，若有则直接使用，若没有则去原型对象中寻找</p>
<pre><code>function Person(name,age,gender)&#123;
    this.name = name;
    this.age = age;
    this.gender = gender;
&#125;
Person.prototype.sayName = function()&#123;
    alert(this.name);
&#125;
var per = new Person(&quot;xxx&quot;,18,&quot;男&quot;); 
per.sayName();</code></pre>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="原型对象"></p>
<p>使用 <code>&quot;属性名&quot; in 对象实例</code> 检查对象中是否含有某属性时，若对象中没有但是原型中有也会返回 true</p>
<p>使用 <code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查的是对象自身中是否含有该属性</p>
<p>原型对象也是对象，所以它也有原型，当使用一个对象的属性或方法时，先在自身中寻找，若没有则去原型对象中寻找，若依然没有则去原型的原型中寻找，直到找到 Object 对象的原型</p>
<p>Object 对象的原型没有原型，若在 Object 中依然没有找到，则返回 undefined。Object 的 <strong>proto</strong> 是 null</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt="原型的原型"></p>
<h2 id="修改原型对象中的方法"><a href="#修改原型对象中的方法" class="headerlink" title="修改原型对象中的方法"></a>修改原型对象中的方法</h2><p>当在页面中打印对象时实际上是输出对象的 toString() 方法的返回值，若不希望输出 [Object Object]，可为当前对象实例添加一个 toString() 方法，或者修改对象原型的 toString()方法</p>
<pre><code>per.toString() = function()&#123; //但该方法只对当前实例有效
    return &quot;xxx&quot;
&#125;
Person.prototype.toString = function()&#123;  //该方法对该对象的所有实例有效
    return &quot;xxxx&quot;
&#125;</code></pre>
<h1 id="六、垃圾回收（GC）"><a href="#六、垃圾回收（GC）" class="headerlink" title="六、垃圾回收（GC）"></a>六、垃圾回收（GC）</h1><p>程序运行过程中会产生垃圾，垃圾积攒过多后会导致程序运行速度过慢</p>
<p>垃圾：当一个对象没有任何的变量或属性对它进行引用，此时将用于无法操作该对象，这是这种对象就是一个垃圾，这种对象过多会占用大量内存空间导致程序运行变慢，须进行清理</p>
<p>JS 中有自动垃圾回收机制，由浏览器、JS 引擎将这些垃圾对象自动从内存中销毁，我们不需要也不能进行垃圾回收操作</p>
<p>我们需要做的只是要将不再使用的对象设置为 null 即可</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="垃圾回收"></p>
<h1 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h1><p>数组也是个内建对象，和普通对象不同的是普通对象使用字符串作为属性名，而数组使用数字作为索引操作元素</p>
<p>数组的存储性能比普通对象好，开发中常使用数组存储数据</p>
<p>数组中的元素可以是任意数据类型，也可以是对象（函数、数组等）</p>
<p>使用 typeof 检查一个数组时会返回 object</p>
<h2 id="1、数组对象的操作"><a href="#1、数组对象的操作" class="headerlink" title="1、数组对象的操作"></a>1、数组对象的操作</h2><p><code>var 数组名 = new Array(元素1,元素2,...,元素n)</code> 或 <code>var 数组名 = new Array(数组长度)</code> 使用构造函数创建数组对象</p>
<p><code>var 数组名 = [元素1,元素2,...,元素n]</code> 使用字面量创建数组对象</p>
<p><code>数组名[索引] = 值</code> 向数组中添加元素</p>
<p><code>数组名[索引]</code> 读取数组中的元素，若读取不存在的索引不会报错而是返回 undefined</p>
<p><code>数组名.length</code> 设置或获取数组的最大索引+1，即使数组中不连续；通过 length 设置数组长度时，若修改的长度大于原长度则多出部分会空出来，若小于原长度则多出部分会被移除</p>
<p><code>数组名[数组名.length] = 值</code> 向数组最后添加元素</p>
<h2 id="2、数组的方法"><a href="#2、数组的方法" class="headerlink" title="2、数组的方法"></a>2、数组的方法</h2><h3 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a>添加与删除</h3><p><code>push(元素1,元素2,...,元素n)</code> 向数组末尾添加一个或多个元素，并返回数组的新长度</p>
<p><code>pop()</code> 删除数组的最后一个元素，并返回被删除的元素</p>
<p><code>unshift(第一个元素,第二个元素,...,第n个元素)</code> 向数组开头添加一个或多个元素，并返回数组的新长度，新数组中新增元素的顺序和传参顺序一致</p>
<p><code>shift()</code> 删除数组的第一个元素，并返回被删除的元素</p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><code>数组名.forEach(function(value,index,当前数组))</code> 遍历数组（只支持 IE8 以上的浏览器），需要一个函数作为参数（这种由我们创建不由我们调用的称为回调函数）</p>
<p>数组中有几个元素函数就会执行几次，每次执行时浏览器会将遍历到的元素以实参形式传进来，浏览器会在回调函数中传递三个参数：(当前正遍历的元素, 当前正遍历元素的索引, 正在遍历的数组)</p>
<h3 id="数组片段获取"><a href="#数组片段获取" class="headerlink" title="数组片段获取"></a>数组片段获取</h3><p><code>slice(开始位置,结束位置)</code> 从某个已有的数组返回选定的元素，第二个参数可选，左闭右开，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>splice(开始位置,删除个数,添加元素1,添加元素n)</code> 删除元组并向数组添加新元素，<strong>会修改原数组</strong>，并返回被删除的元素，添加的元素会自动插入开始位置，并且顺序与参数传入顺序一致</p>
<h3 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h3><p><code>数组1.concat(数组2,数组n,元素1,元素n)</code> 连接两个或多个数组，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>数组.join(连接符)</code> 该方法将数组转换为字符串，方法<strong>不会影响原数组</strong>，默认使用 <code>,</code> 作为连接符</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>数组.reverse()</code> 用来反转数组，该方法<strong>直接修改原数组</strong></p>
<p><code>数组.sort()</code> 对数组中元素排序，该方法<strong>直接修改原数组</strong>，默认按照 Unicode 编码排序，所以对数组排序会得到错误结果（1开头都会排在前面）</p>
<p>可在 sort() 中添加回调函数指定排序规则，回调函数中需定义两个形参，浏览器根据回调函数返回值决定元素顺序（返回大于0，元素会交换位置，返回小于等于0，元素位置不变）</p>
<pre><code>数组.sort(function(a,b)&#123;
    return a-b;  //升序排列
&#125;)</code></pre>
<h1 id="八、call-和-apply"><a href="#八、call-和-apply" class="headerlink" title="八、call 和 apply"></a>八、call 和 apply</h1><p>call 和 apply 都是函数对象的方法，需要通过函数对象（不带括号的函数名）调用</p>
<h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>调用函数执行：当对函数调用 call() 和 apply() 都会调用函数执行</p>
<p>修改函数的 this：调用 call() 和 apply() 可将一个对象指定为第一个参数，此时这个对象会成为函数执行时的 this（原先 <code>函数名()</code> 函数调用时的 this 指向 window）</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>call() 方法可将实参在对象之后依次传递</p>
<p>apply() 方法需要将实参封装到一个数组中统一传递</p>
<pre><code>function fun()&#123;
    console.log(this)
&#125;
var obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
var obj2=&#123;name: &quot;obj2&quot;&#125;
fun.call(obj);  //this 指 obj，apply 同理
obj.sayName.call(obj);  //alert 的是 obj，apply 同理
obj.sayName.apply(obj2);  //alert 的是 obj2，call 同理

function fun(a,b)&#123;
    console.log(a);
    console.log(b);
&#125;
obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
fun.call(obj,2,3);
fun.apply(obj,[2,3]);</code></pre>
<h1 id="九、arguments"><a href="#九、arguments" class="headerlink" title="九、arguments"></a>九、arguments</h1><p>在调用函数时，浏览器每次都会传递两个隐含参数：（1）函数的上下文对象 this（2）封装实参的对象 arguments</p>
<p>arguments 是一个类数组对象，可以通过索引来操作数据，也可以获取长度（arguments.length）</p>
<p>调用函数时，传递的实参都会在 arguments 中保存，即使不定义形参也可通过 arguments 来使用实参（如 arguments[0] 表示第一个实参）</p>
<p>arguments 中有个属性叫 callee，该属性对应当前正在指向的函数对象</p>
<pre><code>function fun(a,b)&#123;
    console.log(arguments.callee == fun);  //输出 true
&#125;</code></pre>
<h1 id="十、Date-对象"><a href="#十、Date-对象" class="headerlink" title="十、Date 对象"></a>十、Date 对象</h1><p>Date 对象也是一个内建对象</p>
<p><code>var 变量 = new Date();</code> 使用构造函数创建 Date 对象，会封装为当前代码执行的时间</p>
<p><code>var 变量 = new Date(&quot;月/日/年 时:分:秒&quot;);</code> 创建指定时间的对象</p>
<p><code>Date对象实例.getDate();</code> 获取当前日期对象的日</p>
<p><code>Date对象实例.getDay();</code> 获取当前日期对象的星期几，会返回 0<del>6 表示周日</del>周六</p>
<p><code>Date对象实例.getMonth();</code> 获取当前日期对象的月，会返回 0<del>11 表示1月</del>12月</p>
<p><code>Date对象实例.getFullYear();</code> 获取当前日期对象的年</p>
<p><code>Date对象实例.getTime();</code> 获取当前日期对象的时间戳，时间戳指从格林威治标准时间1970年1月1日0时0分0秒到当前日期所花费的毫秒数</p>
<pre><code>var d = new Date(&quot;1/1/1970 0:0:0&quot;);
console.log(d.getTime());  //输出为 -28800000，因为系统使用的时背景时间，和格林威治标准时间相差八小时</code></pre>
<p><code>Date.now();</code> 获取当前时间戳</p>
<p>计算机底层在保存时间时使用的都是时间戳</p>
<p>可使用时间戳测试代码的执行性能</p>
<h1 id="十一、Math"><a href="#十一、Math" class="headerlink" title="十一、Math"></a>十一、Math</h1><p>Math 和其他对象（如 Date）不同，它不是一个构造函数，它属于工具类，封装了数学运算相关的属性和方法</p>
<p><code>Math.PI</code> 圆周率</p>
<p><code>Math.abs(数字)</code> 计算绝对值</p>
<p><code>Math.ceil(数字)</code> 向上取整，小数位有就自动进 1</p>
<p><code>Math.floor(数字)</code> 向下取整</p>
<p><code>Math.round(数字)</code> 四舍五入取整</p>
<p><code>Math.random()</code> 生成 0~1 之间（不包括 0 和 1）的随机数  </p>
<p><code>Math.round(Math.random()*x)</code> 生成 0~x 之间（包括 0 和 x）的随机整数    </p>
<p><code>Math.round(Math.random()*(y-x)+x)</code> 生成 x~y 之间（包括 x 和 y）的随机整数</p>
<p><code>Math.max(数字1,数字2,...,数字n)</code> 取最大值</p>
<p><code>Math.min(数字1,数字2,...,数字n)</code> 取最小值 </p>
<p><code>Math.pow(x,y)</code> x 的 y 次幂</p>
<p><code>Math.sqrt(数字)</code> 开方</p>
<h1 id="十二、包装类"><a href="#十二、包装类" class="headerlink" title="十二、包装类"></a>十二、包装类</h1><p>JS 中提供了三个包装类将基本数据类型转换为对象：</p>
<p><code>String()</code> 将基本数据类型字符串转换为 String 对象</p>
<p><code>Number()</code> 将基本数据类型数字转换为 Number 对象</p>
<p><code>Boolean()</code> 将基本数据类型字符串转换为 Boolean 对象</p>
<p>转换成对象后可添加属性</p>
<p>实际应用中不会使用基本数据类型的对象，若使用基本数据类型的对象，在做比较时可能会有不可预料的结果</p>
<p>方法和属性只能添加给对象，不能添加给基本数据类型</p>
<p>但是当对基本数据类型的值调用属性或方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法，调用后再转换回基本数据类型，如基本数据类型调用 toString() 方法</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>在底层字符串是以字符数组的形式保存的，可使用索引和 length</p>
<p><code>字符串.charAt(索引)</code> 返回指定位置的字符，<strong>不会影响原字符串</strong></p>
<p><code>字符串.charCodeAt(索引)</code> 返回指定位置字符的 Unicode 编码 </p>
<p><code>String.fromCharCode(十进制编码或 0x十六进制)</code> 根据字符 Unicode 编码获取字符 </p>
<p><code>字符串.concat(字符串1,字符串2,字符串n)</code> 连接两个或多个字符串,<strong>不会影响原字符串</strong></p>
<p><code>字符串.indexOf(字符,开始检索位置)</code> 返回字符在字符串中第一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.lastIndexOf(字符,开始检索位置)</code> 返回字符在字符串中最后一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.slice(开始位置,结束位置)</code> 截取字符串，左闭右开，<strong>不会影响原字符串</strong>，若省略第二个参数则默认是字符串末尾，可使用负值参数</p>
<p><code>字符串.substring(开始位置,结束位置)</code> 截取字符串，和 slice 类似，左闭右开，，<strong>不会影响原字符串</strong>，但该方法不能接收负值参数，若传递负值默认使用 0，并且会自动调整参数为升序</p>
<p><code>字符串.substr(开始位置,截取长度)</code> 截取字符串，<strong>不会影响原字符串</strong>，但 ECMAScript 没有对该方法标准化，所以不建议使用</p>
<p><code>字符串.split(分割符)</code> 将字符串拆分为数组，若传递一个空串作为参数，则会拆分出字符串中的每个字符，也可传正则表达式</p>
<p><code>字符串.toUpperCase()</code> 字符串转为大写，<strong>不会影响原字符串</strong></p>
<p><code>字符串.toLowerCase()</code> 字符串转为小写，<strong>不会影响原字符串</strong></p>
<h1 id="十三、正则表达式"><a href="#十三、正则表达式" class="headerlink" title="十三、正则表达式"></a>十三、正则表达式</h1><p>正则表达式用于定义一些字符串的规则，计算机可根据正则表达式，检查一个字符串是否符合规则，或将字符串中符合规则的内容提取出来</p>
<p>正则表达式是个对象，使用 typeof 检查正则对象，会返回 object</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><p><code>var 变量 = new RegExp(正则表达式,匹配模式)</code> 创建正则表达式对象，匹配模式可选值有 <code>&quot;i&quot;</code> 忽略大小写，<code>&quot;g&quot;</code> 全局匹配模式，可设置多个匹配模式，且顺序无要求，这种创建方式更灵活，因为参数中可传变量</p>
<p><code>var 变量 = /正则表达式/匹配模式</code> 使用字面量创建正则表达式，如 <code>var 变量 = /a/i;</code>，在正则表达式中使用 <code>|</code>或 <code>[]</code> 表示或，使用 <code>[^xxx]</code> 表示除了 xxx 以外的内容，这种创建方式更简单</p>
<h2 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h2><p><code>正则对象.test(待检查字符串)</code> 检查字符串是否符合正则表达式规则，返回布尔值</p>
<pre><code>var reg = new RegExp(&quot;a&quot;);  //该正则表达式可检查一个字符串中是否含有 a，默认严格区分大小
console.log(reg.test(&quot;abc&quot;)); //返回 true，因为含有 a

var reg = new RegExp(&quot;ab&quot;,&quot;i&quot;);  //该正则表达式可检查一个字符串中是否含有 ab，忽略大小写
console.log(reg.test(&quot;Abc&quot;)); //返回 true，因为含有 ab

var reg = /a|b|c/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[abc]/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[a-z]/;  //检查字符串中是否有任意小写字母
var reg = /[A-Z]/;  //检查字符串中是否有任意大写字母
var reg = /[A-z]/;  //检查字符串中是否有任意字母
var reg = /[0-9]/;  //检查字符串中是否有任意数字
var reg = /a[bde]c/;  //检查字符串中是否有 abc 或 adc 或 aec
var reg = /[^ab]/;  //检查字符串中是否有除了 ab 以外的内容
var reg = /[^0-9]/;  //检查字符串中是否有除了数字以外的内容</code></pre>
<h2 id="字符串和正则相关方法"><a href="#字符串和正则相关方法" class="headerlink" title="字符串和正则相关方法"></a>字符串和正则相关方法</h2><pre><code>字符串.split(/[A-z]/); 根据任意字母拆分字符串，该方法即使不指定全局匹配也会全都拆分 
字符串.search(/a[bde]c/); 搜索字符串中是否含有指定内容，返回第一次出现索引或 -1，设置全局匹配无效
字符串.match(/[A-z]/gi); 根据正则表达式，从字符串中将符合条件的内容提取出来，默认只找第一个符合要求的内容，可设置为全局匹配 g 模式这样可找符合要求的所有内容，返回数组
字符串.replace(被替换内容,新的内容); 
字符串.replace(/[a-z]/ig,&quot;&quot;);  //可删除所有字母</code></pre>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>通过量词可设置内容出现的次数</p>
<p>量词只对它前边的一个内容起作用</p>
<p><code>&#123;n&#125;</code> 正好出现 n 次</p>
<p><code>&#123;n,m&#125;</code> 出现 n~m 次</p>
<p><code>&#123;n,&#125;</code> 出现 n 次以上</p>
<p><code>n+</code> 至少出现 1 次 n，相当于 <code>&#123;1,&#125;</code></p>
<p><code>n*</code> 出现 0 次或多次 n，相当于 <code>&#123;0,&#125;</code></p>
<p><code>n?</code> 出现 0 次或 1 次 n，相当于 <code>&#123;0,1&#125;</code></p>
<p><code>^n</code> 以 n 开头</p>
<p><code>n$</code> 以 n 结尾</p>
<p><code>^n|n$</code> 以 n 开头或以 n 结尾</p>
<p><code>^n$</code> 字符串只能是 n</p>
<pre><code>var reg = /a&#123;3&#125;/;  字符串中连续出现 3 次 a
var reg = /(ab)&#123;3&#125;/;  字符串中连续出现 3 次 ab
var reg = /ab+c/;  字符串中 abc，其中 b 至少有一个
var reg = /^a/;  字符串中是否以 a 开头
var reg = /a$/;  字符串中是否以 a 结尾</code></pre>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><code>.</code> 表示任意字符，除了换行和行结束符</p>
<p><code>\w</code> 表示任意字母、数字、_</p>
<p><code>\W</code> 除了字母、数字、<em>，相当于 [^A-z0-9</em>]</p>
<p><code>\d</code> 任意数字，相当于 [0-9_]</p>
<p><code>\D</code> 除了数字，相当于 [^0-9_]</p>
<p><code>\s</code> 表示空格</p>
<p><code>\S</code> 除了纯空格</p>
<p><code>\b</code> 表示单词边界，标识是个独立的单词</p>
<p><code>\B</code> 除了单词边界</p>
<p>正则表达式中使用 <code>\</code> 作为转义字符</p>
<p>注意：使用构造函数时，由于它的参数是一个字符串，而 \ 是字符串中转义字符，若使用 \ 则需使用 \ 代替</p>
<pre><code>var reg = /\\/;
reg.test(&quot;b.\&quot;);  //返回 false，因为 \ 转义的是 &quot;
reg.test(&quot;b.\\&quot;);  //返回 true
var reg = new RegExp(&quot;\\.&quot;);  //相当于 var reg = /\./;
var reg = new RegExp(&quot;\\\\&quot;);  //相当于 var reg = /\\/;</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>去除字符串中所有空格</p>
<pre><code>字符串.replace(/\s/g,&quot;&quot;)</code></pre>
<p>去除字符串开头的所有空格</p>
<pre><code>字符串.replace(/^\s*/,&quot;&quot;)</code></pre>
<p>去除字符串末尾的所有空格</p>
<pre><code>字符串.replace(/\s*$/,&quot;&quot;)</code></pre>
<p>去除字符串前后的所有空格</p>
<pre><code>字符串.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre>
<p>检查手机号是否合法：（1）以 1 开头（2）第二位 3-9 任意数字（3）第三位以后任意 9 个数字</p>
<pre><code>var reg = /^1[3-9][0-9]&#123;9&#125;$/  </code></pre>
<p>电子邮箱匹配：任意字母数字下划线.任意字母数字下划线（可有可无） @ 任意字母数字下划线.任意字母数字.任意字母（2-5位）.任意字母（2-5位）</p>
<pre><code>var reg = /^\w&#123;3,&#125;(\.\w+)*@[A-z0-9]+(\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/</code></pre>
<h1 id="十四、DOM"><a href="#十四、DOM" class="headerlink" title="十四、DOM"></a>十四、DOM</h1><h2 id="1、DOM"><a href="#1、DOM" class="headerlink" title="1、DOM"></a>1、DOM</h2><p>DOM（文档对象模型）是宿主对象，JS 中通过 DOM 对 HTML 文档进行操作</p>
<p>— 文档：整个 HTML 网页文档</p>
<p>— 对象：网页中的每个部分都转换为一个对象</p>
<p>— 模型：使用模型表示对象之间的关系，方便获取对象，DOM 树</p>
<h2 id="2、节点"><a href="#2、节点" class="headerlink" title="2、节点"></a>2、节点</h2><p>节点：构成网页的组基本的组成部分（最基本单元），网页中每一部分都可称为节点（如：html 标签、属性、文本、注释、整个文档等），但它们具体类型不同，节点类型不同，则其属性和方法也不同。</p>
<p>常用节点分为四类：</p>
<p>— 文档节点：整个 HTML 文档</p>
<p>— 元素节点：HTML 文档中的 HTML 标签</p>
<p>— 属性节点：元素的属性，并非元素节点的子节点，而是元素节点的一部分</p>
<p>— 文本节点：HTML 标签中的文本内容（任意非 HTML 的文本）</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>节点的共有属性：nodeName、nodeType、nodeValue</p>
<table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<p>浏览器已提供文档节点对象，该对象是 window 的属性，可在页面中直接使用，是全局变量。通过document 对象可在整个文档访问内查找节点对象，并可以通过该对象创建各种节点对象</p>
<h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><p>获取元素节点，都通过 document 对象调用</p>
<pre><code>document.getElementById(&quot;xxx&quot;)   通过 id 获取一个元素节点对象
document.getElementsByTagName(&quot;xxx&quot;)  通过标签名获取一组元素节点对象
document.getElementsByName(&quot;xxx&quot;)   通过 name 属性获取一组元素节点对象
document.documentElement;  获取 html 根标签
document.body;  获取 body 标签，保存的是 body 的引用
document.all;  代表页面中的所有元素
document.getElementsByTagName(&quot;*&quot;);  获取页面中的所有元素，相当于 document.all
document.getElementsByClassName(&quot;xxx&quot;);  根据元素的 class 属性值查询一组元素节点对象，但该方法不支持 IE8 及以下浏览器
document.querySelector(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法只返回唯一一个元素，若有多个满足条件的元素，则返回第一个，IE8也支持
document.querySelectorAll(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法返回符合条件的元素数组</code></pre>
<h3 id="获取-修改元素属性"><a href="#获取-修改元素属性" class="headerlink" title="获取/修改元素属性"></a>获取/修改元素属性</h3><p>获取元素属性：<code>元素.属性名</code>，注意 class 属性不能采用这种方式，因为 class 是 JS 中的保留字</p>
<p>读取 class 属性时需要使用 <code>元素.className</code></p>
<h3 id="获取-修改元素内的文本节点"><a href="#获取-修改元素内的文本节点" class="headerlink" title="获取/修改元素内的文本节点"></a>获取/修改元素内的文本节点</h3><p>修改获取到的元素节点对象属性：<code>变量.innerHTML = &quot;xxx&quot;</code>，注意 innerHTML 对自结束标签没有意义</p>
<p>或者先获取元素的文本子节点，再获取其 nodeValue 就是文本内容，如 <code>var 变量 = 元素对象.firstChild; console.log(变量.nodeValue)</code></p>
<p>注：<code>innerText</code> 可获取元素内部的文本内容，和 <code>innerHTML</code> 类似，不同的是它会自动将 html 标签去除只留下文本内容</p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><p>通过具体元素节点调用</p>
<pre><code>getElementsByTagName(&quot;xxx&quot;)  [方法]，返回当前节点的指定标签名后代节点，注意调用对象
childNodes  [属性]，表示当前节点的所有子节点（包括元素节点、文本节点等），注意 DOM 标签间的空白也会当成一个文本节点（IE8以上和其他浏览器）
children  [属性]，表示当前元素的所有子元素（而非节点，因此不会包含空格换行的文本节点）
firstChild  [属性]，表示当前节点的第一个子节点（包括空白文本节点）
firstElementChild  [属性]，表示当前节点的第一个子元素（不包括空白文本节点），IE8不支持
lastChild  [属性]，表示当前节点的最后一个子节点</code></pre>
<h3 id="获取元素节点的父节点和兄弟节点"><a href="#获取元素节点的父节点和兄弟节点" class="headerlink" title="获取元素节点的父节点和兄弟节点"></a>获取元素节点的父节点和兄弟节点</h3><p>通过具体的节点调用</p>
<pre><code>parentNode  [属性]，表示当前节点的父节点
previousSibling  [属性]，表示当前节点的前一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的前一个兄弟元素（不包括空白文本节点）
nextSibling  [属性]，表示当前节点的后一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的后一个兄弟元素（不包括空白文本节点）</code></pre>
<h3 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h3><pre><code>document.createElement(&quot;标签名&quot;);  可创建一个元素节点对象，并返回创建好的对象
document.createElement(&quot;文本内容&quot;); 可创建一个文本节点对象，并返回新节点
父节点.appendChild(子节点);  可向父节点中添加一个新的子节点
父节点.insertBefore(新子节点,指定的旧子节点);  在指定的子节点前面插入新的子节点
父节点.replaceChild(新子节点,指定的旧子节点);  使用新子节点替换已有子节点
父节点.removeChild(子节点);  删除子节点，相当于 子节点.parentNode.removeChild(子节点)
使用 innerHTML 也可以完成 DOM 的增删改相关操作，但这种方法有时候动静太大</code></pre>
<h2 id="3、文档加载"><a href="#3、文档加载" class="headerlink" title="3、文档加载"></a>3、文档加载</h2><p>浏览器加载页面时，按照自上向下顺序加载，读取到一行就运行一行</p>
<p>事件 JS 代码编写位置的三种情况：</p>
<p>（1）若将 <code>&lt;script&gt;</code> 标签写到页面上边 <code>&lt;head&gt;</code> 里，在代码执行时页面还没加载，则 DOM 对象也没有加载会导致无法获取 DOM 对象</p>
<p>（2）将 JS 代码编写到页面下部就是为了可以在页面加载完后再执行，这样性能也更好</p>
<p>（3）将事件写在 <code>onload</code> 事件中，<code>onload</code> 事件会在整个页面加载完成后才触发，确保代码执行时所有 DOM 对象已经加载完毕，支持该事件的对象有 image，layer，window，<code>window.onload = function()&#123;xxx&#125;</code></p>
<h2 id="4、利用-DOM-修改-CSS-样式"><a href="#4、利用-DOM-修改-CSS-样式" class="headerlink" title="4、利用 DOM 修改 CSS 样式"></a>4、利用 DOM 修改 CSS 样式</h2><h3 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式"></a>操作内联样式</h3><p><code>元素.style.样式名&quot;</code> 读取样式</p>
<p><code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<p>通过 style 属性设置和读取的都是<strong>内联样式</strong>，无法读取样式表中的样式</p>
<p>若 CSS 样式名中含有 <code>-</code>，这种名称在 JS 中是不合法的，如 background-color，需要将这种样式名改为驼峰命名法（去掉 -，将 - 后的字母大写）</p>
<p>因为内联样式有较高优先级，所以通过 JS 修改的样式往往会立即显示，但不会覆盖添加了 <code>!important</code> 的样式</p>
<pre><code>box1.style.width = &quot;200px&quot;;
box1.style.backgroundColor = &quot;red&quot;;</code></pre>
<h3 id="通过类修改样式"><a href="#通过类修改样式" class="headerlink" title="通过类修改样式"></a>通过类修改样式</h3><p>可通过修改元素的 class 属性间接修改样式，<code>元素对象.className = &quot;xxx&quot;</code> 或 <code>元素对象.className += &quot; xxx&quot;</code>（注意新类前面的空格），这样只需修改一次即可同时修改多个样式，浏览器只需重新渲染页面一次，性能较好，并且这种方式可以使表现和行为进一步分离</p>
<h3 id="读取元素样式"><a href="#读取元素样式" class="headerlink" title="读取元素样式"></a>读取元素样式</h3><p>（1）<code>元素.currentStyle.样式名&quot;</code> </p>
<p>获取元素当前正在显示的样式（只有 IE 浏览器支持）</p>
<p>该方法不能修改样式</p>
<p>（2）<code>元素.getComputedStyle(要获取样式的元素，伪元素)</code> </p>
<p>获取元素当前正在显示的样式，第二个参数一般都传 null，该方法返回一个封装了当前元素对应样式的对象</p>
<p>该方法不能修改样式</p>
<p>所有浏览器及 IE9 以上支持</p>
<p>（3）<code>元素.getComputedStyle(要获取样式的元素，伪元素).样式名</code> </p>
<p>获取元素当前正在显示的样式的值，若获取的样式没有设置，则会获取其真实值而非默认值，如若没有设置 width，不会获取到 auto，而会获取其真实宽度</p>
<p>该方法不能修改样式</p>
<p>不支持 IE8 及以下浏览器</p>
<p>（4）同时支持 IE8 和其他浏览器</p>
<p>可通过判断是否有 getComputedStyle 方法，若没有就用 currentStyle</p>
<pre><code>if(window.getComputedStyle)&#123;  
//注意这里需要加 window. 若不加是表示寻找变量，找不到就会报错，而加上表示寻找 window 对象的属性，找不到也不会报错而是返回 undefined
    return getComputedStyle(obj,null)
&#125;else&#123;
    return obj.currentStyle.样式名
&#125;</code></pre>
<h3 id="其他样式相关属性"><a href="#其他样式相关属性" class="headerlink" title="其他样式相关属性"></a>其他样式相关属性</h3><p><code>元素.clientWidth</code> 获取元素的可见宽度（包含内容区和内边距）</p>
<p><code>元素.clientHeight</code> 获取元素的可见高度（包含内容区和内边距）</p>
<p>上述两个属性获取到的值都是不带 px 单位的数字，可直接用于计算，并且是只读的，不能通过该属性修改样式</p>
<p><code>元素.offsetWidth</code> 获取元素的可见宽度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetHeight</code> 获取元素的可见高度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetParent</code> 获取当前元素的定位父元素，获取离当前元素最近的开启了定位的祖先元素，若所有祖先元素都没有开启定位，则返回 body</p>
<p><code>元素.offsetLeft</code> 当前元素相对于其定位父元素的水平偏移量</p>
<p><code>元素.offsetTop</code> 当前元素相对于其定位父元素的垂直偏移量</p>
<p><code>元素.scrollHeight</code> 元素整个滚动区域的高度</p>
<p><code>元素.scrollWidth</code> 元素整个滚动区域的宽度</p>
<p><code>元素.scrollLeft</code> 元素水平滚动条移动的距离</p>
<p><code>元素.scrollTop</code> 元素垂直滚动条移动的距离</p>
<p>onsrcoll 该事件会在元素滚动条滚动时触发</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<h1 id="十五、事件"><a href="#十五、事件" class="headerlink" title="十五、事件"></a>十五、事件</h1><p>事件：就是文档或浏览器窗口中发生的一些特点的交互瞬间（如点击、鼠标移动、按下键盘、关闭窗口等）</p>
<p>JS 与 HTML 间的交互通过事件实现</p>
<p>在事件响应函数中，响应函数给谁绑定的 this 就是谁</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可在事件对应的属性中设置 JS 代码，当事件被触发时这些代码会执行</p>
<p>绑定事件的方式：</p>
<pre><code>方式一：
&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;xxx&#39;)&quot;&gt;按钮&lt;/button&gt;

方式二：
var btn = document.getElementById(&quot;元素id&quot;)
btn.onclick = function()&#123;xxx&#125;</code></pre>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数（除 IE8 及以下浏览器以外）</p>
<p>IE8 及以下浏览器中，是将事件对象作为 window 对象的属性保存的</p>
<p>在事件对象中封装了当前事件相关的一切信息，如鼠标坐标、键盘哪个键被按下、鼠标滚轮滚动的方向</p>
<p><code>event.clientX</code> 鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>window.event.clientX</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>event.clientY</code> 鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>window.event.clientY</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>event.pageX</code> 鼠标指针相对于<strong>整个页面</strong>的水平坐标，但在 IE8 中不支持</p>
<p><code>event.pageY</code> 鼠标指针相对于<strong>整个页面</strong>的垂直坐标，但在 IE8 中不支持</p>
<p><code>event.target</code> 表示触发事件的对象，而非事件所绑定的对象，区别于在响应函数中的 this 是指事件所绑定的对象</p>
<p>兼容不同浏览器的两种方式：</p>
<pre><code>元素.事件如onmousemove = function(event)&#123;
    if(!event)&#123;                     //方式一
        event = window.event;
    &#125;
    event = event || window.event;  //方式二，更常用
&#125;</code></pre>
<h2 id="事件冒泡（Bubble）"><a href="#事件冒泡（Bubble）" class="headerlink" title="事件冒泡（Bubble）"></a>事件冒泡（Bubble）</h2><p>冒泡指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件（如都是 onclick ）也会被触发</p>
<p>在开发中大部分情况冒泡是有用的，若不希望发生事件冒泡可通过事件对象的 cancelBubble 属性设置为 true 来取消冒泡</p>
<pre><code>元素对象.onclick = function(event)&#123;
    event = event || window.event;
    event.cancelBubble = true;
&#125;</code></pre>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><p>事件的委派指将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>通过事件委派可以只绑定一次事件即可应用到多个元素上，即使是后添加的元素</p>
<p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</p>
<p>触发事件的对象是期望的元素则执行，否则不执行，可通过判断 <code>if (event.target.className == &#39;xxx&#39;)</code> 来实现</p>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>（1）元素对象.事件 = 函数</p>
<p>当使用 <code>元素对象.事件 = 函数</code> 的形式绑定响应函数时只能同时为一个元素的一个事件绑定一个响应函数，若为同一事件绑定多个响应函数，则后面的会覆盖前面的</p>
<p>（2）addEventListener()</p>
<p>通过该方法也可为元素绑定响应函数，IE8 及以下浏览器不支持，在 IE8 中可使用 attachEvent() 来实现</p>
<p>参数：</p>
<p>— 事件的字符串（不要加on）</p>
<p>— 回调函数（当事件触发时会被调用）</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<pre><code>元素对象.addEventListener(&quot;click&quot;,function()&#123;&#125;,false);</code></pre>
<p>使用 addEventListener() 可以为一个元素的相同事件同时绑定多个响应函数，当事件被触发时，响应函数将会按照函数的绑定顺序执行</p>
<p>addEventListener() 中的 this，是绑定事件的对象</p>
<p>（3）attachEvent()</p>
<p>该方法功能和 addEventListener() 类似，也可以同时为一个事件绑定多个处理函数，不同的是该方法在 IE8 中支持，但在其他浏览器中不支持，并且它是后绑定的先执行，执行顺序和 addEventListener() 相反</p>
<p>参数：</p>
<p>— 事件的字符串（要加on）</p>
<p>— 回调函数</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<p>由于 attachEvent() 中的回调函数是由浏览器调用，所以 attachEvent() 中的 this 是 window</p>
<p>（4）兼容所有浏览器</p>
<pre><code>function bind(obj,eventStr,callback)&#123; //(要绑定的事件对象,去掉 on 的事件字符串,回调函数)
    if(obj.addEventListener)&#123;  //大部分浏览器兼容的方式
        obj.addEventListener(eventStr,callback,false);
    &#125;else&#123;  //IE8及以下浏览器
        obj.attachEvent(&quot;on&quot;+eventStr,function()&#123;
            callback.call(obj);
            //因为 this 是谁由调用方式决定，因为加匿名函数前 callback 由浏览器调用，所以外面加个匿名函数，在函数内来指定 callback 由谁调用
        &#125;);
    &#125;
&#125;</code></pre>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>关于事件传播，网景公司和微软公司由不同的理解和设计</p>
<p>微软认为事件应该是由内向外传播，当事件触发时应先触发当前元素的事件，再向当前元素的祖先元素上传播，即事件应该在冒泡阶段执行</p>
<p>网景公司认为事件应该由外向内传播，当事件触发时，应先触发当前元素的最外层祖先元素的事件，再向内传播给后代元素（即事件捕获）</p>
<p>W3C 综合了两个公司的方案，将事件传播分成了三个阶段</p>
<p>（1）捕获阶段：从最外层的祖先元素（大部分浏览器从 window 开始），向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>（2）目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>
<p>（3）冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>
<p>若希望在捕获阶段就触发事件，可以将 addEventListener() 的第三个参数设置为 true，一般情况下不会希望在捕获阶段触发事件，所以这个参数一般是 false</p>
<p>在 IE8 及以下浏览器中没有捕获阶段</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<p>onmousemove 该事件会在鼠标在元素中移动时被触发</p>
<p>onmousedown 鼠标按下</p>
<p>onmouseup 鼠标松开，可用于取消其他事件，如</p>
<pre><code>元素对象.onmouseup = function()&#123;
    对象.onmousemove = null;
    对象.onmouseup = null;
&#125;</code></pre>
<p><code>元素对象.setCapture()</code> 设置元素对鼠标按下相关事件进行捕获，该元素会把下一次所有鼠标按下相关的事件捕获到自身上（该方法只有 IE 支持，在火狐中调用不会报错，但 chrome 会报错）</p>
<p><strong>鼠标拖拽元素的例子：</strong></p>
<pre><code>box.onmousedown = function(event)&#123;  //box是开启一个绝对定位的 div
    box.setCapture &amp;&amp; box.setCapture();  //设置捕获代替解决 IE8 不支持 return false
    event = event || window.event;
    val ol = event.clientX - box.offsetLeft;
    val ot = event.clientY - box.offsetTop;
    document.onmousemove = function(event)&#123;
        event = event || window.event;
        val left = event.clientX - ol;
        val top = event.clientY - ot;
        box.style.left = left + &quot;px&quot;;
        box.style.top = top + &quot;px&quot;;
    &#125;
    document.onmouseup = function()&#123;
        box.onmousemove = null;
        box.onmouseup = null;
        box.releaseCapture &amp;&amp; box.releaseCapture();  //鼠标松开时取消对事件的捕获
    &#125;
    return false;  //因为拖拽时浏览器默认会去搜索引擎中所有内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）
&#125;</code></pre>
<h2 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h2><p>onmousewheel 在鼠标滚轮滚动时触发（火狐不支持该属性）</p>
<p>火狐中滚轮滚动可使用 DOMMouseScroll 来绑定滚动事件，且该事件需要通过 addEventListener() 函数来绑定</p>
<p>event.wheelDelta 获取滚轮滚动的方向，往上为正，往下为负（火狐不支持该属性）</p>
<p>火狐中通过 event.detail 来获取滚动方向，往上为负，往下为正</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>当滚轮滚动时，若浏览器由滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为，若使用 addEventListener() 绑定响应函数应使用 event.preventDefault() 取消默认行为(IE8 不支持preventDefault)</p>
<p><strong>随滚轮滚动时元素高度改变的例子：</strong></p>
<pre><code>box.onnmousewheel = function(event)&#123;
    event = event || window.event;
    if(event.wheelDelta&gt;0 || event.wheelDelta&lt;0)&#123;
        //向上滚
        box.style.height = box.clientHeight - 10 + &quot;px&quot;;
    &#125;else&#123;
        //向下滚
        box.style.height = box.clientHeight + 10 + &quot;px&quot;;
    &#125;
    event.preventDefault &amp;&amp; event.preventDefault();
    return false;
&#125;
box.addEventListener(&quot;DOMMouseScroll&quot;,box.onnmousewheel);  //兼容火狐</code></pre>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>onkeydown 某个键盘按键被按下，若一直按着按键不松手事件会一直被触发。当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点（这是为了防止误操作发生）其他次会很快触发</p>
<p>onkeyup 某个键盘按键被松开</p>
<p>event.keyCode 获取按键的 Unicode 编码从而判断哪个按键被按下，数字 0-9 对应编码 48-57</p>
<p>altKey、ctrlKey、shiftKey 判断 alt、ctrl、shift 是否被按下</p>
<p>注意键盘事件一般都会绑定给可以获取焦点的对象（如 input）或者是 document，一般不给 div 绑定</p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123;
        console.log(&quot;ctrl和y都被按下&quot;)
    &#125;
    if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57)&#123;
        return false;  //不能输入数字
    &#125;
&#125;
document.onkeyup = function()&#123;
&#125;</code></pre>
<p><strong>根据方向键移动 div 的例子：</strong></p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    var speek = 10;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;</code></pre>
<h1 id="十六、BOM"><a href="#十六、BOM" class="headerlink" title="十六、BOM"></a>十六、BOM</h1><p>BOM（浏览器对象模型），BOM 可以使我们可以通过 JS 操作浏览器，DOM 是操作网页文档的，在 BOM 中提供了一组对象来完成对浏览器的操作</p>
<p>BOM 对象有：Window、Navigator、Location、History、Screen</p>
<p>（1）Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象</p>
<p>（2）Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器</p>
<p>由于历史原因 Navigator 对象中的大部分属性都已经不能识别浏览器了，一般只会使用 userAgent 来判断浏览器的信息，userAgent 是个包含用来描述浏览器信息内容的字符串</p>
<p>注意 IE11 中已经将微软和 IE 相关的表示去掉，所以不能通过 userAgent 识别是否是 IE 浏览器</p>
<p>若通过 userAgent 不能判断，还可通过一些浏览器中特有的对象来判断浏览器信息，如 ActiveXObject 是 IE 独有的</p>
<pre><code>var ua = navigator.userAgent;
if(/firefox/i,test(ua))&#123;
    console.log(&quot;火狐&quot;);
&#125;else if(/chrome/i,test(ua))&#123;
    console.log(&quot;chrome&quot;);
&#125;else if(/msie/i,test(ua))&#123;
    console.log(&quot;IE&quot;);
&#125;else if(&quot;ActiveXObject&quot; in window)&#123;
    console.log(&quot;IE11&quot;);
&#125;</code></pre>
<p>（3）Location：当前浏览器的地址栏信息，通过 Location 可获取地址栏信息或操作浏览器跳转页面</p>
<p>若直接打印 location 可获取地址栏的信息（当前页面的完整路径）</p>
<p>location = “xxxx” 直接将属性修改为一个完整的路径或相对路径则页面会自动跳转到该路径，<strong>并会生成相应的历史记录</strong></p>
<p>location.assign(“路径”) 用来跳转到其他页面，作用和直接修改 location 一样</p>
<p>location.reload() 重新加载当前页面，作用和刷新一样，若传递 true 作为参数则会强制清空缓存刷新页面</p>
<p>location.replace(“路径”) 使用新的页面替换当前页面，调用完毕也会跳转页面，<strong>但不会生成历史记录</strong>，不能使用回退按钮回退</p>
<p>（4）History：代表浏览器的历史记录，可通过该对象操作浏览器的历史记录，由于保护隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，且该操作只在当次访问时有效</p>
<p>history.length 可获取到当次访问的链接数量</p>
<p>history.back() 可用来回退到上一个页面，和浏览器中的回退按钮一样</p>
<p>history.forward() 可跳转到下一个页面，和浏览器的前进按钮一样</p>
<p>history.go(整数) 可跳转到指定的页面，需要整数作为参数</p>
<p>— 1 表示向前跳转一个页面，相当于 forward()</p>
<p>— 2 表示向前跳转两个页面</p>
<p>— -1 表示向后跳转一个页面</p>
<p>— -2 表示向后跳转两个页面</p>
<p>（5）Screen：代表用户的屏幕信息，通过该对象可获取到用户的显示器的相关信息（在移动端用的多）</p>
<p>这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用</p>
<h1 id="十七、定时器"><a href="#十七、定时器" class="headerlink" title="十七、定时器"></a>十七、定时器</h1><p>setInterval(回调函数,调用间隔) 是 window 对象的方法，将回调函数每隔一段时间执行一次，第二个参数的单位是毫秒，会返回 Number 类型的返回值，该返回值作为定时器的唯一标识</p>
<p>注意在开启定时器前一般需要先使用 clearInterval(xx) 将当前元素上的其他定时器关闭</p>
<p>clearInterval(定时器标识) 关闭定时器，可接收任意参数，若参数是一个有效的定时器标识则停止对应定时器，若不是一个有效标识，则什么也不做</p>
<pre><code>var num = 1;
var timer = setInterval(function()&#123;
    num++;
    console.log(num)
    if(num == 11)&#123;
        clearInterval(timer);
    &#125;
&#125;,1000);</code></pre>
<p>setTimeout(回调函数,延时时间) 演示调用一个函数不马上执行，而是隔一段时间后再执行，而且只会执行一次</p>
<p>clearTimeout(延时器标识) 关闭一个延时调用</p>
<p>延时调用和定时调用实际上可以互相代替的，注意定时调用会执行多次，而延时调用只会执行一次</p>
<p><strong>根据方向键移动 div 并解决第一次按下时延时的例子：</strong></p>
<pre><code>var speek = 10;
var dir = 0;
setInterval(function()&#123;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;)
document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;else&#123;
        speed = 10;  //松开 ctrl 不加速
    &#125;
    dir = event.keyCode;
&#125;
document.onkeyup = function()&#123;  //松开按键时，div 不再移动
    dir = 0;
&#125;</code></pre>
<h1 id="十八、JSON"><a href="#十八、JSON" class="headerlink" title="十八、JSON"></a>十八、JSON</h1><p>JS 中的对象只有 JS 自己认识，其他语言都不认识</p>
<p>JSON（JavaScript Object Notation，JS 对象表示法）是一个特殊格式的<strong>字符串</strong>，该字符串可被任意的语言识别，并且可转换为任意语言中的对象，JSON 在开发汇总主要用于数据的交互</p>
<p>JSON 和 JS 对象的格式一样，但是 JSON 字符串中的属性名必须加双引号</p>
<p>JSON 分类：</p>
<p>— 对象{}</p>
<p>— 数组[]</p>
<p>JSON 中允许的值有字符串、数值、布尔值、null、普通对象（不包括函数对象）、数值六种</p>
<p>通过工具类 JSON 来互换 JSON 字符串与 JS 中的对象（IE7 及一下浏览器不支持）</p>
<p>json –&gt; js 对象</p>
<pre><code>JSON.parse(JSON字符串)
eval(&quot;(&quot;+JSON字符串+&quot;)&quot;)  //IE7中，但不建议使用
通过引入外部的 js 文件（自定义的 JSON 对象）来处理  //兼容 IE7</code></pre>
<p>js 对象 –&gt; json</p>
<pre><code>JSON.stringify(js对象)</code></pre>
<p>eval() 可用来执行一段字符串形式的 JS 代码，并将执行结果返回，若 eval() 执行的字符串中含有 {}，它会将 {} 当成代码块，若不希望将其当成代码块解析，需在字符串前后各加一个 ()</p>
<p>但在开发中尽量不要使用 eval()，因为它的执行性能比较差，并且有安全隐患</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>1、把 JS 写到外部文件中通过外部文件引入可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>2、JS 中每条语句以 <code>;</code> 结尾，若没写分号浏览器会自动添加，但是会消耗一些系统资源，有时浏览器会加错分号</p>
<p>3、把 JS 代码写在 HTML 下方，加载完页面后加载</p>
<p>4、使用 <code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式时，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p><code>console.time(&quot;计时器的名字&quot;)</code> 可用来开启计时器</p>
<p><code>console.timeEnd(&quot;计时器的名字&quot;)</code> 可用来终止计时器</p>
<p>往表格 <code>&lt;table&gt;</code> 里使用 appendChild 添加 <code>&lt;tr&gt;</code> 时会添加在 <code>&lt;tbody&gt;</code> 外部，因此需要获取 tbody 对象后对它使用 appendChild 来添加 tr</p>
<p>对于使用 for 循环遍历元素来给元素添加响应函数，需要注意 for 循环会在页面加载完成后立即执行，而响应函数会在被点击时才执行，当响应函数执行时，for 循环早已执行完毕</p>
<p>浏览器的默认行为</p>
<pre><code>对于表单、超链接等，若不想点击后跳转或提交可在响应函数的最后添加 return false 取消默认行为

拖拽时浏览器默认会去搜索引擎中所有内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）

当滚轮滚动时，若浏览器由滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为

在文本框（如 input）中输入内容属于 onkeydown 的默认行为，可通过 return flase 取消默认行为，取消后输入内容不会出现在文本框中</code></pre>
<p>注意若使用 addEventListener() 方法绑定响应函数时取消默认行为不能用 <code>return false</code>，需要使用 event.preventDefault() 来取消默认行为</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode笔记</title>
    <url>/2021/12/01/LeetCode%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h2><a id="more"></a>

<p>在原数组中删除中某一元素，并返回最终数组的长度（忽略新长度后面的元素）</p>
<pre><code>解法一：

可使用快指针（用于遍历原数组）和慢指针（当前在原数组中填入元素的位置）来实现

时间复杂度：O(n)O(n)，其中 nn 为序列的长度。我们只需要遍历该序列至多两次。

空间复杂度：O(1)O(1)。我们只需要常数的空间保存若干变量。

解法二：（优化）

使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。避免了需要保留的元素的重复赋值操作。</code></pre>
<p>对于有序数组应想到二分查找，时间复杂度为 O(log n)</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>less学习笔记</title>
    <url>/2021/12/15/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>less 是一门 css 的预处理语言，less 是 css 增强版，通过 less 可以编写更少的代码实现更强大的样式</p>
<a id="more"></a>

<p>less 语法大体上和 css 一致，但 less 中增添了许多对 css 的扩展</p>
<p>在 less 中添加了许多新特性，如虽然在原生 css 中支持变量，但是对不同浏览器的兼容性不好，有的浏览器不支持，而通过 less 浏览器对变量、minxin 等都可支持</p>
<p>此外 less 中可以使用 <code>@import</code> 引入其他 less 文件有助于样式模块化</p>
<p>浏览器无法直接执行 less 代码，必须先将 less 转换为 css（如 VSCode 中 Easy LESS 插件可将 less 自动编译为 css），再由浏览器执行</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>变量声明：<code>@变量名:xxx;</code></p>
<p>使用变量：<code>@变量名</code></p>
<p>变量在 less 中属于块级作用域，延迟加载</p>
<p>— 当变量作为类名或属性名或一部分值使用时，通过<code>@&#123;变量名&#125;</code></p>
<p>— 直接使用另一个属性的值 <code>$参考的属性</code>（v3.0.0后支持）</p>
<p>— less 中样式可以嵌套，当表示当前层的元素本身时使用 <code>&amp;</code> 表示，表示子元素时使用<code>&gt;子元素&#123;&#125;</code></p>
<p>— 当前元素有与其他元素共有的部分时，用 <code>当前元素:extend(有相同样式的元素)&#123;&#125;</code>，关键字 all 表示继承所有父类的相关声明块</p>
<pre><code>#test&#123;
    &amp;:extend(.father all)
&#125;
//相当于
#test:extend(.father all)&#123;&#125;

实质上将 .father 选择器和 #test 组合成一个选择器，声明块使用 .father 的</code></pre>
<p>注意父类不能定义成混合（继承不灵活但性能高，混合灵活（因为可以传参）但性能低）</p>
<p>— 对其他元素样式进行引用，相当于直接复制其他元素样式 <code>元素选择器();</code>，这种方式性能比上一种差，因为要先复制</p>
<p>— 解决上个问题，可使用类选择器时可在选择器后添加一个括号，实际上就创建了一个mixins（相当于是个混合函数），即这部分样式不是自己用，而是专门给别人用</p>
<p>引入其他 less 文件，通过 <code>@import &quot;xxx.less;&quot;</code>，该功能可用于样式模块化，如将定义变量、定义动画、定义布局、整合的 less 文件分开，方便后期维护</p>
<p>less 中所有数值都可以直接进行运算，如 + - * /</p>
<p>当重复声明时，使用时依据就近原则，使用最近声明的值</p>
<p>可先使用后声明</p>
<pre><code>@a:100px;
@b:#bfa;
@c:box2;
@d:color;
.box1&#123;
    width: @a;
    @&#123;d&#125;: @b;
    background-@&#123;d&#125;:@b;
&#125;
.@&#123;c&#125;&#123;
    width: @a;
    background-image: url(&quot;@&#123;C&#125;/1.png&quot;);
&#125;
.p2:extend(.p1)&#123;
    color:red;
&#125;
.p3&#123;
    .p1();  //mixins，直接对指定样式进行引用
&#125;
.p4()&#123;  //创建了一个mixins
    width:100px;
    height:100px;
&#125;
.test(@w:100px,@h,@bg-color)&#123;  //调用混合函数，可指定默认值
    width: @w;
    height: @h;
    border: 1px solid @bg-color;
&#125;
div&#123;
    .test(200px,300px,#bfa);  //调用混合函数，按顺序传递参数，或.test(@bg-color:#bfa,@h:300px,@2:200px);
&#125;
.span&#123;
    color: average(red,blue);  //使用 less 定义好的混合函数
&#125;
body:hover&#123;
    background-color: darken(#bfa,20%); //使用 less 定义好的混合函数，当鼠标移入 body 时颜色加深20%
&#125;</code></pre>
<h1 id="less-的避免编译"><a href="#less-的避免编译" class="headerlink" title="less 的避免编译"></a>less 的避免编译</h1><p><code>~&quot;不会被编译的内容&quot;</code></p>
<h1 id="VSCode-中的插件-Easy-LESS"><a href="#VSCode-中的插件-Easy-LESS" class="headerlink" title="VSCode 中的插件 Easy LESS"></a>VSCode 中的插件 Easy LESS</h1><p>Easy LESS 插件可将 less 自动编译为 css，但是在浏览器中检查页面样式时显示的依然时 css 文件中的代码位置，可在插件中设置如下内容，设置后浏览器中调试样式显示的时在 less 文件中的代码位置</p>
<pre><code>&quot;less.compile&quot;:&#123;
    &quot;compress&quot;: false,  //true =&gt; remove surplus whitespace
    &quot;sourceMap&quot;: true,  //true =&gt; generate source maps(.css.map files)
    &quot;out&quot;: true,   //false =&gt; DON&#39;T output .css files(overidable per-file)
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>HTML+CSS学习笔记</title>
    <url>/2021/12/08/HTML-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="网页特点"><a href="#网页特点" class="headerlink" title="网页特点"></a>网页特点</h1><p>优点：（1）无需安装（2）无需更新（3）跨平台</p>
<a id="more"></a>

<h1 id="网页组成"><a href="#网页组成" class="headerlink" title="网页组成"></a>网页组成</h1><p>W3C标准制定网页由结构（HTML）+样式（CSS）+行为（JS）组成</p>
<head>中包含的是网页的元数据，浏览器或搜索引擎根据这些元数据解析网页

<p>注释不能嵌套</p>
<h1 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h1><h2 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2><p>文档声明通过标签 <code>&lt;!doctype&gt;</code> 用于告知浏览器当前网页的版本（如HTML 4、HTML5、XHTML等），不区分大小写</p>
<p>HTML5文档声明：<code>&lt;!doctype html&gt;</code></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>内存中一个小格子为 1 位，内存中无法操作 bit ，最小可操作单位为 1 byte（字节）= 8 bit</p>
<pre><code>8 bit = 1 byte（字节）
1024 byte = 1 kb（千字节）
1024 kb = 1 mb（兆字节）
1024 mb = 1 gb（吉字节）
1024 gb = 1 tb（特字节）
1024 tb = 1 pb</code></pre>
<p>所有数据在计算机中以二进制存储，包括文本、图片、音频等。编码解码采用的规则称为字符集，如ASCII（美国7位）、ISO88591（欧洲 8位）、GB2312（中国）、GBK（中国 GB2312的扩展）、UTF-8（万国码）</p>
<p>字符集说明写在 <code>&lt;meta&gt;</code> 标签里，如 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>，从而避免乱码问题</p>
<h2 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h2><p><code>&lt;meta&gt;</code> 标签用于设置网页中的元数据，用于浏览器或搜索引擎解析网页。<code>&lt;meta&gt;</code> 没有结束标签</p>
<p>常用属性有 name（指定数据的名称，如keywords、description）+ content（指定数据的内容）、http-equiv（网页重定向）+ content、charset（指定网页的字符集）</p>
<p>例子</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;购物,网上购物&quot;&gt;
为网页设置关键字，当在搜索引擎中搜索 “购物” 时会推荐该网站

&lt;meta name=&quot;description&quot; content=&quot;这是网站的描述&quot;&gt;
为网站设置描述，该描述会显示在搜索引擎搜索的结果中

&lt;meta http-quiv=&quot;refresh&quot; content=&quot;秒数,url=https://www.baidu.com&quot;&gt;
为网站设置定时重定向，当到达相应秒数后网页会跳转到相应路径</code></pre>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><h3 id="块元素、行内元素、替换元素"><a href="#块元素、行内元素、替换元素" class="headerlink" title="块元素、行内元素、替换元素"></a>块元素、行内元素、替换元素</h3><h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><p>在页面中独占一行的元素称为块（block）元素。</p>
<p>如 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;blockquote&gt;</code>（表示一个长引用，会换行缩进，对比<code>&lt;q&gt;</code>）</p>
<p>— 块元素一般用于网页布局</p>
<p>— 一般会在块元素中放行内元素，块元素中基本什么都能放</p>
<p>— <code>&lt;p&gt;</code> 中不能放任何块元素，若写错，浏览器在解析时会自动修正</p>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p>在页面中不会独占一行的元素称为行内（inline）元素。</p>
<p>如 <code>&lt;em&gt;</code>（斜体）、<code>&lt;strong&gt;</code>（加粗）、<code>&lt;q&gt;</code>（短引用，不换行加引号，对比 <code>&lt;blockquote&gt;</code>）、<code>&lt;a&gt;</code>（超链接）</p>
<p>— 行内元素主要用于包裹文字</p>
<p>— 行内元素中不会放块元素，<strong>但是 <code>&lt;a&gt;</code> 可嵌套除它自身外的任何元素</strong></p>
<h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>如 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code></p>
<h3 id="布局标签（结构化语义标签）"><a href="#布局标签（结构化语义标签）" class="headerlink" title="布局标签（结构化语义标签）"></a>布局标签（结构化语义标签）</h3><p>如以下 HTML5 新增标签</p>
<pre><code>&lt;header&gt;  表示网页头部
&lt;main&gt;    表示网页主体（一个页面只有一个 &lt;main&gt;）
&lt;footer&gt;  表示网页底部
&lt;nav&gt;     表示网页导航
&lt;aside&gt;   表示网页中与主体相关的其他内容（侧边栏）
&lt;article&gt; 表示一个独立的文章
&lt;section&gt; 表示一个独立的区块，以上标签都不合适时用 &lt;section&gt;</code></pre>
<p>与 <code>&lt;section&gt;</code> 类似的有 <code>&lt;div&gt;</code>（没有语义，表示区块）和 <code>&lt;span&gt;</code>（没有语义，行内元素）</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1、无序列表 <code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code>（列表项，块元素）</p>
<p>2、有序列表 <code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code>（列表项）</p>
<p>3、定义列表 <code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code>（表示定义的内容）+ <code>&lt;dd&gt;</code>（对内容进行解释说明）</p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><code>&lt;a&gt;</code>为行内元素</p>
<p>超链接通过设置属性 href 可跳转至其他网页，或在当前网页中进行跳转。</p>
<p><code>href=&quot;#&quot;</code> 跳转至页面顶部</p>
<p><code>href=&quot;#目标元素的id&quot;</code> 跳转至页面相应元素处</p>
<p><code>href=&quot;javascript:;&quot;</code> 可作为超链接路径的占位符点击后什么也不会发生</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><code>&lt;img&gt;</code> 是替换元素（显示内容并非代码里写的内容，而是利用引入内容进行替换），介于块元素和行内元素之间，兼具两者特点（既能设置宽高，又不会独占一行）</p>
<p>在 <code>&lt;img&gt;</code> 中 alt 属性默认情况不会显示，部分浏览器在图片无法加载时会显示，并且搜索引擎会根据 alt 中内容来识别图片</p>
<p>图片一般有jpeg、jpg、gif、png、webp</p>
<pre><code>jepg/jpg：支持颜色较丰富，不支持透明效果，不支持动图

gif：支持颜色较少，支持简单透明，支持动图

png：支持颜色丰富，支持复杂透明，不支持动图

webp：谷歌新推出的专门用于表示网页中图片的一种格式，具备其他图片格式的所有优点，而且文件还很小。缺点：兼容性不好

base64：将图片使用base64编码，将图片转换为字符，在 src 中通过字符的形式引入图片。一般需要和网页一起加载的图片用 base64，否则其他格式图片是在浏览器向后端请求网页后再次发送图片资源的请求</code></pre>
<p>原则：效果一样，用小的；效果不一样，用效果好的</p>
<h3 id="引入音频-视频"><a href="#引入音频-视频" class="headerlink" title="引入音频/视频"></a>引入音频/视频</h3><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p><code>&lt;audio&gt;</code>标签来引入音频，可在<code>&lt;audio&gt;</code>内添加 src 属性，也可在标签中间添加 <code>&lt;source src=&quot;xxx&quot;&gt;</code>来引入相应文件。</p>
<p>还包括属性 controls（音频文件引入时默认不允许用户控制播放，加入该属性允许用户控制）、autoplay（打开页面时是否自动播放，大部分浏览器考虑到用户体验不会自动播放）、loop（是否循环播放）</p>
<p><strong>考虑浏览器兼容问题：</strong></p>
<p>（1）当浏览器不支持 <code>&lt;audio&gt;</code> 时显示文字提示</p>
<p>（2）当浏览器不支持某种格式音频文件时使用另一种格式的音频文件</p>
<p>（3）老版本浏览器不支持 <code>&lt;audio&gt;</code> 时，可使用 <code>&lt;embed&gt;</code>，包括属性src、<code>type=&quot;audio/mp3&quot;</code>、width、height</p>
<pre><code>&lt;audio src=&quot;./xxx.mp3&quot; controls autoplay loop&gt;&lt;/audio&gt;

（1）浏览器支持 &lt;audio&gt; 时显示音频，不支持时显示文字提示
（2）浏览器会从上至下选择一个音频文件
    &lt;audio controls&gt;
        该浏览器不支持音频播放 
        &lt;source src=&quot;./xxx.mp3&quot;&gt;
        &lt;source src=&quot;./xxx.ogg&quot;&gt;
    &lt;/audio&gt;
（3）让所有浏览器都可显示音频，支持&lt;audio&gt;时用&lt;audio&gt;，并从&lt;source&gt;获取音频文件，不支持&lt;audio&gt;时会选&lt;embed&gt;
    &lt;audio controls&gt; 
        &lt;source src=&quot;./xxx.mp3&quot;&gt;
        &lt;source src=&quot;./xxx.ogg&quot;&gt;
        &lt;embed src=&quot;./xxx.mp3&quot; type=&quot;audio/mp3&quot;&gt;
    &lt;/audio&gt;</code></pre>
<h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p>通过标签 <code>&lt;video&gt;</code>，使用方式和音频差不多，注意 <code>&lt;embed&gt;</code> 中<code>type=&quot;video/mp4&quot;</code></p>
<h3 id="内联框架-lt-iframe-gt"><a href="#内联框架-lt-iframe-gt" class="headerlink" title="内联框架&lt;iframe&gt;"></a>内联框架<code>&lt;iframe&gt;</code></h3><p><code>&lt;iframe&gt;</code>用于向当前页面引入一个其他页面，页面中将会有个窗口显示其他网页，其中 src 属性设置要引入的网页路径，frameborder 属性设置内联框架是否有边框（取值为 0 或 1）</p>
<p>缺点：内联框架中的网页不会被搜索引擎检索，因此对 SEO 也没有什么好处</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><code>&lt;table&gt;&lt;/table&gt;</code> 表示表格（块元素），<code>&lt;tr&gt;</code> 表示一行（块元素），，<code>&lt;td&gt;</code> 表示一列（行内元素）</p>
<p>在 <code>&lt;td&gt;</code> 中设置属性 <code>colspan=&quot;合并的列数&quot;</code> 可横向合并单元格，<code>rowspan=&quot;合并的行数&quot;</code> 可纵向合并单元格</p>
<p>可以将表格分为如下三部分，通过定义这三部分后，表格头部、主体、底部在代码中的书写顺序无要求，最终显示为表头-主体-底部</p>
<pre><code>`&lt;thead&gt;` 头部
`&lt;tbody&gt;` 主体
`&lt;tfoot&gt;` 底部</code></pre>
<p>在这三部分中间可添加行列 <code>&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</code>，还可添加 <code>&lt;th&gt;</code> 表示头部单元格代替 <code>&lt;td&gt;</code> ，如 <code>&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;</code>， <code>&lt;th&gt;</code> 中的文字会加粗居中</p>
<p><strong>注：若表格中没有使用 tbody 而是直接使用 tr，浏览器会自动创建一个 tbody，并将 tr 全都放到 tbody 中，因此 tr 不是 table 的子元素</strong></p>
<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p><code>border-spacing: xxpx;</code> 指定边框间的距离</p>
<p><code>border-collapse: collapse;</code> 设置边框的合并</p>
<pre><code>如表格外边框与单元格边框间有间距，可通过
table&#123;
    border: 1px solid black;
    border-spacing: 0px;
&#125;
td&#123;
    border: 1px solid black;
&#125;
消除间隙，但此时是把两者边框间距设为 0，实际边框为 1+1=2px
可通过如下属性设置边框合并
table&#123;
    border: 1px solid black;
    border-collapse: collapse;
&#125;
td&#123;
    border: 1px solid black;
&#125;
此时也没有间隙，且两者边框合并后实际边框为 1px</code></pre>
<p><code>vertical-align</code> 设置 <code>&lt;td&gt;</code> 中的元素对齐方式，默认情况下元素在 <code>&lt;td&gt;</code> 中是垂直居中的。可选值有 top、bottom、middle（默认） 等</p>
<p>注：在 <code>&lt;td&gt;</code> 中是所有元素都能通过 <code>vertical-align</code> 设置，而其他元素中 <code>vertical-align</code> 只会影响文字</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p><code>&lt;form&gt;</code> 声明表单，属性有 <code>action</code>（表单要提交的服务器地址）</p>
<pre><code>表单内容
文本框
    &lt;input type=&quot;text&quot; name=&quot;服务器根据name获取相应数据&quot;&gt;
密码           
    &lt;input type=&quot;password&quot; name=&quot;服务器根据name获取相应数据&quot;&gt;
提交按钮  
    &lt;input type=&quot;submit&quot; value=&quot;按钮上的文字&quot;&gt;
    或&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
普通按钮
    &lt;input type=&quot;button&quot; value=&quot;按钮上的文字&quot;&gt;
    或&lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt;
重置按钮
    &lt;input type=&quot;reset&quot;&gt;
    或&lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;
单选按钮
    &lt;input type=&quot;radio&quot; name=&quot;xxx&quot; value=&quot;向服务器发送的数据&quot; checked&gt;
    通过相同的 name 属性限制相同 name 只能选一个，checked 表示默认选中
多选框
    &lt;input type=&quot;checkbox&quot; name=&quot;xxx&quot; value=&quot;向服务器发送的数据&quot; checked&gt;
    checked 表示默认选中
下拉列表
    &lt;select name=&quot;xxx&quot;&gt;
        &lt;option value=&quot;向服务器发送的数据&quot; selected&gt;选项一&lt;/option&gt;
        &lt;option value=&quot;向服务器发送的数据&quot;&gt;选项二&lt;/option&gt;
    &lt;/select&gt;
    selected 表示默认选中
颜色选择框（浏览器兼容性不好）
    &lt;input type=&quot;color&quot;&gt;
电子邮件输入框，会检查输入格式（浏览器兼容性不好）
    &lt;input type=&quot;email&quot;&gt;

表单中元素的属性
autocomplete=&quot;on或off&quot; 开启或关闭自动补全
readonly      将表单项设置为只读，无法修改，但数据会提交
disabled      将表单项设为禁用，数据不会提交
autofocus     设置表单项自动获取焦点</code></pre>
<p>数据要提交到服务器中，必须为元素指定 name 属性值</p>
<p>若给表单项添加 <code>disabled = &quot;disabled&quot;</code> 则表单项将变成不可用状态</p>
<h1 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h1><p>网页实际上是一个多层结构，通过 CSS（层叠样式表）为每层设置样式</p>
<p>设置 CSS 方法:</p>
<p>（1）内联/行内样式：在标签内部通过 style 属性设置元素样式。只能对一个标签起作用</p>
<p>（2）内部样式表：在 <code>&lt;head&gt;</code> 的 <code>&lt;style&gt;</code> 中通过CSS选择器选中元素并为其设置样式 。只能对一个页面起作用，不能跨页面复用</p>
<p>（3）外部样式表：编写到外部 CSS 文件里，通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx.css&quot;&gt;</code> 引入。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="1、基本选择器"><a href="#1、基本选择器" class="headerlink" title="1、基本选择器"></a>1、基本选择器</h3><h4 id="（1）元素选择器"><a href="#（1）元素选择器" class="headerlink" title="（1）元素选择器"></a>（1）元素选择器</h4><p>根据标签名选中指定元素，如 <code>p&#123;&#125; div&#123;&#125;</code></p>
<h4 id="（2）id-选择器"><a href="#（2）id-选择器" class="headerlink" title="（2）id 选择器"></a>（2）id 选择器</h4><p>根据元素的 id 选中一个元素，如 <code>#box&#123;&#125; #element&#123;&#125;</code></p>
<h4 id="（3）类选择器"><a href="#（3）类选择器" class="headerlink" title="（3）类选择器"></a>（3）类选择器</h4><p>根据元素的 class 属性选中一组元素，如 <code>.box&#123;&#125; .element&#123;&#125;</code></p>
<p>class 可以重复使用，通过 class 属性为元素分组，也可同时为一个元素指定多个 class 属性</p>
<h4 id="（4）通配选择器"><a href="#（4）通配选择器" class="headerlink" title="（4）通配选择器"></a>（4）通配选择器</h4><p>选中页面所有元素，如 <code>*&#123;&#125;</code></p>
<h3 id="2、复合选择器"><a href="#2、复合选择器" class="headerlink" title="2、复合选择器"></a>2、复合选择器</h3><h4 id="（1）交集选择器"><a href="#（1）交集选择器" class="headerlink" title="（1）交集选择器"></a>（1）交集选择器</h4><p>选中同时符合多个条件的元素，如 <code>选择器1选择器2选择器n&#123;&#125;</code></p>
<p>注意：交集选择器中若有元素选择器，必须使用元素选择器开头</p>
<h4 id="（2）选择器分组（并集选择器）"><a href="#（2）选择器分组（并集选择器）" class="headerlink" title="（2）选择器分组（并集选择器）"></a>（2）选择器分组（并集选择器）</h4><p>同时选择多个选择器对应的元素，如 <code>选择器1,选择器2,选择器n&#123;&#125;</code></p>
<h3 id="3、关系选择器"><a href="#3、关系选择器" class="headerlink" title="3、关系选择器"></a>3、关系选择器</h3><h4 id="（1）子元素选择器"><a href="#（1）子元素选择器" class="headerlink" title="（1）子元素选择器"></a>（1）子元素选择器</h4><p>选中指定父元素的指定子元素，语法 <code>父元素 &gt; 子元素&#123;&#125;</code></p>
<h4 id="（2）后代元素选择器"><a href="#（2）后代元素选择器" class="headerlink" title="（2）后代元素选择器"></a>（2）后代元素选择器</h4><p>选中指定元素内的指定后代元素，语法 <code>祖先 后代&#123;&#125;</code></p>
<h4 id="（3）选择下一个兄弟元素"><a href="#（3）选择下一个兄弟元素" class="headerlink" title="（3）选择下一个兄弟元素"></a>（3）选择下一个兄弟元素</h4><p>语法 <code>兄 + 弟&#123;&#125;</code></p>
<h4 id="（4）选择下边所有兄弟元素"><a href="#（4）选择下边所有兄弟元素" class="headerlink" title="（4）选择下边所有兄弟元素"></a>（4）选择下边所有兄弟元素</h4><p>语法 <code>兄 ~ 弟&#123;&#125;</code></p>
<h3 id="4、属性选择器"><a href="#4、属性选择器" class="headerlink" title="4、属性选择器"></a>4、属性选择器</h3><p>[属性名] 选择含有指定属性的元素</p>
<p>[属性名=属性值] 选择含有指定属性和属性值的元素</p>
<p>[属性名^=属性值] 选属性值以指定值开头的元素</p>
<p>[属性名$=属性值] 选属性值以指定值结尾的元素</p>
<p>[属性名*=属性值] 选属性值中含有某值的元素</p>
<h3 id="5、伪类选择器"><a href="#5、伪类选择器" class="headerlink" title="5、伪类选择器"></a>5、伪类选择器</h3><p>伪类（不存在的类/特殊的类）用来描述一个元素的<strong>特殊状态</strong>，如：第一个子元素、被点击的元素、鼠标移入的元素</p>
<h4 id="（1）子元素伪类1"><a href="#（1）子元素伪类1" class="headerlink" title="（1）子元素伪类1"></a>（1）子元素伪类1</h4><p><code>:first-child</code>  第一个子元素</p>
<p><code>:last-child</code>  最后一个子元素</p>
<p><code>:nth-child(第几个)</code>  选中第n个子元素，特殊值：n（子元素全选）、2n 或 even（选中偶数位的子元素）、2n+1 或 odd（选中奇数位的子元素）</p>
<p><strong>注：以上伪类都是根据其父元素的所有子元素进行排序</strong></p>
<h4 id="（2）子元素伪类2"><a href="#（2）子元素伪类2" class="headerlink" title="（2）子元素伪类2"></a>（2）子元素伪类2</h4><p><code>:first-of-type</code>、<code>:last-of-type</code>、<code>:nth-of-type()</code> 这三种伪类与上述功能相似，不同是这三种是在同类型子元素中排序</p>
<pre><code>如
&lt;ul&gt;
    &lt;span&gt;xxx&lt;/span&gt;
    &lt;li&gt;xxx&lt;/li&gt;
    &lt;li&gt;xxx&lt;/li&gt;
&lt;/ul&gt;

设置样式
ul &gt; li:first-child&#123;
    color:red;   //对第一个 &lt;li&gt; 不生效，因为 &lt;span&gt; 才是第一个子元素
&#125;
ul &gt; li:first-of-type&#123;
    color:red;   //对第一个 &lt;li&gt; 生效
&#125;</code></pre>
<h4 id="（3）否定伪类"><a href="#（3）否定伪类" class="headerlink" title="（3）否定伪类"></a>（3）否定伪类</h4><p>否定伪类 <code>:not()</code>，将符合条件的元素从选择器中去除</p>
<pre><code>ul &gt; li:not(:nth-of-type(3))&#123;
    color:red;   //除了第三个 &lt;li&gt; 外，其他 &lt;li&gt; 变为红色
&#125;</code></pre>
<h4 id="（4）超链接伪类"><a href="#（4）超链接伪类" class="headerlink" title="（4）超链接伪类"></a>（4）超链接伪类</h4><p><code>:link</code> 表示正常链接/没访问过的链接</p>
<p><code>:visited</code> 表示访问过的链接</p>
<p>由于保护隐私原因，<code>:visited</code> 伪类只能修改链接颜色，无法修改大小、背景等。</p>
<p>以上两种是超链接独有的伪类</p>
<h4 id="（5）其他伪类"><a href="#（5）其他伪类" class="headerlink" title="（5）其他伪类"></a>（5）其他伪类</h4><p><code>:hover</code> 表示鼠标移入的状态</p>
<p><code>:active</code> 表示鼠标点击时</p>
<h3 id="6、伪元素选择器"><a href="#6、伪元素选择器" class="headerlink" title="6、伪元素选择器"></a>6、伪元素选择器</h3><p>伪元素（不真实存在的元素/特殊的元素）用来描述一个元素的<strong>特殊位置</strong></p>
<p><code>::first-letter</code>  第一个字母</p>
<p><code>::first-line</code>  第一行</p>
<p><code>::selection</code>  鼠标选中的内容</p>
<p><code>::before</code> 元素的开始，必须结合 <code>content</code> 属性， <code>content</code> 中添加的内容鼠标无法选中</p>
<p><code>::after</code> 元素的最后，必须结合 <code>content</code> 属性</p>
<pre><code>如
div::before&#123;
    content:&#39;xxx&#39;;
    color:red;
&#125;
会在 &lt;div&gt; 元素前添加字符串 &#39;xxx&#39;，并且该添加的部分为红色</code></pre>
<p>伪元素默认是一个行内元素</p>
<h2 id="样式继承"><a href="#样式继承" class="headerlink" title="样式继承"></a>样式继承</h2><p>样式继承是发生在祖先和后代之间的，为一个元素设置的样式会同时应用到其后代元素上</p>
<p>但部分样式如背景（图片、颜色）相关、布局相关等的样式不会被继承</p>
<h2 id="样式冲突与选择器权重"><a href="#样式冲突与选择器权重" class="headerlink" title="样式冲突与选择器权重"></a>样式冲突与选择器权重</h2><p><strong>样式冲突：</strong>当通过不同选择器，选中<strong>相同元素</strong>，并为<strong>相同样式</strong>设置不同值时，就发生了样式冲突</p>
<p>发生样式冲突时，应用哪个样式由选择器权重（优先级）决定</p>
<p><strong>选择器权重</strong>如下，从上至下递减：</p>
<pre><code>1. 内联样式       优先级：1,0,0,0
2. id 选择器      优先级：0,1,0,0
3. 类和伪类选择器  优先级：0,0,1,0
4. 元素选择器      优先级：0,0,1,0
5. 通配选择器      优先级：0,0,0,0
6. 继承的样式      没有优先级</code></pre>
<p>比较优先级时遵循以下<strong>原则</strong>：</p>
<p>（1）比较优先级时，需要将针对该元素的所有选择器的优先级进行相加计算，优先级越高，越优先显示（分组选择器中每个元素是独立计算互不影响）</p>
<p>（2）选择器的累加不会超过其最大数量级，对同一元素设置多个类累加后再高也不会超过 id 选择器</p>
<p>（3）若优先级计算后相等，则优先使用靠下的样式</p>
<p>（4）在某个样式后添加 <code>!important</code>，此时该样式会获取最高优先级，甚至超过内联样式（慎用）</p>
<h2 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h2><p><strong>使用外部样式表，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户体验</strong></p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h3><p><strong>像素：</strong>不同屏幕像素大小不同，像素越小屏幕显示越清晰，同样像素值在不同设备下显示效果不同</p>
<p><strong>百分比：</strong>可将属性值设置为相对其父元素属性的百分比</p>
<p><strong>em：</strong>相对于元素的字体大小计算的，em会根据字体大小变化而改变，如 1 em = 1 font-size，默认情况下 font-size = 16 px</p>
<p><strong>rem：</strong>是相对与根元素 <code>&lt;html&gt;</code> 的字体大小来计算的</p>
<p><strong>vw：</strong>是相对于视口宽度（viewport width）计算，1 vw = 1% 视口宽度，100 vw = 100% 视口宽度（移动端都支持，PC 端新版浏览器支持）</p>
<p><strong>vw 与 百分比：</strong>百分比参照的是父元素的宽高，参照物是会一直改变的，而 vw 参照的总是视口宽度</p>
<h3 id="颜色单位"><a href="#颜色单位" class="headerlink" title="颜色单位"></a>颜色单位</h3><p>颜色名称：可通过颜色英文名来设置颜色</p>
<p>RGB：通过三原色调配出不同颜色，此处指光的三原色，每种颜色范围为 0-255（0%-100%），全 0 为黑色，全为 255 表示白色</p>
<p>RGBA：在 rgb 基础上增加一个透明度，1 表示完全不透明，0 表示完全透明</p>
<p>十六进制 RGB：共六位，两位两位分别对应R、G、B，范围为 00-ff，若两位两位重复可简写，如 #aabbcc 可简写为 #abc</p>
<p>HSL/HSLA 值：</p>
<p>H（色相，对应一个色环，红橙黄绿蓝靛紫一圈最后转回红，取值为0-360）</p>
<p>S（饱和度，取值为0%-100%，取值为 0% 时为灰色）</p>
<p>L（亮度，取值为0%-100%，当取值为 0% 时为黑色，取值为 100% 时为白色）</p>
<p>A（透明度，取值为0-1，和 RGBA 类似）</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>网页是一个立体多层结构，最底下的一层称为文档流，文档流是网页的基础，创建的元素默认都是在文档流中排列</p>
<p>在文档流中</p>
<p>—块元素：</p>
<pre><code>会在页面中独占一行（自上向下垂直排列）
默认宽度是把父元素填满，是父元素的全部
默认高度是被子元素内容撑开</code></pre>
<p>—行内元素：</p>
<pre><code>不会在页面中独占一行（自左向右水平排列），一行容不下会自动换行
默认宽度和高度是被子元素内容撑开，无法设置宽高</code></pre>
<h3 id="盒模型-盒子模型-框模型（box-model）"><a href="#盒模型-盒子模型-框模型（box-model）" class="headerlink" title="盒模型/盒子模型/框模型（box model）"></a>盒模型/盒子模型/框模型（box model）</h3><p>CSS 将页面中所有元素都设置为一个矩形的盒子</p>
<p>盒子 = 内容区（content）+ 内边距（padding）+ 边框（border）+ 外边距（margin）</p>
<p><strong>盒子的可见大小由内容区、内边距和边框共同决定</strong></p>
<h4 id="（1）内容区"><a href="#（1）内容区" class="headerlink" title="（1）内容区"></a>（1）内容区</h4><p>元素中所有的子元素和文本内容都在内容区中排列，大小由 width 和 height 属性设置</p>
<h4 id="（2）边框"><a href="#（2）边框" class="headerlink" title="（2）边框"></a>（2）边框</h4><p>边框大小会影响到整个盒子大小，至少设置三个样式</p>
<pre><code>宽度 border-width，默认为 3px
颜色 border-color，默认使用 color（实际上指定的是前景的颜色如字体、边框等，区别于背景） 的颜色
样式 border-style，默认为none，取值有solid（实线）、dotted（点状虚线）、dashed（虚线）、double（双线）

四个值：上       右       下     左
三个值：上       左右     下
两个值：上下     左右
一个值：上下左右

单独指定某一边样式：border-top/right/bottom/left-width/color/style

简写：将三种属性写在一行用空格隔开，没有顺序要求
如border: 10px green solid;
border-top：10px solid red;</code></pre>
<p><strong>outline 与 border 的区别：</strong></p>
<p>outline 用来设置元素的轮廓线，用法与 border 一样，但是 outline 不会影响可见区域大小，不会挤走其他元素，会覆盖在其他元素上，不占用其余空间，即不会影响页面布局</p>
<p><strong>盒子阴影</strong></p>
<p>box-shadow 同样不会影响页面布局</p>
<pre><code>第一个值 水平偏移量，正值向右移动，负值向左移动

第一个值 垂直偏移量，正值向下移动，负值向上移动

第三个值 阴影的模糊半径

第四个值 阴影的颜色</code></pre>
<p><strong>盒子圆角</strong></p>
<p>border-radius、border-top/bottom-left/right-radius 会通过设置圆角的圆半径来形成圆角效果。</p>
<pre><code>border-top-left-radius:50px 100px; //椭圆角，两个值分别为 x、y 轴半径
border-radius 取值规则如下
    四个值：左上       右上        右下   左下
    三个值：左上       右上/左下    右下
    两个值：左上/右下   右上/左下    右下
    一个值：四个角
设置椭圆角 border-radius: 20px / 40px;
设置元素为圆形 border-radius: 50%;</code></pre>
<h4 id="（3）内边距"><a href="#（3）内边距" class="headerlink" title="（3）内边距"></a>（3）内边距</h4><p>内边距为内容区和边框间的距离，有四个方向的内边距。</p>
<p>内边距的设置会影响盒子的大小，背景颜色会延伸到内边距。当有四个值时规则和 border 相同分别表示“上右下左”</p>
<h4 id="（4）外边距"><a href="#（4）外边距" class="headerlink" title="（4）外边距"></a>（4）外边距</h4><p>外边距不会影响盒子可见大小，但会影响位置以及盒子实际占用空间。也有四个方向外边距</p>
<p>元素在页面中是按照自左向右的顺序排列，<strong>若设置左和上边距则会移动元素自身，而设置下和右边距会移动其他元素</strong></p>
<p>默认情况下设置 <code>margin-right</code> 不会产生任何效果</p>
<h4 id="（5）水平布局"><a href="#（5）水平布局" class="headerlink" title="（5）水平布局"></a>（5）水平布局</h4><p>元素水平方向的位置由 margin-left、border-left、padding-left、width、padding-right、border-right、margin-right 共同决定</p>
<p>其中 width（默认为 auto）、margin-left、margin-right 这三个属性可以设置为 auto</p>
<p>一个元素在其父元素中，水平布局必须满足以下等式</p>
<pre><code>margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 父元素（更准确应为包含块）内容区宽度（width）</code></pre>
<p>其中可设置为 auto 的值有 margin、width</p>
<p>若相加结果等式不成立，则称为过度约束，则等式会自动调整</p>
<p>— 在这七个值没有为 auto 的情况下，浏览器会自动调整 margin-right 值使等式成立；</p>
<p>— 若某个值为 auto 的情况，则浏览器会自动调整值为 auto 的属性值以使等式成立</p>
<p>— 若将一个宽度和一个外边距设为 auto 或三个值都设置为 auto，则宽度会调整为最大，设置为 auto 的外边距会自动为 0</p>
<p>— 若将两个外边距设置为 auto，宽度为固定值，则会将外边距设置为相同的值，即元素在父元素中水平居中</p>
<h4 id="（6）垂直布局"><a href="#（6）垂直布局" class="headerlink" title="（6）垂直布局"></a>（6）垂直布局</h4><h5 id="1-当父元素没有设置高度时，默认父元素高度是被内容撑开"><a href="#1-当父元素没有设置高度时，默认父元素高度是被内容撑开" class="headerlink" title="1. 当父元素没有设置高度时，默认父元素高度是被内容撑开"></a>1. 当父元素没有设置高度时，默认父元素高度是被内容撑开</h5><h5 id="2-处理子元素从父元素中溢出："><a href="#2-处理子元素从父元素中溢出：" class="headerlink" title="2. 处理子元素从父元素中溢出："></a>2. 处理子元素从父元素中溢出：</h5><pre><code>通过设置
overflow
overflow-x（处理水平方向溢出）
overflow-y（处理垂直方向溢出）

取值有
visible（默认值，溢出依然显示）
hidden（裁剪溢出内容）
scroll（生成水平和述竖直两个滚动条）
auto（根据需要生成滚动条）</code></pre>
<h5 id="3-垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。"><a href="#3-垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。" class="headerlink" title="3. 垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。"></a>3. 垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。</h5><p>如上面的 div1 设置 margin-bottom:100px; 下面的 div2 设置 margin-top:100px; 则两个 div 间的距离为 100px</p>
<p><strong>对于兄弟元素（对于开发有利，一般不需要处理）</strong></p>
<p>— 兄弟元素间的<strong>相邻</strong>的<strong>垂直</strong>外边距会取两者间绝对值较大的值（包括正负）</p>
<p>— 若兄弟元素间外边距一正一负，则取两者的和</p>
<p>对于父子元素（会影响页面布局，需处理）</p>
<p><strong>父子元素间的外边距，子元素的会传递给父元素（上边距）</strong></p>
<p><strong>处理方式一</strong>：不使用外边距</p>
<p>通过内边距代替，在父元素中设置 padding-top，并且父元素的高度 height 也要调整减去 padding-top 的值</p>
<p><strong>处理方式二：</strong>不让外边距相邻</p>
<p>在父元素中设置 border，同时调整父元素和子元素的 height</p>
<p><strong>处理方式三：</strong>不让外边距相邻</p>
<p>在父元素中设置一个子元素，把父元素与带有 margin-top 的子元素隔开，具体使用如下</p>
<pre><code>父元素::before&#123;
    content:&#39;&#39;;
    display:table;
&#125;</code></pre>
<h4 id="（7）行内元素盒模型"><a href="#（7）行内元素盒模型" class="headerlink" title="（7）行内元素盒模型"></a>（7）行内元素盒模型</h4><p>行内元素不支持设置宽度和高度</p>
<p>行内元素可以设置 padding、margin、border，但是垂直方向的 padding、margin、border 不会影响页面布局（即不会把其他元素挤开），但是可能会覆盖住其他元素</p>
<p>水平方向相邻的 padding、margin 不会折叠，会直接相加</p>
<h4 id="（8）行内元素与块元素间的转换"><a href="#（8）行内元素与块元素间的转换" class="headerlink" title="（8）行内元素与块元素间的转换"></a>（8）行内元素与块元素间的转换</h4><p>通过 <code>&lt;display&gt;</code> 来设置元素显示类型</p>
<pre><code>可选值：
    inline        将元素设置为行内元素
    block         将元素设置为块元素
    inline-block  将元素设置为行内块元素（既可设置宽度和高度又不会独占一行），但是会像文字一样元素的换行会在页面中显示一个空格
    table         将元素设置为一个表格
    none          元素不在页面中显示，且不占位，隐藏元素</code></pre>
<h4 id="（9）盒子大小"><a href="#（9）盒子大小" class="headerlink" title="（9）盒子大小"></a>（9）盒子大小</h4><p>默认盒子可见大小由内容区 + 内边距 + 边框共同决定</p>
<p>通过设置 <code>box-sizing</code> 属性可更改盒子尺寸的计算方式，即设置 width 和 height 属性的作用</p>
<pre><code>可选值有
    content-box：默认值，此时 width 和 height 用来设置内容区大小
    border-box：此时 width 和 height 用来设置整个盒子可见区域大小，即 width 和 height 表示内容区 + 内边距 + 边框的总大小</code></pre>
<h2 id="浏览器默认样式"><a href="#浏览器默认样式" class="headerlink" title="浏览器默认样式"></a>浏览器默认样式</h2><p>由于默认样式未知，且不同浏览器的默认样式不同，因此编写网页时要去除浏览器默认样式</p>
<pre><code>如*&#123;
    margin:0;
    padding:0;
&#125;
ul&#123;
    list-style:none; //去除无需列表前的小黑点
&#125;</code></pre>
<p>但上述方式去除可能会有残留</p>
<p>可通过引入外部重置样式表来去除浏览器默认样式 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./reset.css&quot;&gt;</code></p>
<p>可在<a href="https://meyerweb.com/eric/tools/css/reset/">该网站</a>获取，内容如下</p>
<pre><code>/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video &#123;
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
&#125;
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section &#123;
    display: block;
&#125;
body &#123;
    line-height: 1;
&#125;
ol, ul &#123;
    list-style: none;
&#125;
blockquote, q &#123;
    quotes: none;
&#125;
blockquote:before, blockquote:after,
q:before, q:after &#123;
    content: &#39;&#39;;
    content: none;
&#125;
table &#123;
    border-collapse: collapse;
    border-spacing: 0;
&#125;</code></pre>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>通过 float 属性设置元素浮动，此时水平布局的等式不需要强制成立。</p>
<p>但是元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置，所以元素下边还在文档流中的元素会自动向上移动，但若文档流中的元素是文字则会环绕浮动元素</p>
<p>通过浮动可制作水平布局</p>
<h3 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h3><p>（1）浮动元素会完全脱离文档流，不再占据文档流中的位置</p>
<p>（2）设置浮动后元素会向父元素的左侧或右侧移动</p>
<p>（3）浮动元素默认不会从父元素中移出，即不能跨出父元素边界</p>
<p>（4）浮动元素向左或向右移动时不会超过前边的其他浮动元素</p>
<p>（5）若浮动元素上边是一个没有浮动的元素，则浮动元素无法上移</p>
<p>（6）浮动元素不会超过它上边的浮动的兄弟元素，最多和兄弟一样高</p>
<p>（7）浮动元素不会盖住文字，文字会自动环绕在浮动元素周围，可利用该特性设置文字环绕图片效果</p>
<h3 id="脱离文档流的特点"><a href="#脱离文档流的特点" class="headerlink" title="脱离文档流的特点"></a>脱离文档流的特点</h3><h4 id="1、块元素"><a href="#1、块元素" class="headerlink" title="1、块元素"></a>1、块元素</h4><p>（1）块元素不再独占一行</p>
<p>（2）脱离文档流后，块元素的宽度和高度默认都被内容撑开</p>
<h4 id="2、行内元素"><a href="#2、行内元素" class="headerlink" title="2、行内元素"></a>2、行内元素</h4><p>行内元素脱离文档流后会变成块元素，特点和脱离文档流后的块元素一样，且可设置宽高</p>
<p><strong>脱离文档流后，不再需要区分块和行内元素了</strong></p>
<h3 id="浮动的问题"><a href="#浮动的问题" class="headerlink" title="浮动的问题"></a>浮动的问题</h3><h4 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h4><p>在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，则会无法撑起父元素高度，导致父元素的高度丢失。父元素高度丢失后其下方元素会自动上移，导致页面布局混乱</p>
<h4 id="解决高度塌陷：BFC（Block-Formatting-Context）块级格式化环境"><a href="#解决高度塌陷：BFC（Block-Formatting-Context）块级格式化环境" class="headerlink" title="解决高度塌陷：BFC（Block Formatting Context）块级格式化环境"></a>解决高度塌陷：BFC（Block Formatting Context）块级格式化环境</h4><p>BFC 是一个 CSS 中的一个隐含属性，可为一个元素开启 BFC，开启 BFC 后该元素会变成一个独立的布局区域</p>
<p><strong>元素开启 BFC 后的特点：</strong></p>
<pre><code>1、开启 BFC 的元素不会被浮动元素所覆盖，下边文档流中的元素会跑到浮动元素旁边
2、开启 BFC 的父元素，其子元素和父元素外边距不会重叠，即给子元素设置 margin-top 后不会影响父元素
3、开启 BFC 的元素可以包含浮动的子元素，即不会发生高度塌陷</code></pre>
<p><strong>开启 BFC 的方式：</strong></p>
<pre><code>1、设置父元素的浮动 float（不推荐）
2、将父元素设置为行内块元素（不推荐）
3、将父元素的 overflow 设置为非 visible 的值，如 `overflow:hidden;`或`overflow:auto;`，从而使其可以包含住浮动的子元素</code></pre>
<h4 id="解决高度塌陷：clear（较完美，无副作用）"><a href="#解决高度塌陷：clear（较完美，无副作用）" class="headerlink" title="解决高度塌陷：clear（较完美，无副作用）"></a>解决高度塌陷：clear（较完美，无副作用）</h4><p>通过在父元素的最后添加一个子元素，并为该子元素设置 <code>clear:both;</code> 则父元素会依靠添加的这个子元素撑起，在该子元素上方其实浏览器自动为其添加了外边距，使其不受浮动的兄弟元素的影响，设置方式如下</p>
<pre><code>父元素::after&#123;
    content:&#39;&#39;;
    display:block;  //由于伪元素默认是行内元素会环绕在浮动元素周围，依然无法撑起父元素，所以要将其转为块元素，或者使用 display:table;
    clear:both;
&#125;</code></pre>
<h3 id="解决浮动对其他元素的影响"><a href="#解决浮动对其他元素的影响" class="headerlink" title="解决浮动对其他元素的影响"></a>解决浮动对其他元素的影响</h3><p>clear 属性可清除浮动元素对当前元素产生的影响</p>
<pre><code>可选值
    left：清除左侧浮动元素（即 float:left 的元素）对当前元素的影响
    right：清除右侧浮动元素（即 float:right 的元素）对当前元素的影响
    both：清除两侧中最大影响的那侧</code></pre>
<p>原理：设置清除浮动以后，浏览器会自动为元素<strong>添加相应外边距</strong>，使其位置不受其他元素的影响。如 div1 在 div3 上方，给 div1 设置 float 属性后原本 div3 会上移并被 div1 覆盖住，但给 div1 设置 <code>clear:left;</code> 后浏览器会自动为 div3 添加 margin-top，值为 div1 的高度，使得 div3 还在原本的位置不会上移</p>
<h3 id="自定义clearfix类同时解决外边距重叠与高度塌陷"><a href="#自定义clearfix类同时解决外边距重叠与高度塌陷" class="headerlink" title="自定义clearfix类同时解决外边距重叠与高度塌陷"></a>自定义clearfix类同时解决外边距重叠与高度塌陷</h3><pre><code>通过给类 clearfix 添加属性
.clearfix::before,.clearfix::after&#123;
    content: &#39;&#39;;
    display: table;
    clear: both;
&#125;</code></pre>
<p>给需要解决外边距重叠与高度塌陷的父元素的 class 属性中添加 clearfix 即可使用上述样式解决问题</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>使用 position 属性设置定位</p>
<pre><code>可选值
    static    默认值，元素是精致的，没有开启定位
    relative  开启元素的相对定位
    absolute  开启元素的绝对定位
    fixed     开启元素的固定定位
    sticky    开启元素的粘滞定位</code></pre>
<h3 id="1、相对定位"><a href="#1、相对定位" class="headerlink" title="1、相对定位"></a>1、相对定位</h3><p>偏移量（offset）：当元素<strong>开启定位后</strong>，通过偏移量设置元素位置</p>
<p>— top/bottom/left/right：定位元素和定位位置上/下/左/右边的距离</p>
<p>定位元素垂直（水平）方向的位置由 top（left） 和 bottom（right） 两个属性控制，一般用其一</p>
<p>和 margin-right 等的区别是设置 right 移动的是元素自身，而 margin-right 是挤走其他元素</p>
<h4 id="相对定位特点"><a href="#相对定位特点" class="headerlink" title="相对定位特点"></a>相对定位特点</h4><p>（1）元素开启相对定位后，若不设置偏移量，元素不会发生任何变化</p>
<p>（2）相对定位是参照<strong>元素自身原本在文档流中的位置</strong>进行定位的</p>
<p>（3）相对定位会提升元素的层级，层级会高于文档流中的元素</p>
<p>（4）相对定位不会使元素脱离文档流（因为它在文档流中还占据位置）</p>
<p>（5）相对定位不会改变元素的性质，块还是块（如元素原来位置是否还独占一行，宽高是否改变，是否还能设置宽高），行内元素还是行内元素</p>
<h3 id="2、绝对定位"><a href="#2、绝对定位" class="headerlink" title="2、绝对定位"></a>2、绝对定位</h3><p>包含块（containing block）：</p>
<p>— 正常情况下，包含块是离当前元素最近的祖先块元素，如 <code>&lt;div&gt;&lt;span&gt;&lt;em&gt;hello&lt;/em&gt;&lt;/span&gt;&lt;/div&gt;</code> 其中 <code>&lt;em&gt;</code> 的包含块是 <code>&lt;div&gt;</code></p>
<p>— 绝对定位时，包含块是离当前元素最近的开启了定位的祖先元素，若所有祖先元素都没开启定位，则相对于根元素进行定位，根元素就是它的包含块（<code>&lt;html&gt;</code>是根元素，也称为初始包含块）</p>
<h4 id="绝对定位特点"><a href="#绝对定位特点" class="headerlink" title="绝对定位特点"></a>绝对定位特点</h4><p>（1）开启绝对定位后，若不设置偏移量，元素的位置不会发生变化</p>
<p>（2）开启绝对定位后，元素会从文档流中脱离</p>
<p>（3）绝对定位会使元素提升一个层级</p>
<p>（4）绝对定位会改变元素的性质，行内变成块，块的宽高变为被内容撑开</p>
<p>（5）绝对定位元素是相对于其<strong>包含块</strong>进行定位的</p>
<h4 id="绝对定位元素的位置"><a href="#绝对定位元素的位置" class="headerlink" title="绝对定位元素的位置"></a>绝对定位元素的位置</h4><p><strong>水平布局：</strong></p>
<p>元素开启绝对定位后水平布局等式需添加 left 和 right，即应满足等式 </p>
<pre><code>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块内容区宽度</code></pre>
<p><strong>垂直布局：</strong></p>
<p>之前垂直方向的等式不强制满足，但元素开启绝对定位后垂直布局必须满足等式 </p>
<pre><code>top + margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom + bottom = 包含块内容区高度</code></pre>
<p>其中可设置为 auto 的值有 margin、width/height、left/top、right/bottom</p>
<p>当发生过度约束（等式不成立）时，</p>
<p>— 若 9 个值中没有 auto 则自动调整 right/bottom 以使等式满足</p>
<p>— 因为 left 和 right 的值默认是 auto，所以若不知道 left 和 right 时若等式不满足，则会自动调整这两个值</p>
<p>— 若显式设置了 left 或 right 为 auto，若还有其他属性如 margin 类设为 auto，也会去自动调整 left 或 right，而不是 margin</p>
<p>— 若 <code>left=0; right=0;</code> 其他值有 auto 则自动调整 auto 的值以使等式满足</p>
<p>元素水平居中：</p>
<pre><code>方式一：
    父元素 position:relative;
    子元素 
    position:absolute;
    left=0; 
    right=0; 
    margin-left=auto; 
    margin-right=auto
方式二：
    父元素
    display:flex; 
    justify-content:center; </code></pre>
<p>元素垂直居中：</p>
<pre><code>方式一：
    父元素 position:relative;
    子元素 
    position:absolute;
    top=0; 
    bottom=0; 
    margin-top=auto; 
    margin-bottom=auto
方式二：
    父元素
    display: table-cell;   //将元素设置为单元格&lt;td&gt;
    vertical-align: middle;
方式三：
    父元素
    display:flex; 
    align-items:center;`</code></pre>
<p>元素水平 + 垂直居中：</p>
<pre><code>方式一：    
    父元素 position:relative;
    子元素 
    position:absolute;
    left=0; 
    right=0; 
    top=0; 
    bottom=0; 
    margin-left=auto; 
    margin-right=auto
    margin-top=auto; 
    margin-bottom=auto
方式二：
    父元素
    display:flex; 
    justify-content:center; 
    align-items:center;`</code></pre>
<p>也可通过表格 table 实现</p>
<p>也可通过 绝对定位 + transform 实现</p>
<p>也可通过弹性盒 flex 实现</p>
<h3 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h3><p>固定定位是一种特殊的绝对定位，固定定位大部分特点都和绝对定位一样（如脱离文档流，元素性质改变，行内元素变为块元素，块元素宽高变为由内容撑开，不设置偏移量位置不会变），唯一不同的是固定定位永远参照浏览器的<strong>视口</strong>进行定位</p>
<p>对于开启固定定位的元素水平布局满足以下等式</p>
<pre><code>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 视口宽度</code></pre>
<p><strong>如设置元素贴在某元素右边</strong></p>
<p>无法通过直接设置 right 等值进行定位，因为视口宽度不固定，此时可先设置 <code>right=50%;</code> 并设置 <code>margin-right: -(被贴元素宽度/2+元素宽度)</code> 即可，不能设置任何关于 left 的值，left 默认是 auto，通过这个 auto 会自动计算不同视口宽度下的对应的值，而为了元素往右需要增大 left，因此需要减小 margin-left，但是 margin-left 为正值且越大元素才会向右移，这互相矛盾了，所以需要通过设置 margin-right，并且 margin-right 不是移动元素自身而是挤其他元素，其值越负表示右移，因此最合适</p>
<h3 id="4、粘滞定位（浏览器兼容性不好）"><a href="#4、粘滞定位（浏览器兼容性不好）" class="headerlink" title="4、粘滞定位（浏览器兼容性不好）"></a>4、粘滞定位（浏览器兼容性不好）</h3><p>粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置（如通过 top 等属性设置，在到达离顶端多少的位置把它定住）时将其固定</p>
<h3 id="5、元素层级"><a href="#5、元素层级" class="headerlink" title="5、元素层级"></a>5、元素层级</h3><p>对于开启定位元素，可通过 <code>z-index</code> 属性指定元素的层级，<code>z-index</code> 需要一个整数为参数，值越大元素的层级越高越优先显示</p>
<p>但是祖先元素的层级再高也不会盖住后代元素，因为祖先元素层级高了后代元素也会跟着高所以无法覆盖</p>
<p>只要是开启定位且没有设置 <code>z-index</code> 的元素的层级都一样</p>
<p>若元素层级一样，则优先显示代码中靠下的元素</p>
<h2 id="弹性盒-伸缩盒-flex（CSS3）"><a href="#弹性盒-伸缩盒-flex（CSS3）" class="headerlink" title="弹性盒/伸缩盒 flex（CSS3）"></a>弹性盒/伸缩盒 flex（CSS3）</h2><p>要使用弹性盒，必须先将一个元素设置为弹性容器</p>
<h3 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h3><p>通过 <code>display</code> 来设置弹性容器</p>
<pre><code>display: flex;         设置块级弹性容器，独占一行（用得多）
display: inline-flex;  设置为行内弹性容器，不会独占一行</code></pre>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><p>1、flex-direction 指定容器中弹性元素的排列方式以及主轴</p>
<pre><code>可选值
    row 默认值，弹性元素在容器中从左向右水平排列，主轴自左向右
    row-reverse  弹性元素在容器中从右向左反向水平排列，主轴自右向左
    column  弹性元素自上向下纵向排列，主轴自上向下
    column-reverse  弹性元素自下向上反向纵向排列，主轴自下向上</code></pre>
<p>主轴：弹性元素的排列方向称为主轴</p>
<p>侧轴：与主轴垂直方向称为侧轴</p>
<p>justifyxxxxx属性与主轴有关，alignxxxxx属性与辅轴有关</p>
<p>2、flex-wrap 设置弹性元素在弹性容器中是否自动换行</p>
<pre><code>可选值
    nowrap 默认值，不会自动换行
    wrap 元素沿着辅轴方向自动换行
    wrap-reverse 元素沿着辅轴反方向换行</code></pre>
<p>3、flex-flow 是 flex-direction 和 flex-wrap 的简写属性</p>
<pre><code>如 flex-flow: row wrap;</code></pre>
<p>4、justify-content 如何分配<strong>主轴</strong>上的空白空间，即主轴上元素如何排列</p>
<pre><code>可选值
    flex-start 元素沿着主轴起边排列
    flex-end 元素沿着主轴终边排列
    center 元素居中排列，空白会在两边
    space-around 空白分布到元素两侧，元素之间的距离会稍微大，是两边距离的两倍，因为中间空白是两个元素两边空白相加的结果
    space-evenly 空白分布到元素的单侧，此时两边与元素中间空白大小相同（浏览器兼容不好）
    space-between 空白均匀分布到元素之间</code></pre>
<p>5、align-items 元素在<strong>辅轴</strong>上如何对齐</p>
<pre><code>可选值
    stretch  默认值，将一行内元素的高度设置为相同的值
    flex-start  元素不会拉伸，元素沿着辅轴起边排列
    flex-end  元素不会拉伸，元素沿着辅轴终边排列
    center  元素在辅轴居中对齐
    baseline 基线对齐（当字大小不同时基线不同）</code></pre>
<p>6、align-content 辅轴上空白空间的分布</p>
<pre><code>可选值
    flex-start
    flex-end
    center 元素垂直居中排列，空白会在两边
    space-around
    space-evenly（浏览器兼容不好）
    space-between</code></pre>
<h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>弹性容器的直接子元素是弹性元素/弹性项</p>
<p>弹性元素可以同时是弹性容器</p>
<h4 id="相关属性-1"><a href="#相关属性-1" class="headerlink" title="相关属性"></a>相关属性</h4><p>1、flex-grow 指定弹性元素的伸展系数，即指定当父元素有多余空间时子元素如何伸展，父元素的剩余空间会按照比例进行分配</p>
<pre><code>flex-grow:0;  子元素不伸展
flex-grow:1或2或3等;</code></pre>
<p>2、flex-shrink 指定弹性元素的收缩系数，即指定当父元素中空间不足以容纳所有子元素时，如何对子元素进行收缩。缩减缩少是根据缩减系数和元素大小来计算</p>
<pre><code>flex-shrink: 1;  默认值，等比例收缩
flex-shrink: 0;  当为 0 时不会收缩，子元素可能会超过父元素
flex-shrink: 2或3等;  可是其他整数</code></pre>
<p>3、align-self 用来覆盖当前弹性元素上的 align-items</p>
<p>4、flex-basis 指定元素在主轴上的基础长度，若主轴是横向的，该值指定的是元素的宽度，若主轴是纵向的，该值指定的是元素的高度</p>
<pre><code>可选值
    auto 默认值，表示参考元素自身的高度或宽度
    具体数值  若传递了一个具体数值，则以该值为准</code></pre>
<p>5、flex 设置弹性元素 flex-grow，flex-shrink，flex-basis 样式的简写。<code>flex: 增长系数 缩减系数 基础长度</code></p>
<pre><code>可选值
    增长系数 缩减系数 基础长度
    initial  表示 flex: 0 1 auto 只能减
    auto   表示 flex: 1 1 auto  能增能减
    none   表示 flex: 0 0 auto  不能增不能减</code></pre>
<p>6、order 决定弹性元素的排列顺序</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体是属于矢量图（放大后不会失真）</p>
<p>1、color 设置前景色（如字体、边框颜色）</p>
<p>2、font-size 字体大小</p>
<pre><code>单位：em，相对于当前元素的 font-size
     rem，相对于根元素的 font-size</code></pre>
<p><strong>注意：网页中字体大小最小是 12px，不能设置一个比 12 像素还小的字体</strong></p>
<p>3、font-family 字体族</p>
<pre><code>可选值（不是具体字体，而是对字体分类）：
    serif      衬线字体
    sans-serif 非衬线字体
    monospace  等宽字体（有利于上下行对其）
    cursice    草书字体
    fantasy    虚幻字体
以上只是指定字体的类别，浏览器会自动使用该类别下的字体，指定类别后具体用那种字体由浏览器决定</code></pre>
<p>font-family 可同时指定多个字体，多个字体间用 <code>,</code> 隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>4、font-face 可将服务器中的字体直接提供给用户使用，</p>
<pre><code>@font-face&#123;
    font-family:&#39;myfont&#39;; //这里是指给字体起的名字，而非字体类别
    src:url(&#39;./xxx/xxx.ttf&#39;) format(&quot;truetyp&quot;),
        url(&#39;./xxx/xxx.ttf&#39;); //服务器中字体的路径,format()不是必须
&#125;
font-family:myfont;</code></pre>
<p>问题：（1）加载速度（2）版权（但 font-family 中没有版权问题，因为 font-family 只是建议字体，具体用不用看用户电脑中是否安装；但 font-face 会涉及版权问题，因为是你提供的字体）（3）字体文件格式，如 <code>.ttf</code></p>
<p>5、字体属性简写</p>
<p><code>font</code> 属性可设置字体相关所有属性，语法：<code>font: 其他样式（加粗、斜体等） 字体大小/行高 字体族</code>，字体大小和字体族必写，若行高省略不写不表示不设置，而是使用默认值</p>
<pre><code>font:50px/2 &#39;Times New Roman&#39;,Times,serif;

line-height:2;
font:50px &#39;Times New Roman&#39;,Times,serif;

以上写法，两倍行高不生效，因为在 font中设置 50px 后面没有指定行高则会使用默认行高，会覆盖前面设置的 line-height:2;，可将 line-height:2; 移至 font 下方则可生效，如下

font:50px &#39;Times New Roman&#39;,Times,serif;
line-height:2;</code></pre>
<p>6、文字对齐</p>
<p>水平对齐：text-align，可选值：left（左对齐）、right（右对齐）、center（居中对齐）、justify（两端对齐）</p>
<p>垂直对齐：vertical-align，可选值：baseline（默认值，文字基线对齐）、top（顶部对齐）、bottom（底部对齐）、middle（居中对齐，是指与字母 x 的中间对齐）</p>
<p>注意：添加图片时，下方会由小缝隙，可通过设置图片的样式 <code>vertical-align:非baseline的值</code>来消除缝隙</p>
<p>7、其他文本样式</p>
<p>text-decoration</p>
<pre><code>可选值 
none
underline（下划线）
line-through（删除线）
overline（上划线）
如
text-decoration: underline red dotted; //下划红虚线</code></pre>
<p>white-space</p>
<pre><code>可选值
normal（自动换行）
nowrap（不换行）
pre（保留空白，原本多个空格仅显示为一个空格，设置为 pre 后会保留多个空格）</code></pre>
<p>设置省略号</p>
<pre><code>white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;</code></pre>
<h3 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h3><p>图标可以通过图片引入，但是图片文件大小本身比较大，且不灵活（如放大缩小、改颜色）。还可以把图标设置为字体，通过 font-face 引入字体，这样可以通过使用字体的形式使用图标</p>
<p>图标字体库：<a href="https://fontawesome.com/">Font Awesome</a>、<a href="https://www.iconfont.cn/">阿里 iconfont</a></p>
<p><strong>font awesome 使用方法：</strong></p>
<p>（1）官网下载软件并解压</p>
<p>（2）将 css 和 webfont 文件夹移动到项目中，且放同一级目录下</p>
<p>（3）将 css 文件夹中 all.css文件引入网页中 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx/all.css&quot;&gt;</code></p>
<p>（4）方法一：直接通过类名使用图标字体，在标签中添加 <code>class=&quot;fas&quot;</code> 或 <code>class=&quot;fab&quot;</code>，并通过 <code>font-size</code>、<code>color</code> 属性改变图标大小、颜色，如</p>
<pre><code>&lt;i class=&quot;fas 具体图标对应类&quot;&gt;&lt;/i&gt;
（`&lt;i&gt;`可换，图标类可换，但 fas 或 fab 是固定的）</code></pre>
<p>方法二：通过伪元素设置图标，在 content 中设置 <code>\图标编码</code>（在 font awesome 文档中查找），并设置字体样式，如</p>
<pre><code>对于 fas 类
font-family:&#39;font Awesome 5 Brands&#39;;
对于 fab 类
font-family:&#39;font Awesome 5 Free&#39;;
font-weight:900;</code></pre>
<p>方法三：通过实体使用，<code>&amp;#x字体编码;</code>，如</p>
<pre><code>&lt;span class=&quot;fas或fab&quot;&gt;&amp;#x图标编码;&lt;/span&gt;</code></pre>
<p><strong>阿里 iconfont 使用方法：</strong></p>
<p>（1）在官网选择图标加入“购物车”，在“购物车”中点击“添加指项目”，在“图标管理”-&gt;“我的项目”中点击“下载至本地”，并解压</p>
<p>（2）将解压后所有文件移动到项目中，且放同一级目录下</p>
<p>（3）将 css 文件夹中 all.css文件引入网页中 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx/iconfont.css&quot;&gt;</code></p>
<p>（4）方法一：直接通过类名使用图标字体，在标签中添加 <code>class=&quot;iconfont 图标类名&quot;</code>如</p>
<pre><code>&lt;i class=&quot;fas 具体图标对应类&quot;&gt;&lt;/i&gt;</code></pre>
<p>方法二：通过伪元素设置图标，在 content 中设置 <code>\图标编码</code>，以及 <code>font-family:&#39;iconfont&#39;;</code></p>
<p>方法三：通过实体引入图标，设置 <code>class=&quot;iconfont&quot;</code>以及<code>&amp;#x字体编码;</code>，如</p>
<pre><code>&lt;i class=&quot;iconfont&quot;&gt;&amp;#x图标编码;&lt;/i&gt;
修改样式
i.iconfont&#123;
    font-size:100px;
&#125;</code></pre>
<p><strong>Unicode 编码中的字符使用方法：</strong></p>
<p>可在 html 中通过 <code>&amp;#十进制编码;</code> 使用</p>
<p>也可在 js 中通过 <code>\u十六进制编码</code> 使用</p>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><p>行高指文字占有的实际高度，可通过 <code>line-height</code> 设置，<code>line-height</code> 可直接指定大小（px，em），也可设置为整数，表示行高为字体大小的相应倍数，默认是 1.333</p>
<p>字体框指字体存在的格子，设置 <code>font-size</code> 是在设置字体框的高度</p>
<p><strong>行高用处：</strong></p>
<p>行高会在字体框的上下平均分配，因此可以通过设置 <code>line-height</code> 和 <code>height</code> 相等使单行文字在一个元素中垂直居中 </p>
<p>行高还可用于设置文字行间距，行间距 = 行高 - 字体大小</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1、background-color（设置背景颜色）、background-image（设置背景图片）</p>
<p>2、background-repeat：设置背景重复方式</p>
<pre><code>可选值
repeat    默认值，背景会沿 x、y 轴双方向重复
repeat-x  沿着 x 轴方向重复
repeat-y  沿着 y 轴方向重复
no-repeat 背景图片不重复</code></pre>
<p>3、background-position：设置背景图片位置</p>
<pre><code>可选值一：top left right bottom center，需要同时指定两个值，若只写一个，则第二个值默认为 center 如
background-position:top left;    //左上角
background-position:center left; //左侧中间
background-position:center center;  //正中间

可选值二：通过 水平方向偏移量 垂直方向偏移量设置，如
background-position:50px 300px;
background-position:-50px 300px;</code></pre>
<p>4、background-clip：设置背景范围</p>
<pre><code>可选值
border-box  默认值，背景会出现在边框下边
padding-box 背景不会出现在边框，只出现在内容区和内边距
content-box 背景只出现在内容区</code></pre>
<p>5、background-origin：设置背景图片的偏移量计算的原点</p>
<pre><code>可选值
padding-box  默认值，此时 background-position 从内边距处开始计算
content-box  此时背景图片的偏移量从内容区开始计算
border-box   此时背景图片的偏移量从边框处开始计算</code></pre>
<p>6、background-size：设置背景图片大小，</p>
<pre><code>可选值
宽度 高度  若只写一个，则第二个值默认是 auto
cover     图片的比例不变，图片较小边为 100% 来将元素填满，大的边可能显示不全
contain   图片比例不变，将图片在元素中完整显示，图片较大边为 100%，使图片全部显示，此时元素可能不会被填满</code></pre>
<p>7、background-attachment：设置背景图片是否跟随元素移动</p>
<pre><code>可选值
scroll   默认值，背景图片会跟随元素移动
fixed    背景图片会固定在页面中，不会跟随元素移动</code></pre>
<p>8、background：背景相关所有属性的简写</p>
<pre><code>如 background:#bfa url(&#39;./img.jpg&#39;) center center/contain border-box content-box no-repeat fixed; 
无顺序要求，也没有哪个属性是必须写的
但是 background-size 只能写在 background-position 后，并用 / 隔开
background-clip 要写在 background-origin 后</code></pre>
<h3 id="雪碧图（CSS-Sprite）"><a href="#雪碧图（CSS-Sprite）" class="headerlink" title="雪碧图（CSS-Sprite）"></a>雪碧图（CSS-Sprite）</h3><p>雪碧图：将多个小图片统一保存到大图片中，通过 background-position 来切换显示的图片，这样图片会同时加载到网页中，从而有效避免出现闪烁问题，该技术称为 CSS-Sprite</p>
<h4 id="雪碧图使用步骤"><a href="#雪碧图使用步骤" class="headerlink" title="雪碧图使用步骤"></a>雪碧图使用步骤</h4><p>1、确定使用的图标及其大小</p>
<p>2、根据测量结果创建一个元素</p>
<p>3、将雪碧图设置为元素的背景图片</p>
<p>4、设置偏移量以显示正确图片</p>
<h4 id="雪碧图特点"><a href="#雪碧图特点" class="headerlink" title="雪碧图特点"></a>雪碧图特点</h4><p>一次性将多个图片加载到页面中，降低请求的次数，加快访问速度，提升用户体验</p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>渐变的特质是图片，不是颜色，其很多特点和 background-image 相似，而非 background-color，通过 background-image 设置</p>
<h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><pre><code>线性渐变1
linear-gradient(渐变方向,开始的颜色 正颜色开始位置,中间颜色2 正颜色开始位置,中间颜色n，结束的颜色)
渐变方向可为 to left、to right、to bottom、to top、to top left、xxxdeg（deg表示度数）、xxturn（转多少圈，如.5）等，也可省略，默认是180deg/to bottom
颜色开始位置也可省略
如
background-image: linear-gradient(red 50px,yellow 100px); //红色向黄色从上往下渐变，红色从 50px 开始，上面也自动填充为红色，黄色从 100px 开始
background-image: linear-gradient(to right，red,yellow); //红色向黄色从左往右渐变

线性渐变2
repeating-linear-gradient(渐变方向,开始的颜色 开始颜色的位置,结束的颜色 结束颜色的位置)
通过设置渐变发生在 ‘开始颜色的位置’ 到 ‘结束颜色的位置’ 之间，范围也只有这么大，其他区域就重复这部分渐变
此时 background-repeat:no-repeat 无效</code></pre>
<h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h4><p>径向渐变即放射性效果，默认情况下径向渐变的形状根据元素形状来计算</p>
<pre><code>radial-gradient(大小 at 圆心位置, 颜色1 位置1, 颜色2 位置2, 颜色n 位置n)，只有颜色是必须写的
大小可选值
    xxxpx xxxpx     径向 x 轴半径 径向 y 轴半径
    circle          圆形
    ellipse         椭圆形
    closest-side    渐变会覆盖到元素最近的边
    farthest-side   渐变会覆盖到元素最远的边
    closest-corner  渐变会覆盖到元素最近的角    
    farthest-corner 渐变会覆盖到元素最远的角
位置可选值
    xxxpx xxxpx     圆心 x 位置 圆心 y 位置
    top
    bottom
    left
    right
    center    
如
background-image: radial-gradient(100px 100px,red,yellow);
background-image: radial-gradient(100px 100px at 100px 100px,red,yellow);
background-image: radial-gradient(100px 100px at center center,red,yellow);
background-image: radial-gradient(ellipse,red,yellow);</code></pre>
<h2 id="样式切换过渡"><a href="#样式切换过渡" class="headerlink" title="样式切换过渡"></a>样式切换过渡</h2><p><code>transition</code> 用于为样式设置过渡效果</p>
<p>支持过渡的属性：大部分属性都支持，其值是个能计算的值的属性</p>
<p>过渡有四个属性</p>
<p>（1）<code>transition-property</code> 指定要执行过渡的属性，多个属性间用<code>,</code>隔开，若所有属性都要过渡，则用 <code>all</code> 关键字。要出现过渡效果还需要搭配 <code>transition-duration</code></p>
<p>（2）<code>transition-duration</code> 指定过渡的持续时间，单位有 s 和 ms</p>
<p>（3）<code>transition-timing-function</code> 过渡的时序函数，指定过渡的执行方式，可选值有<br>— ease        默认值，先加速再减速</p>
<p>— linear      匀速运动</p>
<p>— ease-in     加速运动</p>
<p>— ease-out    减速运动</p>
<p>— ease-in-out 先加速后减速</p>
<p>— cubic-bezier(xx,xx,xx,xx)  贝塞尔曲线，可在<a href="https://cubic-bezier.com/">官网</a>查看不同参数的效果</p>
<p>— step(步数,执行时间点)      分步执行过渡效果，第二个值可选，<code>end</code> 表示在时间结束时执行过渡（默认值），<code>start</code> 表示在时间开始时执行过渡</p>
<p>— transition-delay   过渡效果的延迟，等待一段时间后再执行过渡</p>
<p>过渡属性简写 <code>transition</code> 可同时设置过渡相关所有属性，无顺序要求，但若要写延迟，则持续时间要写在延迟时间之前</p>
<pre><code>transition: height 0.3s;  //当元素高度发生变化时需要 0.3s 进行切换，但变化前后的高度不能有 auto 值
transition: all 0.3s;  //当元素样式发生变化时所有变化的样式需要 0.3s 进行切换
transition: 2s margin-left 1s cubic-bezier(.24,.95,.82,-0.88);</code></pre>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><strong>动画与过渡的异同：</strong>动画和过渡类似，都可以实现动态效果，但是过渡需在某个属性发生变化时才会出发，而动画可自动出发动态效果</p>
<p>设置动画效果，需先设置关键帧，关键帧设置了动画执行的每一个步骤</p>
<pre><code>元素选择器&#123;
    animation-name:动画名；//对当前元素生效的关键帧名字
    animation-duration: 2s; //动画执行时间
    animation-delay: 1s;
    animation-timing-function: ease-in-out;
    animation-iteration-count: infinite;  //动画执行的次数，取值为数值或 infinite（无限次）
    animation-direction: normal; //动画运行的方向，
         normal（默认值）表示从 from 向 to 运行，每次都是这样
        reverse 表示从 to 向 from 执行，每次都是这样
        alternate 从 from 向 to 开始，重复执行时动画反向执行
        alternate-reverse 从 to 向 from 开始，重复执行时动画方向执行
    animation-play-state //设置动画的执行状态，
        running 动画执行
        paused  动画暂停
    animation-fill-mode  //动画填充模式
        none（默认值）表示动画执行完毕元素回到原来位置
        forwards 动画执行完毕元素会停止在动画结束位置
        backwards 动画延时等待时，元素就会处于开始位置
        both 结合了 forwards 和 backwards
&#125;
@keyframe 动画名&#123;
    from&#123;
        margin-left: 0;
    &#125;   //动画开始位置，也可用 0%&#123;&#125; 表示
    40%&#123;
        xxxx;
    &#125;  //可选项
    to&#123;
        margin-left: 700px;
    &#125;  //动画结束位置，也可用 100%&#123;&#125; 表示
&#125;</code></pre>
<p>动画属性简写 <code>animation</code> 可同时设置动画相关所有属性，无顺序要求，但若要写延迟，则持续时间要写在延迟时间之前</p>
<h2 id="变形平移"><a href="#变形平移" class="headerlink" title="变形平移"></a>变形平移</h2><p>transform 用来设置元素的变形效果</p>
<p>注意变形不会影响页面布局，即元素改变位置但对其他元素产生影响，不会挤走其他元素，同时也没脱离文档流</p>
<h3 id="1、平移"><a href="#1、平移" class="headerlink" title="1、平移"></a>1、平移</h3><pre><code>translateX(xxx) 沿着 x 轴方向平移，可设置像素或百分比
translateY(xxx) 沿着 y 轴方向平移，可设置像素或百分比
translateZ(xxx) 沿着 z 轴方向平移，可设置像素或百分比
百分比是相对于自身计算的</code></pre>
<h3 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h3><pre><code>rotateX(xxxdeg或xxxturn) 沿着 x 轴方向旋转
rotateY(xxxdeg或xxxturn) 沿着 y 轴方向旋转
rotateZ(xxxdeg或xxxturn) 沿着 z 轴方向旋转</code></pre>
<h3 id="3、缩放"><a href="#3、缩放" class="headerlink" title="3、缩放"></a>3、缩放</h3><pre><code>scaleX(xxx) 水平方向缩放
scaleY(xxx) 垂直方向缩放
scale(xxx) 双方向缩放
scaleZ(xxx) z轴方向缩放，对立体元素才会看到效果</code></pre>
<p>z轴平移属于立体效果（近大远小），默认情况下网页不支持透视，若需要看见效果必须要设置网页的视距</p>
<pre><code>html&#123;
    perspective: 800px;  //设置当前王阿耶视距（人眼与网页的距离），一般为 800-1200px
&#125;</code></pre>
<p>元素变形默认是 2D 效果，若要 3D 变形效果需设置 <code>transform-style:preserve-3d</code> 搭配 <code>transform</code></p>
<p><code>backface-visibility</code> 可设置旋转后背面效果，可选值：visible、<br>hidden</p>
<p><code>transform-origin: xxxpx xxxpx;</code> 设置变形原点，默认值 center</p>
<p><code>transform</code>中可同时设置平移和旋转，用空格隔开，写的顺序不同效果不同</p>
<p><strong>利用变形可设置鼠标移入时元素浮出效果</strong>，如</p>
<pre><code>元素选择器&#123;
    transition: all .3s;  //设置过渡
&#125;
元素选择器:hover&#123;
    transform:translateY(-4px);  //鼠标移入时元素向上移
    box-shadow: 0 0 10px rgba(0,0,0,.3)
&#125;</code></pre>
<h2 id="CSS-中的变量与计算（浏览器兼容不太好）"><a href="#CSS-中的变量与计算（浏览器兼容不太好）" class="headerlink" title="CSS 中的变量与计算（浏览器兼容不太好）"></a>CSS 中的变量与计算（浏览器兼容不太好）</h2><p>CSS 原生支持变量设置</p>
<p>变量：通过 <code>--变量名;</code> 声明变量，使用时通过 <code>var(--变量名)</code></p>
<p>计算：通过 <code>calc(表达式)</code>进行属性值计算，如 <code>width: calc(200px/2);</code></p>
<h2 id="页面适配"><a href="#页面适配" class="headerlink" title="页面适配"></a>页面适配</h2><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>前端开发中像素分为 CSS 像素和物理像素两种，浏览器在显示网页时需将 CSS 像素转为物理像素然后呈现</p>
<p>一个 CSS 像素由几个物理像素显示是由浏览器决定，默认情况下在 PC 端，1 个 CSS 像素 = 1 个物理像素</p>
<p>浏览器开发者工具中的像素大小表示的是视口大小（CSS 像素）</p>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="像素比"><a href="#像素比" class="headerlink" title="像素比"></a>像素比</h4><p>视口就是屏幕中用来显示网页的区域</p>
<p>可通过查看视口大小来改变 CSS 像素和物理像素的比值</p>
<p>— 默认情况下</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;视口宽度 1920px（CSS像素），1920px（物理像素）</p>
<p>— 浏览器放大两倍时</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;视口宽度 960px（CSS像素），1920px（物理像素），此时 CSS 像素 : 物理像素 = 1 : 2</p>
<h4 id="改变视口"><a href="#改变视口" class="headerlink" title="改变视口"></a>改变视口</h4><p>每款移动设备设计时都有一个最佳像素比，一般只需将像素比设置为该值即可得到最佳效果，将像素比设置为最佳像素比的视口大小，称其为完美视口</p>
<p>可通过 <code>&lt;meta&gt;</code> 设置视口大小</p>
<pre><code>设置完美视口
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
其中 device-width 表示设备的宽度（完美视口），initial-scale=1.0 也表示完美视口，都写上是为了保险起见</code></pre>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>不同屏幕的单位像素大小不同，像素越小屏幕越清晰</p>
<p>智能手机的像素点远小于计算机的像素点，在<a href="https://material.io/resources/devices/">该网站</a>可查看不同设备的分辨率</p>
<p>如 24 寸显示器：1920 x 1080，iPhone 6：750 x 1334（物理像素）</p>
<p>默认情况下移动端的网页会将视口设置为 980 像素（CSS像素），以确保 PC 端的网页可以在移动端正常访问，但若网页宽度超过 980 像素，则移动端的浏览器会自动对网页缩放以完整显示网页，所以大部分 PC 端网站都可在移动端正常浏览，但用户体验不太好，因此一般会设计两套网页</p>
<p>默认情况下移动端像素比为 CSS 像素 : 物理像素 = 980 : 移动端宽度，如当 980 像素的视口在 iPhone 6 的 750 x 1334 的屏幕中显示时 1 个 CSS = 零点几个物理像素</p>
<h4 id="单位-1"><a href="#单位-1" class="headerlink" title="单位"></a>单位</h4><p>使用 vw 作为单位，vw 相对于视口宽度计算，100 vw = 整个视口宽度</p>
<p>vw 在移动端浏览器中基本都支持</p>
<p>移动端设计图宽度一般为 750px 或 1125px</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;100vw = 750px，即0.1333333333333vw = 1px</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;6.4vw = 48px</p>
<h4 id="vw适配"><a href="#vw适配" class="headerlink" title="vw适配"></a>vw适配</h4><p>由于在编写网页时换算 px 与 vw 较为麻烦，设计图中某元素vw = 100vw * (设计图某元素px/设计图宽度)px，因此可结合 rem 来进行适配</p>
<pre><code>对于 750px 大小的设计图
0.1333333vw = 设计图中 1px，但是不能设置小于 12px 的字体大小，所以扩大 40 倍
5.3333vw = 设计图中 40px
html&#123;
    font-size: 5.3333vw;  //所以 1rem = 设计图中40px
&#125;
此时要显示设计图中 48 * 35 px 的块
.box&#123;
    width: 1.2rem;     //48/40 = 1.2 rem
    height: 0.875rem;  //35/40 = 0.875 rem
&#125;</code></pre>
<p>为了在写代码时更方便计算可使用 less 写样式，可在代码中直接写表达式</p>
<pre><code>html&#123;
    font-size:100vw / 750 * 40;
&#125;
.box&#123;
    width: 48/40rem;
    height: 35/40rem;
&#125;</code></pre>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>网页可根据不同的设备或窗口大小呈现出不同布局，使用响应式布局可使一个网页适用于所有设备</p>
<p>响应式设计的网页（1）移动端优先（2）渐进增强</p>
<p>注意：在移动端不能去设置鼠标移入后的效果（即 hover，因为是触屏），所以该效果需要通过 js 实现</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>通过媒体查询，可为不同设备（如有屏幕设备等，不是指 PC 和移动端）或设备不同状态来分别设置</p>
<p>可通过在样式中使用 <code>@media 媒体类型&#123;&#125;</code> 进行媒体查询，可通过 <code>,</code> 连接多个媒体类型表示或，用 <code>and</code> 表示与，也可在媒体类型前加 <code>only</code>（主要是为了兼容一些老版本浏览器，因为老版本浏览器不认识 only，会直接忽略这一部分）</p>
<h4 id="1、媒体类型（即设备类型）"><a href="#1、媒体类型（即设备类型）" class="headerlink" title="1、媒体类型（即设备类型）"></a>1、媒体类型（即设备类型）</h4><p>— all 所有设备</p>
<p>— print 打印设备</p>
<p>— screen 带屏幕的设备</p>
<p>— speech 屏幕阅读器</p>
<pre><code>@media all&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media print,screen&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media only screen&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;</code></pre>
<h4 id="2、媒体特性"><a href="#2、媒体特性" class="headerlink" title="2、媒体特性"></a>2、媒体特性</h4><p>— width 视口宽度 <code>@media(width:xxxpx)&#123;&#125;</code> </p>
<p>— height 收口高度</p>
<p>— min-width 视口的最小宽度（视口大于指定宽度时生效）<code>@media(min-width:xxxpx)&#123;&#125;</code> </p>
<p>— max-width 视口的最大宽度（视口小于指定宽度时生效）<code>@media(max-width:xxxpx)&#123;&#125;</code> </p>
<pre><code>@media (width:500px)&#123;  //视口宽度为 500 px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media (min-width:500px)&#123;  //视口宽度大于 500 px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media (min-width:500px),(max-width:300px)&#123;  //视口宽度大于 500 px 或小于 300px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media only screen (min-width:500px) and (max-width:700px)&#123;  //视口宽度大于 500 px 且小于 700px 的有屏设备生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media not only screen (min-width:500px) and (max-width:700px)&#123;&#125; //not 是对后面的整体作否定</code></pre>
<p><strong>断点：</strong>样式切换的分界点，称其为断点，网页会在该点发生变化，</p>
<p>一般常用断点有：</p>
<p>— 小于768（超小屏幕） max-width:768px</p>
<p>— 大于768（小屏幕） min-width:768px</p>
<p>— 大于992（中型屏幕） min-width:992px</p>
<p>— 大于1200（大屏幕） min-width:1200px</p>
<h1 id="SEO-与-性能"><a href="#SEO-与-性能" class="headerlink" title="SEO 与 性能"></a>SEO 与 性能</h1><p>1、标题标签</p>
<p>标题标签有 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code> 重要性递减，搜索引擎检索时首先看 <code>&lt;title&gt;</code> 判断网站主要内容，接着看 <code>&lt;h1&gt;</code>，<code>&lt;h1&gt;</code> 在网页中的重要性仅次于 <code>&lt;title&gt;</code> ，一般一个页面只有一个 <code>&lt;h1&gt;</code>，一般只会用 <code>&lt;h1&gt;</code> - <code>&lt;h3&gt;</code></p>
<p>2、浏览器在解析网页时会自动对网页中不符合规范的内容进行修正，这会影响性能</p>
<p>如：（1）标签写在 <code>&lt;html&gt;</code> 外部（2）根元素 <code>&lt;html&gt;</code> 中出现除 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 以外的子元素（3）<code>&lt;p&gt;</code> 中嵌套了块元素</p>
<p>3、样式加载</p>
<p>当使用外部样式表时，浏览器第一次加载完该 css 文件或后会保存在浏览器的缓存中，下一个页面加载同一 css 文件时无需向服务器请求，直接在浏览器缓存中读取</p>
<p>4、雪碧图</p>
<p>浏览器加载外部资源（如图片）是按需加载，用则加载，不用则步加载，可通过雪碧图一次性将多个图片加载到页面中，降低请求的次数，加快访问速度，提升用户体验</p>
<p>5、<code>text-indent</code> 用于设置文字缩进，可用于文字隐藏，这样可以在设置一些标题供浏览器搜索但不在页面中显示</p>
<p>6、加快加载速度</p>
<p>为了使项目上线时加载速度尽量快，需删除代码中的注释以及无用的换行等，可通过在 VSCode 中安装插件 JS &amp; CSS Minifier，选中要压缩的文件，按 F1，并输入 <code>Minify:Document</code>，则该插件会对文件进行压缩生成 <code>xxx.min.css</code> 或 <code>xxx.min.js</code> 文件，在 html 代码中 <link> 引入时换成压缩后的文件</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1、<code>&lt;hgroup&gt;</code> 用于标题分组，将一组相关的标题同时放入<code>&lt;hgroup&gt;</code> 中</p>
<p>2、隐藏元素可通过 display 或 visibility 属性进行设置</p>
<p>设置 <code>display:none;</code> 元素不在页面中显示，且不占位置</p>
<p>设置<code>visibility:hidden;</code> 元素不在页面中显示，但依然占据位置</p>
<p>（<code>visibility:visible;</code> 为默认值，元素在页面中正常显示）</p>
<p>3、文字在父元素中垂直居中：将父元素的 line-height 设置为和父元素 height 一样的值</p>
<p>4、子元素在父元素中垂直居中：</p>
<p><strong>方式一：</strong>子元素开启绝对定位，父元素也开启定位后，在子元素中设置 <code>top=0; bottom=0; margin-top=auto; margin-bottom=auto</code>（但这种方式只适用于大小确定的元素）</p>
<p><strong>方式二：</strong>将父元素设置为<code>&lt;td&gt;</code>单元格，<code>display: table-cell; vertical-align: middle;</code></p>
<p><strong>方式三：</strong>对于大小不确定的元素，可通过绝对定位配合 transform 设置水平或垂直居中，<code>position: absolute; left:50%; top:50%; transform: translateX(-50%) translateY(-50%);</code></p>
<p><strong>方式四：</strong>通过弹性盒 flex 来设置，<code>display:flex; justify-content:center; align-items:center;</code></p>
<p>5、图片闪烁问题————雪碧图</p>
<p>如超链接中若以背景图片表示不同状态下的显示效果，则 <code>:link</code> 会首先加载，而 <code>:hover</code>、<code>:active</code> 会在指定状态触发时才会加载，可能就会出现空白一闪的情况</p>
<p>解决：通过雪碧图来解决， 如将超链接三种状态的背景图片并排放在一张图里，通过 background-position 属性设置不同状态下显示背景图片的位置</p>
<p>6、当屏幕宽度缩小时，为了不让窗口宽度过小导致布局混乱，可给 body 设置 <code>min-width: xxxpx;</code>，当窗口小于 min-width 时 body 不会再缩小</p>
<p>7、轮播图</p>
<p>方法一：通过 CSS 实现轮播图</p>
<p>对图片开启绝对定位脱离文档流，使得多张图片摞在一起，当要显示哪一图片时设置该图片 z-index 即可</p>
<p>8、标签页或收藏栏中小图标</p>
<p>网站图标一般存储于根目录，名为 <code>favicon.ico</code>，通过 <code>&lt;link rel=&quot;icon&quot; href=&quot;./favicon.ico&quot;&gt;</code> 引入</p>
<p>9、动画</p>
<p>方式一：雪碧图 + 样式过渡 transition</p>
<p>方式二：通过 animation 属性</p>
<p>10、一般给 <code>&lt;body&gt;</code> 设置 background-color 是给 <code>&lt;html&gt;</code> 设置，因此要看 body 的真实大小要通过 border</p>
<p>11、设置透明度可通过 <code>opacity:0.5;</code>，但在 IE8 中需要使用 <code>filter: alpha(opacity=50)</code></p>
</head>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记2</title>
    <url>/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="一、JS-基础的深入"><a href="#一、JS-基础的深入" class="headerlink" title="一、JS 基础的深入"></a>一、JS 基础的深入</h1><a id="more"></a>

<h2 id="1、数据"><a href="#1、数据" class="headerlink" title="1、数据"></a>1、数据</h2><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>判断数据类型的方法有 typeof、instanceof、===</p>
<p>typeof 返回的是字符串类型的数据类型表达</p>
<p>— 可以判断：undefined、数值、字符串、布尔值、函数</p>
<p>— 不能判断：null 与 object（因为都会返回’object’）、object 与 array</p>
<p>instanceof 用于判断对象的具体类型（数组、函数等）</p>
<p>=== 可以判断：undefined、null（因为这两种数据类型只有一种值）</p>
<pre><code>var a1 = &#123;
    a2:[1,&#39;a&#39;,console.log],
    a3:function()&#123;&#125;
&#125;
a1 instanceof Object //true
a1.a2 instanceof Object //true
a1.a2 instanceof Array //true
a1.a3 instanceof Object //true
a1.a3 instanceof Function //true
typeof a1.a3 === &#39;function&#39;  //true</code></pre>
<h3 id="undefined-和-null-的区别"><a href="#undefined-和-null-的区别" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>undefined 代表定义了未赋值，null 表示定义并赋值了，值为null</p>
<h3 id="什么时候为变量赋值为-null"><a href="#什么时候为变量赋值为-null" class="headerlink" title="什么时候为变量赋值为 null"></a>什么时候为变量赋值为 null</h3><p>初始赋值为 null，表明其将要赋值为对象</p>
<p>结束前赋值为 null 为了释放对象在内存中的位置，让变量指向的对象成为垃圾对象（被垃圾回收器回收）</p>
<h3 id="变量类型与数据类型"><a href="#变量类型与数据类型" class="headerlink" title="变量类型与数据类型"></a>变量类型与数据类型</h3><p>数据类型分为基本类型和对象类型，变量的类型（变量内存值的类型）分为基本类型（保存的是基本类型数据）和引用类型（保存的是地址值）</p>
<h2 id="2、数据、变量与内存"><a href="#2、数据、变量与内存" class="headerlink" title="2、数据、变量与内存"></a>2、数据、变量与内存</h2><h3 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h3><p>存储在内存中代表特定信息的东西，本质上是 01 串</p>
<p>数据的特点：可传递，可运算</p>
<p>一切皆数据，函数也是数据</p>
<p>内存中所有操作的目标是数据，如算术运算、逻辑运算、赋值、运行函数</p>
<h3 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h3><p>内存条通电后产生的可存储数据的临时空间</p>
<p>内存的产生和死亡：内存条（电路板）–&gt; 通电 –&gt; 产生内存空间 –&gt; 存储数据 –&gt; 处理数据 –&gt; 断电 –&gt; 内存空间和数据消失</p>
<p>分配内存：声明变量和函数或创建对象时，JS 引擎会自动分配一定大小的内存来存放对应数据</p>
<p>释放内存：清空内存中的数据，表示内存可以再分配使用（内存不释放就不能复用）</p>
<p>一块内存有两个数据：内部存储的数据和地址值</p>
<p>内存分类：栈和堆</p>
<p>— 栈：存全局变量、局部变量、标识对象的变量（如函数名），空间较小</p>
<p>— 堆：对象（如数组、函数），空间较大</p>
<h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量是可变化的量，由变量名和变量值组成</p>
<p>每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h3 id="数据、内存、变量之间的关系"><a href="#数据、内存、变量之间的关系" class="headerlink" title="数据、内存、变量之间的关系"></a>数据、内存、变量之间的关系</h3><p>内存是一个容器，用来存储程序运行需要操作的数据的临时空间</p>
<p>变量（变量名、变量值）是内存的标识，通过变量找到对应内存，进而操作（读/写）内存中的数据</p>
<h3 id="var-a-xxx，-a-内存中保存的是什么？"><a href="#var-a-xxx，-a-内存中保存的是什么？" class="headerlink" title="var a = xxx， a 内存中保存的是什么？"></a>var a = xxx， a 内存中保存的是什么？</h3><p>（1）xxx 是基本数据类型，a 保存的是这个数据 </p>
<p>（2）xxx 是对象，保存的是对象的地址值</p>
<p>（3）xxx 是一个变量，保存的是 xxx 的内存内容（可能是基本数据类型，也可能是地址值）</p>
<pre><code>var b = &#39;abc&#39;
var a = b   //a 保存的是 &#39;abc&#39;
b = &#123;&#125;
a = b    //a 保存的是 b 中的内存内容，只是 b 的内存内容存的对象地址值</code></pre>
<h3 id="引用变量赋值"><a href="#引用变量赋值" class="headerlink" title="引用变量赋值"></a>引用变量赋值</h3><p>n 个引用变量指向同一个对象，通过一个变量修改对象内部数据，其他所有变量看到的是修改之后的数据</p>
<p>n 个引用变量指向一个对象，让其中一个引用变量指向另一个对象，其他所有引用变量依然指向前一个对象</p>
<pre><code>var a = &#123;age:10&#125;
var b = a
b.age = 12  //此时 a.age 也变为 12
function fn(obj)&#123;
    obj.age = &#39;15&#39;
&#125;
fn(a)  //此时 a.age 和 b.age 都变为 15

var c = &#123;age:12&#125;
var d = c
c = &#123;name:&#39;BOB&#39;,age:13&#125;  //c 相当于重新开辟了新的空间创建了个新的对象，此时 c 和 d 指向两个对象，d.age 还是 12

var e = &#123;age:12&#125;
function fun(obj)&#123;
    obj = &#123;age:15&#125;  //相当于创建一个新对象，obj 存的地址改变
&#125;
fun(e)  // 此时 e.age 还是12，函数中的 obj 会变成垃圾被回收</code></pre>
<h3 id="在-JS-调用函数时传递变量参数时，是值传递还是引用传递"><a href="#在-JS-调用函数时传递变量参数时，是值传递还是引用传递" class="headerlink" title="在 JS 调用函数时传递变量参数时，是值传递还是引用传递"></a>在 JS 调用函数时传递变量参数时，是值传递还是引用传递</h3><p>理解1：都是值（包括基本值或地址值）传递</p>
<p>理解2：可能是值传递，也可能是引用传递（即传地址值，注意不是地址，而是表示地址的值）</p>
<pre><code>var a = 3
function fn(a)&#123;
    a = a + 1
&#125;
console.log(a)   // a 还是 3
function fn2(obj)&#123;
    console.log(obj.name)
&#125;
var obj = &#123;name:&#39;tom&#39;&#125;
fn2(obj)</code></pre>
<h3 id="JS-引擎如何管理内存"><a href="#JS-引擎如何管理内存" class="headerlink" title="JS 引擎如何管理内存"></a>JS 引擎如何管理内存</h3><p>（1）内存生命周期</p>
<p>— 分配小内存空间，等到它的使用权</p>
<p>— 存储数据，可以对它反复进行操作</p>
<p>— 释放小内存空间，清空内存中数据，内存可再被分配复用</p>
<p>（2）释放内存</p>
<p>局部变量（为执行函数分配的栈空间内存）：函数执行完自动释放</p>
<p>对象（存储对象的堆空间内存）：先成为垃圾对象（即先把指向对象的变量设为 null，即内存没有引用指向时） —&gt; 由垃圾回收器回收</p>
<p>全局变量在运行时不会释放</p>
<pre><code>var a = 3
var obj = &#123;&#125;  //此时共占用 3 个小内存，分别被 a、obj、obj 所指向对象占用
obj = null   //此时 obj 指向的对象成为垃圾对象，而 obj 变量所占内存没有释放</code></pre>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>多个数据的封装体（集合体），用来保存多个数据的容器</p>
<p>一个对象代表现实中的一个事物</p>
<p>对象类型的数据有 Object、Function（可执行）、Array（内部数据有序）</p>
<h3 id="为什么要用对象"><a href="#为什么要用对象" class="headerlink" title="为什么要用对象"></a>为什么要用对象</h3><p>统一管理多个数据</p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><p>对象由属性和方法组成</p>
<p>属性：由属性名（字符串）和属性值（任意类型）组成</p>
<p>方法：是一种特别的属性，属性值是函数的属性</p>
<h3 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a>如何访问对象内部数据</h3><p><code>.属性名</code>：编码简单，有时不能用</p>
<p><code>[&#39;属性名&#39;]</code>：编码复杂，能通用</p>
<h3 id="什么时候必须使用-‘属性名’-的方式获取属性"><a href="#什么时候必须使用-‘属性名’-的方式获取属性" class="headerlink" title="什么时候必须使用[‘属性名’]的方式获取属性"></a>什么时候必须使用[‘属性名’]的方式获取属性</h3><p>— 属性名包含特殊字符：- 空格</p>
<p>— 使用变量表示属性名</p>
<h2 id="4、函数"><a href="#4、函数" class="headerlink" title="4、函数"></a>4、函数</h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h3><p>实现特定功能的 n 条语句的封装体</p>
<p>只有函数是可执行的，其他类型的数据不能执行</p>
<p>函数也是对象</p>
<h3 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数"></a>为什么要用函数</h3><p>提高代码复用</p>
<p>便于阅读交流</p>
<h3 id="如何定义函数"><a href="#如何定义函数" class="headerlink" title="如何定义函数"></a>如何定义函数</h3><p>— 函数声明 <code>function fn()&#123;&#125;</code></p>
<p>— 表达式 <code>var fn = function()&#123;&#125;</code></p>
<h3 id="如何调用（执行）函数"><a href="#如何调用（执行）函数" class="headerlink" title="如何调用（执行）函数"></a>如何调用（执行）函数</h3><p><code>test()</code> 直接调用</p>
<p><code>对象.方法名()</code> 通过对象调用</p>
<p><code>new 函数名()</code> new 调用</p>
<p><code>函数对象.call(对象实例)</code> 或 <code>函数对象.apply(对象实例)</code> 让一个函数成为指定任意对象的方法进行调用</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="什么函数才是回调函数"><a href="#什么函数才是回调函数" class="headerlink" title="什么函数才是回调函数"></a>什么函数才是回调函数</h4><p>1）定义的 2）没有显式调用 3）但最终它在某个时刻或某个条件下执行了</p>
<h4 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h4><p>— dom 事件回调函数（如 点击 onclick、获取焦点等），this 是发生事件的 dom 元素</p>
<p>— 定时器（如setTimeout）回调函数，this 是 window</p>
<p>— ajax 请求回调函数</p>
<p>— 生命周期回调函数</p>
<h3 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式 IIFE"></a>立即执行函数表达式 IIFE</h3><p>IIFE 全称是 Immediately-Invoked Function Expression，可理解为匿名函数自调用</p>
<p>作用：隐藏内部实现，不会污染外部（全局）命名空间，可用它来编码 js 模块</p>
<pre><code>;(function()&#123;  //匿名函数自调用，前面的分号是为了防止上一行后没有分号把下面都连一块，所以使用分号分隔开
    var a = 1;
    function test()&#123;
        console.log(++a)
    &#125;
    window.$ = function()&#123;  //向外暴露一个全局函数
        return&#123;
            test:test
        &#125;
    &#125;
&#125;)()
$().test()  //输出 2</code></pre>
<h3 id="函数中的-this"><a href="#函数中的-this" class="headerlink" title="函数中的 this"></a>函数中的 this</h3><h4 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h4><p>任何函数本质上都是通过某个对象调用的，若没有直接指定就是window</p>
<p>所有函数内部都有一个变量 this</p>
<p>this 的值是调用函数的当前对象</p>
<h4 id="如何确定-this-的值"><a href="#如何确定-this-的值" class="headerlink" title="如何确定 this 的值"></a>如何确定 this 的值</h4><p>函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是 window</p>
<p>对象实例.函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是对象实例</p>
<p>new 函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是新创建的对象</p>
<p>函数对象.call(对象实例)&nbsp;&nbsp;&nbsp;&nbsp;this 是参数中的对象实例</p>
<pre><code>function Person(color)&#123;
    console.log(this)
    this.color = color
    this.getColor = function()&#123;
        console.log(this)
    &#125;
&#125;
Person(&#39;red&#39;)              //this 是 window
var p = new Person(&#39;red&#39;)  //this 是 p
p.getColor()               //this 是 p
var obj = &#123;&#125;
p.getColor.call(obj)       //this 是 obj
var test = p.getColor
test()                     //this 是 window
function fun1()&#123;
    function fun2()&#123;
        console.log(this)
    &#125;
    fun2()                 //this 是 window
&#125;
fun1()                     //this 是 window</code></pre>
<h2 id="5、JS-语句中的分号"><a href="#5、JS-语句中的分号" class="headerlink" title="5、JS 语句中的分号"></a>5、JS 语句中的分号</h2><p>是否加分号是编码风格的问题，看个人喜好（如 vue.js 框架源码中没用分号）</p>
<p>必须加分号的情况：</p>
<p>— 小括号开头的前一条语句</p>
<p>— 中括号开头的前一条语句</p>
<p>上面的情况以防万一可以在行首加分号</p>
<pre><code>;(function()&#123;&#125;)()
;[1,3].forEach(function()&#123;&#125;)</code></pre>
<h1 id="二、函数高级"><a href="#二、函数高级" class="headerlink" title="二、函数高级"></a>二、函数高级</h1><h2 id="1、原型与原型链"><a href="#1、原型与原型链" class="headerlink" title="1、原型与原型链"></a>1、原型与原型链</h2><h3 id="函数的-prototype-属性"><a href="#函数的-prototype-属性" class="headerlink" title="函数的 prototype 属性"></a>函数的 prototype 属性</h3><p>每个函数都有一个 prototype 属性（在函数定义时创建函数对象，并添加 prototype 属性 <code>this.prototype = &#123;&#125;</code>）它默认指向一个 Object 空对象（没有我们指定的属性），prototype 指向的对象即称为原型对象</p>
<p>原型对象（即 prototype 所指向的）中有一个属性 constructor，它指向函数对象</p>
<pre><code>Date.prototype.constructor === Date  //true
function Fun()&#123;&#125;
Fun.prototype.constructor === Fun   //true
Fun.prototype.test = function()&#123;&#125;
var fun = new Fun()
fun.test()</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="原型对象"></p>
<p>如上图构造函数（左边）和原型对象（右边）相互引用</p>
<h3 id="给原型对象添加属性（一般都是方法）"><a href="#给原型对象添加属性（一般都是方法）" class="headerlink" title="给原型对象添加属性（一般都是方法）"></a>给原型对象添加属性（一般都是方法）</h3><p>作用：函数的所有对象实例自动拥有原型中的属性（方法）</p>
<h3 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h3><p>每个函数都有一个 prototype，即显式原型属性，在定义函数时自动添加的 <code>this.prototype = &#123;&#125;</code>，默认指向一个空的 Object 实例对象（但是 Object 不满足）</p>
<p>每个实例对象都有一个 <code>__proto__</code>，称为隐式原型属性，创建对象时自动添加的 <code>this.__proto__ = 构造函数.prototype</code>，默认为构造函数的 ptototype 属性值</p>
<p>对象的隐式原型的值为其对应的构造函数的显式原型的值</p>
<p>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6 之前）</p>
<pre><code>function Fn()&#123;&#125;    //定义构造函数，内部语句：this.prototype = &#123;&#125;，this 指函数对象
Fn.prototype       //显式原型属性

var fn = new Fn()  //内部语句：this.proto__ = Fn.prototype，this 指 fn
fn.__proto__       //隐式原型属性
Fn.prototype === fn.__proto  //true

Fn.prototype.test = function()&#123;&#125;
fn.test()</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%98%BE%E5%BC%8F%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="显式隐式原型"></p>
<p>（prototype 是给构造函数使用（读/写），<code>__proto__</code> 是给对象实例使用（读））</p>
<p><strong>记住：实例对象的隐式原型 <code>__proto__</code> = 构造函数的显式原型 <code>prototype</code></strong></p>
<h3 id="原型链（别名隐式原型链）"><a href="#原型链（别名隐式原型链）" class="headerlink" title="原型链（别名隐式原型链）"></a>原型链（别名隐式原型链）</h3><p>访问一个对象属性时，先在自身属性中查找，找到返回；若没有，再沿着 <code>__proto__</code> 这条链向上查找，找到返回；若最终没有找到，返回 undefined</p>
<p>作用：查找对象的属性（方法）</p>
<pre><code>function Fn = function()&#123;
    this.test1 = function()&#123;&#125;
&#125;
Fn.prototype.test2 = function()&#123;&#125;
var fn = new Fn()
fn.test1()
fn.test2()
fn.toString()
fn.test3()  //报错函数 not define</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<h3 id="构造函数、原型、实例对象的关系"><a href="#构造函数、原型、实例对象的关系" class="headerlink" title="构造函数、原型、实例对象的关系"></a>构造函数、原型、实例对象的关系</h3><p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB1.png" alt="构造函数-原型-实例关系1"></p>
<p>所有函数都是 Function 的实例（包含 Function）</p>
<p>所有函数的 <code>__proto__</code> 都是一样的，因为构造函数都是 Function()</p>
<p>function Foo(){} 等价于 var Foo = new Function()</p>
<p>注意 Function = new Function()</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB2.png" alt="构造函数-原型-实例关系2"></p>
<p>上图中 Foo 是 Function 的实例对象，Object 是 Function 的实例对象，Function 的实例对象和构造函数都是它自己，Function 的原型是 Object 的实例对象</p>
<pre><code>Foo.prototype instanceof Object   //true
Object.prototype instanceof Object  //false
Function.prototype instanceof Object  //true</code></pre>
<h3 id="原型链补充"><a href="#原型链补充" class="headerlink" title="原型链补充"></a>原型链补充</h3><p>（1）函数的显式原型指向的对象默认是空 Object 实例对象（但 Object 不满足）</p>
<pre><code>Foo.prototype instanceof Object   //true
Object.prototype instanceof Object  //false
Function.prototype instanceof Object  //true</code></pre>
<p>（2）所有函数都是 Function 的实例（包含 Function）</p>
<pre><code>Function.__proto__ === Function.prototype</code></pre>
<p>（3）Object 的原型对象是原型链的尽头</p>
<pre><code>Object.prototype.__proto__  //是 null</code></pre>
<h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h3><p>读取对象属性值时，会自动到原型链中查找</p>
<p>设置对象的属性值时，不会查找原型链，若当前对象中没有该属性，则直接添加该属性</p>
<p>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.prototype.setName = function(name)&#123;
    this.name = name
&#125;
var p1 = new Person(&#39;aa&#39;,12)
p1.setName(&#39;bb&#39;)  //此时 p1 实例中有两个属性 name（为 bb） 和 age
var p2 = new Person(&#39;cc&#39;,12)
p2.setName(&#39;dd&#39;)  //此时 p2 实例中有两个属性 name（为 dd） 和 age

p1.__proto__ === p2.__proto__   //true</code></pre>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>A实例对象 instanceof B构造函数</code> 若 B 函数的显式原型对象在 A 对象的（隐式）原型链上，返回 true，否则返回 false</p>
<p>Function 是通过 new 自己产生的实例</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof.png" alt="instanceof"></p>
<pre><code>Object instanceof Function  //true
Object instanceof Object  //true
Function instanceof Function  //true
Function instanceof Object  //true
function Foo()&#123;&#125;
Object instanceof Foo  //false</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof1.png" alt="instanceof1"></p>
<h3 id="相关例子"><a href="#相关例子" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>function A()&#123;&#125;
A.prototype.n = 1
var b = new A()
A.prototype = &#123;n:2,m:3&#125;
var c = new A()
console.log(b.n, b.m, c.n, c.m)  //1 undefined 2 3</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E4%BE%8B%E5%AD%901.png" alt="例子1"></p>
<pre><code>function Foo()&#123;&#125;
Object.prototype.a = function()&#123;&#125;
Function.prototype.b = function()&#123;&#125;
var f1 = new Foo()
f1.a()  //不报错
f1.b()  //报错
F.a()   //不报错
F.b()   //不报错</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof1.png" alt="instanceof1"></p>
<h2 id="2、执行上下文与执行上下文栈"><a href="#2、执行上下文与执行上下文栈" class="headerlink" title="2、执行上下文与执行上下文栈"></a>2、执行上下文与执行上下文栈</h2><h3 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h3><p>变量声明提升：通过 var 定义的变量，在定义语句之前就可以访问到，只是值为 undefined</p>
<p>函数声明提升：<strong>通过 function 声明的函数</strong>，在声明语句之前就可以直接调用，值为函数对象</p>
<pre><code>console.log(a)  //输出 undefined，变量提升
fn1()   //可调用，函数提升
fn2()   //不能调用，变量提升
var a = 3
function fn1()&#123;&#125;
var fn2 = function()&#123;&#125;</code></pre>
<p>变量提升和函数提升的产生过程：</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>代码根据其位置可分为全局代码和函数（局部）代码</p>
<p>执行上下文的个数 = 调用的函数数量 + 1（指 window）</p>
<h4 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h4><p>（1）在全局代码前将 window 确定为全局执行上下文</p>
<p>（2）对全局数据进行预处理</p>
<p>&nbsp;&nbsp;&nbsp;— var 定义的全局变量=undefined，并添加为 window 的属性</p>
<p>&nbsp;&nbsp;&nbsp;— function 声明的全局函数创建好函数对象，并添加为 window 的方法</p>
<p>&nbsp;&nbsp;&nbsp;— this 赋值为 window</p>
<p>（3）开始执行全局代码</p>
<h4 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h4><p>只有在调用函数的时候才会生成执行上下文</p>
<p>（1）在调用函数，准备执行函数体前，创建对应的函数执行上下文对象（封闭的虚拟对象，是栈内存中的一片区域，里面存放局部变量、形参、arguments等）</p>
<p>（2）对局部数据进行预处理</p>
<p>&nbsp;&nbsp;&nbsp;— 形参=实参，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— arguments=实参列表，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— var 定义的局部变量=undefined，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— function 声明的函数创建好函数对象，并添加为执行上下文的方法</p>
<p>&nbsp;&nbsp;&nbsp;— this 赋值为调用函数的对象</p>
<p>（3）开始执行函数体代码</p>
<pre><code>function fn(a1)&#123;
    console.log(a1)  //2
    console.log(a2)  //undefined
    a3()             //a3()执行
    console.log(this)  //this 指 window
    console.log(arguments)  //伪数组[2,3]
    var a2 = 3
    function a3()&#123;
        console.log(&#39;a3()执行&#39;)
    &#125;
&#125;
fn(2,3)</code></pre>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>（1）在全局代码执行前，JS 引擎会创建一个栈来存储管理所有的执行上下文对象</p>
<p>（2）在全局执行上下文（window）确定后，将其添加到栈中（压栈）</p>
<p>（3）在函数执行上下文创建后，将其添加到栈中（压栈）</p>
<p>（4）在当前函数执行完成后，将栈顶的对象移除（出栈）</p>
<p>（5）当所有的代码执行完后，栈中只剩下 window</p>
<pre><code>                    //1.进入全局执行上下文
var a = 10
var bar = function(x)&#123;
    var b = 5
    foo(x+b)          //3.进入 foo 执行上下文
&#125;
var foo = function(y)&#123;
    var c = 5
    console.log(a+c+y)
&#125;
bar(10)               //2.进入 bar 函数执行上下文</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt="执行上下文栈"></p>
<p>栈底一定是 window，当前运行的总是栈顶的上下文对象</p>
<h3 id="相关例子-1"><a href="#相关例子-1" class="headerlink" title="相关例子"></a>相关例子</h3><p>1</p>
<pre><code>var a = 3
function fn()&#123;
    console.log(a)
    var a = 4  //a 在 console.log 前声明 a，在此行才赋值
&#125;
fn()  //输出 undefined，因为在 fn 函数中</code></pre>
<p>2</p>
<pre><code>console.log(&#39;gb:&#39;+i)
var i = 1
foo(1)
function foo(i)&#123;
    if(i === 4)&#123;return&#125;
    console.log(&#39;fb:&#39;+i)
    foo(i+1)
    console.log(&#39;fe:&#39;+i)
&#125;
console.log(&#39;ge:&#39;+i)</code></pre>
<p>代码依次输出 gb:undefined、fb:1、fb:2、fb:3、fb:3、fb:2、fb:1、ge:1，整个过程中产生了 5 个执行上下文</p>
<p>3</p>
<pre><code>function a()&#123;&#125;
var a
console.log(typeof a)  //输出 &#39;function&#39;</code></pre>
<p>先执行变量提升，再执行函数提升</p>
<p>4</p>
<pre><code>if(!(b in window))&#123;  //此处判断为 true
    var b = 1
&#125;
console.log(b)   //输出 undefined</code></pre>
<p>5</p>
<pre><code>var c = 1
function c(c)&#123;
    console.log(c)
    var c =3
&#125;
c(2)   //此处会报错</code></pre>
<p>上述代码会报错，因为上述代码相当于</p>
<pre><code>var c
function c(c)&#123;
    console.log(c)
    var c =3
&#125;
c = 1
c(2)   //此处会报错</code></pre>
<h2 id="3、作用域与作用域链"><a href="#3、作用域与作用域链" class="headerlink" title="3、作用域与作用域链"></a>3、作用域与作用域链</h2><p>作用域是一个代码所在的区域，它是静态的（执行上下文对象是在执行调用的时候才产生是动态的），在编写代码时就确定了</p>
<p>作用域分为全局作用域、函数作用域</p>
<p>没有块作用域（即在大括号内声明的变量在外面也可见，但 ES6 有，Java 中也有）</p>
<pre><code>if(true)&#123;var c =3;&#125;  //大括号内的 c 在外面也可见，没有块作用域
console.log(c)</code></pre>
<p>作用域的作用：隔离变量，不同作用域下同名变量不会冲突</p>
<p>作用域的个数 = 定义的函数数量 + 1（指全局）</p>
<h3 id="作用域与执行上下文的区别"><a href="#作用域与执行上下文的区别" class="headerlink" title="作用域与执行上下文的区别"></a>作用域与执行上下文的区别</h3><p>（1）全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</p>
<p>全局执行上下文环境是在全局作用域确定之后，js 代码马上执行之前创建</p>
<p>函数执行上下文是在调用函数时，函数体代码执行之前创建</p>
<p>（2）作用域是静态的，只要函数定义好就一直存在，且不会再变化</p>
<p>执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放</p>
<h3 id="作用域与执行上下文的联系"><a href="#作用域与执行上下文的联系" class="headerlink" title="作用域与执行上下文的联系"></a>作用域与执行上下文的联系</h3><p>执行上下文环境（对象）是从属于所在的作用域</p>
<p>全局上下文环境 ==&gt; 全局作用域</p>
<p>函数上下文环境 ==&gt; 对应的函数作用域</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链是多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外），即嵌套的作用域产生的由内向外的链</p>
<p>作用域链作用：查找变量时就是沿着作用域链来查找的</p>
<p>查找一个变量的查找规则：</p>
<p>— 1.在当前作用域的执行上下文中查找对应的属性，若有直接返回，否则进入 2</p>
<p>— 2.在上一级作用域的执行上下文中查找对应的属性，若有直接返回，否则进入 3</p>
<p>— 3.再次执行 2 的相同操作，直到全局作用域，若还找不到就抛出找不到的异常</p>
<h3 id="相关例子-2"><a href="#相关例子-2" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>var x = 10
function fn()&#123;
    console.log(x)
&#125;
function show(f)&#123;
    var x = 20
    f()
&#125;
show(fn)  //会输出 10</code></pre>
<p>上述代码会输出 10</p>
<pre><code>var fn = function()&#123;
    console.log(fn)
&#125;
fn()  //会输出 fn 函数</code></pre>
<p>上述代码会输出 fn 函数</p>
<pre><code>var obj = &#123;
    fn2: function()&#123;
        console.log(fn2)
    &#125;
&#125;</code></pre>
<p>上述代码会报错 fn2 is not defined，因为在当前作用域先找 fn2 没有，再去外部全局作用域找也没有</p>
<pre><code>var obj = &#123;
    fn2: function()&#123;
        console.log(this.fn2)
    &#125;
&#125;</code></pre>
<p>上述代码不会报错，会输出 obj 对象中的 fn2 方法</p>
<h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2><p>例子：分别点击三个按钮弹出相应的数字</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    var btn = btns[i]
    btn.onclick = function()&#123;
        alert(&#39;第&#39;+(i+1)+&#39;个&#39;)
    &#125;
&#125;</code></pre>
<p>上述代码在点击所有按钮时都是弹出 ‘第4个’</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    var btn = btns[i]
    btn.index = i  //将 btn 所对应的下标保存在 btn 上
    btn.onclick = function()&#123;
        alert(&#39;第&#39;+(this.index+1)+&#39;个&#39;)
    &#125;
&#125;</code></pre>
<p>上述代码可正常实现功能</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    （function(i)&#123;
        var btn = btns[i]
        btn.onclick = function()&#123;
            alert(&#39;第&#39;+(i+1)+&#39;个&#39;)
        &#125;
    &#125;)(i)
&#125;</code></pre>
<p>上述代码利用闭包实现功能</p>
<h3 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h3><p>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（包括函数）时，就产生了闭包，如</p>
<pre><code>function fn1()&#123;
    var a = 2
    var b = &#39;abc&#39;
    function fn2()&#123;  //闭包
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()</code></pre>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>理解1：闭包是嵌套的内部函数</p>
<p>理解2：包含被引用变量（函数）的对象</p>
<p>注意：闭包存在于嵌套的内部函数中</p>
<h3 id="产生闭包的条件"><a href="#产生闭包的条件" class="headerlink" title="产生闭包的条件"></a>产生闭包的条件</h3><p>（1）函数嵌套</p>
<p>（2）内部函数引用了外部函数的数据（变量/函数），并执行内部函数定义就会产生闭包（不用调用内部函数，但必须调用外部函数）</p>
<p>外部函数执行几次（内部函数就创建几次）就产生几个闭包，和内部函数执行几次没有关系</p>
<pre><code>function fn1()&#123;
    var a = 2   //在此处打断点就已产生闭包，因为变量提升和函数提升，已执行 fn2 函数定义
    var b = &#39;abc&#39;
    function fn2()&#123;  //闭包
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()

function fn1()&#123;
    var a = 2   //在此处打断点就还未产生闭包，因为变量提升但 fn2 变量还未赋值为函数，所以函数定义未执行
    var b = &#39;abc&#39;
    var fn2 = function()&#123;  //闭包，闭包中有 a 没有 b
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()</code></pre>
<h3 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h3><p>（1）将函数作为另一个函数的返回值</p>
<pre><code>function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;  //闭包
        a++
        console.log(a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4</code></pre>
<p>上述代码只产生一次闭包，并且在调用 f() 时闭包没有消失 </p>
<p>（2）将函数作为实参传递给另一个函数调用</p>
<pre><code>function showDelay(msg,time)&#123;
    setTimeout(function()&#123;  //此处产生闭包，因为内部函数使用了外部函数的 msg，产生闭包的原因和 setTimeout 以及 time 变量无关
        alert(msg)
    &#125;,time)
&#125;
showDelay(&#39;xxx&#39;,2000)</code></pre>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>（1）使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</p>
<p>（2）让函数外部可以操作（读写）到函数内部的数据（变量/函数）</p>
<pre><code>function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;
        a++
        console.log(a)
    &#125;
    var fn3 = function()&#123;
        a--
        console.log(a)
    &#125;
    return fn3
&#125;
fn1()  //此时 fn1 内部的对象 fn2、fn3 都成为垃圾对象，局部变量也不存在了
var f = fn1()  //fn1 执行完后 fn2 就不存在了，闭包中只有 a，fn3 本身也不存在，但 fn3 不成为垃圾对象，因为 f 指向了 fn3
f()  //输出 3
f()  //输出 4</code></pre>
<p>总结：函数执行完后，函数内部声明的局部变量一般不存在，只有存在于闭包中的变量才可能存在（前提是闭包中的函数对象没有成为垃圾对象，被引用的局部变量才存在）</p>
<p>在函数外部不能直接访问函数内部的局部变量，但可以通过闭包让外部操作它</p>
<h3 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h3><p>产生：在嵌套内部<strong>函数定义执行完</strong>时就产生了（不是在调用时）</p>
<p>死亡：在嵌套的内部函数成为垃圾对象时</p>
<pre><code>function fn1()&#123;
    //此时闭包就已经产生了（因为函数提升，内部函数对象已经创建了）
    var a = 2
    function fn2()&#123;  //闭包
        a++
        console.log(a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4
f = null  //此时闭包死亡（因为包含闭包的函数对象 fn2 成为垃圾对象）

function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;
        a++
        console.log(a)
    &#125;  //此时闭包才产生，因为此时才执行完函数定义
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4
f = null   //此时闭包死亡（因为包含闭包的函数对象 fn2 成为垃圾对象）</code></pre>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>闭包可用于定义 JS 模块：</p>
<p>— 具有特定功能的 js 文件</p>
<p>— 将所有的数据和功能都封装在一个函数内部（私有的）</p>
<p>— 只向外暴露一个包含 n 个方法的对象或函数</p>
<p>— 模块的使用者只需通过模块暴露的对象调用方法来实现对应的功能</p>
<p>定义和使用模块的方式一：</p>
<pre><code>定义一个模块 myModule.js
function myModule()&#123;
    //私有数据
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    return &#123;
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var module = myModule()
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<p>定义和使用模块的方式二（这种方式更方便）：</p>
<pre><code>定义一个模块 myModule.js
(function()&#123;
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    window.module = &#123;  //通过 window 向外暴露
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;)()

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<p>定义和使用模块的方式三（这种方式有利于代码压缩，即把变量名自动转为单个字母表示）：</p>
<pre><code>定义一个模块 myModule.js
(function(w)&#123;
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    w.module = &#123;  //通过 window 向外暴露
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;)(window)

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<h3 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h3><p>闭包缺点：</p>
<p>（1）函数执行完后，函数内的局部变量没有释放，占用内存事件会变长</p>
<p>（2）容易造成内存泄露</p>
<p>解决：</p>
<p>（1）能不用闭包就不用</p>
<p>（2）及时释放，将指向内部函数的变量设为 null，让内部函数成为垃圾对象，进而回收闭包</p>
<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><p>（1）内存溢出：一种程序运行出现的错误，错误原因是当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误</p>
<p>（2）内存泄露：占用的内存没有及时释放（但程序不出错），内存泄露积累多了就容易导致内存溢出</p>
<p>常见的内存泄露：</p>
<p>— 意外的全局变量</p>
<p>— 没有及时清理的计时器或回调函数</p>
<p>— 闭包</p>
<pre><code>function fn()&#123;
    a = 3  //意外的全局变量
&#125;
fn()

setInterval(function()&#123;  //启动循环定时器后不清理
    console.log(&#39;xxx)
&#125;,1000)

function fn1()&#123;
    var a =4
    function fn2()&#123;
        console.log(++a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()</code></pre>
<h3 id="相关例子-3"><a href="#相关例子-3" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>var name = &quot;The window&quot;
var obj = &#123;
    name:&#39;My object&#39;
    fn:function()&#123;
        return function()&#123;
            return this.name;
        &#125;
    &#125;
&#125;
alert(obj.fn()())</code></pre>
<p>输出 The window，因为相当于直接调用 fn 里的匿名函数，上面代码中没有闭包，有函数嵌套，但内部函数没有引用外部函数变量</p>
<pre><code>var name = &quot;The window&quot;
var obj = &#123;
    name:&#39;My object&#39;
    fn:function()&#123;
        var that = this
        return function()&#123;
            return that.name;
        &#125;
    &#125;
&#125;
alert(obj.fn()())</code></pre>
<p>输出 My object，直接调用 fn 里的匿名函数，但是输出的是 that 对象的 name，上面代码中有闭包，有函数嵌套，且内部函数引用外部函数变量 that</p>
<pre><code>function fun(n,o)&#123;
    console.log(o)
    return&#123;
        fun:function(m)&#123; //闭包，因为 n 引用了外部函数 fun 中的 n
            return fun(m,n)  //这里的 fun 函数是只最外面第一行的 fun 函数
        &#125;
    &#125;
&#125;
var a = fun(0);  //undefined，因为没有给形参 o 赋值，此时闭包里的 n 是 0 
a.fun(1);    //0，函数执行产生了新的闭包，但马上消失，因为没有变量来接收 a.fun(1) 返回值
a.fun(2);    //0
a.fun(3);    //0
var b = fun(0).fun(1).fun(2).fun(3);  //undefined,0，1，2
var c = fun(0).fun(1);  //undefined,0
c.fun(2);  //1
c.fun(3);  //1</code></pre>
<h1 id="三、面向对象高级"><a href="#三、面向对象高级" class="headerlink" title="三、面向对象高级"></a>三、面向对象高级</h1><h2 id="1、对象创建模式"><a href="#1、对象创建模式" class="headerlink" title="1、对象创建模式"></a>1、对象创建模式</h2><h3 id="方式一：构造函数"><a href="#方式一：构造函数" class="headerlink" title="方式一：构造函数"></a>方式一：构造函数</h3><p>Object 构造函数（new Object()）模式：先创建空 Object 对象，再动态添加属性/方法</p>
<p>适用场景：起始时不确定对象内部数据</p>
<p>问题：语句太多</p>
<h3 id="方式二：对象字面量模式"><a href="#方式二：对象字面量模式" class="headerlink" title="方式二：对象字面量模式"></a>方式二：对象字面量模式</h3><p>使用 {} 创建对象，同时指定属性/方法</p>
<p>适用场景：起始时对象内部数据是确定的</p>
<p>问题：如果创建多个对象有，重复代码</p>
<h3 id="方式三：工厂模式（较不常用）"><a href="#方式三：工厂模式（较不常用）" class="headerlink" title="方式三：工厂模式（较不常用）"></a>方式三：工厂模式（较不常用）</h3><p>通过工厂函数（返回一个对象的函数都可以称为工厂函数）动态创建对象并返回</p>
<p>适用场景：需要创建多个对象</p>
<p>问题：对象没有一个具体的类型，都是 Object 类型</p>
<pre><code>function createPerson(name,age)&#123;
    var obj = &#123;
        name:name,
        age:age,
        setName:function(name)&#123;
            this.name = name
        &#125;
    &#125;
    return obj
&#125;</code></pre>
<h3 id="方式四：自定义构造函数模式"><a href="#方式四：自定义构造函数模式" class="headerlink" title="方式四：自定义构造函数模式"></a>方式四：自定义构造函数模式</h3><p>自定义构造函数，通过 new 创建对象</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<p>问题：每个对象都有相同的数据，浪费内存</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
    this.setName = function(name)&#123;
        this.name = name
    &#125;
&#125;</code></pre>
<h3 id="方式五：构造函数-原型的组合模式"><a href="#方式五：构造函数-原型的组合模式" class="headerlink" title="方式五：构造函数+原型的组合模式"></a>方式五：构造函数+原型的组合模式</h3><p>自定义构造函数，通过在函数中初始化，方法添加到原型上</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.prototype.setName = function(name)&#123;
    this.name = name
&#125;</code></pre>
<h2 id="2、继承模式"><a href="#2、继承模式" class="headerlink" title="2、继承模式"></a>2、继承模式</h2><h3 id="方式一：原型链继承（得到方法）"><a href="#方式一：原型链继承（得到方法）" class="headerlink" title="方式一：原型链继承（得到方法）"></a>方式一：原型链继承（得到方法）</h3><p>步骤</p>
<p>— 定义父类型构造函数</p>
<p>— 给父类型的原型添加方法</p>
<p>— 定义子类型构造函数</p>
<p>— 创建父类型的实例对象赋值为子类型的原型</p>
<p>— 将子类型原型的构造属性设置为子类型</p>
<p>— 给子类型原型添加方法</p>
<p>— 创建子类型的对象：可以调用父类型的方法</p>
<pre><code>//父类型
function Supper()&#123;
    this.supprop = &#39;supper&#39;
&#125;
Supper.prototype.showSupperProp = function()&#123;
    console.log(this.supprop)
&#125;
//子类型
function Sub()&#123;
    this.subprop = &#39;sub&#39;
&#125;
//子类型的原型为父类型的一个实例对象
Sub.prototype = new Supper()
//让子类型的原型的 constructor 指向子类型
Sub.prototype.constructor = Sub //若没有这条语句则 constructor 指向 Supper
Sub.prototype.showSubProp = functioin()&#123;
    console.log(this.subprop)
&#125;
var sub = new Sub()
sub.showSupperProp()
sub.showSubProp()</code></pre>
<p>关键：子类型的原型为父类型的一个实例对象</p>
<h3 id="方式二：借用构造函数继承（得到属性）"><a href="#方式二：借用构造函数继承（得到属性）" class="headerlink" title="方式二：借用构造函数继承（得到属性）"></a>方式二：借用构造函数继承（得到属性）</h3><p>步骤：</p>
<p>— 定义父类型构造函数</p>
<p>— 定义子类型构造函数</p>
<p>— 在子类型构造函数中调用父类型的构造</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
function Student(name,age,price)&#123;
    Person.call(this,name,age)  //相当于 this.Person(name,age)
    this.price = price
&#125;
var s = new Student(&#39;xx&#39;,12,10000)</code></pre>
<p>关键：在子类型构造函数中通过 call() 调用父类型构造函数</p>
<h3 id="方式三：组合继承"><a href="#方式三：组合继承" class="headerlink" title="方式三：组合继承"></a>方式三：组合继承</h3><p>原型链 + 借用构造函数的组合继承</p>
<p>步骤：</p>
<p>— 利用原型链实现对父类型对象的方法继承</p>
<p>— 利用 call() 借用父类型构造函数初始化相同属性</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.protorype.setName = function(name)&#123;
    this.name = name
&#125;
function Student(name,age,price)&#123;
    Person.call(this,name,age)  //为了得到属性
    this.price = price
&#125;
Student.prototype = new Person()  //为了能看到父类型原型的方法
Student.protorype.constructor = Student //为了修正 constructor 属性
Student.prototype.setPrice = function(price)&#123;
    this.price = price
&#125;
var s = new Student(&#39;xx&#39;,12,10000)
s.setName(&#39;yyy&#39;)
s.setPrice(12000)
console.log(s.name,s.age,s.price)  //输出 yyy 12 12000</code></pre>
<h1 id="四、线程机制与事件机制"><a href="#四、线程机制与事件机制" class="headerlink" title="四、线程机制与事件机制"></a>四、线程机制与事件机制</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><p>进程（process）：程序的一次执行，占有独有的内存空间，各个应用程序间内存空间相互独立，可通过 Windows 任务管理器查看进程</p>
<p>线程（thread）：线程是进程内一个独立的执行单元，是程序执行的一个完整流程，是 CPU的最小调度单元</p>
<p>程序是单线程还是多线程是看一个进程内有多少线程</p>
<p>应用程序必须运行在某个进程的某个线程上</p>
<p>一个进程中至少有一个运行的线程，主线程，进程启动后自动创建</p>
<p>一个进程中可以同时运行多个线程，会说程序是多线程运行的</p>
<p>一个进程内的数据可以供其中的多个线程直接共享</p>
<p>多个进程之间的数据是不能直接共享的</p>
<p>线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用</p>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><p>多进程运行：一个应用程序可以同时启动多个实例运行</p>
<p>多线程：在一个进程内，同时有多个线程运行</p>
<p>CPU 的核数可对应同时运行的线程数</p>
<h3 id="比较单线程与多线程"><a href="#比较单线程与多线程" class="headerlink" title="比较单线程与多线程"></a>比较单线程与多线程</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>优点：</strong></p>
<p>能有效提升 CPU 利用率</p>
<p><strong>缺点：</strong></p>
<p>（1）创建多线程开销</p>
<p>（2）线程间切换开销</p>
<p>（3）死锁与状态同步问题</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p><strong>优点：</strong>顺序编程简单易懂</p>
<p><strong>缺点：</strong>效率低</p>
<p>js 是单线程运行的，但使用  H5 中的 Web Workers 可以多线程运行</p>
<p>浏览器是多线程运行的</p>
<p>浏览器有单进程和多进程，单进程的有 Firefox、老版 IE，多进程的有 chrome、新版 IE，可通过在浏览器打开多个标签后在任务管理器中查看是单进程还是多进程</p>
<h2 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h2><p>浏览器内核：支撑浏览器运行的最核心的程序</p>
<h3 id="不同浏览器的内核不同"><a href="#不同浏览器的内核不同" class="headerlink" title="不同浏览器的内核不同"></a>不同浏览器的内核不同</h3><p>— Chrome、Safari：webkit</p>
<p>— Firefox：Gecko</p>
<p>— IE：Trident</p>
<p>— 360、搜狗等国内浏览器：Trident + webkit</p>
<h3 id="内核组成模块"><a href="#内核组成模块" class="headerlink" title="内核组成模块"></a>内核组成模块</h3><p><strong>主线程中：</strong></p>
<p>— js 引擎模块（也是程序）：负责 js 程序的编译（运行前动态编译）与运行，因此 js 代码在主线程中运行（使用了 Web Worker 另说）</p>
<p>— html,css 文档解析模块：负责页面文本的解析（读文本-按一定规则拆解）</p>
<p>— DOM/CSS 模块：负责 DOM/CSS 在内存中的相关处理（把标签转换为对象，页面在内存中是个 DOM 对象树）</p>
<p>— 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</p>
<p>……</p>
<p><strong>分线程中：</strong></p>
<p>— 定时器模块：负责定时器的管理</p>
<p>— DOM 事件响应模块：负责事件的管理</p>
<p>— 网络请求模块：负责 ajax 请求</p>
<h2 id="3、定时器引发的思考"><a href="#3、定时器引发的思考" class="headerlink" title="3、定时器引发的思考"></a>3、定时器引发的思考</h2><h3 id="定时器真的是定时执行的吗？"><a href="#定时器真的是定时执行的吗？" class="headerlink" title="定时器真的是定时执行的吗？"></a>定时器真的是定时执行的吗？</h3><p>定时器并不能保证真正定时执行</p>
<p>一般会延迟一点（可以接受），也可能延迟很长时间（不能接受）</p>
<p>若在主线程执行了一个长时间的操作，可能导致延时才处理</p>
<h3 id="定时器回调函数是在分线程中执行的吗？"><a href="#定时器回调函数是在分线程中执行的吗？" class="headerlink" title="定时器回调函数是在分线程中执行的吗？"></a>定时器回调函数是在分线程中执行的吗？</h3><p>定时器回调函数是在主线程中执行的，js 是单线程的，所有 js 代码都是在主线程中执行（无论是回调函数还是非回调函数）</p>
<h3 id="定时器是如何实现的？"><a href="#定时器是如何实现的？" class="headerlink" title="定时器是如何实现的？"></a>定时器是如何实现的？</h3><p>事件循环模型</p>
<h2 id="4、JS-是单线程执行的"><a href="#4、JS-是单线程执行的" class="headerlink" title="4、JS 是单线程执行的"></a>4、JS 是单线程执行的</h2><p>js 是单线程执行的，回调函数也是在主线程，H5 提出了实现多线程的方案（Web Worker）</p>
<p>只有主线程能更新界面</p>
<h3 id="证明-js-执行是单线程的"><a href="#证明-js-执行是单线程的" class="headerlink" title="证明 js 执行是单线程的"></a>证明 js 执行是单线程的</h3><p>setTimeout() 的回调函数是在主线程执行的，定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</p>
<pre><code>setTimeout(function()&#123;
    console.log(&#39;22&#39;)
&#125;,2000)
setTimeout(function()&#123;
    console.log(&#39;11&#39;)
&#125;,1000)
function fn()&#123;console.log(&#39;fn&#39;)&#125;
fn()
console.log(&#39;alert之前&#39;)
alert(&#39;----&#39;) //暂停当前主线程执行，同时暂停计时，点击确定后恢复程序执行和计时
console.log(&#39;alert之后&#39;)</code></pre>
<h3 id="为什么-js-要用单线程模式，而不用多线程模式"><a href="#为什么-js-要用单线程模式，而不用多线程模式" class="headerlink" title="为什么 js 要用单线程模式，而不用多线程模式"></a>为什么 js 要用单线程模式，而不用多线程模式</h3><p>JavaScript 的单线程与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题（如同时对一个对象更新和删除）</p>
<h3 id="代码分类"><a href="#代码分类" class="headerlink" title="代码分类"></a>代码分类</h3><p>代码分类：初始化代码、回调代码</p>
<p>初始化执行代码（同步代码）：包含绑定 DOM 事件监听，设置定时器，发送 ajax 请求的代码</p>
<p>回调执行代码（异步代码）：处理回调逻辑</p>
<h3 id="js-引擎执行代码的基本流程"><a href="#js-引擎执行代码的基本流程" class="headerlink" title="js 引擎执行代码的基本流程"></a>js 引擎执行代码的基本流程</h3><p>（1）先执行初始化代码：包含一般代码和以下一些特别的代码</p>
<p>— 设置定时器</p>
<p>— 绑定监听</p>
<p>— 发生 ajax 请求</p>
<p>上述三种情况都包含回调函数，回调函数是异步执行</p>
<p>（2）后面在某个时可才会执行回调代码</p>
<pre><code>setTimeout(function()&#123;
    console.log(&#39;22&#39;)
&#125;,0)
console.log(&#39;alert之前&#39;)
alert(&#39;----&#39;) //暂停当前主线程执行，同时暂停计时，点击确定后恢复程序执行和计时
console.log(&#39;alert之后&#39;)

输出
alert之前
弹出----
alert之后
22  //即使 setTimeout 的时间设为 0，回调函数也在初始化代码都执行结束后才会执行</code></pre>
<h2 id="5、-浏览器的事件循环（轮询）模型"><a href="#5、-浏览器的事件循环（轮询）模型" class="headerlink" title="5、 浏览器的事件循环（轮询）模型"></a>5、 浏览器的事件循环（轮询）模型</h2><p>模型的两个重要组成部分：</p>
<p>— 事件（定时器/DOM 事件/Ajax）管理模块</p>
<p>— 回调队列</p>
<h3 id="事件驱动模型（event-driven-interaction-model）"><a href="#事件驱动模型（event-driven-interaction-model）" class="headerlink" title="事件驱动模型（event-driven interaction model）"></a>事件驱动模型（event-driven interaction model）</h3><p>如下图所示</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"></p>
<p>如上图所示最左侧的栈中表示初始化代码执行，栈中是一些执行上下文对象，回调函数交给右侧的不同管理模块处理，右侧表示在分线程上执行的不同管理模块，各模块不由 js 引擎执行（在主线程执行），而是由浏览器负责，管理模块把回调函数插入下方队列待执行</p>
<h3 id="模型运转流程"><a href="#模型运转流程" class="headerlink" title="模型运转流程"></a>模型运转流程</h3><p>（1）执行初始化代码，将事件回调函数交给对应模块管理</p>
<p>（2）当事件发生时，管理模块会将回调函数及其数据添加到回调队列中</p>
<p>（3）只有当初始化代码执行完后，才遍历读取队列中的回调函数执行</p>
<h3 id="执行栈（execution-stack）"><a href="#执行栈（execution-stack）" class="headerlink" title="执行栈（execution stack）"></a>执行栈（execution stack）</h3><p>所有代码都在此空间中执行</p>
<h3 id="浏览器内核（browser-core）"><a href="#浏览器内核（browser-core）" class="headerlink" title="浏览器内核（browser core）"></a>浏览器内核（browser core）</h3><p>js 引擎模块（在主线程处理）</p>
<p>其他模块（在主/分线程处理）</p>
<h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>callback queue 也称为任务队列（task queue）/消息队列（message queue）/事件队列（event queue）</p>
<h3 id="事件轮询（event-loop）"><a href="#事件轮询（event-loop）" class="headerlink" title="事件轮询（event loop）"></a>事件轮询（event loop）</h3><p>从任务队列中循环取出回调函数放入执行栈中一个接一个处理</p>
<h3 id="请求响应模型（request-response-model）"><a href="#请求响应模型（request-response-model）" class="headerlink" title="请求响应模型（request-response model）"></a>请求响应模型（request-response model）</h3><p>浏览器向服务器发送请求，服务器接收请求，并处理请求，并返回响应数据，浏览器接收响应数据并渲染</p>
<h2 id="6、H5-Web-Workers（多线程）"><a href="#6、H5-Web-Workers（多线程）" class="headerlink" title="6、H5 Web Workers（多线程）"></a>6、H5 Web Workers（多线程）</h2><p>H5 规范提供了 js 分线程的实现，名为 Web Workers，是一个 JavaScript 多线程解决方案（js 原本是单线程运行的）</p>
<p>这样可以将一些大计算量的代码交由 Web Worker 给分线程运行而不冻结用户界面，但是子线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JavaScript 单线程的本质</p>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Worker：构造函数，加载分线程执行的 js 文件</p>
<p>Worker.prototype.onmessage：用于接收另一个线程的回调函数</p>
<p>Worker.prototype.postMessage：向另一个线程发送消息</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建在分线程执行的 js 文件</p>
<p>在主线程中的 js 中发消息并设置回调</p>
<p>主线程中</p>
<pre><code>//创建一个 Worker 对象并向它传递将在新线程中执行的脚本的 URL
var worker = new Worker(&#39;worker.js&#39;)
//绑定接收消息的监听，主线程接收 worker 分线程传来的数据函数
worker.onmessage = function(event)&#123; //也可写在 postMessage 后面，因为只有在初始化代码执行完后才有可能执行回调函数
    console.log(event.data)
&#125;
//主线程向 worker 分线程发送数据
woreker.postMessage(&quot;hello world&quot;)</code></pre>
<p>分线程代码文件中</p>
<pre><code>var onmessage = function (event)&#123;  //不能用函数声明
    var msg = event.data  //通过 event.data 获得发送来的数据
    postMessage(&#39;ok&#39;)  //将获取到的数据发送回主线程
&#125;</code></pre>
<p>分线程中的全局变量不是 window，而是它自己的全局变量，所以在分线程中无法操作 DOM 元素（document相关）不能更新界面，也无法使用 alert（window 的方法）等</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/webworker.png" alt="webworker"></p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>（1）慢，因为增加了消息传输</p>
<p>（2）Worker 内代码不能操作 DOM（更新 UI），因为全局对象不是 window</p>
<p>（3）不能跨域加载 JS</p>
<p>（4）不是每个浏览器都支持这个新特性</p>
<h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h1><p>1、定义在对象中的属性变量不是私有的，因为外部可直接操作，只有定义在函数内的变量才可能是私有的（闭包另说），因为函数有作用域</p>
<p>2、找变量是通过作用域链，找对象的属性是通过原型链</p>
<p>3、变量找不到会报错，属性找不到会返回 undefined，如找变量 a 找不到会报错，找 window.a 找不到会返回 undefined</p>
<p>4、new 一个对象背后做了什么？</p>
<p>— 创建一个空对象</p>
<p>— 给对象设置 <code>__proto__</code>，值为构造函数对象的 prototype 属性值（即 <code>this.__proto__ = Fn.prototype</code>）</p>
<p>— 执行构造函数体（给对象添加属性/方法）</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery笔记</title>
    <url>/2021/12/29/jQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、jQuery-基础"><a href="#一、jQuery-基础" class="headerlink" title="一、jQuery 基础"></a>一、jQuery 基础</h1><p>jQuery 是一个 JS 函数库（write less, do more），封装了 BOM 和 DOM 的一些函数、对象、方法等，如 CRUD（增删改查）、Ajax，使用 jQuery 的网站超过 90%，jQuery 是中大型 WEB 项目开发首选</p>
<a id="more"></a>

<h2 id="1、jQuery-的用途"><a href="#1、jQuery-的用途" class="headerlink" title="1、jQuery 的用途"></a>1、jQuery 的用途</h2><p>HTML 元素选择（选择器）（方便快速查找 DOM 元素）</p>
<p>HTML 元素操作（如增删改）</p>
<p>CSS 操作</p>
<p>HTML 事件处理</p>
<p>JS 动画效果</p>
<p><strong>链式调用</strong>（如 a().b().c()）（通过在方法或函数（除了获取数据的方法）中最后返回 this（jQuery 对象），来实现可链式调用）</p>
<p><strong>读写合一</strong>（方法中不传参表示读，传参表示写），若 jQuery 对象中包含多个 dom 元素，则统一读时只读第一个，写时是对所有元素写</p>
<p><strong>隐式遍历</strong>（$(‘#box&gt;li’).click(function(){}) 会对 box 下所有 li 加监听）</p>
<p>浏览器兼容</p>
<p>易扩展插件</p>
<p>ajax 封装</p>
<p>……</p>
<h2 id="2、jQuery-的不同版本"><a href="#2、jQuery-的不同版本" class="headerlink" title="2、jQuery 的不同版本"></a>2、jQuery 的不同版本</h2><p>1.x：用的最多，因为兼容老版本 IE，文件更大</p>
<p>2.x：部分 IE8 及以下不支持，文件小，执行效率更高</p>
<p>3.x：完全不再支持 IE8 及以下版本，提供了一些新的 API，提供不包含 ajax/动画 API 的版本</p>
<p>两种 js 库库文件：.js 和 .min.js</p>
<p>.js 文件是开发版（测试版）</p>
<p>.min.js 文件是生产版（压缩版），去掉空格、换行，并把变量都转成单个字母的形式</p>
<h2 id="3、引入-jQuery"><a href="#3、引入-jQuery" class="headerlink" title="3、引入 jQuery"></a>3、引入 jQuery</h2><p>jQuery 库的大体结构如下</p>
<pre><code>(functon(window)&#123;
    var jQuery = function()&#123;
        return new jQuery.fn.init(xxx)
    &#125;
    window.$ = window.jQuery = jQuery
&#125;)(window)</code></pre>
<p>引入 jQuery 后相当于给 window 添加了两个属性 window.jQuery 和 window.$，两个的含义相同，表示的是一个函数，并且调用 jQuery 库返回的是一个对象</p>
<p>有两种引入 jQuery 的方式：服务器本地库引入、CDN 远程库引入</p>
<p>服务器本地库引入是把 jQuery 库文件保存在服务器中的文件夹下，使用 <code>&lt;script type=&quot;type/javascript&quot; src=&quot;./jquery-1.12.13.js&quot;&gt;&lt;/script&gt;</code> 引入 jQuery</p>
<p>CDN 远程库在项目上线时，一般使用比较靠谱的 CDN 资源库，减轻服务器负担，如免费的 CDN 资源库 <a href="www.bootcdn.cn">bootcdn</a> </p>
<h2 id="4、使用-jQuery"><a href="#4、使用-jQuery" class="headerlink" title="4、使用 jQuery"></a>4、使用 jQuery</h2><p>把 jQuery 函数 当作函数使用 <code>$(xxxx)</code>，把 jQuery 函数当作对象使用 <code>$.xxx()</code>，如 $.each，$.trim</p>
<p>jQuery 函数是 jQuery 库向外暴露的，直接可用，而 jQuery 对象是执行 jQuery 函数产生的</p>
<p>jQuery 对象（<code>$xxx</code>）包含所有匹配的 n 个 DOM 元素的伪数组对象，是执行 <code>$()</code> 返回的就是 jQuery 对象</p>
<h3 id="（1）jQuery-核心函数（-jQuery）"><a href="#（1）jQuery-核心函数（-jQuery）" class="headerlink" title="（1）jQuery 核心函数（$/jQuery）"></a>（1）jQuery 核心函数（$/jQuery）</h3><p>jQuery 库向外直接暴露的就是 jQuery 函数 $/jQuery，引入 jQuery 库后，直接使用即可</p>
<pre><code>jQuery === $   //true </code></pre>
<p><strong>参数类型：</strong></p>
<p>1）参数为函数：当 DOM 加载完成后，执行此回调函数</p>
<pre><code>$(function()&#123;&#125;)  //绑定文档加载完成的监听</code></pre>
<p>2）参数为选择器字符串：查找所有匹配的标签，并将它们封装成 jQuery 对象</p>
<pre><code>$(&#39;#btn&#39;).click(function()&#123;&#125;)  //绑定点击事件监听，在回调函数中的 this 依然指向发生事件的 dom 元素 &lt;button&gt;</code></pre>
<p>3）参数为 DOM 对象：将 DOM 对象封装成 jQuery 对象</p>
<pre><code>$(&#39;#btn&#39;).click(function()&#123;   //绑定点击事件监听，在回调函数中的 this 依然指向发生事件的 dom 元素 &lt;button&gt;
    alert($(this).html())  //参数为 DOM 对象，封装成 jQuery 对象后就可以调用 jQuery 的方法
&#125;)  </code></pre>
<p>4）参数为 html 标签字符串：创建标签对象并封装成 jQuery 对象</p>
<pre><code>$(&#39;&lt;input type=&quot;text&quot;&gt;&#39;).appendTo(&quot;div&quot;)  //把 &lt;input&gt; 插入 &lt;div&gt; 中</code></pre>
<h3 id="（2）jQuery-核心对象"><a href="#（2）jQuery-核心对象" class="headerlink" title="（2）jQuery 核心对象"></a>（2）jQuery 核心对象</h3><p>执行 jQuery 函数 <code>$()</code> 返回的对象为 jQuery （核心）对象，一般名称前会加 $，通过 <code>$obj.xxx()</code> 使用</p>
<p>如 <code>var $btn = $(&#39;#btn&#39;)</code></p>
<p>jQuery 对象内部包含的是 DOM 元素对象（一个或多个）的伪数组对象（能获取 length 且可用下标访问的对象）</p>
<p>jQuery 对象拥有很多有用的属性和方法，让程序员能方便地操作 dom</p>
<h5 id="jQuery-对象的属性和方法"><a href="#jQuery-对象的属性和方法" class="headerlink" title="jQuery 对象的属性和方法"></a>jQuery 对象的属性和方法</h5><p>1）基本行为</p>
<p><code>length</code> 或 <code>size()</code>，返回 jQuery 对象内包含的 dom 元素的个数</p>
<p><code>[index]</code> 或 <code>get(index)</code>，返回的是对应位置的 dom 元素</p>
<p><code>each()</code>，遍历 jQuery 对象内包含的 dom 元素，如下</p>
<p><code>$.each(数组,function(index,item)&#123;&#125;)</code> 或 <code>数组.each(function(index,item)&#123;&#125;)</code> 隐式遍历数组，回调函数中第一个参数为数组中元素下标，第二个参数为遍历的数组中的当前元素</p>
<p><code>index()</code>，得到在所在兄弟元素中的下标</p>
<pre><code>var $buttons = $(&#39;button&#39;)
$buttons.each(function(index,domEle)&#123;
    console.log(index,domEle.innerHTML)
    console.log(this)  //this 表示数组中当前 dom 元素对象 domEle
&#125;)

$(&#39;#btn3&#39;).index()  //第三个按钮是所有按钮中的第几个</code></pre>
<p>2）属性</p>
<p>操作内部标签的属性或值</p>
<p>3）CSS</p>
<p>操作标签的样式</p>
<p>4）文档</p>
<p>对标签进行增删改操作</p>
<p>5）筛选</p>
<p>根据指定的规则过滤内部的标签</p>
<p>6）事件</p>
<p>处理事件监听相关</p>
<p>7）效果</p>
<p>实现一些动画效果</p>
<h1 id="二、jQuery-函数"><a href="#二、jQuery-函数" class="headerlink" title="二、jQuery 函数"></a>二、jQuery 函数</h1><h2 id="1、选择器"><a href="#1、选择器" class="headerlink" title="1、选择器"></a>1、选择器</h2><p>选择器本身只是一个有特定语法规则的字符串，没有实质用处</p>
<p>它的基本语法规则使用的就是 CSS 的选择器语法，并对其进行了扩展</p>
<p>只有调用 <code>$()</code>，并将选择器作为参数传入才能起作用</p>
<p><code>$(选择器)</code> 的作用：根据选择器规则在整个文档中查找所有匹配的标签的数组，并封装成 jQuery 对象返回</p>
<p>选择器分类：基本选择器、层次选择器、过滤选择器、表单选择器</p>
<h3 id="（1）基本选择器"><a href="#（1）基本选择器" class="headerlink" title="（1）基本选择器"></a>（1）基本选择器</h3><p>基本选择器是最常用的选择器</p>
<p><code>#id</code>、<code>element</code>、<code>.类</code>、<code>*</code>、<code>选择器1,选择器2,选择器n</code>、<code>选择器1选择器2选择器n</code></p>
<pre><code>$(&#39;#div1&#39;).css(&#39;background&#39;,&#39;red&#39;)
或
$(&#39;#div1&#39;).css(&#123;&#39;background&#39;:&#39;red&#39;&#125;)</code></pre>
<h3 id="（2）层次选择器"><a href="#（2）层次选择器" class="headerlink" title="（2）层次选择器"></a>（2）层次选择器</h3><p>层次选择器用于查找子元素、后代元素、兄弟元素</p>
<p><code>祖先元素 后代元素</code>，<code>父元素 &gt; 子元素</code>，<code>兄元素 + 弟元素</code>（兄元素后紧跟着的某类型弟元素），<code>兄元素 ~ 弟元素们</code>（兄元素后所有的某类型弟元素）</p>
<h3 id="（3）过滤选择器"><a href="#（3）过滤选择器" class="headerlink" title="（3）过滤选择器"></a>（3）过滤选择器</h3><p>过滤选择器是在原有选择器匹配的元素中进一步进行过滤，既不是找子元素也不是找兄弟元素</p>
<p>多个过滤选择器不是同时执行，而是依次执行</p>
<p><code>:first</code> 第一个</p>
<p><code>:last</code>  最后一个</p>
<p><code>:eq(index)</code> 根据下标找出某个</p>
<p><code>:not(selector)</code>  排除某些</p>
<p><code>:lt</code> 下标小于</p>
<p><code>:gt</code> 下标大于</p>
<p><code>:odd</code> 奇数元素</p>
<p><code>:even</code>  偶数元素</p>
<p><code>:hidden</code>  隐藏</p>
<p><code>:visible</code>  显示</p>
<p><code>[属性名]</code>  某个属性</p>
<p><code>[属性名=属性值]</code>  某属性为某值的元素</p>
<pre><code>$(&#39;div:not(.box)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择所有 class 属性不为 box 的div（这里包含没有 class 属性的元素）
$(&#39;li:lt(3):gt(0)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择第二个和第三个 li 元素
$(&#39;li:gt(0):lt(3)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //这里选出来是第二三四个 li 元素，而不是第二个和第三个 li 元素，因为先执行 :gt(0)，在选出的元素里再执行 :lt(3)
$(&#39;li:contains(&#39;xxx&#39;)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择内容为 xxx 的 li 元素
$(&#39;li:hidden&#39;).length  //选择隐藏的 li 个数
$(&#39;li:hidden&#39;).length[0]  //选择第一个隐藏的 li
$(&#39;li[title]&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择有 title 属性的 li
$(&#39;li[title=xxx]&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择有title 属性值为 xxx 的 li</code></pre>
<h3 id="（4）表单选择器"><a href="#（4）表单选择器" class="headerlink" title="（4）表单选择器"></a>（4）表单选择器</h3><p><code>:input</code> 所有表单项，包括 <code>&lt;select&gt;</code> 等</p>
<p><code>:text</code>、<code>:checkbox</code>、<code>:radio</code>、<code>:checked</code>（选中的项）</p>
<pre><code>$(&#39;:text:disabled&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择不可用的文本输入框
$(&#39;:checkbox:checked&#39;).length  //多选框选择的个数
$(&#39;:submit&#39;)  //提交按钮
$(&#39;select&gt;option:selected&#39;).html()  //所选下拉框的文本内容
$(&#39;select&#39;).val()  //所选下拉框 option 的 value 属性值</code></pre>
<p>表单</p>
<p>表单对象属性</p>
<h2 id="2、-工具（把-jQuery-函数当对象使用）"><a href="#2、-工具（把-jQuery-函数当对象使用）" class="headerlink" title="2、$工具（把 jQuery 函数当对象使用）"></a>2、$工具（把 jQuery 函数当对象使用）</h2><p><code>$.each()</code> 遍历数组或对象中的数据</p>
<pre><code>$.each(数组,function(index,item)&#123;&#125;) 隐式遍历数组，回调函数中第一个参数为数组中元素下标，第二个参数为遍历的数组中的当前元素

$.each(对象,function(key,value)&#123;&#125;)  //遍历对象</code></pre>
<p><code>$.trim()</code> 去除字符串两边的空格</p>
<pre><code>$.trim(字符串) 去除两端的空格，和字符串本身的方法 `字符串.trim()` 效果相同</code></pre>
<p><code>$.type(obj)</code> 得到数据的类型</p>
<pre><code>$.type($)  //返回 &#39;function&#39;</code></pre>
<p><code>$.isArray(obj)</code> 判断是否是数组</p>
<pre><code>$.isArray($(&#39;body&#39;))  //false</code></pre>
<p><code>$.isFunction(obj)</code> 判断是否是函数</p>
<pre><code>$.isFunction($)  //true</code></pre>
<p><code>$.parseJSON(json)</code> 解析 json 字符串转换为 js 对象/数组</p>
<pre><code>var json = &#39;&#123;&quot;nsme&quot;:&quot;xxx&quot;,age:12&#125;&#39;  //其中 json 对象就是 &#123;&#125;
$.parseJSON(json)  //json 对象转为 js 对象，返回 js 对象
var json = &#39;[&#123;&quot;nsme&quot;:&quot;xxx&quot;,age:12&#125;,&#123;&quot;nsme&quot;:&quot;yyy&quot;,age:10&#125;]&#39;  //其中 json 数组就是 []
$.parseJSON(json)  //json 对象转为 js 数组，返回 js 数组</code></pre>
<h2 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h2><p>操作标签的属性、标签体文本</p>
<p><code>attr(&#39;属性名&#39;)</code> 或 <code>attr(&#39;属性名&#39;,&#39;属性值&#39;)</code>：读写非布尔值的标签属性</p>
<p><code>prop(&#39;属性名&#39;)</code> 或 <code>prop(&#39;属性名&#39;,属性值)</code> 读写布尔值的标签属性</p>
<p><code>removeAttr(&#39;属性名&#39;)</code> 或 <code>removeProp(&#39;属性名&#39;)</code> 删除属性</p>
<p><code>addClass(&#39;class值&#39;)</code> 添加 class 属性值</p>
<p><code>removeClass(&#39;class值&#39;)</code>  移除指定 class 值</p>
<p><code>html()</code> 或 <code>html(&#39;xxx&#39;)</code> 读写标签体文本</p>
<p><code>val()</code> 或 <code>val(&#39;xxx&#39;)</code>：读写标签的 value</p>
<p><code>$(&#39;:text&#39;).val()</code> 得到输入框 <input> 的文本</p>
<p><code>$(&#39;:text&#39;).val(&#39;xxx&#39;)</code>  设置输入框 <input> 的文本</p>
<pre><code>$(&#39;div:first&#39;).attr(&#39;title&#39;)
$(&#39;div&#39;).attr(&#39;name&#39;,&#39;xxx&#39;)
$(&#39;div&#39;).addClass(&#39;class值&#39;)
$(&#39;div&#39;).removeClass(&#39;xxx&#39;)  //移除所有 div 的 class 为 xxx 的 class
$(&#39;li:first&#39;).html(&#39;&lt;h1&gt;xxx&lt;/h1&gt;&#39;)  //设置第一个 li 的标签体为 &lt;h1xxx&lt;/h1&gt;
$(&#39;div&#39;).removeClass(&#39;xxx&#39;)</code></pre>
<h2 id="4、ajax"><a href="#4、ajax" class="headerlink" title="4、ajax"></a>4、ajax</h2><h1 id="三、jQuery-对象"><a href="#三、jQuery-对象" class="headerlink" title="三、jQuery 对象"></a>三、jQuery 对象</h1><h2 id="1、CSS"><a href="#1、CSS" class="headerlink" title="1、CSS"></a>1、CSS</h2><h3 id="设置-style-样式"><a href="#设置-style-样式" class="headerlink" title="设置 style 样式"></a>设置 style 样式</h3><p><code>jQuery对象.css(&#39;属性&#39;)</code> 或 <code>jQuery对象.css(&#39;属性&#39;,&#39;值&#39;)</code> 或 <code>jQuery对象.css(&#123;多个样式对&#125;)</code>：读写样式，返回的仍然是当前的 jQuery 对象，方法最后返回的是 this</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>offset()</code>：获取相对于页面左上角的位置，返回的对象包含 top 和 left 两个整数，该方法只对可见元素有效，（读）</p>
<p><code>offset(&#123;top:xx,left:xx&#125;)</code>：设置相对于页面左上角的位置（写）</p>
<p><code>position()</code>：获取相对于父元素左上角的位置，返回的对象包含 top 和 left 两个整数，（只能读）</p>
<p><code>scrollTop()</code>：读取/设置滚动条的 Y 坐标</p>
<p><code>$(document.body).scrollTop()+$(document.documentElement).scrollTop()</code>：读取页面滚动条的 Y 坐标（兼容 chrome 和 IE）</p>
<p><code>$(&#39;html,body&#39;).scrollTop(60)</code>：滚动到指定位置（兼容 chrome 和 IE）</p>
<p>滚动条回到顶部的例子</p>
<pre><code>//瞬间回到顶部
$(&#39;#btn&#39;).click(function()&#123;
    $(html,body).scrollTop(0)
&#125;)

//平滑地回到顶部
$(&#39;#btn&#39;).click = function()&#123;
    var $page = $(&#39;html&#39;,&#39;body&#39;)  //这里是用于后面设置，不能用于读取，因为有两个值
    var distance = $(&#39;html&#39;).scrollTop() + $(&#39;body&#39;).scrollTop()  //总距离
    var time = 500  //总时间
    var intervalTime = 50  //间隔时间
    var itemDistance = distance/(time/intervalTime)  //单位时间运动距离
    var intervalId = setInterval(function()&#123;
        distance -= itemDistance
        if(distance&lt;=0)&#123;
            distance = 0
            clearInterval(intervalId)
        &#125;
        $page.scrollTop(distance)
    &#125;,intervalTime)
&#125;</code></pre>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>（1）内容尺寸</p>
<p>height()：height</p>
<p>width()：width</p>
<p>（2）内部尺寸</p>
<p>innerHeight()：height+padding</p>
<p>innerWidth()：width+padding</p>
<p>（3）外部尺寸</p>
<p>outerHeight(false/true)：height+padding+border，若是 true 加上 margin，默认是 false</p>
<p>outerWidth(false/true)：width+padding+border，若是 true 加上 margin，默认是 false</p>
<h2 id="2、筛选————过滤和查找"><a href="#2、筛选————过滤和查找" class="headerlink" title="2、筛选————过滤和查找"></a>2、筛选————过滤和查找</h2><p>对包含多个 dom 元素的 jQuery 对象进行过滤是找出对象中的一个或多个元素，并封装成新的 jQuery 对象返回；</p>
<p>而查找是指查找对象内部某元素的父母、子孙后代或兄弟元素，并封装成新的 jQuery 对象返回</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p><code>first()</code>：jQuery 对象中的第一个 dom 元素组成的 jQuery 对象，返回的是 jQuery 对象（<code>last()</code>、<code>eq(index)</code>同理）</p>
<p>注意 <code>jQuery对象.first()</code> 返回的是 jQuery 对象，而 <code>jQuery对象[0]</code> 返回的是对象中包含的的第一个 dom 元素</p>
<p><code>filter(&#39;[属性名]=xxx&#39;)</code> 过滤出属性为某值的元素，（对当前元素提要求）</p>
<p><code>filter(&#39;[属性名]!=xxx&#39;)</code> 或 <code>not(&#39;[属性名]=xxx&#39;)</code> 过滤出没有某属性以及属性不为某值的元素，（对当前元素提要求并取反）</p>
<p><code>filter(&#39;[属性名][属性名]!=xxx&#39;)</code> 过滤出有某属性并且属性值不为某值的元素</p>
<p><code>has(&#39;标签名&#39;)</code> 过滤出元素中有子标签的元素，（对子元素提要求）</p>
<pre><code>var $lis = $(&#39;ul&gt;li&#39;)
$lis.first().css(&#39;background&#39;,&#39;red&#39;)  //相当于 $lis[0].style.background = &#39;red&#39;
$lis.filter(&#39;[title=hello]&#39;)  //title 属性为 hello 的 li
$lis.not(&#39;[title=hello]&#39;)  //title 属性不为 hello 的 li
$lis.filter(&#39;[title][title!=hello]&#39;) //有 title 属性且title 属性不为 hello，相当于 $lis.filter(&#39;[title]).filter(&#39;[title!=hello])&#39;
$lis.has(&#39;span&#39;) //有 span 子标签的 li</code></pre>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>children(&#39;条件&#39;)</code> 查找子元素（直接子元素，而非后代） </p>
<p><code>find(&#39;条件&#39;)</code> 查找后代元素</p>
<p><code>parent()</code> 查找父元素</p>
<p><code>preAll(&#39;条件&#39;)</code> 前面的所有的符合条件的兄弟元素</p>
<p><code>nextAll(&#39;条件&#39;)</code> 后面所有的符合条件的兄弟元素</p>
<p><code>siblings(&#39;条件&#39;)</code> 前后所有的兄弟元素</p>
<pre><code>var $ul = $(&#39;ul&#39;)
$ul.children(&#39;span:eq(1)&#39;)  //ul 下的第 2 个 span 子标签
$ul.find(&#39;span:eq(1)&#39;)  //ul 下的第 2 个 span 后代标签
$ul.parent()  // ul 的父元素
var $li = $(&#39;#aa&#39;)
$li.preAll(&#39;li&#39;)  //id 为 aa 的 li 标签前面的所有 li
$li.siblings(&#39;li&#39;)  //id 为 aa 的 li 标签的所有兄弟 li</code></pre>
<h2 id="3、文档处理（CUD-增删改）"><a href="#3、文档处理（CUD-增删改）" class="headerlink" title="3、文档处理（CUD 增删改）"></a>3、文档处理（CUD 增删改）</h2><h3 id="（1）添加元素"><a href="#（1）添加元素" class="headerlink" title="（1）添加元素"></a>（1）添加元素</h3><h4 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h4><p><code>append(content)</code> 向当前匹配的所有元素内部的最后插入指定内容</p>
<p><code>$(content).appendTo($父)</code> 向当前匹配的所有元素内部的最后插入指定内容，和上面效果相同</p>
<p><code>prepend(content)</code> 向当前匹配的所有元素内部的最前面插入指定内容</p>
<p><code>$(content).prependTo($父)</code> 向当前匹配的所有元素内部的最前面插入指定内容，和上面效果相同</p>
<h4 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h4><p><code>before(content)</code> 将指定内容插入到当前所有匹配元素的前面</p>
<p><code>after(content)</code> 将指定内容插入到当前所有匹配元素的后面替换节点</p>
<h3 id="（2）删除元素"><a href="#（2）删除元素" class="headerlink" title="（2）删除元素"></a>（2）删除元素</h3><p><code>empty()</code> 删除所有匹配元素的子元素，父元素本身还在，等价于 <code>$(&#39;父 &gt; *&#39;).remove()</code></p>
<p><code>remove()</code> 删除所有匹配的元素（包括父元素本身和其下子元素）</p>
<pre><code>$(&#39;#ul2&#39;).empty()
相当于 $(&#39;#ul2&gt;*&#39;).remove()</code></pre>
<h3 id="（3）替换元素"><a href="#（3）替换元素" class="headerlink" title="（3）替换元素"></a>（3）替换元素</h3><p><code>replaceWith(content)</code> 用指定内容替换所有匹配的标签删除节点</p>
<p><code>replaceAll(选择器)</code> 用指定元素替换所有匹配的标签删除节点</p>
<pre><code>var $ul1 = $(&#39;#ul1&#39;)
$ul1.append(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //相当于 $(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;).appenTo($ul1)
$ul1.prepend(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //相当于 $(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;).prepenTo($ul1)
$ul1.children(&#39;li[title=hello]&#39;).before(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //在 id 为 ul1 的 ul 下的 li（title 为 hello）的前面添加 span
$(&#39;#ul2&gt;li[title=hello]&#39;).replaceWith(&#39;&lt;p&gt;xxx&lt;/p&gt;&#39;)//在 id 为 ul2 的 ul 下的 li（title 为 hello）全部替换为 p</code></pre>
<h2 id="4、事件处理"><a href="#4、事件处理" class="headerlink" title="4、事件处理"></a>4、事件处理</h2><h3 id="（1）绑定事件"><a href="#（1）绑定事件" class="headerlink" title="（1）绑定事件"></a>（1）绑定事件</h3><p>方式一：<code>jQuery对象.事件名(function()&#123;&#125;)</code>，这种方式好写但并不通用，有些事件没有这种绑定方法</p>
<p>方式二：<code>jQuery对象.on(&#39;事件名1 事件名n&#39;,function()&#123;&#125;)</code></p>
<p>优缺点：方式一编码方便，但只能加一个监听，且有的事件监听不支持</p>
<p>方式二编码不方便，可以添加多个监听，且更通用</p>
<p>常用：click、mouseenter/mouseleave、mouseover/mouseout、focus/blur</p>
<pre><code>$(&#39;#image&#39;).on(&#39;load&#39;,function()&#123;&#125;) //监听图片加载完成，这时只能用 on</code></pre>
<h4 id="绑定鼠标点击事件"><a href="#绑定鼠标点击事件" class="headerlink" title="绑定鼠标点击事件"></a>绑定鼠标点击事件</h4><p>方式一：<code>jQuery对象.click(function()&#123;&#125;)</code></p>
<p>方式二：<code>jQuery对象.on(&#39;click&#39;,function()&#123;&#125;)</code></p>
<h4 id="绑定鼠标移入移出事件"><a href="#绑定鼠标移入移出事件" class="headerlink" title="绑定鼠标移入移出事件"></a>绑定鼠标移入移出事件</h4><p>方式一：<code>jQuery对象.mouseenter(function()&#123;&#125;)</code> 和 <code>jQuery对象.mouseleave(function()&#123;&#125;)</code></p>
<p>方式二：<code>jQuery对象.on(&#39;mouseenter&#39;,function()&#123;&#125;)</code> 和 <code>jQuery对象.on(&#39;mouseleave&#39;,function()&#123;&#125;)</code></p>
<p>方式三：<code>jQuery对象.hover(function()&#123;console.log(&#39;鼠标移入，绑定在mouseenter&#39;)&#125;,function()&#123;console.log(&#39;鼠标移出，绑定在mouseleave&#39;)&#125;)</code></p>
<h3 id="（2）解除事件绑定"><a href="#（2）解除事件绑定" class="headerlink" title="（2）解除事件绑定"></a>（2）解除事件绑定</h3><p><code>jQuery对象.off(&#39;事件名&#39;)</code></p>
<h3 id="（3）事件坐标"><a href="#（3）事件坐标" class="headerlink" title="（3）事件坐标"></a>（3）事件坐标</h3><p>event.clientX、event.clientY 相对于视口的左上角</p>
<p>event.pageX、event.pageY 相对于页面的左上角</p>
<p>event.offsetX、event.offsetY 相对于事件元素左上角</p>
<pre><code>$(#btn).click(function(event)&#123;
    console.log(event.clientX,event.clientY) //原点为窗口左上角
    console.log(event.pageX,event.pageY) //原点为页面左上角
    console.log(event.offsetX,event.offsetY) //原点为事件元素左上角
&#125;)</code></pre>
<h3 id="（4）事件相关处理"><a href="#（4）事件相关处理" class="headerlink" title="（4）事件相关处理"></a>（4）事件相关处理</h3><h4 id="停止事件冒泡"><a href="#停止事件冒泡" class="headerlink" title="停止事件冒泡"></a>停止事件冒泡</h4><p><code>event.stopPropagation</code> 点击子元素，父元素点击监听不响应</p>
<h4 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h4><p><code>event.preventDefault()</code> 阻止事件默认行为</p>
<pre><code>$(&#39;#test&#39;).click(function(event)&#123;
    if(Date.now()%2===0)&#123;
        event.preventDefault()
    &#125;
&#125;)</code></pre>
<h4 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h4><p>mouseover 在移入子元素时也会重新触发一次，mouseout 同理</p>
<p>mouseenter 只在移入当前元素时才触发，mouseleave 同理，hover() 使用的就是 mouseenter() 和 mouseleave()</p>
<p>若不存在子元素则 mouseover 和 mouseenter 没有区别</p>
<h4 id="on-‘click’-fun-和-click-fun-的区别"><a href="#on-‘click’-fun-和-click-fun-的区别" class="headerlink" title="on(‘click’,fun) 和 click(fun) 的区别"></a>on(‘click’,fun) 和 click(fun) 的区别</h4><p>on 方法通用，但编码麻烦</p>
<p>click 方法编码简单，但有的事件没有对应的方法</p>
<h3 id="（5）事件委托-事件代理-事件委派"><a href="#（5）事件委托-事件代理-事件委派" class="headerlink" title="（5）事件委托/事件代理/事件委派"></a>（5）事件委托/事件代理/事件委派</h3><p>绑定事件监听的问题：新加的元素没有监听</p>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>— 将多个子元素的事件监听委托给父辈元素处理</p>
<p>— 事件监听是加在父辈元素上，但事件发生在子元素上</p>
<p>— 当操作任何一个子元素时，事件会冒泡到父辈元素</p>
<p>— 父元素不会直接处理事件，而是根据 event.target 得到发生事件的子元素，通过这个子元素来调用事件回调函数（回调函数中的 this 指发生事件的子元素）</p>
<h4 id="使用事件委托的好处"><a href="#使用事件委托的好处" class="headerlink" title="使用事件委托的好处"></a>使用事件委托的好处</h4><p>添加新的子元素，自动有事件响应处理</p>
<p>减少事件监听的数量（如从 n 个减为 1 个）</p>
<h4 id="jQuery-的事件委托-API"><a href="#jQuery-的事件委托-API" class="headerlink" title="jQuery 的事件委托 API"></a>jQuery 的事件委托 API</h4><p>设置事件委托：$(父元素选择器).delegate(子元素选择器,事件名,回调函数)</p>
<p>移除事件委托：$(父元素选择器).undelegate(事件名)，若不加事件名参数表示移除对应的所有事件</p>
<h1 id="四、动画效果"><a href="#四、动画效果" class="headerlink" title="四、动画效果"></a>四、动画效果</h1><h2 id="1、淡入淡出"><a href="#1、淡入淡出" class="headerlink" title="1、淡入淡出"></a>1、淡入淡出</h2><p>淡入淡出通过不断改变元素的透明度来实现</p>
<p><code>fadeIn()</code> 带动画的显示</p>
<p><code>fadeOut()</code> 带动画隐藏</p>
<p><code>fadeToggle()</code> 带动画切换显示/隐藏</p>
<p>可选参数有速度、切换效果、回调函数</p>
<p>— 速度：slow、normal、fast、毫秒数</p>
<p>— 切换效果：swing（默认）、linear</p>
<p>— 回调函数：在动画完成时执行</p>
<h2 id="2、滑动"><a href="#2、滑动" class="headerlink" title="2、滑动"></a>2、滑动</h2><p>滑动动画通过不断改变元素的高度实现</p>
<p><code>slideDown()</code> 带动画的展开</p>
<p><code>slideUp()</code> 带动画的收缩</p>
<p><code>slideToggle()</code> 带动画的切换展开/收缩</p>
<p>可选参数有速度、切换效果、回调函数</p>
<h2 id="3、显示与隐藏"><a href="#3、显示与隐藏" class="headerlink" title="3、显示与隐藏"></a>3、显示与隐藏</h2><p>显示与隐藏通过不断改变宽度、高度、透明度来实现，默认是没有动画</p>
<p><code>show()</code> （不）带动画的显示</p>
<p><code>hide()</code> （不）带动画的隐藏</p>
<p><code>toggle()</code> （不）带动画的切换显示/隐藏</p>
<p>可选参数有速度、切换效果、回调函数</p>
<h2 id="4、自定义动画"><a href="#4、自定义动画" class="headerlink" title="4、自定义动画"></a>4、自定义动画</h2><p><code>jQuery对象.animate(&#123;样式设置&#125;,毫秒数)</code>，其中样式可不写单位，若写单位需要将数值和单位加引号</p>
<pre><code>$(&#39;#div1&#39;)  //宽度先变为200px，高度再变为200px
    .animate(&#123;
        width:200
    &#125;,1000)
    .animate(&#123;
        height:200
    &#125;,1000)
$(&#39;#div1&#39;).animate(&#123;  //移动距离为（100，50）
    left:&#39;+=100&#39;,
    top:&#39;+=50&#39;
&#125;,1000)
$(&#39;#div1&#39;).animate(&#123;  //移动距离为（-100，-20）
    left:&#39;-=100&#39;,
    top:&#39;-=50&#39;
&#125;,1000)</code></pre>
<h2 id="5、停止动画"><a href="#5、停止动画" class="headerlink" title="5、停止动画"></a>5、停止动画</h2><p><code>jQuery对象.stop()</code> 停止动画</p>
<h1 id="五、多库共存"><a href="#五、多库共存" class="headerlink" title="五、多库共存"></a>五、多库共存</h1><p>问题：如果有两个库都有 $，就存在冲突</p>
<p>解决：jQuery 库可以通过 <code>jQuery.noConflict()</code> 释放 $ 的使用权，让另一个库可以正常使用，此时 jQuery 库只能使用 jQuery 了</p>
<h1 id="六、onload-与-ready"><a href="#六、onload-与-ready" class="headerlink" title="六、onload 与 ready"></a>六、onload 与 ready</h1><p><code>$(function($)&#123;&#125;)</code></p>
<p><code>$(document).ready(function()&#123;&#125;)</code></p>
<p><code>window.onload = function()&#123;&#125;</code></p>
<p>上面三种方式基本等价，其中回调函数会在 DOM 加载完成时运行</p>
<h2 id="window-load-与-document-ready-区别"><a href="#window-load-与-document-ready-区别" class="headerlink" title="window.load 与 $(document).ready()区别"></a>window.load 与 $(document).ready()区别</h2><p>window.load 中包括页面的图片加载完后才会回调（晚），且只能有一个监听回调，后面加的监听回调会覆盖前面的</p>
<p>$(document).ready() 等同于 $(function(){})，页面加载完就回调（早），且可以有多个监听回调</p>
<pre><code>window.onload = function()&#123;  //不执行，被下面的 window.onload 覆盖
    console.log(&#39;onload1&#39;)
&#125;
window.onload = function()&#123;  //执行
    console.log(&#39;onload2&#39;)
&#125;
$(function()&#123;                //执行
    console.log(&#39;ready1&#39;)
&#125;)
$(function()&#123;                //也执行
    console.log(&#39;ready2&#39;)
&#125;)</code></pre>
<h1 id="七、jQuery插件"><a href="#七、jQuery插件" class="headerlink" title="七、jQuery插件"></a>七、jQuery插件</h1><h2 id="1、扩展插件"><a href="#1、扩展插件" class="headerlink" title="1、扩展插件"></a>1、扩展插件</h2><p><code>jQuery.extend</code> 是扩展 jQuery 对象本身（即jQuery 函数对象）的工具方法（扩展 $ 的方法），调用时 <code>$.新方法()</code></p>
<p><code>jQuery.fn.extend</code> 是扩展 jQuery 对象（jQuery 元素集）的功能方法（扩展 $() 返回值的方法），调用时 <code>$(xxx).新方法()</code></p>
<p>注意：自定义的插件文件要在 jQuery 后引入</p>
<h3 id="（1）扩展-jQuery-的工具方法"><a href="#（1）扩展-jQuery-的工具方法" class="headerlink" title="（1）扩展 jQuery 的工具方法"></a>（1）扩展 jQuery 的工具方法</h3><p><code>$.extend(object)</code>，其中 this 指 $，使用 <code>$.xxx()</code> 调用</p>
<h3 id="（2）扩展-jQuery-对象的方法"><a href="#（2）扩展-jQuery-对象的方法" class="headerlink" title="（2）扩展 jQuery 对象的方法"></a>（2）扩展 jQuery 对象的方法</h3><p><code>$.fn.extend(object)</code>，其中 this 指 jQuery 对象，使用 <code>$obj.xxx()</code> 调用</p>
<pre><code>编写插件文件 myjQuery-plugin.js
(function()&#123;
    $.extend(&#123;          //给 $ 添加工具方法
        min:function(a,b)&#123;
            return a &lt; b ? a : b
        &#125;,
        max:function(a,b)&#123;
            return a &gt; b ? a : b
        &#125;,
        leftTrim:function(str)&#123;
            return str.replace(/^\s+/,&#39;&#39;)
        &#125;,
        rightTrim:function(str)&#123;
            return str.replace(/\s+$/,&#39;&#39;)
        &#125;
    &#125;)
    $.fn.extend(&#123;      //给 jQuery 对象添加功能方法
        checkAll:function()&#123;
            this.prop(&#39;checked&#39;,true) //this 是 jQuery 对象
        &#125;,
        unCheckAll:function()&#123;
            this.prop(&#39;checked&#39;,false)
        &#125;,
        reverseCheck:function()&#123;
            this.each(function()&#123; //this 是 jQuery 对象
                this.checked = !this.checked   //this 是 dom 元素
            &#125;)
        &#125;,
    &#125;)
&#125;)()
在其他 js 文件中使用插件
&lt;script src=&quot;./jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  //先引入 jQuery
&lt;script src=&quot;./myjQuery-plugin.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  //引入自定义的插件文件
&lt;script type=&quot;text/javascript&quot;&gt;
    console.log($.min(1,2),$.max(2,1))
&lt;/script&gt;</code></pre>
<h2 id="2、jQuery-插件"><a href="#2、jQuery-插件" class="headerlink" title="2、jQuery 插件"></a>2、jQuery 插件</h2><p>jQuery 插件是基于 jQuery 编写的扩展库，在<a href="http://plugins.jquery.com/">官网</a>可查看相关 jQuery 插件</p>
<p>常用的有 jquery-validation（表单验证插件）、jquery UI、laydate（日期控件，该控件其实不属于 jQuery 插件）</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><h4 id="jquery-validation"><a href="#jquery-validation" class="headerlink" title="jquery-validation"></a>jquery-validation</h4><p>先在<a href="http://plugins.jquery.com/">官网</a>下载相应插件，并把有用文件拷贝在项目文件夹下，然后利用 <code>&lt;script&gt;</code> 引入 jQuery 和 插件库</p>
<pre><code>&lt;form id=&quot;myForm&quot; action=&quot;xxx&quot;&gt;
    &lt;p&gt;用户名（必须，最小6位）：&lt;input name=&quot;username&quot; type=&quot;text&quot; required minlength=&quot;6&quot;&gt;&lt;/p&gt;
    &lt;p&gt;密码（必须，6-8位）：&lt;input id=&quot;password&quot; name=&quot;password1&quot; type=&quot;password&quot; required minlength=&quot;6&quot; maxlength=&quot;8&quot;&gt;&lt;/p&gt;
    &lt;p&gt;确认密码：&lt;input name=&quot;password2&quot; type=&quot;password&quot; equalTo=&quot;#password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.validate.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //声明式验证：程序员只需声明各种验证规则，也可自定义验证错误信息
    $(&#39;#myForm&#39;).validate(&#123;  //对此表单开启验证
        messages:&#123;  //自定义错误提示（可选）
            username:&#123;  //使用表单项的 name 值
                required:&#39;用户名是必须的&#39;,
                minlength:&#39;用户名至少6位&#39;
            &#125;,
            password1:&#123;  //使用表单项的 name 值
                required:&#39;密码是必须的&#39;,
                minlength:&#39;密码至少6位&#39;,
                maxlength:&#39;密码最多6位&#39;
            &#125;,
            password2:&#123;
                equalTo:&#39;必须与密码相同&#39;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<h4 id="jquery-UI"><a href="#jquery-UI" class="headerlink" title="jquery UI"></a>jquery UI</h4><p>在<a href="http://jqueryui.com/">官网</a>下载插件，并把 jquery.js、jquery-ui.js、jquery-ui.css 三个文件拷贝至项目文件夹</p>
<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;jquery-ui.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;手风琴Accordion效果&lt;/h2&gt;  &lt;!--以下结构是从插件的index.html中拷贝来的--&gt;
    &lt;div id=&quot;accordion&quot;&gt;
        &lt;h3&gt;First&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
        &lt;h3&gt;Second&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
        &lt;h3&gt;Third&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-ui.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(&#39;#accordion&#39;).accordion()  //开启样式效果
&lt;/script&gt;</code></pre>
<h4 id="laydate"><a href="#laydate" class="headerlink" title="laydate"></a>laydate</h4><p>在<a href="http://www.layui.com/laydate/">官网</a>下载插件，把 need 文件夹、skins 文件夹、laydate.js 文件拷贝至项目文件夹中并放在同一目录下</p>
<pre><code>&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;laydate.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--方式一--&gt;
    &lt;input placeholder=&quot;请输入日期&quot; class=&quot;laydate-icon&quot; onclick=&quot;&quot;laydate()&gt;
    &lt;!--方式二--&gt;
    &lt;input class=&quot;laydate-icon&quot; id=&quot;demo&quot; value=&quot;xxx&quot;&gt;   
    &lt;script&gt;
        ;!function()&#123;
            laydate(&#123;
                elem:&#39;#demo&#39;
            &#125;)
        &#125;()
    &lt;/script&gt;
    &lt;!--方式三--&gt;
    &lt;input class=&quot;laydate-icon&quot; id=&quot;test&quot;&gt;
    &lt;script&gt;
        laydate(&#123;
            elem:&#39;#test&#39;,
            format:&#39;YYYY/MM&#39;,  //分隔符可以任意定义，该例子只显示年月
            festival:true,   //显示节日
            choose:function(datas)&#123;  //选择完日期的回调
                alert(datas);
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h1 id="八、jQuery-文档结构图"><a href="#八、jQuery-文档结构图" class="headerlink" title="八、jQuery 文档结构图"></a>八、jQuery 文档结构图</h1><p><img src="/2021/12/29/jQuery%E7%AC%94%E8%AE%B0/jQuery%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="jQuery文档结构图"></p>
<h1 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h1><p>1、伪数组</p>
<p>伪数组是 Object 对象，有 length 属性和数值下标属性，但不是数值（即 伪数组 instanceof Array 结果为 false），没有数组特别的方法（如 forEach()、push()、pop()、splice()等）</p>
<p>自定义一个伪数组</p>
<pre><code>var w = &#123;&#125;
w.length = 0
w[0] = &#39;xxx&#39;
w.length = 1
w[1] = 123
w.length = 2
for(var i=0;i&lt;w.length;i++)&#123;  //可循环遍历元素
    var obj = w[i]
    console.log(i,obj)
&#125;
console.log(w.forEach)  //会返回 undefined</code></pre>
<p>2、轮播图</p>
<p>要实现循环切换，需在最后一张图片（5.jpg）后添加一张第一张图片（1.jpg），在第一张图片（1.jpg）前面添加最后一张图片（5.jpg）</p>
<p>若到达最后一张图片（5.jpg），则跳转到最左边第 2 张图片（1.jpg），若到达最左边的图片（5.jpg），则跳转到最右边的第 2 张图片（5.jpg）</p>
<p>还需注意快速点击时的bug（即正在翻页时点击向上或向下翻页），可在代码中设置标识判断当前是否正在翻页，翻页结束后更新标识值</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Bootstrap学习笔记</title>
    <url>/2022/01/05/Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、引入-bootstrap"><a href="#一、引入-bootstrap" class="headerlink" title="一、引入 bootstrap"></a>一、引入 bootstrap</h1><a id="more"></a>

<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap.min.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>可在<a href="https://v3.bootcss.com/getting-started/#template">官网的文档</a>中引入基本模板，然后开始使用 bootstrap</p>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><p>bootstrap 首先将 box-sizing 设置为 border-box</p>
<p>在 bootstrap 中为了增强跨浏览器表现的一致性，使用 Normalize.css （可在 GitHub 上搜到）重置样式，也可使用<a href="https://cssreset.com/">cssreset</a>上的重置样式库</p>
<h2 id="1、容器"><a href="#1、容器" class="headerlink" title="1、容器"></a>1、容器</h2><p>容器两侧都有 15px 的 padding</p>
<h3 id="（1）流体容器"><a href="#（1）流体容器" class="headerlink" title="（1）流体容器"></a>（1）流体容器</h3><p>container-fluid 流体容器，相当于一个弹性盒，width 为 auto</p>
<h3 id="（2）固定容器"><a href="#（2）固定容器" class="headerlink" title="（2）固定容器"></a>（2）固定容器</h3><p>固定容器 container 分为三个阈值 768、992、1200，在 xs、sm、md、lg 都具备时</p>
<p>视口大小 &lt; 768 时，（xs 移动手机），width = auto，此时相当于流体容器</p>
<p>768 &lt; 视口大小 &lt; 992 时，（sm 平板），width = 750 = 720 + 槽宽30</p>
<p>992 &lt; 视口大小 &lt; 1200 时，（md 中屏pc），width = 970 = 940 + 槽宽30</p>
<p>视口大小 &gt;= 1200 时，（lg 大屏pc），width = 1170 = 1140 + 槽宽30</p>
<p>严格上说，sm 表示视口大小 &gt;= 768，md 表示视口大小 &gt;= 992，lg 表示视口大小 &gt;= 1200，代码执行时移动（小屏）优先，大屏下的样式写在小屏后会覆盖小屏的样式</p>
<p>若只有 sm，则表示视口大小 &gt;= 768</p>
<h2 id="2、栅格系统"><a href="#2、栅格系统" class="headerlink" title="2、栅格系统"></a>2、栅格系统</h2><p>栅格系统由固定容器、行、列组成，默认每行由 12 列组成</p>
<p>栅格是基于浮动的，本质上用的是 float</p>
<p>在栅格中通过 col-lg-pull-x 表示 left，col-lg-push-x 表示 right，col-lg-offset-x 表示 margin-left，其中 x 表示 0-12 的整数，md、sm、xs 同理</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-10&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;col-lg-2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;col-lg-8&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="栅格系统源码"><a href="#栅格系统源码" class="headerlink" title="栅格系统源码"></a>栅格系统源码</h3><p>源码可在 <a href="https://www.bootcss.com/">bootstrap官网</a>下载</p>
<pre><code>//固定容器
.container&#123;
    container-fixed();
    ...
&#125;
//流体容器
.container-fluid&#123;
    container-fixed();
&#125;
//行
.row&#123;
    .make-row();
&#125;
//列
.make-grid-columns();
.make-grid(xs);  //移动优先
@media(min-width:@screen-sm-min)&#123;
    .make-grid(sm);
&#125;
@media(min-width:@screen-md-min)&#123;
    .make-grid(md);
&#125;
@media(min-width:@screen-lg-min)&#123;
    .make-grid(lg);
&#125;</code></pre>
<h4 id="固定容器和流体容器的公共样式"><a href="#固定容器和流体容器的公共样式" class="headerlink" title="固定容器和流体容器的公共样式"></a>固定容器和流体容器的公共样式</h4><pre><code>.container-fixed(@gutter:@grid-gutter-width)&#123;  //@grid-gutter-width 表示槽宽，默认为 30px
    margin-right:auto;
    margin-left:auto;
    padding-left:floor((@gutter/2));  // 15px
    padding-right:ceil((@gutter/2));  // 15px
    &amp;:extend(.clearfix all);
&#125;
//其中 .clearfix 内容如下
.clearfix()&#123;
    &amp;:before,
    &amp;:after&#123;
        content:&quot;&quot;;
        display:table;
    &#125;
    &amp;:after&#123;
        clear:both;
    &#125;
&#125;</code></pre>
<h4 id="固定容器的特定样式"><a href="#固定容器的特定样式" class="headerlink" title="固定容器的特定样式"></a>固定容器的特定样式</h4><pre><code>@media(min-width:@screen-sm-min)&#123;
    width:@container-sm;
&#125;
@media(min-width:@screen-md-min)&#123;
    width:@container-md;
&#125;
@media(min-width:@screen-lg-min)&#123;
    width:@container-lg;
&#125;
//上述媒体查询必须从小到大，当屏幕大于 1200 时前两种媒体查询也会读到，但前面会被最后一个覆盖，若屏幕小于 768 时，则三种媒体查询都不会读到，width 则为默认值 auto</code></pre>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>行两侧都有 -15px 的 margin</p>
<pre><code>.make-row(@gutter:@grid-gutter-width)&#123;
    margin-left:ceil((@gutter/-2));  //-15px
    margin-right:floor((@gutter/-2));  //-15px
    &amp;:extend(.clearfix all);
&#125;</code></pre>
<h4 id="列"><a href="#列" class="headerlink" title="列"></a>列</h4><p>公共样式：列两侧都有 15px 的 padding，开启相对定位</p>
<p>float</p>
<p>width：1~12个级别</p>
<p>left、right（列排序）：0~12，0:auto</p>
<p>margin-left（列偏移）：0~12</p>
<p>在列排序中注意阈值上样式的设置不能跳跃，即例如不能设置完 col-lg-push-x 后直接设置  col-sm-push-x，中间的 col-md-push-x 也需设置</p>
<p>第一步：.make-grid-columns()</p>
<pre><code>.make-grid-columns()&#123;
    .col(@index)&#123;
        @item:~&quot;.col-xs-@&#123;index&#125;,.col-sm-@&#123;index&#125;,.col-md-@&#123;index&#125;,.col-lg-@&#123;index&#125;&quot;;
        .col((@index + 1),@item)  //此处不是递归，因为形参个数不同
        //即.col(2,&quot;.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1&quot;)
    &#125;
    .col(@index,@list) when (@index =&lt; @grid-columns)&#123;
        @item:~&quot;.col-xs-@&#123;index&#125;,.col-sm-@&#123;index&#125;,.col-md-@&#123;index&#125;,.col-lg-@&#123;index&#125;&quot;;
        .col((@index + 1),~&quot;@&#123;list&#125;,@&#123;item&#125;&quot;)  //此处是递归
        //即.col(3,&quot;.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2&quot;)
        //...
        //.col(13,str)
        //其中 str:
        //    .col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,
        //    .col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,
        //    ...
        //    .col-xs-12,.col-sm-12,.col-md-12,.col-lg-12,
    &#125;
    .col(@index,@list) when (@index &gt; @grid-columns)&#123;
        @&#123;list&#125;&#123;
            position:relative;
            min-height:1px;
            padding-left:ceil((@grid-gutter-width/2));
            padding-right:floor((@grid-gutter-width/2));
        &#125;
    &#125;//即str&#123;position:...&#125;，str作为选择器
    .col(1);
&#125;</code></pre>
<p>上面整体相当于执行了</p>
<pre><code>.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,
.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,
...
.col-xs-12,.col-sm-12,.col-md-12,.col-lg-12&#123;
    position: relative;
    min-height: 1px;
    padding-left: 15px;
    padding-right: 15px;
&#125;</code></pre>
<p>第二步：.make-grid(xs)</p>
<pre><code>.make-grid(@class)&#123;
    .float-grid-columns(@class); 
    //相当于 .col-xs-1,.col-xs-2,...,.col-xs-12&#123;
    //    float:left;
    //&#125;
    .loop-grid-columns(@grid-columns,@class,width); //从 12 递减到 1
    //相当于 .col-xs-12&#123;
    //    width:12/12;
    //&#125;
    //.col-xs-11&#123;
    //    width:11/12;
    //&#125;
    //...
    //.col-xs-1&#123;
    //    width:1/12;
    //&#125;
    .loop-grid-columns(@grid-columns,@class,pull);  //列排列，从 12 递减到 0
    .loop-grid-columns(@grid-columns,@class,push);  //列排列，从 12 递减到 0
    .loop-grid-columns(@grid-columns,@class,offset);  //列偏移，从 12 递减到 0
&#125;</code></pre>
<p>第二步中.float-grid-columns(@class)</p>
<pre><code>//其中
.float-grid-columns(@class)&#123;
    .col(@index)&#123;
        @item:~&quot;.col-@&#123;class&#125;-@&#123;index&#125;&quot;;
        .col((@index + 1),@item);
    &#125;
    .col(@index,@list) when (@index =&lt; @grid-columns)&#123;
        @item:~&quot;.col-@&#123;class&#125;-@&#123;index&#125;&quot;;
        .col((@index + 1),~&quot;@&#123;list&#125;,@&#123;item&#125;&quot;);
    &#125;
    .col(@index,@list) when (@index &gt; @grid-columns)&#123;
        @&#123;list&#125;&#123;
            float:left;  //本质使用 float
        &#125;
    &#125;
    .col(1);
&#125;</code></pre>
<p>第二步中.loop-grid-columns(@index,@class,@type)</p>
<pre><code>.loop-grid-columns(@index,@class,@type) when (@index &gt;= 0)&#123;
    .calc-grid-column(@index,@class,@type);
    .loop-grid-columns((@index-1),@class,@type);
&#125;
.calc-grid-column(@index,@class,@type) when (@type = width) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-@&#123;index&#125;&#123;
        width:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = push) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-push-@&#123;index&#125;&#123;
        left:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = push) and (@index = 0)&#123;  //调用 1 次
    .col-@&#123;class&#125;-push-0&#123;
        left:auto;
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = pull) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-pull-@&#123;index&#125;&#123;
        right:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = pull) and (@index = 0)&#123;  //调用 1 次
    .col-@&#123;class&#125;-pull-0&#123;
        right:auto;
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = offset)&#123;  //调用 13 次，index 为 0 时，margin-left 为 0
    .col-@&#123;class&#125;-offset-@&#123;index&#125;&#123;
        margin-left:percentage((@index/@grid-columns));
    &#125;
&#125;
//以 push 为例执行时相当于 .col-xs-push-12&#123;
//    left:12/12;
//&#125;
//.col-xs-push-11&#123;
//    left:11/12;
//&#125;
//...
//.col-xs-push-1&#123;
//    left:1/12;
//&#125;
//.col-xs-push-0&#123;
//    left:auto;
//&#125;</code></pre>
<h3 id="栅格组合"><a href="#栅格组合" class="headerlink" title="栅格组合"></a>栅格组合</h3><p>栅格组合即在一个列中写多个不同的栅格</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-10 col-md-6&quot;&gt;xxx&lt;/div&gt;
        &lt;div class=&quot;col-lg-2 col-md-6&quot;&gt;xxx&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>当 992 &lt; 视口大小 &lt; 1200 （md）时，布局为两列每列占 6 格，此时不执行 lg</p>
<p>栅格组合就是利用了 less 的递归</p>
<h3 id="栅格实例"><a href="#栅格实例" class="headerlink" title="栅格实例"></a>栅格实例</h3><p>lg 时每行 4 块、md 时每行 3 块、sm 时每行 2 块、xs 时每行 1 块，显示时按照 1234 顺序显示，但是缩小窗口时，1 会最先换到下一行（正常情况下是 4 先换行）</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-3 col-lg-push-9 col-md-4 col-md-push-8 col-sm-6 col-sm-push-6&quot;&gt;
            ...
            4
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-push-3 col-md-4 col-md-pull-0 col-sm-6 col-sm-pull-6&quot;&gt;
            ...
            3
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-pull-3 col-md-4 col-md-pull-8 col-sm-6&quot;&gt;
            ...
            2
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-pull-9 col-md-4 col-sm-6&quot;&gt;
            ...
            1
            ...
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="自定义栅格系统"><a href="#自定义栅格系统" class="headerlink" title="自定义栅格系统"></a>自定义栅格系统</h3><p>1、新建文件夹，并新建文件 custom.less</p>
<pre><code>@import &quot;mixin/clearfix.less&quot;;
@import &quot;mixin/grid.less&quot;;
@import &quot;mixin/grid-framework.less&quot;;
@import &quot;grid.less&quot;;
@import &quot;variables.less&quot;;
//以上是栅格系统相关源码</code></pre>
<p>注意 clearfix.less 中 .clearfix 后不能有空格、、括号</p>
<p>2、把 grid-framework.less 文件中的 col-xxx 全部重命名为自定义名字，如 custom-col-xxx</p>
<p>3、使用 Kaolo 软件对文件夹文件进行编译，会生成 custom.css、variable.css、mixin/clearfix.css、mixin/grid.css、mixin/grid-framework.css，只需用到其中的 custom.css</p>
<p>4、只需在 html 文件中引入 custom.css 即可使用</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;custom.css&quot;&gt;
&lt;style&gt;
    *&#123;
        box-sizing:border-box;
    &#125;
&lt;/style&gt;</code></pre>
<p>html 中通过 custom-col-xxx 使用自定义栅格</p>
<h3 id="栅格盒模型设计精妙之处"><a href="#栅格盒模型设计精妙之处" class="headerlink" title="栅格盒模型设计精妙之处"></a>栅格盒模型设计精妙之处</h3><p>容器两边具有 15px 的 padding</p>
<p>行两边有 -15px 的 margin</p>
<p>列中间两边有 15px 的 padding（必须）</p>
<p>为了维护槽宽的规则，列两边必须有 16px 的 padding</p>
<p>为了能使列嵌套行，行两边必须有 -15px 的 margin</p>
<p>为了让容器能包裹住行，容器两边必须有 15px 的 padding</p>
<p><a href="./Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%85%E6%A0%BC%E8%AE%BE%E8%AE%A1.png">栅格设计</a></p>
<h2 id="3、响应式工具"><a href="#3、响应式工具" class="headerlink" title="3、响应式工具"></a>3、响应式工具</h2><p>visible-xs、hidden-xs 视口大小 &lt; 768 时显示/隐藏</p>
<p>visible-sm、hidden-sm 768 &lt; 视口大小 &lt; 992 时显示/隐藏</p>
<p>visible-md、hidden-md 992 &lt; 视口大小 &lt; 1200 时显示/隐藏</p>
<p>visible-lg、hidden-lg 视口大小 &gt; 1200 时显示/隐藏</p>
<h2 id="4、bootstrap-定制化"><a href="#4、bootstrap-定制化" class="headerlink" title="4、bootstrap 定制化"></a>4、bootstrap 定制化</h2><p>方法一：在源码中修改，并重新编译入口文件 bootstrap.less 后，在 html 代码中使用新生成的 bootstrap.css 文件</p>
<p>方法二：新建 css 文件，在该文件中</p>
<pre><code>@import &quot;bootstrap.less&quot;;
//接下来写需要修改的部分
@grid-gutter-width:100px;  //如修改槽宽</code></pre>
<p>然后编译该 css 文件，并在 html 文件中使用</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax学习笔记</title>
    <url>/2022/01/07/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、AJAX"><a href="#一、AJAX" class="headerlink" title="一、AJAX"></a>一、AJAX</h1><p>AJAX（Asynchronous JavaScript and XML）即异步的 JS 和 XML</p>
<p>通过 AJAX 可在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据</p>
<a id="more"></a>

<p>AJAX 不是编程语言，而是一种将现有的标准组合在一起使用的新方式</p>
<p><strong>特点：</strong>可在不刷新网页的情况下向后端发送 http 请求，得到 http 响应，实现懒加载效果（用则加载不用则步加载）提高网页加载速度</p>
<h1 id="二、XML"><a href="#二、XML" class="headerlink" title="二、XML"></a>二、XML</h1><p>XML（）可扩展标记语言</p>
<p>XML 被设计用来传输（如服务器以 XML 形式返回数据给客户端）和存储数据（如可用来保存一些用户数据、订单数据、商品数据等）</p>
<pre><code>&lt;student&gt;
    &lt;name&gt;xxx&lt;/name&gt;
    &lt;age&gt;12&lt;/age&gt;
    &lt;gender&gt;男&lt;/gender&gt;
&lt;/student&gt;</code></pre>
<p>最初 AJAX 在数据交换时使用的是 XML，现在一般使用 JSON 格式</p>
<h2 id="XML-和-HTML-区别"><a href="#XML-和-HTML-区别" class="headerlink" title="XML 和 HTML 区别"></a>XML 和 HTML 区别</h2><p>XML 和 HTML 类似都是由标签组成</p>
<p>不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示数据</p>
<p>XML 被设计用来传输和存储数据，而 HTML 用来呈现数据</p>
<h2 id="AJAX-优缺点"><a href="#AJAX-优缺点" class="headerlink" title="AJAX 优缺点"></a>AJAX 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）可无需刷新页面与服务器端进行通信（这是创造 AJAX 的初衷）</p>
<p>（2）允许根据用户事件（如鼠标事件、键盘事件、表单事件、文档事件等）来更新部分页面内容</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>（1）没有浏览历史，不能回退</p>
<p>（2）存在跨域问题（同源）</p>
<p>（3）SEO 不友好，即源码（即响应体）第一次向服务器请求的数据中没有某元素，然后通过 AJAX 向服务端发请求后通过 JS 动态创建元素到页面中，则爬虫爬不到该元素</p>
<h1 id="三、HTTP-协议"><a href="#三、HTTP-协议" class="headerlink" title="三、HTTP 协议"></a>三、HTTP 协议</h1><p>HTTP 协议（hypertext transport protocol）即超文本传输协议，协议详细规定了浏览器和万维网服务器之间互相通信的规则</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报文包括四部分：请求行、请求头、空行、请求体</p>
<p>请求行：请求类型（如 GET/POST/…）、URL、HTTP 协议版本（如 HTTP/1.1）</p>
<p>请求头：Host、Cookie、Content-type、User-Agent</p>
<p>当请求类型为 GET 时请求体为空，为 POST 时请求体可不为空</p>
<pre><code>行  POST /bv?p=123 HTTP/1.1
头  Host: xxx.com
    Cookie: name=xxx
    Content-type: application/x-www-form-urlencoded
    User-Agent: chrome 83
空行
体  username=admin&amp;password=admin</code></pre>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>响应报文包括四部分：行、头、空行、体</p>
<p>响应行：HTTP 协议版本（如 HTTP/1.1）、响应状态码（如 200、404 找不到页面、403 Forbidden、401 未授权、500 内部错误等，2xx都表示成功）、响应状态字符串（如 OK，与状态码对应）</p>
<p>响应头（对响应体作描述）：Content-type、Content-length、Content-encoding</p>
<pre><code>行  HTTP/1.1 200 OK
头  Content-type: text/html;charset=utf-8  表示请求体内容的类型
    Content-length: 2048
    Content-encoding: gzip
    ...
空行
体  &lt;html&gt;
        &lt;head&gt;&lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;xxx&lt;/h1&gt;
        &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<h1 id="四、服务端的准备"><a href="#四、服务端的准备" class="headerlink" title="四、服务端的准备"></a>四、服务端的准备</h1><p>AJAX 需要向服务端发请求，所以需要准备服务端环境，安装 Node.js、使用 Express 框架搭建后端</p>
<h2 id="1、Node-js"><a href="#1、Node-js" class="headerlink" title="1、Node.js"></a>1、Node.js</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，是一个可以解析 js 代码的应用程序，通过 js 代码对计算机资源做一些操作</p>
<p>因为 AJAX 的应用当中需要一个服务端，所以需要安装 Node.js</p>
<h2 id="2、Express-框架的简单使用"><a href="#2、Express-框架的简单使用" class="headerlink" title="2、Express 框架的简单使用"></a>2、Express 框架的简单使用</h2><p>Express 是基于 Node.js 平台的 Web 开发框架</p>
<p>在终端</p>
<pre><code>//做初始化，npm 是 Node.js 平台下的包管理工具
npm init --yes  
//安装 express
npm i express</code></pre>
<p>js 代码</p>
<pre><code>//引入 express
const express = require(&#39;express&#39;);
//创建应用对象
const app = express();
//创建路由规则
//当请求头中的 URL 匹配时会执行下方函数中的回调函数
app.get(&#39;/请求头第二个字段URL&#39;,(request,response)=&gt;&#123;  //参数request是对请求报文的封装，response是对响应报文的封装
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<p>在终端启动服务</p>
<pre><code>node 文件名.js</code></pre>
<p>当 js 文件内容发生变化时需重新启动服务</p>
<h2 id="3、nodemon-自动重启服务工具"><a href="#3、nodemon-自动重启服务工具" class="headerlink" title="3、nodemon 自动重启服务工具"></a>3、nodemon 自动重启服务工具</h2><p>当 js 文件改变时 nodemon 可启动重启 node 应用</p>
<p>在终端安装</p>
<pre><code>npm install -g nodemon</code></pre>
<p>安装完 nodemon 后在启动服务需使用</p>
<pre><code>nodemon 文件名.js</code></pre>
<h1 id="五、原生-AJAX"><a href="#五、原生-AJAX" class="headerlink" title="五、原生 AJAX"></a>五、原生 AJAX</h1><h2 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h2><p>步骤：</p>
<p>— 1、创建对象，<code>new XMLHttpRequest()</code></p>
<p>— 2、初始化，<code>xhr.open(&#39;xxx&#39;,&#39;xxx&#39;)</code> 设置请求方法和 url，url 中设置参数 <code>?参数1=值&amp;参数2=值&amp;参数n=值</code></p>
<p>— 3、发送，<code>xhr.send()</code></p>
<p>— 4、事件绑定，<code>xhr.onreadystatechange</code> 处理服务端返回的结果</p>
<p>其中 readyState 是 xhr 对象中的属性，表示状态，有 5 个值：</p>
<pre><code>0（未初始化）
1（open方法已调用完毕）
2（send方法已调用完毕）
3（服务端返回了部分结果）
4（服务端返回了所有结果）</code></pre>
<p>例子（前端部分）</p>
<pre><code>const xhr = new XMLHttpRequest();  //创建对象
xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/server?a=1&amp;b=2&amp;c=3&#39;); //初始化
xhr.send();  //发送
xhr.onreadystatechange = function()&#123;  //事件绑定，会触发四次，0-1，1-2，2-3，3-4
    if(xhr.readyState === 4)&#123;  //服务端返回了所有结果
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;  //判断响应状态码
            //处理结果--行 头 空行 体
            console.log(xhr.status);  //状态码
            console.log(xhr.statusText);  //状态字符串
            console.log(xhr.getAllResponseHeaders());  //所有响应头
            console.log(xhr.response);  //响应体

        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="2、发送-POST-请求"><a href="#2、发送-POST-请求" class="headerlink" title="2、发送 POST 请求"></a>2、发送 POST 请求</h2><p>无参数的 post 请求与 get 类似，参考上面的例子，同时后端也需有相应路径下的 post 方法</p>
<h3 id="post-中设置请求体"><a href="#post-中设置请求体" class="headerlink" title="post 中设置请求体"></a>post 中设置请求体</h3><pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send(&#39;a=1&amp;b=2&amp;c=3&#39;);  //发送，设置请求体，请求体的内容可以任意
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //处理结果
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h3 id="post-中设置请求头"><a href="#post-中设置请求头" class="headerlink" title="post 中设置请求头"></a>post 中设置请求头</h3><p>一般会把身份校验信息放在头信息中</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);  //设置请求头
xhr.send(&#39;a=1&amp;b=2&amp;c=3&#39;);  //发送，设置请求体，请求体的内容可以任意
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //处理结果
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<p>若使用自定义请求头名，此时发送完 post 请求后还会再发送一个 options 请求，需在后端设置</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();   //创建应用对象
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;  //设置 all 方法可接收任意类型的请求
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //设置使所有类型头信息都能接受，从而允许那些自定义的头信息
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h2 id="3、传输-JSON-数据"><a href="#3、传输-JSON-数据" class="headerlink" title="3、传输 JSON 数据"></a>3、传输 JSON 数据</h2><p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();  //创建应用对象
//创建路由规则
app.get(&#39;/请求头第二个字段URL&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    const data = &#123;
        name:&#39;xxx&#39;
    &#125;
    let str = JSON.stringfy(data);  //将对象进行字符串转换
    response.send(str);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<p>前端方式一：手动对数据转化</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //方式一：手动对数据转化
            let data = JSON.parse(xhr.response);
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<p>前端方式一：（自动转换）设置响应体数据类型</p>
<pre><code>const xhr = new XMLHttpRequest(); 
//方式二：设置响应体数据类型
xhr.responseType = &#39;json&#39;;
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="4、IE-缓存问题"><a href="#4、IE-缓存问题" class="headerlink" title="4、IE 缓存问题"></a>4、IE 缓存问题</h2><p>IE 浏览器会缓存 AJAX 的请求结果，下次发相同请求时使用的是本地的缓存结果而不是服务器返回的最新数据，不利于一些时效性要求比较高的场景</p>
<p>解决：</p>
<p>在前端中设置 url 时添加一个时间戳参数来表示每次发送的是不同请求</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server?t=&#39;+Date.now());  //通过 url 解决 IE 缓存问题
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="5、AJAX-请求超时和网络异常处理"><a href="#5、AJAX-请求超时和网络异常处理" class="headerlink" title="5、AJAX 请求超时和网络异常处理"></a>5、AJAX 请求超时和网络异常处理</h2><p>添加请求超时及网络异常处理，在前端添加</p>
<pre><code>const xhr = new XMLHttpRequest(); 
//设置超过 2s 为超时，则取消请求
xhr.timeout = 2000;
//超时回调
xhr.ontimeout = function()&#123;
    alert(&quot;网络异常，请稍后重试&quot;);
&#125;
//网络异常回调
xhr.onerror = function()&#123;
    alert(&quot;网络出问题了&quot;);
&#125;
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="6、AJAX-取消请求"><a href="#6、AJAX-取消请求" class="headerlink" title="6、AJAX 取消请求"></a>6、AJAX 取消请求</h2><p>通过 xhr 对象的 abort 方法来取消请求 <code>xhr.abort()</code>（xhr 是XMLHttpRequest 对象实例）</p>
<h2 id="7、AJAX-请求重复发送问题"><a href="#7、AJAX-请求重复发送问题" class="headerlink" title="7、AJAX 请求重复发送问题"></a>7、AJAX 请求重复发送问题</h2><p>当服务器响应较慢时，用户可能多次重复发送相同请求，会增加服务器的压力，因此当多次发相同请求时可把前面未响应完成的请求取消</p>
<p>在前端添加一个标识变量来表示是否正在发送请求</p>
<pre><code>let xhr = null;
let isSending = false;  //是否正在发送请求
if(isSending)&#123;  //若正在发送请求，则取消该请求
    xhr.abort();
&#125;
xhr = new XMLHttpRequest(); 
isSending = true;
xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/server);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        isSending = false;
    &#125;
&#125;</code></pre>
<h1 id="六、jQuery-中使用-AJAX"><a href="#六、jQuery-中使用-AJAX" class="headerlink" title="六、jQuery 中使用 AJAX"></a>六、jQuery 中使用 AJAX</h1><h2 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h2><p><code>$get(url,[请求携带的参数],[载入成功时回调函数],[返回内容格式])</code></p>
<p>其中返回内容格式可以是 xml、html、script、json、text、_default</p>
<pre><code>$.get(&#39;http://127.0.0.1:8000/server&#39;,&#123;a:1,b:2&#125;,function(data)&#123;
    console.log(data)
&#125;,&#39;json&#39;)</code></pre>
<p>若使用 CDN 引入jQuery，在发送请求时出现警告 A cookie associated with a cross-site resource at <a href="http://bootcss.com/">http://bootcss.com/</a> was set without the ‘SameSite’ attibute….</p>
<p>可在引入时添加跨源请求的属性设置 <code>crossorigin=&quot;anonymous&quot;</code>，添加后向对于 src 资源请求时不会带当前域名下的 cookie</p>
<pre><code>&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<h2 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h2><p><code>$post(url,[请求携带的参数],[载入成功时回调函数],[返回内容格式])</code></p>
<pre><code>$.post(&#39;http://127.0.0.1:8000/server&#39;,&#123;a:1,b:2&#125;,function(data)&#123;
    console.log(data)
&#125;,&#39;json&#39;)</code></pre>
<h2 id="通用发送请求的方法"><a href="#通用发送请求的方法" class="headerlink" title="通用发送请求的方法"></a>通用发送请求的方法</h2><p>前端</p>
<pre><code>$.ajax(&#123;
    url: &#39;http://127.0.0.1:8000/server&#39;,
    data: &#123;a:1,b:2&#125;,   //参数
    type: &#39;GET&#39;,       //请求类型
    dataType: &#39;json&#39;,  //响应体结果类型，这样可直接解析json字符串
    success: function(data)&#123;  //成功的回调
        console.log(data);
    &#125;,
    timeout: 2000,  //设置超时时间
    error: function()&#123;  //失败的回调，包括超时、异常等
        console.log(&#39;错误&#39;);
    &#125;,
    headers: &#123;
        c:3,
        d:4
    &#125;
&#125;)</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //设置使所有类型头信息都能接受，从而允许那些自定义的头信息
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h1 id="七、axios"><a href="#七、axios" class="headerlink" title="七、axios"></a>七、axios</h1><p>axios 是目前最热门的 AJAX 工具库，也是 Vue 和 React 推荐的 AJAX 工具包</p>
<p>可在项目中使用 <code>npm install axios</code> 安装或使用 <code>&lt;script  crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;&gt;&lt;/script&gt;</code> 引入并使用</p>
<h2 id="get-请求-1"><a href="#get-请求-1" class="headerlink" title="get 请求"></a>get 请求</h2><pre><code>const axios = require(&#39;axios&#39;);  //通过 npm 方式安装需先引入 axios

axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;; //配置 baseURL，也可不配置，都写在请求的 url 里
axios.get(&#39;/server&#39;,&#123;
    params: &#123;  //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;
&#125;).then(value =&gt; &#123;  //数据返回和处理和 jQuery 不同，jQuery 使用回调函数，而 axios 是基于 promise
    console.log(value)
&#125;)</code></pre>
<h2 id="post-请求-1"><a href="#post-请求-1" class="headerlink" title="post 请求"></a>post 请求</h2><p><code>axios.post(url,&#123;请求体&#125;,&#123;其他配置&#125;)</code></p>
<pre><code>axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;; //配置 baseURL，也可不配置，都写在请求的 url 里
axios.get(&#39;/server&#39;,&#123;
    e:5,       //请求体
    f:6
&#125;,&#123;
    params: &#123;  //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;
&#125;).then(value =&gt; &#123;  //数据返回和处理和 jQuery 不同，jQuery 使用回调函数，而 axios 是基于 promise
    console.log(value)
&#125;)</code></pre>
<h2 id="通用发送请求的方法-1"><a href="#通用发送请求的方法-1" class="headerlink" title="通用发送请求的方法"></a>通用发送请求的方法</h2><pre><code>axios(&#123;
    method: &#39;POST&#39;,
    url: &#39;http://127.0.0.1:8000/server&#39;,
    params: &#123;    //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;,
    data: &#123;       //请求体
        e:5,
        f:6
    &#125;    
&#125;).then(response =&gt; &#123;
    console.log(response)
&#125;)</code></pre>
<h1 id="八、使用-fetch-函数发送请求"><a href="#八、使用-fetch-函数发送请求" class="headerlink" title="八、使用 fetch 函数发送请求"></a>八、使用 fetch 函数发送请求</h1><p>fetch 函数属于全局对象，返回一个 promise 对象，这个 promise 会在请求响应后被 resolve，并传回 Response 对象</p>
<pre><code>fetch(&#39;http://127.0.0.1:8000/server?c=1&#39;,&#123;
    method: &#39;POST&#39;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;,
    body: &#39;e=5&amp;f=6&#39;  //请求体，请求体可以是 Blob、BufferSource、Formdata、URLSearchParam 对象或字符串
&#125;).then(response =&gt; &#123;
    return response.text(); //获取响应体结果，不能直接看到响应体结果，需使用 return，若返回的是 json，则使用 return response.json()
&#125;).then(response =&gt; &#123;
    console.log(response)
&#125;)</code></pre>
<h1 id="九、跨域"><a href="#九、跨域" class="headerlink" title="九、跨域"></a>九、跨域</h1><h2 id="1、同源策略"><a href="#1、同源策略" class="headerlink" title="1、同源策略"></a>1、同源策略</h2><p>同源策略（Same-Origin Policy）最早由网景公司提出，是浏览器的一种安全策略</p>
<p>同源即当前网页的 URL 和 AJAX 请求的目标资源的 URL 的协议、域名、端口号完全相同</p>
<p>若违背同源策略就是跨域</p>
<p>AJAX 默认是遵循同源策略的，若不满足同源策略则无法直接发送 AJAX 请求</p>
<p>在同源情况下的请求中 url 可不用加协议、域名、端口（浏览器会自动加上），可简写为 <code>/xxx</code></p>
<h2 id="2、跨域的解决方案"><a href="#2、跨域的解决方案" class="headerlink" title="2、跨域的解决方案"></a>2、跨域的解决方案</h2><h3 id="（1）JSONP"><a href="#（1）JSONP" class="headerlink" title="（1）JSONP"></a>（1）JSONP</h3><p>JSONP（JSON with Padding）是一个非官方的跨域解决方案，只支持 get 请求</p>
<h4 id="JSONP-如何工作"><a href="#JSONP-如何工作" class="headerlink" title="JSONP 如何工作"></a>JSONP 如何工作</h4><p>在网页有一些标签天生具有跨域能力，如 img、link、iframe、script</p>
<p>JSONP 就是利用 script 标签的跨域能力来发送请求的</p>
<p>JSONP 的返回结果是一个定义好的函数的调用（即 js 代码，不能是字符串等数据），这样浏览器引擎才能解析并执行，若是自定义函数，需在前端代码中定义好，函数中的参数一般放要返回的数据内容</p>
<p>前端</p>
<pre><code>&lt;script&gt;
    function handle(data)&#123;
        console.log(data.a)
    &#125;
&lt;/script&gt;
&lt;script src=&quot;http://127.0.0.1:8000/server&quot;&gt;&lt;/script&gt;</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    const data = &#123;
        a:1
    &#125;
    response.send(&#39;console.log(&#39;xxx&#39;)&#39;);
    //或 response.end(&#39;handle($&#123;str&#125;)&#39;); //end 和 send 差不多，但 end 方法不会加特殊响应头
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h4 id="JSONP-的使用"><a href="#JSONP-的使用" class="headerlink" title="JSONP 的使用"></a>JSONP 的使用</h4><ol>
<li><p>动态创建一个 script 标签</p>
<p> var script = document.createElement(“script”);</p>
</li>
<li><p>设置 script 的 src，设置回调函数</p>
<p> script.src = ‘<a href="http://127.0.0.1:8000/sever&#39;">http://127.0.0.1:8000/sever&#39;</a>;</p>
</li>
<li><p>将 script 插入文档中</p>
<p> document.body.appendChild(script);</p>
</li>
</ol>
<h4 id="jQuery-发送-JSONP-请求"><a href="#jQuery-发送-JSONP-请求" class="headerlink" title="jQuery 发送 JSONP 请求"></a>jQuery 发送 JSONP 请求</h4><p>需在 url 参数中设置 <code>?callback=?</code>，发送请求时 jQuery 会注册一个函数作为 callback 参数的值，后端返回该函数的调用则前端就可以对数据做处理</p>
<p>前端</p>
<pre><code>$.getJSON(&#39;http://127.0.0.1:8000/sever?callback=?&#39;,function(data)&#123;
    console.log(data)
&#125;)</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    const data = &#123;
        a:1
    &#125;
    let str = JSON.stringify(data);
    let cb = request.query.callback;
    response.end(&#39;$&#123;cb&#125;($&#123;str&#125;)&#39;)
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h3 id="（2）CORS"><a href="#（2）CORS" class="headerlink" title="（2）CORS"></a>（2）CORS</h3><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，CORS 是官方的跨域解决方案</p>
<p>CORS 的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
<h4 id="CORS-如何工作"><a href="#CORS-如何工作" class="headerlink" title="CORS 如何工作"></a>CORS 如何工作</h4><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应后会对该响应放行</p>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置允许跨域
    //或 response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://127.0.0.1:5000&#39;);  //仅允许 http://127.0.0.1:5000 的网页可向该服务器发送跨域请求
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //可接收自定义头信息
    response.setHeader(&#39;Access-Control-Allow-Method&#39;,&#39;*&#39;);  //允许 get、post 等任意方法
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>ES新特性学习笔记</title>
    <url>/2022/01/07/ES%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、ES-一些背景"><a href="#一、ES-一些背景" class="headerlink" title="一、ES 一些背景"></a>一、ES 一些背景</h1><a id="more"></a>

<p>ECMA（European Computer Manufactures Association）欧洲计算机制造商协会，该组织的目标是评估、开发和认可电信和计算机标准，1994 年后该组织改名为 Ecma 国际</p>
<p>ES（EcmaScript）是脚本语言的规范，是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。 ECMA-262 由 TC39（Technical Committee 39）委员会推进和维护</p>
<p>JavaScript 是 EcmaScript 的一种实现，ES 新特性其实指的是 JavaScript 新特性</p>
<p>ES 新特性语法简洁，功能丰富，框架开发应用（如 Vue、React、Angular）开发过程中需要用到大量的 ES6 新特性语法</p>
<h1 id="二、ES6-语法"><a href="#二、ES6-语法" class="headerlink" title="二、ES6 语法"></a>二、ES6 语法</h1><h2 id="1、let"><a href="#1、let" class="headerlink" title="1、let"></a>1、let</h2><p>特性：</p>
<p>（1）变量不能重复声明，而使用 var 可以重复声明</p>
<p>（2）块级作用域</p>
<p>ES5 中作用域分为全局作用域、函数作用域、eval 作用域（在 ES5 的严格模式中才会出现）</p>
<p>ES6 中引入块级作用域，即变量只在代码块中有效，出代码块就无效了，let 声明变量就是块级作用域</p>
<p>（3）不存在变量提升</p>
<p>不能在变量声明之前使用</p>
<p>（4）不影响作用域链</p>
<p>如函数作用域中没有找到某变量依然会向上一级作用域中找</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(var i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        items[i].style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>上述代码在点击时会报错 items[i] undefined，因为在点击时已经执行完 for 循环，执行点击的回调函数时在函数作用域中没有 i，则去上一级找，在全局下找到 i，并且 i 为 3，因此 items[i] 为 undefined</p>
<p>但若改成</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(var i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        this.style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>上述代码会出现预期效果</p>
<p>或者使用 let 声明变量 i</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(let i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        items[i].style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>此时代码也会出现预期效果，行点击的回调函数时在函数作用域中没有 i，则去上一级找，在代码块中找到相应的 i</p>
<h2 id="2、const-声明常量"><a href="#2、const-声明常量" class="headerlink" title="2、const 声明常量"></a>2、const 声明常量</h2><p>常量就是值不能修改的量</p>
<p>特点：</p>
<p>（1）一定要赋初始值</p>
<p>（2）一般常量名使用大写</p>
<p>（3）常量的值不能修改</p>
<p>（4）块级作用域</p>
<pre><code>&#123;
    const A = &#39;XX&#39;;
&#125;
console.log(A);   //此时会报错</code></pre>
<p>（5）对于数组和对象的元素进行修改不算对常量的修改，不会报错</p>
<p>因为仅对其元素修改并不会影响它保存的地址值</p>
<h2 id="3、变量的解构赋值"><a href="#3、变量的解构赋值" class="headerlink" title="3、变量的解构赋值"></a>3、变量的解构赋值</h2><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这称为解构赋值</p>
<h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><pre><code>const arr = [&#39;12&#39;,&#39;23&#39;,&#39;34&#39;,&#39;45&#39;];
let [a,b,c,d] = arr;  //则 a 为 12，b 为 23，c 为 34，d 为45</code></pre>
<h3 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h3><pre><code>const obj = &#123;
    name: &#39;xxx&#39;;
    age: 12;
    fun: function()&#123;&#125;
&#125;;
let &#123;name,age,fun&#125; = obj;</code></pre>
<h2 id="4、模板字符串"><a href="#4、模板字符串" class="headerlink" title="4、模板字符串"></a>4、模板字符串</h2><p>ES6 中引入新的声明字符串的方式：使用反引号</p>
<p>特点：</p>
<p>（1）内容中可以直接出现换行符</p>
<p>（2）变量拼接</p>
<pre><code>let a = &#39;123&#39;;
let b = `$&#123;a&#125;456`;  //b 为 123456</code></pre>
<h2 id="5、简化对象写法"><a href="#5、简化对象写法" class="headerlink" title="5、简化对象写法"></a>5、简化对象写法</h2><p>ES6 允许在大括号里直接写入变量和函数作为对象的属性和方法</p>
<pre><code>let name = &#39;xxx&#39;;
let fun = function()&#123;&#125;
const obj = &#123;
    name,
    fun,
    fun1()&#123;&#125;  //在 ES5 中是 fun1: function()&#123;&#125;
&#125;</code></pre>
<h2 id="6、箭头函数"><a href="#6、箭头函数" class="headerlink" title="6、箭头函数"></a>6、箭头函数</h2><p>ES6 允许使用箭头（=&gt;）定义函数</p>
<pre><code>//ES5
let fn = function(a,b)&#123;
    return a + b;
&#125;
//ES6
let fn = (a,b) =&gt; &#123;
    return a + b;
&#125;</code></pre>
<p>特性：</p>
<p>（1）this 是静态的，this始终指向函数声明时所在作用域下的 this 值</p>
<pre><code>function getName()&#123;
    console.log(this.name);
&#125;
let getName1 = () =&gt; &#123;
    console.log(this.name);
&#125;
window.name = &#39;aaa&#39;;
const obj = &#123;
    name: &#39;bbb&#39;;
&#125;
getName();  //输出 aaa
getName1();  //输出 aaa
getName.call(obj);  //输出 bbb
getName1.call(obj);  //输出 aaa</code></pre>
<p>（2）不能作为构造函数实例化对象</p>
<pre><code>let Person = (name,age) =&gt; &#123;
    this.name = name;
    this.age = age;
&#125;
let p = new Person(&#39;xx&#39;,12);
console.log(p);    //报错 Person is not a constructor</code></pre>
<p>（3）不能使用 arguments 变量</p>
<pre><code>let fn = () =&gt; &#123;
    console.log(arguments);
&#125;
fn(1,2,3);  //报错 arguments is not defined</code></pre>
<p>（4）箭头函数的简写</p>
<p>省略小括号 ———— 当形参只有一个的时候</p>
<pre><code>let add = n =&gt; &#123;return n+n;&#125;
console.log(add(1));</code></pre>
<p>省略大括号 ———— 当代码体只有一条语句时可省略大括号，此时 return 语句必须省略，语句的执行结果就是函数的返回值</p>
<pre><code>let pow = n =&gt; n * n;
console.log(pow(2));</code></pre>
<h3 id="箭头函数的使用例子"><a href="#箭头函数的使用例子" class="headerlink" title="箭头函数的使用例子"></a>箭头函数的使用例子</h3><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    setTimeout(function()&#123;
        this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>上述代码执行无效，因为定时器回调函数里的 this 指向 window，可改成如下</p>
<pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    let _this = this;
    setTimeout(function()&#123;
        _this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>上述代码可实现相应效果，也可通过箭头函数来解决</p>
<pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    setTimeout(() =&gt; &#123;
        this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>因为箭头函数中的 this 始终指向 函数声明时作用域下（addEventListener 的回调函数作用域）的 this，因此定时器回调函数中的 this 指向事件元素</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>返回数组中的偶数元素</p>
<pre><code>const arr = [1,2,3,4,5,6]
//不使用箭头函数
const result = arr.filter(function(item)&#123;
    if(item % 2 === 0)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;);
//使用箭头函数
const result = arr.filter(item =&gt; item % 2 === 0)</code></pre>
<p><strong>总结：箭头函数适合与 this 无关的回调，如定时器中回调函数、数组的方法回调；箭头函数不适合与 this 有关的回调，如事件回调（this 一般需要指向事件元素）、对象的方法</strong></p>
<pre><code>var obj = &#123;
    name: &#39;xx&#39;;
    getName: function()&#123;
        this.name;  //这里 this 指向该对象，若使用箭头函数，则 this 指向外层作用域的 this（如 window）
    &#125;
&#125;</code></pre>
<h2 id="7、函数参数的默认值"><a href="#7、函数参数的默认值" class="headerlink" title="7、函数参数的默认值"></a>7、函数参数的默认值</h2><p>ES6 允许给函数参数赋值初始值</p>
<p>（1）形参初始值</p>
<p>具有默认值的参数一般位置要靠后</p>
<p>（2）与解构赋值结合</p>
<pre><code>function connect(&#123;host=&quot;127.0.0.1&quot;,username,password,port&#125;)&#123;&#125;
connect(&#123;
    username:&#39;root&#39;,
    password:&#39;root&#39;,
    port:3306
&#125;)</code></pre>
<h2 id="8、rest-参数"><a href="#8、rest-参数" class="headerlink" title="8、rest 参数"></a>8、rest 参数</h2><p>ES6 引入 rest 参数，形参中通过 <code>...标识符</code> 表示，用于获取函数的实参，返回数组，用来代替 arguments（返回的是对象），并且 rest 参数必须要放到参数最后</p>
<pre><code>function fn(a,b,...args)&#123;
    console.log(args);
&#125;
fn(1,2,3,4,5,6);  //输出数组[3,4,5,6]</code></pre>
<h2 id="9、扩展运算符"><a href="#9、扩展运算符" class="headerlink" title="9、扩展运算符"></a>9、扩展运算符</h2><p>扩展运算符 <code>...</code> 能将数组转换为逗号分隔的参数序列</p>
<pre><code>const arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
function fn()&#123;
    console.log(arguments);
&#125;
fn(arr);  //输出实参数组中只有一个元素，该元素是个数组
fn(...arr);  //输出实参数组中有三个元素，三个元素分别对应 arr 中三个元素</code></pre>
<p>注意 rest 参数是将 <code>...</code> 用在函数形参中，而扩展运算符是用在函数调用的实参中</p>
<p>扩展运算符的应用：</p>
<p>（1）数组的合并</p>
<pre><code>const arr1 = [1,2,3];
const arr2 = [4,5,6];
const arr = [...arr1,...arr2];</code></pre>
<p>（2）数组的克隆</p>
<pre><code>const arr1 = [1,2,3];
const arr2 = [...arr1];  </code></pre>
<p>注意：若元素中有引用类型数据是浅拷贝</p>
<p>（3）将伪数组转为真正的数组</p>
<pre><code>const divs = document.querySelectorAll(&#39;div&#39;);
const divarr = [...divs];</code></pre>
<h2 id="10、Symbol"><a href="#10、Symbol" class="headerlink" title="10、Symbol"></a>10、Symbol</h2><p>ES6 引入了新的原始数据类型 Symbol 表示独一无二的值，是一种类似于字符串的数据类型</p>
<p>特点：</p>
<p>（1）Symbol 的值是唯一的，用来解决命名冲突的问题</p>
<p>（2）Symbol 值不能与其他数据进行运算（如加减乘除、拼接、比较等）</p>
<p>（3）Symbol 定义的对象属性不能使用 for…in 循环遍历，但可以使用 Reflect.ownKeys 来获取对象的所有键名</p>
<pre><code>let s1 = Symbol();       //这里把 Symbol 当成函数使用
let s2 = Symbol(&#39;aaa&#39;);  //其中传入的字符串为描述字符串
let s3 = Symbol(&#39;aaa&#39;);
console.log(s2 === s3);  //false
let s4 = Symbol.for(&#39;bbb&#39;);   //这里把 Symbol 当成函数对象，通过该方式创建，可通过描述字符串得出唯一的 Symbol 值
let s5 = Symbol.for(&#39;bbb&#39;); 
console.log(s4 === s5);  //true </code></pre>
<h3 id="通过-Symbol-给对象添加属性-方法"><a href="#通过-Symbol-给对象添加属性-方法" class="headerlink" title="通过 Symbol 给对象添加属性/方法"></a>通过 Symbol 给对象添加属性/方法</h3><p>方式一：</p>
<pre><code>let game = &#123;......&#125;
let methods = &#123;
    up: Symbol(),
    down: Symbol()
&#125;;
game[methods.up] = function()&#123;&#125;
game[methods.down] = function()&#123;&#125;</code></pre>
<p>通过 Symbol 来添加属性或方法更安全，避免与对象可能已存在的属性或方法冲突</p>
<p>方式二：</p>
<pre><code>let game1 = &#123;
    name:&#39;xxx&#39;,
    [Symbol(&#39;up&#39;)]:function()&#123;&#125;,
    [Symbol(&#39;down&#39;)]:function()&#123;&#125;
&#125;</code></pre>
<h3 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h3><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</p>
<p><strong>Symbol.hasInstance</strong></p>
<p>当其他对象使用 instanceof 运算符判断是否为该对象实例时会调用这个方法</p>
<p><strong>Symbol.isConcatSpreadable</strong></p>
<p>对象的 Symbol.isConcatSpreadable 属性是一个布尔值，表示该对象使用 Array.prototype.concat() 时是否可以展开</p>
<p><strong>Symbol.unscopables</strong></p>
<p>该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除</p>
<p><strong>Symbol.match</strong></p>
<p>当执行 str.match(myObject) 时，若该属性存在，会调用它，返回该方法的返回值</p>
<p><strong>Symbol.replace</strong></p>
<p>当该对象被 str.replace(myObject) 方法调用时，会返回该方法的返回值 </p>
<p><strong>Symbol.search</strong></p>
<p>当该对象被 str.search(myObject) 方法调用时，会返回该方法的返回值</p>
<p><strong>Symbol.split</strong></p>
<p>当该对象被 str.split(myObject) 方法调用时，会返回该方法的返回值</p>
<p><strong>Symbol.iterator</strong></p>
<p>对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器</p>
<p><strong>Symbol.toPrimitive</strong></p>
<p>该对象被转为原始类型的值，会调用该方法，返回该对象对应的的原始类型值</p>
<p><strong>Symbol.toStringTag</strong></p>
<p>在该对象上调用 toString 方法时，返回该方法的返回值</p>
<p><strong>Symbol.species</strong></p>
<p>创建衍生对象时，会使用该属性</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><p>Symbol.hasInstance 这一个整体将作为其他普通对象的方法，可扩展对象功能，通过对它的设置可以改变对象在特定场景下的表现结果（其他内置值也是类似道理），当其他对象使用 instanceof 运算符判断是否为该对象实例时会调用这个方法</p>
<pre><code>class Person&#123;
    static [Symbol.hasInstance](param)&#123;
        console.log(param);  //输出 &#123;&#125;
        //return true;
    &#125;
&#125;
let o = &#123;&#125;
console.log(o instanceof Person);  //false，这个返回值会根据 Person 中 [Symbol.hasInstance](param)&#123;&#125; 方法的返回结果改变，若返回 true 则这里会输出 true</code></pre>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p>对象的 Symbol.isConcatSpreadable 属性是一个布尔值，表示该对象使用 Array.prototype.concat() 时是否可以展开</p>
<pre><code>const arr = [1,2,3];
const arr2 = [4,5,6];
console.log(arr.concat(arr2));  //输出[1,2,3,4,5,6]
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2));  //输出[1,2,3,[4,5,6]]</code></pre>
<h2 id="11、迭代器"><a href="#11、迭代器" class="headerlink" title="11、迭代器"></a>11、迭代器</h2><p>迭代器（Iterator）是一种接口（就是对象里的一个属性 Symbol.iterator，这是一个函数），为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口就可以完成遍历操作</p>
<p>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要提供 <code>for...of</code> 消费</p>
<p>原生具备 iterator 接口（可用 for of 遍历）的数据有 Array、Arguments、Set、Map、String、TypedArray、NodeList</p>
<p><strong>注意：需要自定义遍历数据时要想到迭代器</strong></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>（1）创建一个指针对象，指向当前数据结构的起始位置</p>
<p>（2）第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p>
<p>（3）接下来不断调用 next 方法，指针一直向后移动，直到指向最后一个成员</p>
<p>（4）每调用 next 方法返回一个包含 value 和 done（布尔值，为 true 表示遍历完成） 属性的对象</p>
<pre><code>const arr = [1,2,3,4]
let iterator = arr[Symbol.iterator]();  //第（1）步
console.log(iterator.next());  //第（2）步，返回&#123;value:1,done:false&#125;
console.log(iterator.next());  //返回&#123;value:2,done:false&#125;
console.log(iterator.next());  //返回&#123;value:3,done:false&#125;
console.log(iterator.next());  //返回&#123;value:4,done:false&#125;
console.log(iterator.next());  //返回&#123;value:undefined,done:true&#125;</code></pre>
<h3 id="for…in-和-for…of区别"><a href="#for…in-和-for…of区别" class="headerlink" title="for…in 和 for…of区别"></a>for…in 和 for…of区别</h3><p>for(let i in items){} 遍历过程中这里的 i 表示键（数组中就是下标 0,1,2,…）</p>
<p>for(let i of items){} 遍历过程中这里的 i 表示值</p>
<h3 id="自定义遍历数据"><a href="#自定义遍历数据" class="headerlink" title="自定义遍历数据"></a>自定义遍历数据</h3><p>要遍历对象 obj 对象内的数组arr</p>
<pre><code>const obj = &#123;
    name:&#39;xx&#39;,
    arr:[1,2,3,4],
    [Symbol.iterator]()&#123;
        let index = 0;
        let _this = this;
        return &#123;  //因为 iterator 工作原理中第一步创建一个指针对象，所以返回需要是一个对象
            next:function()&#123;  //因为 iterator 工作原理中第二步调用对象的 next 方法，所以需要一个 next 方法
                if(index &lt; _this.arr.length)&#123;
                    const result = &#123;value: _this.arr[index], done:false&#125;
                    index++;
                    return result;
                &#125;else&#123;
                    return &#123;value: undefined, done:false&#125;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
for(let o of obj)&#123;
    console.log(o)
&#125;</code></pre>
<h2 id="12、生成器"><a href="#12、生成器" class="headerlink" title="12、生成器"></a>12、生成器</h2><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>异步操作有如文件操作、网络操作（ajax、request）、数据库操作等</p>
<p>在 ES6 之前异步编程是通过纯回调函数实现</p>
<pre><code>function * gen()&#123;
    console.log(&#39;hello&#39;)
&#125;
let iterator = gen();  //返回的是一个迭代器对象
console.log(iterator);   //此处并没有输出 hello
iterator.next();  //输出 hello</code></pre>
<p>在生成器中可以出现 yield 语句</p>
<pre><code>function * gen()&#123;
    console.log(&#39;111&#39;);
    yield &#39;aa&#39;;
    console.log(&#39;222&#39;);
    yield &#39;bb&#39;;
    console.log(&#39;333&#39;);
    yield &#39;cc&#39;;
    console.log(&#39;444&#39;);
&#125;
et iterator = gen();
iterator.next();  //输出 111
iterator.next();  //输出 222
iterator.next();  //输出 333
iterator.next();  //输出 444

function * gen()&#123;
    console.log(&#39;111&#39;);
    yield &#39;aa&#39;;
    console.log(&#39;222&#39;);
    yield &#39;bb&#39;;
    console.log(&#39;333&#39;);
    yield &#39;cc&#39;;
    console.log(&#39;444&#39;);
&#125;
et iterator = gen();
console.log(iterator.next());  //输出&#123;value:&#39;aa&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;bb&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;cc&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;undefined&#39;,done:true&#125;

for(let g of gen())&#123;
    console.log(g);  //会分别输出aa bb cc
&#125;</code></pre>
<p>next 方法可以传入实参，该实参将作为上一个 yield 语句的返回结果</p>
<pre><code>function * gen(arg)&#123;
    console.log(arg);
    let one = yield 111;
    console.log(one);
    let two = yield 222;
    console.log(two);
    let three = yield 333;
    console.log(three);
&#125;
et iterator = gen(&#39;AAA&#39;);
console.log(iterator.next());  //输出 AAA &#123;value:111,done:false&#125;
console.log(iterator.next(&#39;BBB&#39;));  //输出 BBB &#123;value:222,done:false&#125;
console.log(iterator.next(&#39;CCC&#39;));  //输出 CCC&#123;value:333,done:false&#125;
console.log(iterator.next(&#39;DDD&#39;));  //输出 DDD&#123;value:&#39;undefined&#39;,done:true&#125;</code></pre>
<h3 id="生成器实例"><a href="#生成器实例" class="headerlink" title="生成器实例"></a>生成器实例</h3><h4 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h4><p>1s 后控制台输出 111，2s 后输出 222，3s 后输出 333</p>
<p>方式一：使用定时器</p>
<pre><code>setTimeout(() =&gt; &#123;
    console.log(111);
    setTimeout(() =&gt; &#123;
        console.log(222);
        setTimeout(() =&gt; &#123;
            console.log(333);
        &#125;,3000);
    &#125;,2000);
&#125;,1000);</code></pre>
<p>若使用定时器实现会出现回调地狱，一层层不停回调，阅读、调试不方便，且容易重名</p>
<p>方式二：使用生成器</p>
<pre><code>function one()&#123;
    setTimeout(() =&gt; &#123;
        console.log(111);
        iterator.next();
    &#125;,1000)
&#125;
function two()&#123;
    setTimeout(() =&gt; &#123;
        console.log(222);
        iterator.next();
    &#125;,2000)
&#125;
function three()&#123;
    setTimeout(() =&gt; &#123;
        console.log(333);
        iterator.next();
    &#125;,3000)
&#125;
function * gen()&#123;
    yield one();
    yield two();
    yield three();
&#125;
let iterator = gen();
iterator.next();</code></pre>
<h4 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h4><p>第一秒获取用户数据，下一秒获取订单数据，下一秒获取商品数据</p>
<pre><code>function getUsers()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;用户数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function getOrders()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;订单数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function getGoods()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;商品数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function * gen()&#123;
    let users = yield getUsers();
    let orders = yield getOrders();
    let goods = yield getGoods();
&#125;
let iterator = gen();
iterator.next();</code></pre>
<h2 id="13、Promise"><a href="#13、Promise" class="headerlink" title="13、Promise"></a>13、Promise</h2><p>Promise 是 ES6 引入的异步编程的新解决方案，语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p>
<p>（1）Promise 构造函数</p>
<p>（2）Promise.prototype.then 方法</p>
<p>（3）Promise.prototype.catch 方法</p>
<pre><code>//实例化 Promise 对象
const p = new Promise(function(resolve,reject)&#123;  //通过 resolve 和 reject 函数改变 Promise 实例对象的状态
    setTimeout(function()&#123;  //把异步任务封装在 Promise 对象中
        let data = &#39;xxx&#39;;
        resolve(data); //调用 resolve 方法后 Promise 实例对象的状态就变为成功
        let err = &#39;错误&#39;;        
        reject(err);  //调用 resolve 方法后 Promise 实例对象的状态就变为失败
    &#125;,1000);
&#125;);
//Promise 实例对象状态改变后调用 then 方法
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value);
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.error(reason);
&#125;)</code></pre>
<h2 id="Promise-封装读取文件"><a href="#Promise-封装读取文件" class="headerlink" title="Promise 封装读取文件"></a>Promise 封装读取文件</h2><p>Promise 读取文件会使用到 Node.js 的 API</p>
<p>使用 fs 模块读取文件的原始方法：</p>
<pre><code>const fs = require(&#39;fs&#39;);
fs.readFile(&#39;./xxx.md&#39;, (err, data) =&gt; &#123;
    if(err) throw err;  //若失败抛出错误
    console.log(data.toString());  //若没有出错输出内容，其中 data 是一个 Buffer
&#125;);</code></pre>
<p>使用 Promise 封装</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    fs.readFile(&#39;./xxx.md&#39;, (err, data) =&gt; &#123;
        if(err) reject(err);
        resolve(data)
    &#125;);
&#125;);
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value.toString());
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.log(&quot;读取失败&quot;);
&#125;)</code></pre>
<h2 id="Promise-封装-AJAX-请求"><a href="#Promise-封装-AJAX-请求" class="headerlink" title="Promise 封装 AJAX 请求"></a>Promise 封装 AJAX 请求</h2><pre><code>const p = new Promise(function(resolve,reject)&#123;
    const xhr = new XMLHttpRequest(); 
    xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server);
    xhr.send();
    xhr.onreadystatechange = function()&#123;
        if(xhr.readyState === 4)&#123;
            if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
                resolve(xhr.response)
            &#125;else&#123;
                reject(xhr.status)
            &#125;
        &#125;
    &#125;
&#125;);
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value);
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.error(reason);
&#125;)</code></pre>
<h2 id="Promise-prototype-then-方法"><a href="#Promise-prototype-then-方法" class="headerlink" title="Promise.prototype.then 方法"></a>Promise.prototype.then 方法</h2><p>Promise.prototype.then 方法返回值也是一个 Promise 对象，该返回对象的状态由 then 里的回调函数的执行结果决定</p>
<p>若回调函数中返回的结果是非 Promise 类型的属性，则状态为成功，返回的值为成功时回调函数的返回值</p>
<p>若回调函数中返回 Promise 类型的对象，则内部的该 Promise 对象的返回状态就是外部 then 方法返回的 Promise 对象的状态</p>
<p>若回调函数中抛出错误，则 then 方法返回的 Promise 对象状态也为失败，值为出错的值</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
        let data = &#39;xxx&#39;;
        resolve(data);
    &#125;,1000);
&#125;);
const result = p.then(value =&gt; &#123;
    console.log(value);
    //1、返回非 Promise 类型
    //return 123; //或者直接没有 return 语句返回 undefined
    //2、返回 Promise 对象，则内部的该 Promise 对象的返回状态就是外部 then 方法返回的 Promise 对象的状态
    //return new Promise((resolve,reject)=&gt;&#123;
    //    resolve(&#39;ok&#39;); //外部 then 方法返回的 Promise 对象状态也为成功，且值为 ok
    //&#125;)
    //3、抛出错误，外部 then 方法返回的 Promise 对象状态也为失败，值为出错的值
    //throw new Error(&#39;出错&#39;);
&#125;, reason =&gt; &#123;
    consle.error(reason);
&#125;)</code></pre>
<p>因为 then 方法返回值也是一个 Promise 对象，所以可以进行链式调用，从而杜绝回调地狱</p>
<pre><code>p.then(value =&gt; &#123;

&#125;, reason =&gt; &#123;

&#125;).then(value =&gt;&#123;

&#125;, reason =&gt;&#123;

&#125;)</code></pre>
<h3 id="then-方法的链式调用"><a href="#then-方法的链式调用" class="headerlink" title="then 方法的链式调用"></a>then 方法的链式调用</h3><p>例子：按顺序读三个文件，并把三个文件内容合在一起后做输出</p>
<p>可通过 Promise 读取多个文件，Promise 可解决回调地狱</p>
<pre><code>const p = new Promise((resolve,reject) =&gt; &#123;
    fs.readFile(&#39;./文件1.md&#39;, (err, data) =&gt; &#123;
        resolve(data)
    &#125;);
&#125;);
p.then(value =&gt; &#123;  //状态为成功时调用
    return new Promise((resolve,reject) =&gt; &#123;
        fs.readFile(&#39;./文件2.md&#39;, (err, data) =&gt; &#123;
            resolve([value,data])
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    return new Promise((resolve,reject) =&gt; &#123;
        fs.readFile(&#39;./文件3.md&#39;, (err, data) =&gt; &#123;
            value.push(data);
            resolve(value);
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    console.log(value.join(&#39;\r\n&#39;));
&#125;)</code></pre>
<h2 id="Promise-prototype-catch-方法"><a href="#Promise-prototype-catch-方法" class="headerlink" title="Promise.prototype.catch 方法"></a>Promise.prototype.catch 方法</h2><p>Promise.prototype.catch 方法其实算是一个语法糖，其实由 then 方法不指定第一个参数结果和 catch 方法一样</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
        let err = &#39;错误&#39;;        
        reject(err); 
    &#125;,1000);
&#125;);
p.catch(function(reason)&#123;  //只需指定失败的回调
    console.warn(reason);
&#125;)</code></pre>
<h2 id="14、Set"><a href="#14、Set" class="headerlink" title="14、Set"></a>14、Set</h2><p>ES6 提供了新的数据结构 Set（集合），它类似于数组，但成员的值都是唯一的</p>
<p>集合实现了 iterator 接口，所以可使用扩展运算符和 for…of 进行遍历</p>
<p>集合的属性和方法：</p>
<p>size 属性返回会集合元素个数</p>
<p>add(xxx) 增加一个新元素，返回当前集合</p>
<p>delete(xxx) 删除元素，返回 boolean 值</p>
<p>has(xxx) 检测集合中是否包含某个元素，返回 boolean 值</p>
<p>clear() 清空集合中元素</p>
<pre><code>let s1 = new Set();
let s2 = new Set([1,2,3,1])  //会自动去重
console.loge(s2.size);  //输出3
for(let s of s2)&#123;
    console.log(s); //输出 1，2，3
&#125;</code></pre>
<h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let result = [...new Set(arr)]</code></pre>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let result = [...new Set(arr)].filter(item =&gt; &#123;
    let s = new Set(arr1);  //4 5 6
    if(s.has(item))&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;)
//上述代码可简化为let result = [...new Set(arr)].filter(item =&gt; new Set(arr1).has(item));</code></pre>
<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let union = [...new Set([...arr,...arr2])]</code></pre>
<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>差集即对交集取反</p>
<pre><code>//arr - arr1
let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr1).has(item)));</code></pre>
<h2 id="15、Map"><a href="#15、Map" class="headerlink" title="15、Map"></a>15、Map</h2><p>ES6 提供了 Map 数据结构，它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键</p>
<p>Map 也实现了 iterator 接口，所以可使用扩展运算符和 for…of 进行遍历</p>
<p>Map 的属性和方法：</p>
<p>size 属性返回会 Map 元素个数</p>
<p>set(键,值) 增加一个新元素，返回当前 Map</p>
<p>delete(键) 删除元素</p>
<p>get(键) 返回键名对象的键值</p>
<p>has(xxx) 检测 Map 中是否包含某个元素，返回 boolean 值</p>
<p>clear() 清空集合中，返回 undefined</p>
<p>使用 iterator 遍历返回的结果每个元素是个数组 [键,值]</p>
<h2 id="16、class-类"><a href="#16、class-类" class="headerlink" title="16、class 类"></a>16、class 类</h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）作为对象的模板。通过 class 关键字可以定义类</p>
<p>基本上 ES6 的 class 可以看作只是一个语法糖，它绝对部分功能 ES5 都能做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>
<p>class 声明类</p>
<p>constructor 定义构造函数初始化</p>
<p>extends 继承父类</p>
<p>super 调用父级构造方法</p>
<p>static 定义静态方法和属性</p>
<p>父类方法可以重写</p>
<pre><code>//ES5 构造类
function Phone (brand,price)&#123;
    this.brand = brand;
    this.price = price;
&#125;
Phone.prototype.call = function()&#123;&#125;
let huawei = new Phone(&#39;华为&#39;,6000);
huawei.call()

//ES6
class Phone&#123;
    constructor(brand,price)&#123;  //构造方法，new 创建实例对象时会自动执行
        this.brand = brand;
        this.price = price;
    &#125;
    call()&#123;  //方法必须使用该语法，不能使用 ES5 中的 call: function()&#123;&#125;
    &#125;
&#125;
let oneplus = new Phone(&#39;1+&#39;,2000);</code></pre>
<h3 id="class-的静态成员"><a href="#class-的静态成员" class="headerlink" title="class 的静态成员"></a>class 的静态成员</h3><p>函数对象和实例对象的属性是不相通的，属于类的属性但不属于类实例的属性这种属性称为静态成员</p>
<p>ES5 中</p>
<pre><code>function Phone (brand,price)&#123;
    this.brand = brand;
    this.price = price;
&#125;
Phone.name = name; //静态成员
Phone.size = size; //静态成员
Phone.prototype.change = function()&#123;&#125;
let nokia = new Phone();
conosle.log(nokia.name);  //报错
console.log(nokia.size);  //报错
nokia.change();  //不报错</code></pre>
<p>ES6 中，通过 static 标注的属性或方法属于类而不属于类实例对象</p>
<pre><code>class Phone&#123;
    //静态属性
    static name = &quot;手机&quot;;
    static change()&#123;&#125;
&#125;
let nokia = new Phone();
conosle.log(nokia.name);  //输出 undefined
console.log(Phone.size);  //输出 手机</code></pre>
<h3 id="class-类对象继承"><a href="#class-类对象继承" class="headerlink" title="class 类对象继承"></a>class 类对象继承</h3><p>ES5 中使用原型链 + 借用构造函数的组合继承，可参考之前的<a href="https://beingjay.com/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/#more">博客中 3.2 部分</a></p>
<p>在 ES6 的 class 中使用 extends 继承父类</p>
<pre><code>//父类
class Phone&#123;
    constructor(brand,price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;
    //父类的成员属性
    call()&#123;
    &#125;
&#125;
//子类
class SmartPhone extends Phone&#123;
    //构造方法
    constructor(brand,price,color,size)&#123;
        super(brand,price);//super 就是父类中 constrctor 方法，通过 super 完成调用，相当于 ES5 中 Phone.call(this,brand,price);
        this.color = color;
        this.size = size;
    &#125;
    photo()&#123;&#125;
&#125;
const xiaomi = new SmartPhone(&#39;xx&#39;,1000,&#39;黑色&#39;,&#39;4.7inch&#39;);
xiaoomi.call();
xiaomi.photo();</code></pre>
<h4 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写"></a>子类对父类方法的重写</h4><pre><code>//父类
class Phone&#123;
    constructor(brand,price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;
    //父类的成员属性
    call()&#123;
        console.log(&#39;call&#39;)
    &#125;
&#125;
//子类
class SmartPhone extends Phone&#123;
    //构造方法
    constructor(brand,price,color,size)&#123;
        super(brand,price);//super 就是父类中 constrctor 方法，通过 super 完成调用，相当于 ES5 中 Phone.call(this,brand,price);
        this.color = color;
        this.size = size;
    &#125;
    photo()&#123;&#125;
    call()&#123;  //重写父类中 call 方法
        console.log(&#39;call1&#39;);
    &#125;
&#125;
const xiaomi = new SmartPhone(&#39;xx&#39;,1000,&#39;黑色&#39;,&#39;4.7inch&#39;);
xiaomi.call();  //输出 call1</code></pre>
<p>注意：在 js 的 class 中子类不能直接调用父类的同名方法，普通成员方法中也不能使用 super() 去调用父类的同名方法</p>
<h3 id="class-中的-getter-和-setter"><a href="#class-中的-getter-和-setter" class="headerlink" title="class 中的 getter 和 setter"></a>class 中的 getter 和 setter</h3><pre><code>class Phone&#123;
    get price()&#123;  //对 price 属性的读取绑定了一个函数，只要读取实例对象里的 price 属性就会执行该函数，函数的返回值就是 price 属性的值
        console.log(&#39;price属性被读取了&#39;)
        return &#39;xxx&#39;
    &#125;
    get price(newVal)&#123;  //对 price 属性的进行赋值时就会调用该函数，且 setter 中必须有一个参数
        console.log(&#39;price属性被修改了&#39;)
    &#125;
&#125;
let s = new Phone();
console.log(s.price);  //，输出 “price属性被读取了” 以及 “xxx”
s.price = &#39;free&#39;;  //输出 “price属性被修改了”</code></pre>
<p>get 的使用场景：get 常用来对对象的动态属性（即属性值是变化的）做封装，如求整数、求平均数时</p>
<p>set：通过 set 可以添加更多的控制和判断，如判断给属性设置的值是否合法（如得是数字，结果传了字符串）若成功则赋值否则不赋值</p>
<h2 id="17、数值扩展"><a href="#17、数值扩展" class="headerlink" title="17、数值扩展"></a>17、数值扩展</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>Number.EPSILON 属性值为 2.2204460492503130808472633361816-16 是 JavaScript 表示的最小精度</p>
<p>若两个数的差值小于 Number.EPSILON 则相等</p>
<pre><code>console.log(0.1 + 0.2 === 0.3)  //false
//0.1 + 0.2 的结果为 0.30000000000000004

function equal(a, b)&#123;
    if(Math.abs(a-b) &lt; Number.EPSILON)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;
console.log(equal(0.1 + 0.2, 0.3))  //true</code></pre>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>二进制 <code>0b</code> 开头，八进制 <code>0o</code> 开头，十六进制 <code>0x</code> 开头</p>
<h3 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite"></a>Number.isFinite</h3><p>Number.isFinite 检测一个数值是否为有限数</p>
<pre><code>console.log(Number.isFinite(100/0))  //false
console.log(Number.isFinite(Infinity))  //false</code></pre>
<h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN"></a>Number.isNaN</h3><p>Number.isNaN 检测一个数值是否为 NaN</p>
<p>在 ES5 中 isNaN() 是个单独的函数，在 ES6 中把它作为 Number 中的一个方法</p>
<pre><code>console.log(Number.isNaN(10))  //false</code></pre>
<h3 id="Number-parseInt-和-Number-parseFloat"><a href="#Number-parseInt-和-Number-parseFloat" class="headerlink" title="Number.parseInt 和 Number.parseFloat"></a>Number.parseInt 和 Number.parseFloat</h3><p>Number.parseInt 和 Number.parseFloat 把字符串转为整数、浮点数</p>
<p>在 ES5 中 parseInt() 和 parseFloat() 是个单独的函数，在 ES6 中也把它们作为 Number 中的一个方法</p>
<pre><code>console.log(Number.parseInt(&#39;10hello&#39;))  //输出 10</code></pre>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><p>Number.isInteger 判断一个数是否为整数</p>
<pre><code>console.log(Number.isInteger(10))  //true</code></pre>
<h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc"></a>Math.trunc</h3><p>Math.trunc 将数字的小数部分抹掉</p>
<pre><code>console.log(Math.trunc(3.5))  //输出 3</code></pre>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign"></a>Math.sign</h3><p>Math.sign 判断一个数为正数、负数还是零，分别输出1、0、-1</p>
<pre><code>console.log(Math.sign(100))  //输出 1
console.log(Math.sign(0))  //输出 0
console.log(Math.sign(-200))  //输出 -1</code></pre>
<h2 id="18、ES6-的对象方法扩展"><a href="#18、ES6-的对象方法扩展" class="headerlink" title="18、ES6 的对象方法扩展"></a>18、ES6 的对象方法扩展</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>Object.is 判断两个值是否完全相等</p>
<pre><code>console.log(Object.is(10,10))  //true
console.log(Object.is(NaN,NaN))  //true
console.log(NaN === NaN)  //false</code></pre>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign(被覆盖的对象,覆盖的对象) 对象的合并，后者会覆盖前者的同名属性，若前者中有后者没有的属性则覆盖后依然存在，若后者有前者没有的属性则不会出现在合并后新对象中</p>
<pre><code>const config1 = &#123;
    host:&#39;localhost&#39;,
    port: 3306,
    name: &#39;root&#39;,
    pass: &#39;root&#39;,
    test: &#39;test&#39;
&#125;
const config2 = &#123;
    host:&#39;http://127.0.0.1&#39;,
    port: 33060,
    name: &#39;root1&#39;,
    pass: &#39;root1&#39;
&#125;
console.log(Object.assign(config1,config2))</code></pre>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf"></a>Object.setPrototypeOf</h3><p>Object.setPrototypeOf(对象实例, 原型对象) 设置原型对象</p>
<p>Object.getPrototypeOf(对象实例) 获取原型对象</p>
<pre><code>const obj1 = &#123;
    name:&#39;xx1&#39;
&#125;
const obj2 = &#123;
    arr: [1,2,3]
&#125;
Object.setPrototypeOf(obj1, obj2);
console.log(Object.getPrototypeOf(obj1)) //会输出 obj2</code></pre>
<h2 id="19、模块化"><a href="#19、模块化" class="headerlink" title="19、模块化"></a>19、模块化</h2><p>模块化是指将一个大的程序文件拆分成许多小的文件，然后将小文件组合起来实现功能</p>
<p>ES6 之前的模块化规范有 </p>
<p>1）CommonJS =&gt; NodeJS、Browserify（浏览器端打包工具）</p>
<p>2）AMD（针对浏览器） =&gt; requireJS</p>
<ol start="3">
<li>CMD（针对浏览器） =&gt; seaJS</li>
</ol>
<p>（左边是规范，右边是实现/产品）</p>
<h3 id="模块化好处"><a href="#模块化好处" class="headerlink" title="模块化好处"></a>模块化好处</h3><p>（1）防止命名冲突</p>
<p>（2）代码复用</p>
<p>（3）高维护性（如不同人员间的修改不冲突，升级只需对某个或某些模块升级）</p>
<h3 id="模块化语法"><a href="#模块化语法" class="headerlink" title="模块化语法"></a>模块化语法</h3><p>export 命令用于规定模块的对外接口，在模块文件中只需在需要暴露的数据或函数前添加 export 即可</p>
<h4 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>方式一：分别暴露</p>
<pre><code>export let school = &#39;xx&#39;;
export function teach()&#123;&#125;</code></pre>
<p>方式二：统一暴露</p>
<pre><code>let school = &#39;xx&#39;;
function teach()&#123;&#125;
export &#123;school,teach&#125;;</code></pre>
<p>方式三：默认暴露</p>
<pre><code>export default &#123;
    school: &#39;xx&#39;,
    teach: function()&#123;&#125;
&#125;</code></pre>
<h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><p>import 命令用于输入其他模块提供的功能</p>
<h5 id="通过-script-标签引入模块"><a href="#通过-script-标签引入模块" class="headerlink" title="通过 script 标签引入模块"></a>通过 script 标签引入模块</h5><p>方式一：通用的导入方式</p>
<pre><code>//对于分别暴露和统一暴露
&lt;script type=&quot;module&quot;&gt;
    import * as m1 from &quot;./m1.js&quot;
    console.log(m1)
&lt;/script&gt;

//对于默认暴露
&lt;script type=&quot;module&quot;&gt;
    import * as m3 from &quot;./m3.js&quot;
    m3.default.teach();  //注意使用方式
&lt;/script&gt;</code></pre>
<p>方式二：解构赋值形式</p>
<pre><code>//对于分别暴露和统一暴露
&lt;script type=&quot;module&quot;&gt;
    import &#123;school,teach&#125; from &quot;./m1.js&quot;
    import &#123;school as xx,teach&#125; from &quot;./m2.js&quot;
&lt;/script&gt;

//对于默认暴露
&lt;script type=&quot;module&quot;&gt;
    import &#123;default as m3&#125; from &quot;./m3.js&quot;
    m3.default.teach();
&lt;/script&gt;</code></pre>
<p>方式三：简便形式（只能针对默认暴露）</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
    import m3 from &quot;./m3.js&quot;
&lt;/script&gt;</code></pre>
<h5 id="通过入口文件引入模块"><a href="#通过入口文件引入模块" class="headerlink" title="通过入口文件引入模块"></a>通过入口文件引入模块</h5><p>新建一个入口文件 xxx.js，在该文件中对各模块进行引入和做一些操作</p>
<pre><code>import * as m1 from &quot;./m1.js&quot;;
import * as m2 from &quot;./m2.js&quot;;
import * as m3 from &quot;./m3.js&quot;;
console.log(m1);
m2.teach();
m3.default.change();</code></pre>
<p>然后在 html 文件中引入该入口文件</p>
<pre><code>&lt;script src=&quot;./xxx.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></pre>
<h5 id="引入-npm-安装的模块"><a href="#引入-npm-安装的模块" class="headerlink" title="引入 npm 安装的模块"></a>引入 npm 安装的模块</h5><p>和上面一样使用入口文件的方式引入模块，并在入口文件中编写相关操作的代码</p>
<p>如通过 <code>npm i jquery</code> 安装 jquery 包，在入口文件中引入并使用：</p>
<pre><code>import $ from &#39;jquery&#39;; //ES6 中的引入方式，相当于 CommonJS 中 const $ = require(&quot;jquery&quot;);
$(&#39;body&#39;).css(&#39;background&#39;,&#39;red&#39;);</code></pre>
<h3 id="ES6-模块化代码转换"><a href="#ES6-模块化代码转换" class="headerlink" title="ES6 模块化代码转换"></a>ES6 模块化代码转换</h3><p>因为并不是所有浏览器都兼容 ES6 新特性，所以需要对代码进行转换</p>
<p>babel 是一个 JavaScript 编译器，可以把 ES6 代码转换为 ES5</p>
<p>步骤：</p>
<p>（1）安装工具 babel-cli（babel 的命令行工具）、babel-preset-env（预设包，能把最新的 ECMAScript 特性转换为 ES5 语法）、browserify（打包工具）</p>
<pre><code>npm init --yes
npm i babel-cli babel-preset-env browserify -D</code></pre>
<p>-D 为开发依赖，为局部安装</p>
<p>（2）编译</p>
<p>前提：入口js文件、其他js源码放在一个目录下</p>
<pre><code>npx babel js代码文件夹 -d dist/js --presets=babel-preset-env</code></pre>
<p>其中 dist/js 为输出的文件夹</p>
<p>因为这里 babel 是局部安装，所以使用 npx babel 命令，若全局安装可直接使用 babel…</p>
<p>（3）打包</p>
<pre><code>npx browserify dist/js/入口文件.js -o dist/bundle.js</code></pre>
<p>（4）引入编译打包好的文件</p>
<pre><code>&lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</code></pre>
<h1 id="三、ES7-新特性"><a href="#三、ES7-新特性" class="headerlink" title="三、ES7 新特性"></a>三、ES7 新特性</h1><h2 id="1、Array-prototype-includes"><a href="#1、Array-prototype-includes" class="headerlink" title="1、Array.prototype.includes"></a>1、Array.prototype.includes</h2><p>数组.includes(xxx) 方法用来检测数组中是否包含某个元素，返回布尔值</p>
<h2 id="2、指数操作符"><a href="#2、指数操作符" class="headerlink" title="2、指数操作符"></a>2、指数操作符</h2><p>在 ES7 中引入指数运算符 <code>**</code> 实现幂运算，相当于 Math.pow</p>
<pre><code>console.log(2 ** 10);  //1024</code></pre>
<h1 id="四、ES8-新特性"><a href="#四、ES8-新特性" class="headerlink" title="四、ES8 新特性"></a>四、ES8 新特性</h1><h2 id="1、async-和-await"><a href="#1、async-和-await" class="headerlink" title="1、async 和 await"></a>1、async 和 await</h2><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 函数的返回值为 promise 对象，promise 对象的结果由 async 函数执行的返回值决定</p>
<p>async 函数里 return 一个非 Promise 类型的值结果都是一个 Promise 对象，对象的值为 return 的相应的值</p>
<p>并且只要 async 函数 return 的不是一个 Promise 类型对象，都会返回成功的状态，即返回一个成功的 Promise 对象</p>
<p>若在 async 函数中抛出错误，则会返回一个失败的 Promise 对象</p>
<p>若在 async 函数中返回一个 Promise 对象，若 Promise 对象是成功的，则 async 函数也是成功的，且返回的 Promise 中 resolve 的值即为 async 函数返回对象成功的值，若 Promise 对象是失败的，则 async 函数也是失败的</p>
<pre><code>//return 一个非 Promise 类型的对象
async function fn1()&#123;
    return; //只要这里 return 的不是一个 Promise 类型对象，最后函数执行完都会返回一个成功的 Promise 对象
&#125;
//抛出错误
async function fn2()&#123;
    throw new Error(&#39;出错&#39;); //函数执行完会返回一个失败的 Promise 对象
&#125;
//return一个 Promise 对象
async function fn3()&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        resolve(&#39;成功&#39;);  //fn3 返回的结果也是成功的
    &#125;)
&#125;
//return一个 Promise 对象
async function fn4()&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        reject(&#39;失败&#39;);  //fn3 返回的结果也是失败的
    &#125;)
&#125;
const result = fn3();
result.then(value=&gt;&#123;
    console.log(value);  //输出 “成功”
&#125;,reason=&gt;&#123;
    console.log(reason);
&#125;)</code></pre>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await 必须写在 async 函数中，但 async 中可以没有 await</p>
<p>await 右侧的表达式一般为 promise 对象，await 返回的是 promise 成功的值，await 的 promise 失败了就会抛出异常，需要通过 try…catch 捕获处理</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
    resolve(&quot;xxxx&quot;)
&#125;)
async function main() &#123;
    try&#123;
        let result = await p;
        console.log(result);  //输出的就是 p 成功时的 xxx
    &#125;catch(e)&#123;
        console.log(e)
    &#125;
&#125;
main();</code></pre>
<h3 id="async-和-await-结合读取文件"><a href="#async-和-await-结合读取文件" class="headerlink" title="async 和 await 结合读取文件"></a>async 和 await 结合读取文件</h3><p>分别读取 3 个文件并输出</p>
<pre><code>const fs = require(&#39;fs&#39;);
function fn1()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件1.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

function fn2()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件2.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

function fn3()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件3.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

async function main()&#123;
    let data1 = await fn1();
    let data2 = await fn2();
    let data3 = await fn3();
    console.log(data1.toString());
    console.log(data2.toString());
    console.log(data3.toString());
&#125;
main();</code></pre>
<h3 id="async-和-await-结合发送-AJAX-请求"><a href="#async-和-await-结合发送-AJAX-请求" class="headerlink" title="async 和 await 结合发送 AJAX 请求"></a>async 和 await 结合发送 AJAX 请求</h3><pre><code>function fn(url)&#123;
    return new Promise(function(resolve,reject)&#123;
        const xhr = new XMLHttpRequest(); 
        xhr.open(&#39;GET&#39;,url);
        xhr.send();
        xhr.onreadystatechange = function()&#123;
            if(xhr.readyState === 4)&#123;
                if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
                    resolve(xhr.response)
                &#125;else&#123;
                    reject(xhr.status)
                &#125;
            &#125;
        &#125;
    &#125;);
&#125;

async function main()&#123;
    let result = await fn(&#39;http://127.0.0.1/server&#39;);
    console.log(result);
&#125;
main();</code></pre>
<p>注意：axios 发送 AJAX 请求的返回结果就是一个 Promise 对象，所以通过 axios 发送请求，并利用 await 接收结果非常方便</p>
<h2 id="2、ES8-中对象方法的扩展"><a href="#2、ES8-中对象方法的扩展" class="headerlink" title="2、ES8 中对象方法的扩展"></a>2、ES8 中对象方法的扩展</h2><h3 id="Object-value-和-Object-entries"><a href="#Object-value-和-Object-entries" class="headerlink" title="Object.value 和 Object.entries"></a>Object.value 和 Object.entries</h3><p>Object.values() 方法返回一个给定对象的所有可枚举属性值的数组</p>
<p>Object.entries() 方法返回一个给定对象的自身可遍历属性的数组，数组中每个元素又是一个数组 [key,value]</p>
<pre><code>const obj = &#123;
    name: &#39;xx&#39;,
    arr1:[1,2,3]
&#125;
console.log(Object.entries(obj));  //输出 [[&#39;name&#39;, &#39;xx&#39;],[&#39;arr&#39;,[1,2,3]]]
const m = new Map(Object.entries(obj));
conosle.log(m.get(&#39;arr1&#39;));  //输出 [1,2,3]</code></pre>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>Object.getOwnPropertyDescriptors 返回指定对象所有自身属性的描述对象，通过描述对象可以对对象进行深拷贝</p>
<h1 id="五、ES9-新特性"><a href="#五、ES9-新特性" class="headerlink" title="五、ES9 新特性"></a>五、ES9 新特性</h1><h2 id="1、ES9-的扩展运算符与-rest-参数"><a href="#1、ES9-的扩展运算符与-rest-参数" class="headerlink" title="1、ES9 的扩展运算符与 rest 参数"></a>1、ES9 的扩展运算符与 rest 参数</h2><p>rest 参数与 spread 扩展运算符在 ES6 中已经引入，但是 ES6 中只针对数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p>
<pre><code>function connect(&#123;host,port,...user&#125;)&#123;
    console.log(user)  //除了 host 和 port 以外的参数都会存到 user 中，user 是个对象
&#125;
connect(&#123;
    host:&#39;127.0.0.1&#39;,
    port:3306,
    username: &#39;root&#39;,
    password:&#39;root&#39;,
    type:&#39;master&#39;
&#125;)


const obj1 = &#123;att1:&#39;1&#39;&#125;
const obj2 = &#123;att2:&#39;2&#39;&#125;
const obj3 = &#123;att3:&#39;3&#39;&#125;
const obj = &#123;...obj1,...obj2,...obj3&#125; //把三个对象中的属性都合并到对象 obj 中</code></pre>
<h2 id="2、ES9-的正则扩展"><a href="#2、ES9-的正则扩展" class="headerlink" title="2、ES9 的正则扩展"></a>2、ES9 的正则扩展</h2><h3 id="命名捕获分组"><a href="#命名捕获分组" class="headerlink" title="命名捕获分组"></a>命名捕获分组</h3><p>命名捕获分组就是可以给分组匹配的结果命名，方便对结果进行处理</p>
<pre><code>let str = &#39;&lt;a href=&quot;http://127.0.0.1&quot;&gt;标签文本&lt;/a&gt;&#39;
//没有命名捕获分组时
const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/;
const result = reg.exec(str);
console.log(result);  //result 是个数组，result[0]是str，result[1]是 “http://127.0.0.1”，result[2]是 “标签文本”

//有命名捕获分组时
const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;
const result = reg.exec(str);
console.log(result);  //result 中有个 groups 对象属性，该属性中有 url 和 text
console.log(result.groups.url);  //http://127.0.0.1
console.log(result.groups.text); //标签文本</code></pre>
<h3 id="反向断言"><a href="#反向断言" class="headerlink" title="反向断言"></a>反向断言</h3><p>断言：可以根据目标内容的前边和后边来做唯一性识别</p>
<p>正向断言：根据当前匹配的后边的内容来判断匹配的内容是否合法</p>
<pre><code>let str = &#39;JS12345哈哈哈789啦啦啦&#39;
//正向断言：提取789
const reg = /\d+(?=啦)/;  //通过789后边跟着 “啦” 判断
const result = reg.exec(str);</code></pre>
<p>正向断言：根据当前匹配的前边的内容来判断匹配的内容是否合法</p>
<pre><code>let str = &#39;JS12345哈哈哈789啦啦啦&#39;
//正向断言：提取789
const reg = /(?&lt;=哈)\d+/;  //通过789前边跟着 “哈” 判断
const result = reg.exec(str);</code></pre>
<h3 id="dotAll-模式"><a href="#dotAll-模式" class="headerlink" title="dotAll 模式"></a>dotAll 模式</h3><p>dot即 <code>.</code>，<code>.</code> 是元字符，表示除换行符以外的任意单个字符</p>
<p>通过添加模式修正符 <code>\\s</code> 可使 <code>.</code> 匹配任意字符，包括空格和换行，若用模式修正符 <code>\\gs</code> 则会全局匹配，这样方便通配可能出现多个空格多个换行的情况</p>
<p>例子：提取 a 标签和 p 标签中标签文本</p>
<pre><code>let str = `&lt;ul&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
            &lt;/ul&gt;`;
//没有使用dotAll
const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/;
const result = reg.exec(str);
console.log(result);
//使用dotAll
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;  //加 ? 是为了禁止贪婪
let result;
let data = [];
while(result = reg.exec(str))&#123;
    console.log(result);  //当匹配不到时是 NaN
    data.push(&#123;a:result[1],p:result[2]&#125;)
&#125;
console.log(data)</code></pre>
<h1 id="六、ES10-新特性"><a href="#六、ES10-新特性" class="headerlink" title="六、ES10 新特性"></a>六、ES10 新特性</h1><h2 id="1、ES10-的对象扩展方法-————-Object-fromEntries"><a href="#1、ES10-的对象扩展方法-————-Object-fromEntries" class="headerlink" title="1、ES10 的对象扩展方法 ———— Object.fromEntries"></a>1、ES10 的对象扩展方法 ———— Object.fromEntries</h2><p>Object.fromEntries 用于创建对象，参数为二维数组或 Map</p>
<pre><code>const result = Object.fromEntries([
    [&#39;name&#39;,&#39;xx&#39;],
    [&#39;arr&#39;,&#39;1,2,3,4&#39;]
])
const m = new Map()
m.set(&#39;name&#39;,&#39;xxx&#39;)
const result = Object.fromEntries(m);</code></pre>
<p>ES8 中 Object.entries 可将对象转化为二维数组</p>
<pre><code>cosnt arr = Object.entries(&#123;
    name: &#39;xxx&#39;
&#125;);  //返回一个数组，第一个元素为键名，第二个元素为键值</code></pre>
<p>因此 Object.fromEntries 和 Object.entries 相当于逆运算，前者将二维数组转化为对象，后者将对象转化为二维数组</p>
<h2 id="2、ES10-的字符串扩展方法-————-trimStart-和-trimEnd"><a href="#2、ES10-的字符串扩展方法-————-trimStart-和-trimEnd" class="headerlink" title="2、ES10 的字符串扩展方法 ———— trimStart 和 trimEnd"></a>2、ES10 的字符串扩展方法 ———— trimStart 和 trimEnd</h2><p>trimStart 和 trimEnd 用于指定清除字符串左侧或右侧空白字符</p>
<pre><code>let str = &#39;   hello   &#39;
console.log(str.trimStart());
console.log(str.trimEnd());</code></pre>
<h2 id="3、ES10-的数组扩展方法-————-flat-和-flatMap"><a href="#3、ES10-的数组扩展方法-————-flat-和-flatMap" class="headerlink" title="3、ES10 的数组扩展方法 ———— flat 和 flatMap"></a>3、ES10 的数组扩展方法 ———— flat 和 flatMap</h2><p>flat(深度) 能将多维数组转化为低维数组，深度默认是 1</p>
<pre><code>const arr = [1,2,3,[4,5,6]];  //二维数组
console.log(arr.flat());  //输出[1,2,3,4,5,6]
const arr = [1,2,3,[4,5,6,[7,8,9]]];  //三维数组
console.log(arr.flat()); //输出二维数组[1,2,3,4,5,6,[7,8,9]]
console.log(arr.flat(2)); //输出一维数组[1,2,3,4,5,6,7,8,9]</code></pre>
<p>flatMap 是对 Map 结果作维度降低</p>
<pre><code>const arr1 = [1,2,3,4];
const result = arr1.map(item =&gt; item * 10);
console.log(result); //输出[10,20,30,40]

const result = arr1.map(item =&gt; [item * 10]);
console.log(result); //输出二维数组[[10],[20],[30],[40]]

const result = arr1.flatMap(item =&gt; [item * 10]);
console.log(result); //输出一维数组[10,20,30,40]</code></pre>
<h2 id="4、ES10-的-Symbol-扩展方法-————-Symbol-prototype-description"><a href="#4、ES10-的-Symbol-扩展方法-————-Symbol-prototype-description" class="headerlink" title="4、ES10 的 Symbol 扩展方法 ———— Symbol.prototype.description"></a>4、ES10 的 Symbol 扩展方法 ———— Symbol.prototype.description</h2><pre><code>let s = Symbol(&#39;hello&#39;);
console.log(s.description);  //输出 hello</code></pre>
<h1 id="七、ES11-新特性"><a href="#七、ES11-新特性" class="headerlink" title="七、ES11 新特性"></a>七、ES11 新特性</h1><h2 id="1、私有属性"><a href="#1、私有属性" class="headerlink" title="1、私有属性"></a>1、私有属性</h2><p>私有属性在类的外部无法得到其结果，只能通过类内的方法来访问</p>
<pre><code>class Person&#123;
    //公有属性
    name;
    //私有属性
    #age;
    #weight;
    //构造方法
    constructor(name,age,weight)&#123;
        this.name = name;
        this.#age = age;
        this.#weight = weight;    
    &#125;
    intor()&#123;
        console.log(this.name);
        console.log(this.#age);
        console.log(this.#weight);
    &#125;
&#125;
const girl = new Person(&#39;xxx&#39;,18,&#39;50kg&#39;);
console.log(girl.#age);  //报错 Private field &#39;#age&#39; must be declared in an enclosing class
girl.intro();  //不报错</code></pre>
<h2 id="2、Promise-allSettled"><a href="#2、Promise-allSettled" class="headerlink" title="2、Promise.allSettled"></a>2、Promise.allSettled</h2><p>Promise.allSettled 接收 Promise 数组，总是返回成功的 Promise 对象，成功的值是个数组，数组中每个元素是对象{status,value 或 reason}</p>
<pre><code>const p1 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据1&#39;);
    &#125;,1000)
&#125;);
const p2 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据2&#39;);
    &#125;,1000)
&#125;);
const result = Promise.allSettled([p1,p2]);
console.log(result);</code></pre>
<p>类似的方法有 Promise.all，也是接收 Promise 数组，返回 Promise 对象，但返回的 Promise 对象是否为成功由数组中每个 Promise 对象的状态决定，只要有一个 Promise 对象失败则 all 方法返回的 Promise 对象也是失败</p>
<p>all 方法成功的值为数组，数组中的元素是接收的 Promise 对象成功的值，all 方法失败的值为接收的 Promise 对象中失败的那个的失败的值</p>
<pre><code>const p1 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据1&#39;);
    &#125;,1000)
&#125;);
const p2 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据2&#39;);
    &#125;,1000)
&#125;);
const result = Promise.all([p1,p2]);</code></pre>
<h2 id="3、ES11-的字符串扩展方法-————-Sting-prototype-matchAll"><a href="#3、ES11-的字符串扩展方法-————-Sting-prototype-matchAll" class="headerlink" title="3、ES11 的字符串扩展方法 ———— Sting.prototype.matchAll"></a>3、ES11 的字符串扩展方法 ———— Sting.prototype.matchAll</h2><p>Sting.prototype.matchAll 用于得到正则批量匹配的结果</p>
<pre><code>let str = `&lt;ul&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
            &lt;/ul&gt;`;
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
const result = str.matchAll(reg); //返回的结果是一个可迭代对象
for(let v of result)&#123;  //或者使用扩展运算符 const arr = [...result];
    console.log(v);
&#125;</code></pre>
<h2 id="4、可选链操作符"><a href="#4、可选链操作符" class="headerlink" title="4、可选链操作符"></a>4、可选链操作符</h2><p>可选链操作符 <code>?.</code>，当面对对象类型的参数时，若对象深度较深，则通过可选链操作符后无需作层级判断</p>
<p>例子：获取 db 中的 host</p>
<pre><code>function main(config)&#123;
    //原先的方法
    const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host; //但是当没有db对象或 db 中没有 host 属性时会报错
    //使用可选链操作符
    const dbHost = config?.db?.host;  //此时若没有db对象或 db 中没有 host 属性时也不会报错会输出 undefined，只有当前的属性存在时才会读后面的属性
&#125;
main(&#123;
    db: &#123;
        host:&#39;192.168.1.100&#39;
        username: &#39;root&#39;
    &#125;,
    cahce: &#123;
        host:&#39;192.168.1.200&#39;
        username: &#39;admin&#39;
    &#125;
&#125;)</code></pre>
<h2 id="5、动态-import"><a href="#5、动态-import" class="headerlink" title="5、动态 import"></a>5、动态 import</h2><p>通过动态 import 可实现按需加载，提高加载效率，import 方法返回的是 Promise 对象，语法：<code>import(文件).then(module =&gt; &#123;&#125;)</code></p>
<pre><code>//文件hello.js
export function hello()&#123;
    alert(&#39;hello&#39;);
&#125;
//入口文件app.js
//在 ES11 之前使用 import * as m1 from &#39;./hello.js&#39; 静态导入模块
cosnt btn = document.getElementById(&#39;#btn&#39;);
btn.onclick = function()&#123;
    //ES11 中动态导入模块
    import(&#39;./hello.js&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;)
&#125;</code></pre>
<h2 id="6、ES11-引入的数据类型-————-BigInt"><a href="#6、ES11-引入的数据类型-————-BigInt" class="headerlink" title="6、ES11 引入的数据类型 ———— BigInt"></a>6、ES11 引入的数据类型 ———— BigInt</h2><p>大整型通过 <code>整数n</code> 表示</p>
<p>通过 BigInt() 函数可将整数转为大整型</p>
<pre><code>let n = 123;
console.log(BigInt(n));  //输出 123n</code></pre>
<p>BigInt() 函数可用于大数值运算，注意 BigInt 类型数据不能直接和普通 int 作运算</p>
<pre><code>let max = NUMBER.MAX_SAFE_INTEGER;
console.log(max);  //9007199254740991
console.log(max + 1);  //9007199254740992
console.log(max + 2);  //9007199254740992

console.log(BinInt(max));  //9007199254740991n
console.log(BinInt(max) + BigInt(1));  //9007199254740992n
console.log(BinInt(max) + BigInt(2));  //9007199254740993n</code></pre>
<h2 id="7、绝对全局对象-globalThis"><a href="#7、绝对全局对象-globalThis" class="headerlink" title="7、绝对全局对象 globalThis"></a>7、绝对全局对象 globalThis</h2><p>globalThis 始终指向全局对象，无论执行环境是什么（如浏览器、Nodejs 等）</p>
<pre><code>//在浏览器中
console.log(globalThis);  //window 对象
//在 Nodejs 中
console.log(globalThis);  //输出 Object [global]</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>AngularJS学习笔记</title>
    <url>/2022/01/12/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
