<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++学习笔记</title>
    <url>/2021/10/04/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>面向对象编程（OOP）本质是设计并扩展自己的数据类型</p>
<a id="more"></a>

<p>C++对大小写敏感</p>
<p>在C++程序中包含C语言，只需加入头文件<code>&lt;stdio.h&gt;</code></p>
<p><code>#include</code> 预处理器编译指令</p>
<p><code>using namespace xxx</code> 编译指令</p>
<p><code>main()</code> 由启动代码调用，启动代码链接程序与操作系统由编译器添加到程序中</p>
<p>独立的C++程序必须由 <code>main()</code> 函数，运行时通常从 <code>main()</code> 函数开始执行</p>
<p>C中的头文件以.h为扩展名，而在C++中省去扩展名，并使用名称空间</p>
<p>名称空间是为了当组合多个程序时，多个程序中包含相同函数名的函数时，使编译器辨别所使用的函数来自哪个程序。</p>
<p>当使用 <code>#include&lt;iostream&gt;</code> 时，cin、cout、endl等都在std名称空间中，应使用如std::cout来表示</p>
<p>使用 <code>#include&lt;iostream.h&gt;</code> 与 cout 等价于 使用 <code>#include&lt;iostream&gt;</code> 与 std::cout</p>
<p>为了简化编程，可使用using编译指令 <code>using namespace std</code> 来允许程序使用std名称空间中的所有名称，若该 using 编译指令放在函数中则作用范围为相应函数，也可放在多个函数外且在函数前，则多个函数均可使用该名称空间中的对象。但对于大型程序，仅在使用时加上名称空间更好</p>
<p>cin 和 cout 分别时 istream 和 ostream 类的对象，通过重新定义插入运算符 &gt;&gt; 和 &lt;&lt; 将字符插入输入流或输出流中</p>
<p><strong>函数原型与函数定义</strong></p>
<p>函数原型：函数接口</p>
<p>函数定义：包括函数头、函数体等，即函数的具体执行流程</p>
<p>C++程序中使用的每个函数都需要有原型，如 <code>double sqrt(double);</code> （注意分号），原型可以在程序中给出，也可以在头文件中给出并在程序中包含头文件。若在 main 函数中使用用户自定义函数，应把函数原型放在 main 函数之前，可将自定义函数的源码放在 main 之后。C++不能在一个函数定义嵌套在另一个函数定义中</p>
<p>main函数的返回 <code>return 0</code> 是返回给操作系统</p>
<p><strong>函数特性：</strong>函数头和函数体+参数+返回值+原型</p>
<p>C++中整型包括short、int、long、long long（与C不同之处），这些整型都是有符号的</p>
<p><climits>或&lt;limits.h&gt;文件中定义了一些符号常量，如CHAR_BIT（字节的位数）</climits></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客</title>
    <url>/2021/08/05/Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>进入hexo安装的根目录</p>
<a id="more"></a>

<p><strong>新建博客：</strong><code>hexo n “博客名字”</code></p>
<p><strong>本地查看：</strong><code>hexo s</code></p>
<p><strong>清除缓存：</strong><code>hexo clean</code></p>
<p><strong>博客生成：</strong><code>hexo g</code></p>
<p><strong>部署到github：</strong><code>hexo d</code></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2021/11/19/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="廖雪峰的-JavaScript-教程笔记"><a href="#廖雪峰的-JavaScript-教程笔记" class="headerlink" title="廖雪峰的 JavaScript 教程笔记"></a>廖雪峰的 JavaScript 教程笔记</h1><a id="more"></a>

<h2 id="一些背景知识"><a href="#一些背景知识" class="headerlink" title="一些背景知识"></a>一些背景知识</h2><p>只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互</p>
<p>Node.js把JavaScript引入到了服务器端</p>
<p>JavaScript（对ECMAScript标准的一种实现）又称ECMAScript（一种语言标准）、ES6（ECMAScript 6）、ES2015（ECMAScript 2015）</p>
<p>Babel 是 JavaScript 转译器（也称源代码编译器），将使用了 ECMAScript 语言特性的 JavaScript 转换为只使用广泛支持的 ES5（ECMAScript 2009） 特性的等价代码。如Node.js使用的是 CommonJS 模块的 require 语法，之前不支持 import（不支持原生的ES6模块），则要用 babel 转译 js 模块为 CommonJS 模块</p>
<p>Webpack、Browserify 等打包工具主要是将 ES6 代码转译为 ES5 的 js 文件生成传统的代码包</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1、原始数据类型：数、字符串、布尔值、Symbol（ES6）、null、undefined</p>
<p>2、派生数据类型：对象（如：函数、数组、正则表达式）</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript严格区分大小写</p>
<p>JavaScript不区分整数和浮点数，统一用Number表示</p>
<p><strong>== 和 === 的区别</strong>：== 会自动转换数据类型再比较，有时会得到奇怪的结果；=== 不会自动转换数据类型，若数据类型不一致，返回false，若一致，再比较。（JavaScript的设计缺陷，一般使用 === ）</p>
<p>在 == 比较中，遇到比较的一方有数，则全部自动 toNumber(x) 转为数后比较，其中 toNumber(包含字母字符串) -&gt; NaN，toNumber(undefined) -&gt; NaN，toNumber(null) -&gt; +0；</p>
<p>若比较的一方中有布尔值，则布尔值先被 toNumber(x) 转为数；</p>
<p>若比较的一方中有对象，则对象会被 toPrimitive(x) 转为字符串或数</p>
<p>在 === 比较中，类型相同则正常比较（除 NaN 外），类型不同则为 false，不同对象比较也为 false</p>
<pre><code>//判断是否为NaN
NaN === NaN; // false
isNaN(NaN); // true（唯一判断NaN的方法）

null == undefined; //true

//浮点数比较
1 / 3 === (1 - 2 / 3); // false（因为计算机无法精确表示无限循环小数，浮点数运算时会产生误差）
Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true（只能计算浮点数之差的绝对值是否小于某阈值来比较两浮点数是否相等）</code></pre>
<p><strong>null 和 undefined：</strong>null 为空值，undefined 为未定义，一般用 null，undefined 仅在判断函数参数是否传递的情况下有用</p>
<p>JavaScript的一个数组中可以包含多种类型</p>
<p>JavaScript是变量本身类型不固定的动态语言，而静态语言（强类型语言）在定义变量时必须指定变量类型，如Java</p>
<p><strong>变量是否用 var 声明：</strong>通过 var 声明的变量作用域为该变量被申明的函数体内。如果一个变量没有通过 var 申明就被使用，则该变量自动被申明为全局变量，这导致不同js文件中未通过 var 声明的同名变量间会相互影响（JavaScript设计缺陷）————解决：在代码第一行写上 <code>&#39;use strict&#39;;</code> 启用strict模式,在strict模式下运行的JavaScript代码，强制通过 var 声明变量，使用未通过 var 声明的变量会报错</p>
<p><strong>let 和 var：</strong>在同一作用域内重复声明变量，let会报错，var不会报错</p>
<p><strong>const：</strong>const声明的变量是只读变量，若对 const 声明的变量重新用 let 或 var 声明会报错。且对于非对象类型（如数、布尔值、字符串）不可改变其值，但对于 const 声明的对象可改变其属性值，但不可对对象整体重新赋值（即变量本身的引用（内存中的引用地址）不可改）。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>引号：</strong>字符串中包含单引号、双引号前面加转义符 <code>\</code> ，多行字符串用用 <code>\n</code> 表示（较早）或用反引号 `` （ES6）</p>
<p><strong>模板字符串：</strong>用反引号括起来，其中用 <code>$&#123;变量名&#125;</code> 来表示相应值（ES6）</p>
<p><strong>索引：</strong>字符串可以像数组一样通过索引取值，但不可通过索引赋值</p>
<p><strong>部分方法：（调用时不改变原字符串，而是返回一新字符串）</strong></p>
<pre><code>toUpperCase()     //变大写，str.toUpperCase()
toLowerCase()     //变小写，str.toLowerCase()
indexOf()     //搜索指定字符串出现的位置，空格也占一位置，str.indexOf(&#39;xxx&#39;);
substring(开始索引，结束索引) 或 substring(开始索引)     //返回指定索引区间的子串，左闭右开，str.substring(0, 5);</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>长度：</strong><code>数组.length</code>，给 length 属性赋值会改变原数组大小，并且若通过数组索引赋值时索引超出原大小也会改变数组大小</p>
<p><strong>部分方法：</strong></p>
<pre><code>indexOf()     //搜索指定的元素的位置，arr.indexOf(xxx)
slice() 或 slice(开始索引，结束索引)     //返回指定索引区间元素，左闭右开，返回一个新数组，若无参则包含所有元素（可用于复制数组）
push(元素1,元素2,...)     //在末尾添加元素，可加多个
pop()     //返回并删除末尾元素，空数组 pop 不报错，返回 undefined
unshift(元素1,元素2,...)     //在头部添加元素，可加多个
shift()     //返回并删除头部元素
sort()     //排序，直接改变原数组，arr.sort()
reverse()     //倒序，直接改变原数组，arr.reverse()
splice(删除和添加的开始索引, 删除个数, 添加元素1, 添加元素2, ...)     //删除和添加元素
concat()     //连接数组，返回新数组，arr1.concat(arr2)
join(用于连接的字符)     //数组连成字符串</code></pre>
<p><strong>展开运算符：</strong>在ES5中可用 <code>apply()</code> 把数组转为参数，ES6中可直接用 <code>...数组名</code></p>
<p>JavaScript 中数组是可修改对象，若添加元素，它就会动态增长</p>
<p>JavaScript 只支持一维数组，不支持矩阵，可通过数组嵌套数组来实现矩阵</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>ES5创建</p>
<pre><code>function 类名(变量1,...,变量n)&#123;
    this.属性1=变量1
    this.属性n=变量n
&#125;
类名.prototype.方法名 = function()&#123;xxxxx&#125;</code></pre>
<p>ES6创建</p>
<pre><code>class 类名&#123;
    constructor(变量1,...,变量n)&#123;
        this.属性1=变量1
        this.属性n=变量n
    &#125;
    方法名()&#123;xxxxx&#125;
&#125;</code></pre>
<p>继承</p>
<pre><code>class 子类名 extends 父类 &#123;
    constructor(变量1,...,变量n)&#123;
        super(变量1,...,变量n-1)  //调用父类构造函数
        this.属性n=变量n
    &#125;
    方法名()&#123;xxxxx&#125;
&#125;</code></pre>
<p>js 的面向对象编程还是基于原型实现的，ES6的类是基于原型语法的语法糖</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是类的实例</p>
<p>特殊属性名声明时用 <code>&#39;&#39;</code> 括起来，访问它时不用 <code>对象.属性</code>，而用 <code>对象[&#39;属性&#39;]</code></p>
<p>访问不存在的属性返回 undefined</p>
<p>删除属性 <code>delete 对象.属性</code> 或 ``</p>
<h2 id="真假值"><a href="#真假值" class="headerlink" title="真假值"></a>真假值</h2><p>null、undefined、false、+0、-0、NaN、空字符串、不存在的对象属性为假，其余正常变量（如：1、-1）或对象（如：new String(‘’)、new Boolean(false)）为真</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>箭头函数可省略关键字 function，若函数体只有一行还可省略 {} 和 return（ES6）</p>
<p>函数的参数可设置默认值（ES6）</p>
<p>函数中有一个内置对象 <code>arguments</code>（数组），包含函数被调用时传入的参数</p>
<p>可用展开运算符代替 arguments 来表示剩余参数，如 <code>function a(x,y,...剩余参数整体的名字)</code></p>
<h2 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h2><p>1、用 let 和 const 声明变量替代 var，作用域行为</p>
<p>2、模板字面量</p>
<p>3、解构：（1）一次初始化多个变量 <code>let &#123;x,y&#125;=&#123;&#39;a&#39;,&#39;b&#39;&#125;</code>（2）互换值 <code>[x,y]=[y,x]</code>（3）属性简写（给属性同名变量赋值后即可表示对象）</p>
<p>4、展开运算符：（1）数组展开（2）表示剩余函数参数</p>
<p>5、箭头函数</p>
<p>6、函数可设置参数默认值</p>
<p>7、类</p>
<p>8、模块：使用 <code>export &#123;函数1，变量1，函数n&#125;</code> 导出，<code>import &#123;函数1，变量1，函数n&#125; from 文件</code> 导入</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>1、相比于放在 <head> 标签里或使用 include 语句，在关闭 </head><body> 标签前引入 js 代码使得浏览器在加载脚本前解析和显示 HTML，有利于提升页面性能</body></p>
<p>2、在类中声明函数时，可使用 prototype 方法来节约内存和降低实例化的开销。因为在类中声明函数时若通过 <code>类.prototype.方法 = function () &#123;xxxxx&#125;</code> 则函数只会被创建一次并在所有实例中共享；而通过在类定义里声明函数，则每个实例都会创建一个函数副本</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 是开源的、渐进式包含类型的 JavaScript 超集，它为 JavaScript 变量提供类型支持，TypeScript 会被编译为简单的 JavaScript 代码。虽然 TypeScript 在编译时会进行类型和错误检查，但错误不会阻止编译器生成 JavaScript 代码</p>
<p><strong>定义变量</strong></p>
<pre><code>let a: tring = &#39;x&#39;
let a: number = 10
let a: boolean</code></pre>
<p><strong>接口</strong></p>
<p>第一种：自定义一种数据类型</p>
<p>第二种：与面向对象编程相关</p>
<pre><code>interface 接口 &#123;
    函数1(参数): 类型
&#125;
class 类 implements 接口 &#123;
    变量: 类型
    函数1(参数): 类型&#123;xxx&#125;
&#125;</code></pre>
<p><strong>泛型</strong>：指定函数的参数类型</p>
<pre><code>interface 接口 &lt;参数类型&gt; &#123;
    函数1(参数): 类型
&#125;
class 类 implements 接口 &#123;
    变量: 类型
    函数1(参数:参数类型): 类型&#123;xxx&#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL数据库的安装和配置</title>
    <url>/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="下载MySQL安装包"><a href="#下载MySQL安装包" class="headerlink" title="下载MySQL安装包"></a>下载MySQL安装包</h1><p>进入<a href="https://dev.mysql.com/downloads/">官网</a>，选择 <code>MySQL Community Server</code>，再选择下载.zip压缩包。若选择下载 <code>MYSQL Installer for Windows</code> 则是得到一个.msi文件</p>
<a id="more"></a>

<p>点击 <code>No thanks, just start my download.</code> 开始下载，下载完成后解压zip压缩包</p>
<p>将解压后 bin 文件夹所在的路径添加到电脑环境变量的系统变量中</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/systemvariable.png" alt="添加系统变量"></p>
<h1 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h1><p>在解压后的 <code>mysql-5.7.26-winx64</code> 文件夹中新建 <code>my.ini</code> 文件，文件中贴入如下代码</p>
<pre><code>[client]
port=3306
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld] 
#设置3306端口 
port = 3306 
# 设置mysql的安装目录 
basedir=D:\MySQL\mysql-5.7.26-winx64
# 设置mysql数据库的数据的存放目录 
datadir=D:\MySQL\mysql-5.7.26-winx64\data
# 允许最大连接数 
max_connections=200 
# 服务端使用的字符集默认为8比特编码的latin1字符集 
character-set-server=utf8 
# 创建新表时将使用的默认存储引擎 
default-storage-engine=INNODB</code></pre>
<p><strong>初始化配置：</strong>使用命令 <code>mysqld --initialize --console</code> 初始化 mysql ，此时会根据配置生成 mysql 数据库的数据的存放目录</p>
<p><strong>安装mysql：</strong>使用命令 <code>mysqld -install</code> 安装 mysql</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p><strong>以管理员身份运行</strong></p>
<p><strong>启动 mysql 服务器：</strong><code>net start mysql</code></p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/startmysql.png" alt="启动 mysql 服务器"></p>
<p><strong>登录 mysql 服务器：</strong>在安装 mysql 的 bin 目录下输入 <code>mysql -u root -p</code> 回车并输入密码（其中root是指用户名，可以是其他用户名，-p是指使用密码）</p>
<p><strong>停止 mysql 服务：</strong><code>net stop mysql</code></p>
<p><strong>忘记或修改密码：</strong></p>
<p>首先输入 <code>mysql -u root</code> 不使用密码登录 mysql</p>
<p>输入 <code>set password for 用户名@localhost = password(&#39;新密码&#39;);</code> 修改密码</p>
<p>输入 <code>exit</code> 或 <code>quit</code> 退出 mysql</p>
<p>使用 <code>mysql -u root -p</code> 回车并输入密码重新登录 mysql 即可</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/resetpwd.png" alt="修改密码"></p>
<h1 id="MySQL可视化工具"><a href="#MySQL可视化工具" class="headerlink" title="MySQL可视化工具"></a>MySQL可视化工具</h1><p>可以使用 <strong>Navicat for MySQL</strong> 作为 MySQL 的可视化工具</p>
<p>点击 <code>连接</code> ，或 <code>文件-&gt;新建连接</code> ，取个连接名，输入密码后点击连接测试，弹出连接成功字样然后点击确定即可</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/connect.png" alt="Navicat连接"></p>
<p>一个连接下可以添加多个数据库，双击数据库即可看到数据库下的表，如下图所示，这里是之前已添加过多个数据库</p>
<p><img src="/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/db.png" alt="Navicat可视化"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>PC端Chrome调试安卓手机WebView</title>
    <url>/2021/09/15/PC%E7%AB%AFChrome%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAWebView/</url>
    <content><![CDATA[<h1 id="安卓手机端："><a href="#安卓手机端：" class="headerlink" title="安卓手机端："></a>安卓手机端：</h1><p>1、进入开发者模式</p>
<a id="more"></a>

<p>不同手机进入开发者模式的方式不同，以华为手机为例，设置-&gt;点击“关于本机”-&gt;多次连续点击版本号</p>
<p>2、允许USB调试</p>
<p>以华为手机为例，设置-&gt;“系统”-&gt;“开发者选项”-&gt;打开允许USB调试</p>
<p>3、连接电脑</p>
<p>通过数据线将手机连接电脑，在弹出的窗口中选择“传输文件”或“传输照片”模式</p>
<h1 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h1><p>在Chrome浏览器中输入chrome://inspect/#devices可查看当前连接的设备以及在手机端访问的网页，点击“inspect”即可对该网页进行调试</p>
<p><img src="/2021/09/15/PC%E7%AB%AFChrome%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAWebView/inspect.png" alt="inspect"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Vue3+Django+MySQL搭建项目</title>
    <url>/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="一、创建Django项目"><a href="#一、创建Django项目" class="headerlink" title="一、创建Django项目"></a>一、创建Django项目</h1><a id="more"></a>

<h2 id="1-1-安装Django"><a href="#1-1-安装Django" class="headerlink" title="1.1 安装Django"></a>1.1 安装Django</h2><p>在 pycharm 中新建一个项目，确保该项目所使用的 python 解释器已安装 django。若没有则安装 django</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/installdjango.png" alt="installdjango"></p>
<p>若没有使用 IDE 可以通过 <code>pip install django</code> 进行安装</p>
<p>在终端输入 <code>django-admin</code>，出现如下输出则安装成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/django-admin.png" alt="django-admin"></p>
<h2 id="1-2-创建Django项目"><a href="#1-2-创建Django项目" class="headerlink" title="1.2 创建Django项目"></a>1.2 创建Django项目</h2><p>选择一个文件夹位置作为根目录，创建一个新项目 <code>django-admin startproject 项目名</code><br>会生成如下目录结构</p>
<pre><code>-根目录
 --django项目
  ---django项目同名文件夹
  ---manage.py</code></pre>
<p>这里我把 项目同名文件夹 和 manage.py 都移到根目录下，这一步不是必须的，看个人习惯。新的目录结构如下</p>
<pre><code>-根目录
 --django项目
 --manage.py</code></pre>
<p><strong>提示：下面的所有操作是基于新目录结构下的操作</strong></p>
<h2 id="1-3-启动Django项目"><a href="#1-3-启动Django项目" class="headerlink" title="1.3 启动Django项目"></a>1.3 启动Django项目</h2><p>在 manage.py 文件所在目录下使用 <code>python manage.py runserver</code> 运行</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/runserver.png" alt="runserver"></p>
<p>在浏览器中打开相应网址 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> （一般默认在8000端口）出现如下页面，则 django 项目启动成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8000-1.png" alt="8000-1"></p>
<h1 id="二、创建Vue项目"><a href="#二、创建Vue项目" class="headerlink" title="二、创建Vue项目"></a>二、创建Vue项目</h1><p>搭建vue项目需要nodejs+npm+vue</p>
<h2 id="2-1-安装-nodejs-npm"><a href="#2-1-安装-nodejs-npm" class="headerlink" title="2.1 安装 nodejs+npm"></a>2.1 安装 nodejs+npm</h2><p>可参考<a href="https://www.beingjay.com/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/">前面的博客</a>安装 nodejs</p>
<p>安装后使用命令 <code>node -v</code> 检查 nodejs 是否安装成功</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/node-v.png" alt="node-v"></p>
<p>使用 <code>npm -v</code> 查看 npm 版本</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/npm-v.png" alt="npm-v"></p>
<h2 id="2-2-安装Vue"><a href="#2-2-安装Vue" class="headerlink" title="2.2 安装Vue"></a>2.2 安装Vue</h2><p>在终端使用 <code>npm install vue-cli -g</code> 或 <code>npm install @vue/cli -g</code> 全局安装vue</p>
<p>其中第一条命令安装的是3.0以前的版本，第二条命令是安装3.0以后的最新版本。或使用 <code>npm install @vue/cli@x.x.x -g</code> 安装指定版本</p>
<p>（可使用命令 <code>npm uninstall vue-cli -g</code> 卸载已安装的vue）</p>
<p>全局安装Vue后，使用命令 <code>vue --version</code> 或 <code>vue -V</code> 查看版本从而检查是否安装成功</p>
<h2 id="2-3-创建一个Vue项目"><a href="#2-3-创建一个Vue项目" class="headerlink" title="2.3 创建一个Vue项目"></a>2.3 创建一个Vue项目</h2><p><strong>在manage.py同级目录下</strong>，对于Vue3.0以后的版本使用命令 <code>vue create 项目名</code> 来创建一个新的vue项目</p>
<p>创建时会出现如下三个选项，分别是默认的vue2相关依赖、vue3相关依赖、手动选择相关依赖</p>
<pre><code>Default （[Vue 2] babel，eslint）
Default （[Vue 3]）（[Vue 3] babel，eslint）
Manually select features</code></pre>
<p>可按需求自行选择，（若不太懂可以选择 Default（Vue 3） 安装），也可选择第三项自定义安装所需依赖，我的选择如下，</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vue_manually.png" alt="vue_manually"></p>
<p>Babel是负责编译、Router负责路由管理、VueX负责状态存储和数据流通、Linter/Formatter负责对语法和代码格式进行检查</p>
<p>其他选项根据提示也进行按需选择</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vue_setting.png" alt="vue_setting"></p>
<p>此时目录结构已变为</p>
<pre><code>-根目录
 --django项目
 --manage.py
 --vue项目</code></pre>
<h2 id="2-4-Vue项目启动"><a href="#2-4-Vue项目启动" class="headerlink" title="2.4 Vue项目启动"></a>2.4 Vue项目启动</h2><p>创建好后需要进入Vue项目文件夹，在Vue项目根目录下使用 <code>npm run serve</code> 启动项目</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/runserve.png" alt="runserve"></p>
<h2 id="2-5-浏览器查看"><a href="#2-5-浏览器查看" class="headerlink" title="2.5 浏览器查看"></a>2.5 浏览器查看</h2><h3 id="2-5-1-PC端"><a href="#2-5-1-PC端" class="headerlink" title="2.5.1 PC端"></a>2.5.1 PC端</h3><p>在本机浏览器中输入 Local 或 Network 中的网址可查看（一般默认在8080端口）</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8080.png" alt="8080"></p>
<h3 id="2-5-2-移动端"><a href="#2-5-2-移动端" class="headerlink" title="2.5.2 移动端"></a>2.5.2 移动端</h3><p>在手机上输入 Network 的网址也可进行查看，前提是手机与运行项目的主机在同一局域网内。</p>
<p>若不在一个局域网内，则现在终端使用命令 <code>ipconfig</code> 查看主机地址，然后通过 IP 访问</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/ipconfig.png" alt="ipconfig"></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8080-mobile.png" alt="8080-mobile"></p>
<h1 id="三、安装MySQL"><a href="#三、安装MySQL" class="headerlink" title="三、安装MySQL"></a>三、安装MySQL</h1><p>可参考<a href="https://www.beingjay.com/2021/08/05/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">前面的博客</a>安装 MySQL</p>
<h1 id="四、Vue-Django连接"><a href="#四、Vue-Django连接" class="headerlink" title="四、Vue+Django连接"></a>四、Vue+Django连接</h1><h2 id="4-1-Vue配置"><a href="#4-1-Vue配置" class="headerlink" title="4.1 Vue配置"></a>4.1 Vue配置</h2><p>由于Vue3在打包项目后生成的 dist 文件夹中不会生成 static 子文件夹，而 django 项目查找静态资源时只会查找 static 文件夹，因此在Vue项目目录下新建一个 <strong>vue.config.js</strong> 文件，文件中添加如下代码</p>
<pre><code>module.exports = &#123;
    // 输出目录
    assetsDir: &#39;static&#39;,
&#125;;</code></pre>
<p>这样在使用 <code>npm run build</code> 进行项目打包时生成的 dist 文件夹下包含 static 文件夹，静态资源都存放在 static 文件夹中</p>
<h2 id="4-2-Django配置"><a href="#4-2-Django配置" class="headerlink" title="4.2 Django配置"></a>4.2 Django配置</h2><h3 id="（1）前端资源路径配置"><a href="#（1）前端资源路径配置" class="headerlink" title="（1）前端资源路径配置"></a>（1）前端资源路径配置</h3><p>在 django项目-&gt;settings.py 文件里的 DIRS 一项中添加打包后的Vue项目所在路径，这里是 <code>&#39;vue项目名/dist&#39;</code>,</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/templates.png" alt="templates"></p>
<h3 id="（2）前端入口文件路径配置"><a href="#（2）前端入口文件路径配置" class="headerlink" title="（2）前端入口文件路径配置"></a>（2）前端入口文件路径配置</h3><p>在 django项目-&gt;url.py 文件中添加Vue项目入口文件 index.html 作为后端启动页</p>
<pre><code>from django.contrib import admin
from django.urls import path
from django.views.generic import TemplateView

urlpatterns = [
    path(&#39;admin/&#39;, admin.site.urls),
    path(&#39;&#39;, TemplateView.as_view(template_name=&quot;index.html&quot;)),  #添加入口文件
]</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/urlpatterns.png" alt="urlpatterns"></p>
<h3 id="（3）静态资源路径配置"><a href="#（3）静态资源路径配置" class="headerlink" title="（3）静态资源路径配置"></a>（3）静态资源路径配置</h3><p>同样是在 setting.py 文件中添加静态资源引用地址</p>
<pre><code>FRONTEND_ROOT = &#39;vue项目名/dist&#39;
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, FRONTEND_ROOT),
    os.path.join(BASE_DIR, FRONTEND_ROOT + &#39;/static/&#39;),
)</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/staticfiles.png" alt="staticfiles"></p>
<h2 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h2><p>同时运行 Vue 项目（非必须，但前提是vue项目以打包生成dist文件夹）和 django 项目，在浏览器<a href="http://127.0.0.1:8000/%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%88%E5%8D%B3django%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%B5%E4%B8%AD%E6%98%BE%E7%A4%BAVue%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%89%EF%BC%8C%E6%AD%A4%E6%97%B6vue%E9%A1%B9%E7%9B%AE%E5%92%8Cdjango%E9%A1%B9%E7%9B%AE%E5%85%B3%E8%81%94%E6%88%90%E5%8A%9F">http://127.0.0.1:8000/路径下看到如下页面（即django项目的启动页中显示Vue项目的内容），此时vue项目和django项目关联成功</a></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/8000-2.png" alt="8000-2"></p>
<p>单独 vue 项目默认会运行在 8080 端口下，单独 django 项目默认会运行在 8000 端口下，当 django 项目和 vue 项目没有关联之前，运行 django 项目时会在 8000 端口看到 django 项目的默认页面，当关联后，vue项目打包后，此时运行 django 项目会在 8000 端口看到 vue 项目的页面</p>
<h1 id="五、Django-MySQL连接"><a href="#五、Django-MySQL连接" class="headerlink" title="五、Django+MySQL连接"></a>五、Django+MySQL连接</h1><h2 id="5-1-创建项目数据库"><a href="#5-1-创建项目数据库" class="headerlink" title="5.1 创建项目数据库"></a>5.1 创建项目数据库</h2><p>首先以管理员身份运行终端，输入 <code>net start mysql</code> 启动 mysql 服务器</p>
<p>并在 mysql 安装的 bin 目录下输入 <code>mysql -u root -p</code> 并回车后输入密码来登录 mysql 服务器</p>
<p>并使用 SQL 语句创建一个数据库 <code>create database 数据库名称 default charset=utf8;</code> </p>
<p>使用 <code>show databases;</code> 命令查看是否成功创建</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/database.png" alt="database"></p>
<h2 id="5-2-Django配置"><a href="#5-2-Django配置" class="headerlink" title="5.2 Django配置"></a>5.2 Django配置</h2><h3 id="（1）安装所需依赖"><a href="#（1）安装所需依赖" class="headerlink" title="（1）安装所需依赖"></a>（1）安装所需依赖</h3><p>在 django 项目所用的 python 解释器中安装 pymysql 驱动</p>
<h3 id="（2）配置数据库连接信息"><a href="#（2）配置数据库连接信息" class="headerlink" title="（2）配置数据库连接信息"></a>（2）配置数据库连接信息</h3><p>在 django项目-&gt;setting.py 文件中的 DATABASES 一项更换为如下配置</p>
<pre><code>&#39;default&#39;:
&#123;
    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,  # 数据库引擎
    &#39;NAME&#39;: &#39;ssm&#39;,  # 数据库名称
    &#39;HOST&#39;: &#39;127.0.0.1&#39;, # 数据库地址，本机 ip 地址 127.0.0.1
    &#39;PORT&#39;: 3306,  # 端口
    &#39;USER&#39;: &#39;root&#39;,  # 数据库用户名
    &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  # 数据库密码
&#125;</code></pre>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/databases.png" alt="databases"></p>
<p>在 django项目-&gt;<strong>init</strong>.py 文件中添加如下代码</p>
<pre><code>import pymysql
pymysql.install_as_MySQLdb()</code></pre>
<h3 id="（3）创建一个app"><a href="#（3）创建一个app" class="headerlink" title="（3）创建一个app"></a>（3）创建一个app</h3><p>Django 规定，如果要使用模型，必须要创建一个 app，使用命令 <code>django-admin startapp app名称</code> 进行创建</p>
<p>然后在 django项目-&gt;setting.py 文件里的 INSTALLED_APPS 一项中添加app名称</p>
<p>此时目录结构已变为</p>
<pre><code>-根目录
 --django项目
 --manage.py
 --vue项目
 --项目app</code></pre>
<p>在 app 里的 models.py 文件中可以类的形式表示数据库中的表，然后在终端运行 <code>python manage.py makemigrations app名称</code> 和 <code>python manage.py migrate app名称</code> 让 Django 知道模型有一些变更，并创建表结构</p>
<h3 id="（4）-Django中操作数据库"><a href="#（4）-Django中操作数据库" class="headerlink" title="（4） Django中操作数据库"></a>（4） Django中操作数据库</h3><p>接着可以在django项目下添加py文件（如testdb.py）进行数据库操作，并在 django项目-&gt;urls.py 文件里 urlpatterns 中添加接口路径和文件</p>
<p>如 <code>path(&#39;test/&#39;, testdb.testdb)</code> ，第一个 testdb 指 testdb.py 文件，第二个 testdb 指 testdb.py 文件中的 testdb 函数</p>
<h1 id="六、遇到的一些问题"><a href="#六、遇到的一些问题" class="headerlink" title="六、遇到的一些问题"></a>六、遇到的一些问题</h1><h2 id="6-1-跨域问题"><a href="#6-1-跨域问题" class="headerlink" title="6.1 跨域问题"></a>6.1 跨域问题</h2><p>在前端向后端发送请求时会发生如下报错</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png" alt="跨域问题"></p>
<p><strong>解决：</strong></p>
<p>在后端python虚拟环境中安装 django-cors-headers 依赖</p>
<p>在 django项目-&gt;setting.py 文件中 MIDDLEWARE 配置里<br>在’django.contrib.sessions.middleware.SessionMiddleware’,<br>和’django.middleware.common.CommonMiddleware’,<br>中间添加’corsheaders.middleware.CorsMiddleware’,</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/middleware.png" alt="middleware"></p>
<p>同样是在 django项目-&gt;setting.py 文件里，在 INSTALLED_APPS 一项中添加 <code>&#39;corsheaders&#39;,</code> </p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/installedapps.png" alt="installedapps"></p>
<p>并在 django项目-&gt;settings.py 文件中添加 <code>CORS_ORIGIN_ALLOW_ALL = True</code> </p>
<h2 id="6-2-403报错"><a href="#6-2-403报错" class="headerlink" title="6.2 403报错"></a>6.2 403报错</h2><p>前端向后端发送post请求后出现403错误</p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/403.png" alt="403"></p>
<p><img src="/2021/08/21/Vue3-Django-MySQL%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/CSRF.png" alt="CSRF"></p>
<p>CSRF是为了防止跨站请求伪造</p>
<p><strong>解决：</strong></p>
<p>可以引入 <code>from django.views.decorators.csrf import csrf_exempt</code> ，并在函数前添加 <code>@csrf_exempt</code> </p>
<p>或在 django项目-&gt;settings.py 文件中 MIDDLEWARE 一项里注释掉’django.middleware.csrf.CsrfViewMiddleware’</p>
<p>第一种方法对某一接口起作用，而第二种方法针对全局有效</p>
<h2 id="6-3-更改后端IP"><a href="#6-3-更改后端IP" class="headerlink" title="6.3 更改后端IP"></a>6.3 更改后端IP</h2><p>djang项目默认后端运行在 127.0.0.1 本机 IP 上</p>
<p>若要更改，在django项目-&gt;settings.py 文件里的 ALLOWED_HOSTS 中添加新 IP</p>
<p>并在 manage.py 文件所在目录下使用 <code>python manage.py runserver 新IP:端口</code> 启动后端服务</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>一些废话</title>
    <url>/2021/01/20/%E4%B8%80%E4%BA%9B%E5%BA%9F%E8%AF%9D/</url>
    <content><![CDATA[<p>欢迎来到我的个人博客！下面要说一些废话，可以忽略hhh</p>
<a id="more"></a>

<p>放假了终于把写博客的事提上日程了，之前本科时候心血来潮用学生优惠租过一台服务器搭博客，结果自从搭上后没几天就没怎么问津过了。。。然后就就就到期了，真是浪费资源啊。这次决定重新开始写博客记录记录平时学习过程，我就是只菜菜鸟，博客里的内容仅代表个人理解，有理解不到位、不正确的地方还请多多指教哈~</p>
<p>立个flag，这次我一定经常来，哈哈哈</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>关于Web App的个人理解</title>
    <url>/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="App的类型"><a href="#App的类型" class="headerlink" title="App的类型"></a>App的类型</h1><p>App主要分为三类，分别是Native App（原生应用程序）、Web App（Web应用程序）、Hybrid App（混合型应用程序）</p>
<a id="more"></a>

<br>

<p><img src="/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/1.png" alt="App的类型"></p>
<br>

<ul>
<li><p><strong>Native App</strong></p>
<p>  原生App是运行在设备操作系统上的应用程序，例如安装在电脑、手机上的各种软件。</p>
<p>  对于不同的操作系统（如Windows、IOS、安卓等）需要使用不同的语言进行独立开发，这使得它的开发速度较慢、开发成本较高。同时，对于不同操作系统的App进行独立维护，这增加了维护总成本。并且原生App要发布上线、供用户下载使用前需要经过一系列的审核流程，因此从开发到上线还需要一定的时间。</p>
<p>  但是原生App一般将资源放置在用户的设备本地，因此用户获取资源更加便捷。并且原生App可调用的终端硬件设备，如麦克风、摄像头等，从而实现更丰富的功能。交互性、用户体验度最好。</p>
</li>
<li><p><strong>Web App</strong></p>
<p>  Web App是运行在浏览器上的应用程序，是一个轻量级App。只需打开浏览器并输入相应网址即可访问。</p>
<p>  由于Web App不依赖于操作系统，因此对于不同的操作系统而言无需单独开发一套应用程序，通过一次开发，即可让不同设备的用户访问到该应用程序，开发时只需考虑浏览器的兼容问题，使得开发效率提高，开发成本降低。从而只需专注在一套代码程序的优化和维护上，也大大降低了维护成本。<br>  其资源一般存储在云端，使得用户可以实时访问到最新数据。并且用户可最快获取最新功能或版本。  </p>
<p>  Web App也可调用终端的硬件设备，但其可调用的硬件设备功能相较于原生App来说受到一些限制。</p>
</li>
<li><p><strong>Hybrid App</strong></p>
<p>  混合型App是一个相当于在原生程序中伪造了浏览器，并运行Web App的半原生应用程序，运行在操作系统上。</p>
<p>  其资源可放置在本地或云端。交互性和用户体验度次于原生App。</p>
</li>
</ul>
<h1 id="Web-App工作过程"><a href="#Web-App工作过程" class="headerlink" title="Web App工作过程"></a>Web App工作过程</h1><p>Web APP是B/S架构的软件，其运行主要涉及的终端设备、客户终端的浏览器以及服务器。用户访问App，并获取相应返回数据的过程如下图所示：</p>
<br>

<p><img src="/2021/01/20/%E5%85%B3%E4%BA%8EWeb-App%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/2.png" alt="Web App工作过程"></p>
<br>

<p>①访问网址：用户在终端浏览器中栏输入URL路径向相应的服务器请求页面</p>
<p>②连接过程：Web服务器与浏览器间建立连接</p>
<p>③请求过程：浏览器用http协议描述，并封装为TCP/IP数据包寻址，发送http请求</p>
<p>④应答过程：服务器接收和分析http请求，按照用户请求内容执行相应处理，生成返回的HTML页面，并将结果打包成HTTP响应</p>
<p>⑤显示输出：浏览器在客户端屏幕上渲染服务器处理后返回的HTML页面</p>
<p>⑥关闭连接：Web服务器和浏览器间断开连接</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>关于前端框架React的个人理解</title>
    <url>/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>一个Web App的开发主要包括前端和后端两部分，在Web App运行时用户在浏览器端发生点击、输入、表单提交等事件，发生这些交互事件时浏览器端向后端发送http请求，后端服务器接收到前端发来的请求以及数据后执行相应脚本对用户请求进行处理，必要时向数据库查询或更新数据，服务器再将处理结果生成<a id="more"></a>HTML页面返回至浏览器进行渲染。在这个过程中，浏览器端的显示以及事务处理属于前端部分，而服务器端和数据库的程序开发属于后端部分。</p>
<br>

<p><img src="/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/1.png" alt="前后端"></p>
<br>

<p>前端即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。[来自百度百科]进行前端开发需要掌握的基本知识包括HTML、CSS、JavaScript。</p>
<ul>
<li><p>HTML：超文本标记语言 （Hyper Text Markup Language）——页面结构、内容<br>负责定义页面的组成，例如标题、段落、图片、链接等。</p>
</li>
<li><p>CSS：级联样式表（Cascading Style Sheet）——样式<br>负责定义页面各组成部分的布局和样式，例如所处位置、大小、颜色等。</p>
</li>
<li><p>JavaScript：面向对象的客户端脚本语言——控制HTML中的各元素、处理事务逻辑<br>负责处理用户的鼠标点击、滑动所触发的事件的部分事务逻辑，部分事务逻辑可由后端处理。</p>
</li>
</ul>
<h1 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h1><p>可以通过自行创建HTML文件、定义CSS、编写JS来搭建前端，但这样的开发效率较低，且代码杂乱、冗余，难以维护。因此大家都倾向于利用前端框架搭建前端，在前端框架中页面需要重复使用的部分可封装为组件，从而能方便地引用，且各个组件定义自己的js逻辑和样式，使得各部分代码清晰明了且整洁。<br>通过使用前端框架，程序猿可更专注于网页内容的开发，而数据缓存、数据安全校验等由框架来实现。<br>此外，虽然各前端框架的内部实现机制不同，但相比原生态的前端页面开发而言，前端框架在实现机制上进行了性能优化来提高网页速度。<br>而且在前端框架中有许多已封装好的第三方组件可直接调用，使开发效率提升、页面更加美观。<br>如今前端框架层出不穷，下图展示了部分较为流行的前端框架：<br><br></p>
<p><img src="/2021/01/21/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6React%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/2.png" alt="前端框架"></p>
<br>
其中Vue、React、Angular是当前较主流的三个前端框架，此外还有Twitter推出的Bootstrap，饿了么团队推出的基于Vue的桌面端前端框架Element UI和移动端前端框架Mint UI，京东团队推出的可适配微信小程序的Taro UI前端框架，腾讯出品的QMUI，以及基于Vue的UI组件库iview和基于React的UI组件库Antd Design等。

<h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>前端小方法杂记</title>
    <url>/2021/05/21/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%96%B9%E6%B3%95%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、HTML与CSS"><a href="#一、HTML与CSS" class="headerlink" title="一、HTML与CSS"></a>一、HTML与CSS</h1><h2 id="关于居中"><a href="#关于居中" class="headerlink" title="关于居中"></a>关于居中</h2><p><strong>问题1：</strong><code>&lt;div&gt;</code>子元素在父元素中垂直居中</p>
<a id="more"></a>

<p><strong>方法一：</strong>子元素设置<code>display:inline-block;vertical-align:middle;</code></p>
<p><strong>方法二：</strong>父元素设置<code>display:flex;</code>搭配子元素<code>align-self:center;</code></p>
<p><strong>方法三：</strong>父元素设置<code>display:table;</code>搭配子元素<code>display: table-cell;vertical-align: middle;</code></p>
<p><strong>问题2：</strong>在没有设置<code>&lt;div&gt;</code>宽度时的水平居中</p>
<p><strong>方法：</strong>CSS3支持使用<code>width:-moz-fit-content;  width:fit-content;  margin:0 auto;</code>实现水平居中，且仅谷歌与火狐浏览器支持</p>
<h2 id="关于刷新"><a href="#关于刷新" class="headerlink" title="关于刷新"></a>关于刷新</h2><p><strong>问题：</strong>点击<code>&lt;a&gt;</code>标签后页面总会自动刷新</p>
<p><strong>方法：</strong>可添加属性<code>href=&quot;javascript:;&quot;</code>阻止页面刷新</p>
<h2 id="关于大小、高度不一"><a href="#关于大小、高度不一" class="headerlink" title="关于大小、高度不一"></a>关于大小、高度不一</h2><p><strong>问题1：</strong><code>&lt;input&gt;</code>标签中 text 类型和 submit 类型设置相同的高度，显示出来却不同</p>
<p><strong>原因：</strong>因为text类型的<code>&lt;input&gt;</code>标签显示的宽度和高度包含 border</p>
<p><strong>方法：</strong>可在 submit 类型的<code>&lt;input&gt;</code>标签中设置<code>box-sizing: content-box;</code></p>
<p><strong>问题2：</strong>当在子元素中使用<code>display:inline-block</code>使多个子元素并排时，各子元素高度不一</p>
<p><strong>方法：</strong>可在子元素中添加<code>letter-spacing: 0;vertical-align: top;</code>来解决</p>
<h2 id="关于元素样式作用对象"><a href="#关于元素样式作用对象" class="headerlink" title="关于元素样式作用对象"></a>关于元素样式作用对象</h2><p><strong>问题：</strong><code>&lt;div&gt;</code>子元素设置 margin 后会作用于父元素</p>
<p><strong>方法一：</strong>对父元素添加<code>overflow: hidden;</code></p>
<p><strong>方法二：</strong>给父元素增加透明边框<code>border: 1px solid transparent;</code>或<code>border-top: 1px solid transparent;</code></p>
<p><strong>方法三：</strong>为父元素设置<code>padding</code></p>
<h2 id="关于样式"><a href="#关于样式" class="headerlink" title="关于样式"></a>关于样式</h2><p><strong>问题：</strong>去除<code>&lt;button&gt;</code>一些默认样式</p>
<p><strong>方法：</strong>去除边框<code>border:none;</code>&nbsp;&nbsp;&nbsp;去除点击时的边框<code>outline: none;</code></p>
<h1 id="二、JS"><a href="#二、JS" class="headerlink" title="二、JS"></a>二、JS</h1><h2 id="关于多个重叠-lt-div-gt-的点击"><a href="#关于多个重叠-lt-div-gt-的点击" class="headerlink" title="关于多个重叠&lt;div&gt;的点击"></a>关于多个重叠<code>&lt;div&gt;</code>的点击</h2><p><strong>问题1：</strong>上层<code>&lt;div&gt;</code>遮挡下层<code>&lt;div&gt;</code>后，点击重叠部分无法触发下层<code>&lt;div&gt;</code>的函数</p>
<p><strong>方法：</strong>可通过<code>pointer-events:none;</code>解决</p>
<p><strong>问题2：</strong>点击子<code>&lt;div&gt;</code>不触发父<code>&lt;div&gt;</code>的函数</p>
<p><strong>方法：</strong>在子<code>&lt;div&gt;</code>点击时阻止冒泡事件，即在函数中添加<code>event.stopPropagation()</code></p>
<h2 id="关于-lt-input-gt-值不变"><a href="#关于-lt-input-gt-值不变" class="headerlink" title="关于&lt;input&gt;值不变"></a>关于<code>&lt;input&gt;</code>值不变</h2><p><strong>问题：</strong>修改<code>&lt;input&gt;</code>的输入内容，获取到的值不变</p>
<p><strong>方法：</strong><code>&lt;input&gt;</code>标签可通过 value 属性设置默认值，若要可修改需要添加<code>onChange</code>监听函数才行</p>
<h1 id="三、针对React"><a href="#三、针对React" class="headerlink" title="三、针对React"></a>三、针对React</h1><h2 id="关于背景"><a href="#关于背景" class="headerlink" title="关于背景"></a>关于背景</h2><p><strong>问题：</strong>react 中给<code>&lt;div&gt;</code>添加背景图片时背景图片过大</p>
<p><strong>方法：</strong>可设置<code>webkitBackgroundSize: &#39;100% 100%&#39;</code></p>
<h2 id="关于带参数的函数"><a href="#关于带参数的函数" class="headerlink" title="关于带参数的函数"></a>关于带参数的函数</h2><p><strong>问题：</strong>react 中定义带参数的函数</p>
<p><strong>方法：</strong>在标签的 onClick 属性中使用<code>this.函数名.bind(this,参数)</code>，</p>
<p>在 constructor() 构造器中使用<code>this.函数名=this.函数名.bind(this)</code>，</p>
<p>在定义函数时参数为 (参数名,event)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>双系统下重装Ubuntu系统</title>
    <url>/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>前情提要：原主机中已安装 Windows10 和 Ubuntu 16.04 双系统，想重新安装 Ubuntu 系统，改为 Ubuntu 20.04 版本</p>
<a id="more"></a>

<h1 id="一、下载-Ubuntu-20-04-镜像"><a href="#一、下载-Ubuntu-20-04-镜像" class="headerlink" title="一、下载 Ubuntu 20.04 镜像"></a>一、下载 Ubuntu 20.04 镜像</h1><p>在<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/">清华镜像网站</a>上下载 .iso 镜像文件，我这里选择 ubuntu-20.04.3-desktop-amd64.iso 进行下载</p>
<h1 id="二、制作启动-U-盘"><a href="#二、制作启动-U-盘" class="headerlink" title="二、制作启动 U 盘"></a>二、制作启动 U 盘</h1><p>1、安装 UltralSO 软件</p>
<p>2、清空已作为启动盘的 U 盘</p>
<p>已管理员身份打开 UltralSO 软件，点击菜单栏中“启动 -&gt; 写入硬盘映像”</p>
<p>选择硬盘驱动器、映像文件（空白）、写入方式后点击“写入”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-deleteU1.png" alt="deleteU"></p>
<p>3、制作启动盘</p>
<p>已管理员身份打开 UltralSO 软件，点击菜单栏“文件 -&gt; 打开”或在界面下方“本地目录”中找到下载好的 Ubuntu 20.04 系统镜像文件 ubuntu-20.04.3-desktop-amd64.iso 并双击文件</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-write.png" alt="ultraiso-write"></p>
<p>再点击菜单栏中“启动 -&gt; 写入硬盘映像”，选择硬盘驱动器（U盘）、映像文件（ubuntu-20.04.3-desktop-amd64.iso）、写入方式（USB-HDD+）后点击“写入”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ultraiso-write1.png" alt="ultraiso-write1"></p>
<h1 id="三、删除-Ubuntu-系统"><a href="#三、删除-Ubuntu-系统" class="headerlink" title="三、删除 Ubuntu 系统"></a>三、删除 Ubuntu 系统</h1><p>进入 Windows 系统，右键“此电脑” -&gt; 点击“管理” -&gt; 选择“磁盘管理” -&gt; 选择非系统盘的磁盘中属于原 Ubuntu 系统的分区右键选择“删除卷”，使这些区域成为“可用空间”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9Fdeletepartition.png" alt="deletepartition"></p>
<p>键盘按住 Win + R，输入 <code>diskpart</code> 进入相应命令行，输入 <code>list disk</code> 查看所有磁盘，并输入 <code>select disk 系统盘编号</code> 选择 Windows 的系统盘， 输入 <code>list partition</code> 查看该盘所有分区，并选择“系统”分区 <code>select partition 分区编号</code>，输入 <code>assign letter=字母</code> 分配成一个独立磁盘（磁盘字母随意只要不和现有磁盘冲突即可）</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/listdisk.png" alt="listdisk"></p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/selectdisk.png" alt="selectdisk"></p>
<h1 id="四、删除-Ubuntu-系统启动项"><a href="#四、删除-Ubuntu-系统启动项" class="headerlink" title="四、删除 Ubuntu 系统启动项"></a>四、删除 Ubuntu 系统启动项</h1><p>1、以管理员身份打开“记事本”，点击菜单栏“文件 -&gt; 打开”，选择刚刚创建的磁盘，打开其中文件夹“EFI”，并选择该目录下的“ubuntu”文件夹右键删除</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/deleteubuntu.png" alt="deleteubuntu"></p>
<p>2、并在第 4 步命令行中输入 <code>remove letter=磁盘字母</code> 删除创建的磁盘</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/removedisk.png" alt="removedisk"></p>
<p>3、在<a href="https://easyuefi.en.softonic.com/">官网</a>下载 EasyUEFI，安装后运行该软件，进入“管理EFI启动项”，选择原 Ubuntu 系统涉及的启动项并删除</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/easyuefi.png" alt="easyuefi"></p>
<h1 id="五、安装新-Ubuntu-系统"><a href="#五、安装新-Ubuntu-系统" class="headerlink" title="五、安装新 Ubuntu 系统"></a>五、安装新 Ubuntu 系统</h1><p>1、将 U 盘插入电脑，重启电脑，进入“BIOS”，选择 U 盘启动项</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/bios.jpg" alt="bios"></p>
<p>2、接着按照提示按照新 Ubuntu 系统，下面是部分需要注意的地方</p>
<p>（1）安装类型选择“其他选项”</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/installtype.jpg" alt="installtype"></p>
<p>（2）利用空闲空间进行分区，分区可分为两个（‘/’、‘/home’）、四个（‘swap’、‘/’、‘/boot’、‘/home’）或五个（‘swap’、‘/’、‘/boot’、‘/usr’、‘/home’）区，根据自身存储空间选择</p>
<p>‘/boot’是用于启动ubuntu系统的启动器，类型：逻辑分区，用于：Ext4日志文件系统，大约需400M，这里我分配了1G</p>
<p>‘swap’是虚拟内存，类型：逻辑分区，用于：交换空间，可以分固态硬盘的区，大小约为内存大小，这里我分配了32G</p>
<p>‘/’是用于存放系统文件相当于Windows的C盘，类型：逻辑分区，用于：Ext4日志文件系统，这里我分配了115G</p>
<p>‘/usr’是所有程序安装的位置,本地安装的程序在/usr/local下，类型：逻辑分区，用于：Ext4日志文件系统，这里我分配了200G</p>
<p>‘/home’供用户存放文件等数据，相当于Windows系统盘之外的其它盘，类型：逻辑分区，用于：Ext4日志文件系统，这里我把剩余所有空间分配给它</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/bootpartition.jpg" alt="bootpartition"></p>
<p>（3）分配完各分区空间后，在“安装启动引导的设备”处选择“/boot”所在分区</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/partitions.jpg" alt="partitions"></p>
<h1 id="六、可能遇到的问题"><a href="#六、可能遇到的问题" class="headerlink" title="六、可能遇到的问题"></a>六、可能遇到的问题</h1><p><strong>问题：</strong>若没删除干净，或首选启动项无法启动时，重启会出现如下界面</p>
<p><img src="/2021/10/08/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%87%8D%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/rebooterror.jpg" alt="rebooterror"></p>
<p><strong>解决：</strong>在重启时进入“BIOS”，选择可启动项启动，在 EasyUEFI 软件中管理启动项时把可用启动项置于最顶</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>安装构建并运行React项目</title>
    <url>/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>构建一个React项目需要安装Nodejs、Webpack以及React相关包。</p>
<a id="more"></a>

<p>每个脚本都需要解析器，即构建一个运行时环境，而nodejs就是为js脚本提供一个运行时环境。对于JavaScript，在前端html中的js是由浏览器进行解析，主要是对DOM的操作，而nodejs解析的js脚本主要是对磁盘文件等进行操作，搭建起一个服务。</p>
<p>webpack是一个模块管理工具，将项目各文件进行打包，在项目部署时可通过直接调用打包后生成的资源文件，方便快捷。</p>
<h1 id="一、安装Nodejs"><a href="#一、安装Nodejs" class="headerlink" title="一、安装Nodejs"></a>一、安装Nodejs</h1><p>在<a href="https://nodejs.org/zh-cn/">官网</a>根据自己的系统选择对应版本进行下载</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/nodejs.png" alt="nodejs"></p>
<p>下载完成后开始安装，可自定义所要安装的位置，其他选项按照默认即可。<br>打开命令行，输入 <code>node -v</code> 并回车，查看是否安装成功，若出现nodejs版本表示已成功安装。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/node-v.png" alt="node-v"></p>
<h1 id="二、npm初始化"><a href="#二、npm初始化" class="headerlink" title="二、npm初始化"></a>二、npm初始化</h1><p>npm是包管理器，在开发过程中，通过 <code>npm install 包名称</code> 命令安装所需的包，即可使用别人已写好的模块，省去下载源码解压安装等繁琐步骤。npm包管理器集成在nodejs中，当上一步nodejs安装成功后，在命令行输入 <code>npm -v</code> ，显示npm的版本号，表示npm也已成功安装。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/npm-v.png" alt="npm-v"></p>
<p>新建一个React项目的文件夹（这里我命名为test），打开命令行，进入该文件夹，使用命令 <code>npm init</code> 初始化项目，初始化过程中可按提示输入项目名称、版本、描述、入口文件、启动命令等信息，也可选择一路回车。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/npminit.png" alt="npm init"></p>
<p>此时会在该文件夹下生成一个package.json文件，该文件中记录的是刚才项目初始化时所输入的项目相关信息。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagejson.png" alt="packagejson"></p>
<h1 id="三、安装Webpack"><a href="#三、安装Webpack" class="headerlink" title="三、安装Webpack"></a>三、安装Webpack</h1><p>在项目文件夹下使用命令 <code>npm install webpack webpack-cli webpack-dev-server --save-dev</code> 安装webpack和webpack-dev-sever。</p>
<p>其中webpack负责打包工作，方便文件管理，把所有静态文件打包成一个bundle.js资源文件，当项目部署时只需项目入口文件和打包好的bundle.js文件即可。最新版本的webpack需要搭配webpack-cli使用，要编译成功还必须安装webpage-cli。</p>
<p>安装webpack-dev-server包是为了方便在本地实时预览页面，是一个小型的nodejs Express服务器，为静态文件提供web服务，实现热加载，即当更改并保存前端代码后，webpack自动编译，并在浏览器中自动刷新显示最新页面，从而实时预览更改后的页面状态。webpack-dev-sever在本地开发时非常方便，在项目部署到服务器后的生产环境中不需要用到，因此在安装命令中使用–save-dev表示把包安装在dev节点上。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installwebpack.png" alt="installwebpack"></p>
<p>安装完成后，在项目文件夹下生成node_modules文件夹和package-lock.json文件，其中node_modules文件夹中存放的就是项目开发过程中安装的各种模块。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagelockjson.png" alt="package-lock.json"></p>
<p>在项目文件夹下手动创建一个webpack.config.js文件，在该文件中配置项目的入口文件、打包后的文件存放位置等信息。配置如下：</p>
<pre><code>var path = require(&quot;path&quot;);
var webpack = require(&#39;webpack&#39;);
module.exports = &#123;
    entry: &#123; app: [&#39;./src/main.js&#39;] &#125;,  //前端入口文件
    output: &#123;
    path: path.resolve(__dirname, &quot;./build&quot;), //打包后文件的存放位置
    publicPath: &quot;/build/&quot;,   //打包后访问资源时加的路径前缀
    filename: &quot;bundle.js&quot;    //打包生成的文件名
    &#125;,
    resolve: &#123;
    extensions: [&#39;*&#39;,&#39;.js&#39;,&#39;.jsx&#39;]  //当代码中引入模块时若找不到指定文件，则添加这些后缀
    &#125;,  
    devServer: &#123;
    historyApiFallback: true,
    host:&#39;0.0.0.0&#39;,
    hot: true,
    inline: true,
    progress: true,
    port:5000
    &#125;,
    plugins: [
    new webpack.DefinePlugin(&#123;
      &#39;process.env.NODE.ENV&#39;:&quot;development&quot;
    &#125;),
    new webpack.HotModuleReplacementPlugin()
    ]
&#125;;</code></pre>
<h1 id="四、安装React"><a href="#四、安装React" class="headerlink" title="四、安装React"></a>四、安装React</h1><p>在项目文件夹下使用命令 <code>npm install react react-dom --save-dev</code> 命令安装react和react-dom模块。</p>
<p>其中react模块时react的核心库，react-dom模块提供关于DOM的相关操作，将react的虚拟DOM进行编译更新DOM。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installreact.png" alt="install react"></p>
<p>由于在react中支持JSX格式代码，即可以在js中直接写html标签，因此在react中各组件文件以js或jsx后缀都可以，若要把jsx文件转为js文件需要安装jsx-loader包。此外，要把react框架中编写的代码使用webpack打包后还需要使用babel包对其进行编译，</p>
<p>因此使用命令 <code>npm install jsx-loader babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev</code> 安装所需这些包，babel-core是babel的核心库，babel-preset-react可把react的语法转换为ES5规范。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/installbabel.png" alt="install babel"></p>
<p>在webpack.config.js文件中添加如下配置:</p>
<pre><code>module: &#123;
  loaders: [
    &#123;test:/\.jsx$/, loaders:[&#39;jsx?harmony&#39;]&#125;
  ],
   loaders:[
    &#123;
      test: /\.jsx?$/,
      loader: &#39;babel-loader&#39;,
      include: path.resolve(__dirname),
      query: &#123;
        presets: [&#39;es2015&#39;, &#39;react&#39;]
      &#125;
    &#125;,
  ]
&#125;,</code></pre>
<p>安装好这些包后查看package.json文件中的“devDependencies”一项记录了在dev节点安装的所有模块。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/packagejson1.png" alt="package.json"></p>
<p>打开package.json文件，修改“scripts”节点，在该节点中可自定义不同命令，并为不同命令赋予含义。在该节点中添加</p>
<pre><code>&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,
&quot;start&quot;: &quot;webpack-dev-server --inline&quot;</code></pre>
<p>表示使用npm run build命令时将依据webpack.config.js文件中的配置对项目进行编译打包。使用npm run start命令时将启动nodejs小型服务器，开启本地预览。</p>
<h1 id="五、测试react项目"><a href="#五、测试react项目" class="headerlink" title="五、测试react项目"></a>五、测试react项目</h1><p>新建build文件夹，并在该文件夹下新建main.js文件index.html作为页面入口。在index.html文件中编写如下代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot; /&gt;
    &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;page&quot;&gt;&lt;/div&gt;    
&lt;/body&gt;
&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>新建src文件夹，并在该文件夹下新建main.js文件作为前端文件入口。可自定义入口文件位置，只需与webpack.config.js文件中的设置一致即可。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/mainjsposition.png" alt="main.js position"></p>
<p>在main.js文件中编写如下代码：</p>
<pre><code>import React from &#39;react&#39;;  //引入react核心库
import ReactDOM from &#39;react-dom&#39;;   //引入react-dom

ReactDOM.render(&lt;h1&gt;Hello World!&lt;/h1&gt;, document.getElementById(&#39;page&#39;)); //定义所要渲染的内容</code></pre>
<p>在项目文件夹目录下打开命令行，使用命令npm run build打包文件，此时会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/webpackversionerror.png" alt="webpack version error"></p>
<p>在packge.json文件中可以看到安装的webpack和webpack-cli版本</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/webpackversion.png" alt="webpack version"></p>
<p>因此报错原因是在webpack 4以后的版本中将webpack本身和webpack-cli分开来更好地管理它们，而在webpack 3中，两者在同一个包中，所以可以通过降级来解决。</p>
<p>首先使用 <code>npm uninstall webpack webpack-cli</code> 命令将原先安装的webapck和webpack-cli包移除，再使用 <code>npm install webpack@3.8.0 webpack-cli@3.3.12 --save-dev</code></p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newwebpackversion.png" alt="new webpack version"></p>
<p>再次使用 <code>npm run build</code> 命令，此时又会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/babelversionerror.png" alt="babel version error"></p>
<p>原因是babel-loader的版本不匹配，若想用babel-core 6的版本需要使用babel-loader 7的版本，而通过查看package.json文件可以看到安装的babel-core版本为6.26.3，而babel-loader的版本为8.2.2，同样可以通过给babel-loader降级来解决。</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/babelversion.png" alt="babel version"></p>
<p>使用 <code>npm uninstall babel-loader</code> 移除原先安装的babel-loader，再使用 <code>npm install babel-loader@7.1.5 --save-dev</code> 重新安装</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newbabelversion.png" alt="new babel version"></p>
<p>此时再执行 <code>npm run build</code> ，成功编译打包</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/runbuild.png" alt="npm run build"></p>
<p>在build目录下生成打包后的bundle.js文件</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/bundle.png" alt="bundle"></p>
<p>使用命令 <code>npm run start</code> 启动服务，此时又会出现如下报错</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/devservererror.png" alt="devserver error"></p>
<p>因为之前对webpack和webpack-cli进行降级后，最新版的webpack-dev-server与它们不匹配了，同样需要对webpack-dev-server进行降级。</p>
<p>使用 <code>npm uninstall webpack-dev-server</code> 移除原先安装的babel-loader，再使用 <code>npm install webpack-dev-server@2.9.7 --save-dev</code> 重新安装</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/newdevserverversion.png" alt="new devserver version"></p>
<p>使用命令 <code>npm run start</code> 启动服务</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/runstart.png" alt="npm run start"></p>
<p>打开浏览器，输入 <code>127.0.0.1:5000/build</code> 进行查看</p>
<p><img src="/2021/01/26/%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CReact%E9%A1%B9%E7%9B%AE/html.png" alt="html"></p>
<p>如上图所示浏览器成功渲染页面，至此完成react项目的搭建。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>服务器的配置和使用</title>
    <url>/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>深度学习环境配置包括 <strong>显卡驱动 + anaconda + cuda + cudnn + pytorch/tensorflow（GPU版）</strong></p>
<a id="more"></a>

<p>它们之间的关系如下：</p>
<p><strong>cuda版本与显卡驱动有关</strong>，在<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">这里</a>可查看二者的版本关系</p>
<p><strong>cudnn与cuda版本有关</strong>，在<a href="https://developer.nvidia.com/rdp/cudnn-archive">这里</a>可查看二者的版本关系</p>
<p><strong>pytorch与cuda版本有关</strong>，在<a href="https://pytorch.org/get-started/previous-versions/">这里</a>可查看二者的版本关系</p>
<p><strong>tensorflow和gcc、cuda版本有关</strong>，在<a href="https://www.tensorflow.org/install/source#tested_build_configurations">这里</a>可查看它们的版本关系</p>
<p>因为实验室的服务器已经有同学在使用所以基本环境都已装好，只需在anaconda中创建一个新的虚拟环境安装pytorch/tensorflow即可，这样更方便更安全，避免和其他同学的环境产生冲突。所以这里也只记录了在显卡驱动、anaconda、cuda、cudnn都已装好的服务器中，第一次使用前所需要做的准备。</p>
<p>（由于笔记本使用win10系统，实验室台式机使用Linux系统，所以文中图片可能会出现两种系统下的截图，但两种系统下的方法是一样的）。在Windows系统中使用xshell远程连接服务器，Linux系统在终端或VsCode中可远程连接服务器。</p>
<h1 id="一、了解服务器基本信息"><a href="#一、了解服务器基本信息" class="headerlink" title="一、了解服务器基本信息"></a>一、了解服务器基本信息</h1><h2 id="1、硬盘大小及剩余容量"><a href="#1、硬盘大小及剩余容量" class="headerlink" title="1、硬盘大小及剩余容量"></a>1、硬盘大小及剩余容量</h2><p><code>df -lh</code></p>
<h2 id="2、显卡信息"><a href="#2、显卡信息" class="headerlink" title="2、显卡信息"></a>2、显卡信息</h2><p><code>lspci | grep -i nvidia</code> 或 <code>lspci | grep -i vga</code></p>
<h2 id="3、显卡驱动"><a href="#3、显卡驱动" class="headerlink" title="3、显卡驱动"></a>3、显卡驱动</h2><p><code>nvidia-smi</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nvidia-smi.png" alt="nvidia-smi"></p>
<h2 id="4、查看cuda版本"><a href="#4、查看cuda版本" class="headerlink" title="4、查看cuda版本"></a>4、查看cuda版本</h2><p><code>nvcc -V</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nvcc.png" alt="nvcc"></p>
<h2 id="5、查看cudnn版本"><a href="#5、查看cudnn版本" class="headerlink" title="5、查看cudnn版本"></a>5、查看cudnn版本</h2><p><code>cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</code></p>
<h2 id="6、查看gcc版本"><a href="#6、查看gcc版本" class="headerlink" title="6、查看gcc版本"></a>6、查看gcc版本</h2><p><code>gcc -v</code></p>
<h1 id="二、在Anaconda中创建个人环境"><a href="#二、在Anaconda中创建个人环境" class="headerlink" title="二、在Anaconda中创建个人环境"></a>二、在Anaconda中创建个人环境</h1><h2 id="1、创建新环境"><a href="#1、创建新环境" class="headerlink" title="1、创建新环境"></a>1、创建新环境</h2><p><code>conda create -n xwj_pytorch python=3.6</code></p>
<h2 id="2、进入环境"><a href="#2、进入环境" class="headerlink" title="2、进入环境"></a>2、进入环境</h2><p><code>conda activate xwj_pytorch</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/activate.png" alt="activate"></p>
<h2 id="3、在虚拟环境中安装pytorch"><a href="#3、在虚拟环境中安装pytorch" class="headerlink" title="3、在虚拟环境中安装pytorch"></a>3、在虚拟环境中安装pytorch</h2><p>在<a href="https://pytorch.org/get-started/previous-versions/">官网</a>查找对应cuda的pytorch版本</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/pytorch.png" alt="pytorch"></p>
<p>复制命令在终端执行，即可完成安装</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/installpytorch.png" alt="installpytorch"></p>
<p>进入虚拟环境中的python，检查pytorch是否安装成功是否可用</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/checkpytorch.png" alt="checkpytorch"></p>
<p>pytorch中可通过如下代码查看可用显卡的数量和信息</p>
<pre><code>import torch
print([torch.cuda.get_device_properties(i) for i in range(torch.cuda.device_count())])</code></pre>
<p>pytorch中设置可用显卡</p>
<pre><code>import os
os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &#39;0,1&#39;</code></pre>
<h2 id="4、安装tensorflow"><a href="#4、安装tensorflow" class="headerlink" title="4、安装tensorflow"></a>4、安装tensorflow</h2><p>查看gcc版本 <code>gcc -v</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/gcc.png" alt="gcc"></p>
<p>在<a href="https://www.tensorflow.org/install/source#tested_build_configurations">tensorflow官网</a>查看版本匹配</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/tfversion.png" alt="tfversion"></p>
<p>为了避免和其他环境中的模块版本产生冲突，可按照1、2步骤重新创建一个新的虚拟环境，并进入该虚拟环境</p>
<p>创建环境 <code>conda create -n xwj_tensorflow python=3.6</code></p>
<p>进入环境 <code>conda activate xwj_tensorflow</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/activatetf.png" alt="activatetf"></p>
<p>安装GPU版tensorflow <code>conda install tensorflow-gpu==2.0.0</code></p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/installtf.png" alt="installtf"></p>
<p>参照3中的方法进入虚拟环境的python，检查tensorflow是否安装成功，是否可用</p>
<h1 id="三、VsCode的使用"><a href="#三、VsCode的使用" class="headerlink" title="三、VsCode的使用"></a>三、VsCode的使用</h1><p>可以使用Pycharm或Vscode作为本地的python代码编辑器。因为还要远程连接服务器，而Pycharm中只有pro版有此功能，虽然可以使用学生身份申请免费使用pro版，但是为了方便这里直接用vscode。下面列出了使用vscode时遇到的一些问题。</p>
<h2 id="1、在vscode中使用anaconda环境里的python解释器无效"><a href="#1、在vscode中使用anaconda环境里的python解释器无效" class="headerlink" title="1、在vscode中使用anaconda环境里的python解释器无效"></a>1、在vscode中使用anaconda环境里的python解释器无效</h2><p>vscode中可点击左下角选择python解释器。在确保已前面步骤都正确，但是选择anaconda中已安装好的pytorch虚拟环境里的python解释器后，运行代码时仍出现如下报错 </p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/nomodule.png" alt="nomodule"></p>
<p><strong>解决：</strong>在setting.json文件中注释掉原来的 <code>python.pythonPath</code>，添加如下代码，其中第七项 <code>“python”</code> 更改为anaconda中虚拟环境里python的路径</p>
<pre><code>&#123;
    // &quot;python.pythonPath&quot;: &quot;/home/lab406/anaconda3/envs/pytorch/bin/python&quot;
    &quot;code-runner.executorMap&quot;: &#123;
        &quot;javascript&quot;: &quot;node&quot;,
        &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,
        &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; gcc -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;php&quot;: &quot;php&quot;,
        &quot;python&quot;: &quot;~/anaconda3/envs/pytorch/bin/python&quot;,
        &quot;perl&quot;: &quot;perl&quot;,
        &quot;perl6&quot;: &quot;perl6&quot;,
        &quot;ruby&quot;: &quot;ruby&quot;,
        &quot;go&quot;: &quot;go run&quot;,
        &quot;lua&quot;: &quot;lua&quot;,
        &quot;groovy&quot;: &quot;groovy&quot;,
        &quot;powershell&quot;: &quot;powershell -ExecutionPolicy ByPass -File&quot;,
        &quot;bat&quot;: &quot;cmd /c&quot;,
        &quot;shellscript&quot;: &quot;bash&quot;,
        &quot;fsharp&quot;: &quot;fsi&quot;,
        &quot;csharp&quot;: &quot;scriptcs&quot;,
        &quot;vbscript&quot;: &quot;cscript //Nologo&quot;,
        &quot;typescript&quot;: &quot;ts-node&quot;,
        &quot;coffeescript&quot;: &quot;coffee&quot;,
        &quot;scala&quot;: &quot;scala&quot;,
        &quot;swift&quot;: &quot;swift&quot;,
        &quot;julia&quot;: &quot;julia&quot;,
        &quot;crystal&quot;: &quot;crystal&quot;,
        &quot;ocaml&quot;: &quot;ocaml&quot;,
        &quot;r&quot;: &quot;Rscript&quot;,
        &quot;applescript&quot;: &quot;osascript&quot;,
        &quot;clojure&quot;: &quot;lein exec&quot;,
        &quot;haxe&quot;: &quot;haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt&quot;,
        &quot;rust&quot;: &quot;cd $dir &amp;&amp; rustc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;racket&quot;: &quot;racket&quot;,
        &quot;scheme&quot;: &quot;csi -script&quot;,
        &quot;ahk&quot;: &quot;autohotkey&quot;,
        &quot;autoit&quot;: &quot;autoit3&quot;,
        &quot;dart&quot;: &quot;dart&quot;,
        &quot;pascal&quot;: &quot;cd $dir &amp;&amp; fpc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;d&quot;: &quot;cd $dir &amp;&amp; dmd $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,
        &quot;haskell&quot;: &quot;runhaskell&quot;,
        &quot;nim&quot;: &quot;nim compile --verbosity:0 --hints:off --run&quot;,
        &quot;lisp&quot;: &quot;sbcl --script&quot;,
        &quot;kit&quot;: &quot;kitc --run&quot;,
        &quot;v&quot;: &quot;v run&quot;,
        &quot;sass&quot;: &quot;sass --style expanded&quot;,
        &quot;scss&quot;: &quot;scss --style expanded&quot;
    &#125;,
    &quot;code-runner.runInTerminal&quot;: false
&#125;</code></pre>
<p>保存后再次运行如下代码</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/checkvscode.png" alt="checkvscode"></p>
<p>可正常使用了（若依然无法使用则重新启动VsCode即可）</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/vscodenormal.png" alt="vscodenormal"></p>
<h2 id="2、在vscode中远程连接服务器"><a href="#2、在vscode中远程连接服务器" class="headerlink" title="2、在vscode中远程连接服务器"></a>2、在vscode中远程连接服务器</h2><p>首先在vscode中安装 Remote - SSH 插件</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/remotessh.png" alt="remotessh"></p>
<p>点击Configure图标，选择ssh配置</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/configssh.png" alt="configssh"></p>
<p>输入主机名称（自定义）、主机IP、用户名、端口号（可选）</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sshinfo.png" alt="sshinfo"></p>
<p>点击该主机名，右键可选择在当前窗口或新窗口连接服务器</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/connecthost.png" alt="connecthost"></p>
<p>然后输入密码登录服务器</p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/hostpassword.png" alt="hostpassword"></p>
<h2 id="3、同步本地代码到服务器"><a href="#3、同步本地代码到服务器" class="headerlink" title="3、同步本地代码到服务器"></a>3、同步本地代码到服务器</h2><h3 id="（1）安装SFTP插件"><a href="#（1）安装SFTP插件" class="headerlink" title="（1）安装SFTP插件"></a>（1）安装SFTP插件</h3><p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sftp.png" alt="sftp"></p>
<h3 id="（2）配置"><a href="#（2）配置" class="headerlink" title="（2）配置"></a>（2）配置</h3><p>输入 <code>ctrl+shift+p</code>打开输入框输入 <code>SFTP:Config</code>，此时会在 .vscode 目录下生成 sftp.json 文件，配置主机名称、IP、协议、端口、用户名、远程同步地址、本地保存时是否同步上传到服务器（不包括重命名和删除操作）、上传时忽略的文件 </p>
<p><img src="/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/sftpjson.png" alt="sftpjson"></p>
<h3 id="（3）上传"><a href="#（3）上传" class="headerlink" title="（3）上传"></a>（3）上传</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>输入 <code>ctrl+shift+p</code>打开输入框输入 <code>SFTP:Upload Project</code>，然后选择要上传的项目文件夹，再输入服务器密码即可</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>在命令行中</p>
<p>上传文件夹 <code>scp -r xxx/xxx/文件夹/ 用户名@IP地址:/home/xxx/存放文件夹的目录</code></p>
<p>上传文件夹中所有文件 <code>scp xxx/xxx/文件夹/* 用户名@IP地址:/home/xxx/存放文件的目录</code></p>
<p>上传文件 <code>scp 文件1 文件2 文件n 用户名@IP地址:/home/xxx/存放文件的目录</code></p>
<p><strong>遇到的问题：</strong>在上传时，若遇到服务器文件夹为 root 用户创建则无法写入，会出现 “Permission denied, please try again”错误。</p>
<p><strong>解决：</strong>在服务器上为文件夹授权， <code>chmod 777 由root创建的文件夹</code></p>
<p>然后可在xshell登录服务器或在vscode中连接登录服务器打开文件夹，进入虚拟环境，运行代码</p>
<h2 id="4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError-No-module-named-‘xxx’"><a href="#4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError-No-module-named-‘xxx’" class="headerlink" title="4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError: No module named ‘xxx’"></a>4、在vscode中使用python导入不同级目录下的文件时报错ModuleNotFoundError: No module named ‘xxx’</h2><p>假设文件目录为</p>
<pre><code>-project
  --dir1
    ---file1.py
  --dir2
    ---file2.py</code></pre>
<p>在file2.py中使用<code>from dir1.file1 import xxx</code>导入file1.py里定义的变量或函数时出现报错 ModuleNotFoundError: No module named ‘dir1’</p>
<p><strong>解决：</strong>在import之前将文件目录所在路径添加到搜索路径中</p>
<pre><code>import os
import sys 
sys.path.insert(0,os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from dir1.file1 import xxx</code></pre>
<p>这里是把项目 project 的绝对路径插入搜索路径中的第一个位置</p>
<p>其中<code>os.path.abspath(__file__)</code>表示 file2.py 所在的绝对路径</p>
<p><code>os.path.dirname(os.path.abspath(__file__))</code>为 dir2 目录的绝对路径</p>
<p><code>os.path.dirname(os.path.dirname(os.path.abspath(__file__))))</code>为项目 project 的绝对路径</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习包的使用杂记</title>
    <url>/2021/07/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Numpy"><a href="#一、Numpy" class="headerlink" title="一、Numpy"></a>一、Numpy</h1><h2 id="向量、矩阵点乘与叉乘"><a href="#向量、矩阵点乘与叉乘" class="headerlink" title="向量、矩阵点乘与叉乘"></a>向量、矩阵点乘与叉乘</h2><h3 id="点乘：内积、数量积，两向量若垂直点积为0，-a-b-cos-theta"><a href="#点乘：内积、数量积，两向量若垂直点积为0，-a-b-cos-theta" class="headerlink" title="点乘：内积、数量积，两向量若垂直点积为0，|a||b|cos(theta)"></a>点乘：内积、数量积，两向量若垂直点积为0，|a||b|cos(theta)</h3><p>向量：<code>np.dot</code>——相同位置元素相乘后求和——结果是标量，<code>*</code>——相同位置元素相乘——结果与原向量大小相同</p>
<a id="more"></a>

<p>矩阵：<code>*</code>或<code>np.multiply</code>——相同位置元素相乘——结果是矩阵，与原矩阵大小相同</p>
<h3 id="叉乘：向量积、外积，两向量若平行叉积为0，-a-b-sin-theta"><a href="#叉乘：向量积、外积，两向量若平行叉积为0，-a-b-sin-theta" class="headerlink" title="叉乘：向量积、外积，两向量若平行叉积为0，|a||b|sin(theta)"></a>叉乘：向量积、外积，两向量若平行叉积为0，|a||b|sin(theta)</h3><p>向量：<code>np.cross</code>——二维平面向量叉乘结果的长度为组成的四边形面积，多维向量叉乘得到法向量</p>
<p>矩阵：<code>np.dot</code>——矩阵1每行与矩阵2每列相乘</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu系统下搭建深度学习环境</title>
    <url>/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>重装了系统又要重新搭建深度学习环境包括安装 显卡驱动 + anaconda + cuda + cudnn + pytorch/tensorflow（GPU版）</p>
<a id="more"></a>

<h1 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h1><p>查看主机上是否有显卡 <code>lspci | grep -i nvidia</code></p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvidia.png" alt="nvidia"></p>
<p>在<a href="https://www.nvidia.cn/Download/index.aspx?lang=cn">NVIDIA官网</a>上选择与电脑显卡相匹配的驱动并下载</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvidiadriver.png" alt="nvidiadriver"></p>
<p><strong>禁用自带的驱动</strong></p>
<p>在禁用前查看自带驱动 <code>lsmod | grep nouveau</code></p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/lsmod.png" alt="lsmod"></p>
<p>打开文件 <code>sudo gedit /etc/modprobe.d/blacklist.conf</code></p>
<p>在文件末尾添加如下内容并保存后退出</p>
<pre><code>blacklist nouveau
options nouveau modeset=0</code></pre>
<p>更新修改 <code>sudo update-initramfs -u</code>，并重启电脑</p>
<p>禁用后查看驱动 <code>lsmod | grep nouveau</code> 将不会有任何信息</p>
<p>安装ligntdm <code>sudo apt install -y lightdm</code></p>
<p>关闭系统图形化界面 <code>sudo service lightdm stop</code>，若未能关闭则重启在登录界面按“ctrl+alt+F1”</p>
<p>查看是否安装gcc <code>gcc --version</code></p>
<p>若未安装则先安装 gcc <code>sudo apt install gcc</code>，再安装 make <code>sudo apt install make</code>，否则安装驱动时会报错</p>
<p>cd 进入存放下载的驱动文件位置</p>
<p>给驱动文件赋予权限 <code>sudo chmod a+x 驱动文件名</code></p>
<p>安装驱动 <code>sudo ./驱动文件名 -no-x-check -no-nouveau-check -no-opengl-files</code></p>
<p>安装时会遇到如下选择</p>
<pre><code>“Install NVDIA‘s 32-bit compatibility libraries？”
————可选择“No”

“Would you like to run the nvidia-xconfigutility to automatically update your x configuration so that the NVIDIA x driver will be used when you restart x? Any pre-existing x confile will be backed up.”
————选择“Yes”</code></pre>
<p>查看显卡驱动是否安装成功 <code>nvidia-smi</code></p>
<p>安装完成后重新打开系统图像界面  <code>sudo service lightdm start</code></p>
<p>重启电脑 <code>sudo reboot</code></p>
<h1 id="安装-CUDA"><a href="#安装-CUDA" class="headerlink" title="安装 CUDA"></a>安装 CUDA</h1><p>根据<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">CUDA 与显卡驱动版本间的关系</a> ，在<a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA DEVELOPER网站</a>上选择相应 CUDA 版本进行下载，这里我选择 CUDA 10.2</p>
<p>由于安装最新驱动 470.74，和 gcc 9.3.0</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/gcc9.png" alt="gcc9"></p>
<p>而根据<a href="https://docs.nvidia.com/cuda/archive/10.2/cuda-installation-guide-linux/index.html">CUDA 10.2的Versioned Online Documentation-Installation Guide Linux</a>中的表格可以看到与 CUDA 10.2匹配的 gcc 版本为7.x.x，而后续安装 tensorflow 时 2.0.0 以上版本匹配的 gcc 版本为7.3.1，所以需要对 gcc 进行降级，并安装 g++ 7</p>
<pre><code>sudo apt-get install gcc-7 g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 1
sudo update-alternatives --display gcc</code></pre>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/gcc7.png" alt="gcc7"></p>
<p>可以看到 gcc 9的优先级为1，gcc 7的优先级为9</p>
<p>如果系统已安装 g++，同样也要设置 g++ 7为更高的优先级（把上述后三条命令中“gcc”改为“g++”即可）</p>
<p>在<a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA DEVELOPER网站</a>上根据自己的系统选择相应 CUDA 版本进行下载，虽然我的 Ubuntu 系统为20.04，这里只要选择 18.04 即可，按照网页下方给的命令进行下载和安装</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudadownload.png" alt="cudadownload"></p>
<p>安装时会遇到如下选择</p>
<pre><code>“Do you accept the above EULA?”
————输入 accept

“CUDA Installer”
————回车去掉“Driver”前的“X”，再选择“Install”回车</code></pre>
<p>配置环境 CUDA 变量</p>
<p>打开环境变量配置文件 <code>gedit ~/.bashrc</code></p>
<p>在该文件末尾添加如下内容后保存并退出</p>
<pre><code>export PATH=/usr/local/cuda-前两位版本号/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;
export LD_LIBRARY_PATH=/usr/local/cuda-前两位版本号/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</code></pre>
<p>更新生效配置 <code>source ~/.bashrc</code></p>
<p>此时输入 <code>nvcc -V</code> 可以看到输出对应 CUDA 版本，表示安装成功</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/nvcc.png" alt="nvcc"></p>
<h1 id="安装-cuDNN"><a href="#安装-cuDNN" class="headerlink" title="安装 cuDNN"></a>安装 cuDNN</h1><p>在<a href="https://developer.nvidia.com/rdp/cudnn-archive">官网</a>下载与 CUDA 版本匹配的 cuDNN，选择其中的“cuDNN Library for Linux”下载</p>
<p>解压压缩包 <code>tar -xzvf 压缩包</code></p>
<p>拷贝文件</p>
<pre><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/
sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code></pre>
<p>文件权限授权</p>
<pre><code>sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</code></pre>
<p>接着测试，进入“/home/NVIDIA_CUDA-版本号_Samples”，执行 <code>make</code> 进行编译</p>
<p>进入“/home/NVIDIA_CUDA-版本号_Samples/1_Utilities/deviceQuery”执行 <code>./deviceQuer</code>，看到“Result = PASS”结果即为成功</p>
<p>进入“/home/NVIDIA_CUDA-版本号_Samples/1_Utilities/bandwidthTest”执行 <code>./bandwidthTest</code>，看到“Result = PASS”结果即为成功</p>
<h1 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h1><p>在<a href="https://www.anaconda.com/products/individual#download-section">官网</a>或<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&O=D">清华大学开源软件镜像站</a>下载 .sh 安装脚本</p>
<p>执行该 .sh 安装脚本 <code>bash Anaconda3-2021.05-Linux-x86_64.sh</code></p>
<p>安装时会出现“Do you wish the installer to initialize Anaconda3 by running conda init？”，选择“yes”将会自动添加环境变量配置</p>
<p>并输入 <code>source ~/.bashrc</code> 更新配置使其生效</p>
<h1 id="安装-Pytorch、tensorflow"><a href="#安装-Pytorch、tensorflow" class="headerlink" title="安装 Pytorch、tensorflow"></a>安装 Pytorch、tensorflow</h1><p>根据我的<a href="https://beingjay.com/2021/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#more">这篇博客</a>在 anaconda 中创建个人环境并安装即可</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p><strong>问题1：</strong>如果安装 CUDA 时一次没有成功，第二次安装会报如下错误</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudainstallfailed.png" alt="cudainstallfailed"></p>
<p><strong>解决：</strong>将官方给的安装命令 <code>sudo sh cuda_10.2.89_440.33.01_linux.run</code> 更改为 <code>sudo sh cuda_10.2.89_440.33.01_linux.run ----librarypath=/usr/local/cuda-10.2</code></p>
<p><strong>问题2：</strong>在安装完 cuDNN 后进行测试时，执行 <code>make</code> 进行编译可能会出现如下错误，这是由于CUDA 10.2 toolkit中包含的cudaNvSci sample需要一个新的NvStreams开发包，目前为还未发布</p>
<p><img src="/2021/10/10/Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/cudnnmakeerror.png" alt="cudnnmakeerror"></p>
<p><strong>解决：</strong>换用 <code>make -k</code> 忽略该错误进行编译</p>
<h1 id="卸载-Anaconda-的方法（做个记录）"><a href="#卸载-Anaconda-的方法（做个记录）" class="headerlink" title="卸载 Anaconda 的方法（做个记录）"></a>卸载 Anaconda 的方法（做个记录）</h1><p>删除“anaconda3”文件夹，并删除“~/.bashrc”环境变量配置文件末尾的 anaconda 路径配置</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记1</title>
    <url>/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>JavaScript 在1995年由网景公司发明，1996年生成 ECMAScript 标准，不同浏览器对该标准的实现不同，如 FireFox 使用 SpiderMonkey 引擎，Chrome 使用 v8 引擎（Nodejs也是）</p>
<a id="more"></a>

<h1 id="一、JavaScript组成"><a href="#一、JavaScript组成" class="headerlink" title="一、JavaScript组成"></a>一、JavaScript组成</h1><h2 id="1、JS的组成"><a href="#1、JS的组成" class="headerlink" title="1、JS的组成"></a>1、JS的组成</h2><p>JavaScript 包含三部分：ECMAScript（标准）+ DOM（文档对象模型）+BOM（浏览器对象模型）</p>
<h2 id="2、JS的特点"><a href="#2、JS的特点" class="headerlink" title="2、JS的特点"></a>2、JS的特点</h2><p>（1）解释型语言，无需编译</p>
<p>（2）类似 C 和 Java 的语法结构</p>
<p>（3）动态语言</p>
<p>（4）基于原型的面向对象</p>
<p>注意：JS 中严格区分大小写</p>
<h2 id="3、在网页中使用-JS"><a href="#3、在网页中使用-JS" class="headerlink" title="3、在网页中使用 JS"></a>3、在网页中使用 JS</h2><p>（1）可将 JS 代码编写到标签的 <code>onclick</code> 属性中，如 <code>&lt;button onclick=&quot;alert(&quot;xxxx&quot;);&quot;&gt;按钮&lt;/button&gt;</code></p>
<p>（2）可将 JS 代码写在超链接的 <code>href</code> 属性中，点击超链接时会执行 JS 代码，如 <code>&lt;a href=&quot;javascript:alert(&quot;xxxx&quot;);&quot;&gt;超链接&lt;/a&gt;</code></p>
<p>（3）通过 <code>&lt;script&gt;</code> 标签中写 JS 代码， 如<code>&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;xxxx&quot;);&lt;/script&gt;</code></p>
<p>（4）通过 <code>&lt;script&gt;</code> 标签引入外部 JS 文件，<code>&lt;script type=&quot;text/javascript&quot; src=&quot;./xxx.js&quot;&gt;&lt;/script&gt;</code></p>
<p>注意1：第一、二种方法把 JS 写在标签的书中属于结构与行为耦合，不方便维护，而把 JS 写到外部文件中可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>注意2：一个 <code>&lt;script&gt;</code> 标签一旦用于引入外部文件，就不能在其中编写 JS 代码了，即使写了浏览器也会忽略，但若再创建一个 <code>&lt;script&gt;</code> 标签其中的内部 JS 代码可执行</p>
<h1 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h1><h2 id="1、输出与输入"><a href="#1、输出与输入" class="headerlink" title="1、输出与输入"></a>1、输出与输入</h2><p>alert(“xxxxxx”);  //控制浏览器弹出警告框</p>
<p>document.write(“xxxx”);  //向 body 中输出内容，当要换行时不能用 <code>document.write(&quot;xxxx&quot;+&quot;\n&quot;);</code> 而要用 <code>document.write(&quot;xxxx&quot;+&quot;&lt;br /&gt;&quot;);</code> </p>
<p>console.log(“xxx”);   //向控制台输出内容</p>
<p>prompt(“提示文字”);   //用户可输入字符串，用户输入内容会以 String 类型作为函数返回值返回</p>
<p>通过类型转换 +prompt(“提示文字”); 会把字符串转为 Number，可用于输入数字</p>
<h2 id="2、字面量和变量"><a href="#2、字面量和变量" class="headerlink" title="2、字面量和变量"></a>2、字面量和变量</h2><h3 id="（1）字面量"><a href="#（1）字面量" class="headerlink" title="（1）字面量"></a>（1）字面量</h3><p>字面量是一些不可改变的值，字面量都是可直接使用的（但一般不会直接使用，而是通过变量）</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>字面量类型（数据类型）六种：
    String     字符串
    Number     数值
    Boolean    布尔值
    Null       空值，专门用来表示一个为空的对象，typeof 检查一个 null 值会返回 object
    Undefined  未定义，typeof 检查一个 null 值会返回 undefined
    Object     对象
    Symbol     ES6 中引入的新类型
其中 String、Number、Boolean、Null、Undefined 是基本数据类型，Object 属于引用数据类型</code></pre>
<p>可利用 <code>typeof 变量名</code>来查看变量的数据类型，它会将变量的类型以字符串形式返回</p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><pre><code>Number.MAX_VALUE  数字的最大值，若数字超过最大值，会返回
Number.MIN_VALUE  最小的正值，大于 0 的最小值
Infinity   表示正无穷
Infinity   正无穷，也属于数字类型
-Infinity  负无穷
NaN        表示 Not A Number，也属于数字类型</code></pre>
<p>在 JS 中整数运算基本可保证精确，但浮点数运算可能得到不精确结果，因此不要用 JS 进行对精确度要求较高的运算</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><h6 id="1-转换为字符串-String"><a href="#1-转换为字符串-String" class="headerlink" title="1. 转换为字符串 String"></a>1. 转换为字符串 String</h6><p><strong>方式一：</strong>调用 <code>变量.toString()</code>，该方法不会影响原变量，会将转换的结果返回，且 <strong>null 和 undefined 没有 toString() 方法</strong>，若调用会报错</p>
<p><strong>方式二：</strong>调用 <code>String(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回，且<strong>该方式对 null 和 undefined 有效</strong></p>
<p><strong>方式三：</strong>隐式类型转换，将任意数据类型 + 一个 <code>&quot;&quot;</code>，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>String()</code> 函数</p>
<h6 id="2-转换为数字-Number"><a href="#2-转换为数字-Number" class="headerlink" title="2. 转换为数字 Number"></a>2. 转换为数字 Number</h6><p><strong>方式一：</strong>使用 <code>Number(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p>— 若字符串中有非数字内容则转为 NaN，若字符串为空串或是全为空格的字符串会转为 0</p>
<p>— 对于布尔值，true 转为 1，false 转为 0</p>
<p>— null 会转为 0</p>
<p>— undefined 会转为 NaN</p>
<p><strong>方式二：</strong>针对字符串</p>
<p><code>parseInt(变量,进制)</code>可将字符串中的有效整数内容取出并转为 Number，第二个参数可不写，如 “123px” 会转为 123，“123a567” 会转为 123</p>
<p><code>parseFloat(变量)</code>可将字符串中的有效小数内容取出并转为 Number，如 “123.456.789px” 会转为 123.456</p>
<p>若对非 String 使用 <code>parseInt()</code> 或 <code>parseFloat()</code>会先将其转为 String 然后再操作</p>
<p><strong>方式三：</strong>隐式类型转换，可通过一个值 <code>-0</code> 或 <code>*1</code> 或 <code>/1</code> 来将其转为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<p><strong>方式四：</strong>隐式类型转换，将任意数据类型使用 <code>+</code> 来将其转换为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<h6 id="3-转换为布尔-Boolean"><a href="#3-转换为布尔-Boolean" class="headerlink" title="3. 转换为布尔 Boolean"></a>3. 转换为布尔 Boolean</h6><p><strong>方式一：</strong>调用 <code>Boolean(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p><strong>方式二：</strong>隐式类型转换，可通过为任意数据类型取两次反来将其转为 Boolean，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Boolean()</code> 函数</p>
<p>对于数字 —&gt; 布尔，除了 0 和 NaN，其余都是 true</p>
<p>对于字符串 —&gt; 布尔，除了空串，其余都是 true</p>
<p>null 和 undefined 都会转为 false</p>
<p>对象也会转换为 true</p>
<h4 id="其他进制数字"><a href="#其他进制数字" class="headerlink" title="其他进制数字"></a>其他进制数字</h4><p>JS 中十六进制数字需以 <code>0x</code> 开头，八进制数字需以 <code>0</code> 开头，二进制需以 <code>0b</code> 开头（二进制表示方法浏览器兼容性不好）</p>
<p>注意 <code>a=070</code> 表示八进制，而字符串 <code>a=&quot;070&quot;</code> 转为数字时有些浏览器会当八进制，有些会当十进制转换，可在 <code>parseInt(变量,进制)</code> 中传递进制参数来解决</p>
<h3 id="（2）变量"><a href="#（2）变量" class="headerlink" title="（2）变量"></a>（2）变量</h3><p>变量可用来保存和描述字面量，且变量值可任意改变</p>
<h2 id="3、标识符"><a href="#3、标识符" class="headerlink" title="3、标识符"></a>3、标识符</h2><p>所有可自主命名的都是标识符，如变量名、函数名、属性名</p>
<p>规则：（1）可含有字母、数字、_、$</p>
<p>（2）不能以数字开头</p>
<p>（3）不能是 JS 中的关键字或保留字，如下图</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97.png" alt="关键字和保留字"></p>
<p>（4）一般都采用驼峰命名法：首字母小写，每个单词开头字母大写，其余字母小写</p>
<p>除了（4），其他都是强制要求</p>
<p><strong>注意：JS 底层保存标识符时是采用 Unicode 编码，所以理论上所有 utf-8 中含有的内容都可以作为标识符</strong></p>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="（1）二元运算符"><a href="#（1）二元运算符" class="headerlink" title="（1）二元运算符 + - * /"></a>（1）二元运算符 + - * /</h3><p>当对非 Number 类型的值进行运算时，会先将这些值转换为 Number 再运算（除了 Number 和字符串做<strong>加法</strong>以外），Number 和 字符串做减法/乘法等都是转换为 Number</p>
<p>任何值和 NaN 做运算结果都为 NaN</p>
<p>若对两个字符串作加法，则会把两个字符串拼接为一个字符串</p>
<p>任何值和字符串做加法，都会先转换为字符串，然后再和字符串作拼串操作（可用于 String 强制类型转换）</p>
<p>注意<br>    result = 1 + 2 + “3”;   //结果是“33”<br>    result = “1” + 2 + 3;   //结果是“123”</p>
<p>任何值做 - * / 都会自动转换为 Number（可用于 Number 强制类型转换）</p>
<h3 id="（2）一元运算符"><a href="#（2）一元运算符" class="headerlink" title="（2）一元运算符"></a>（2）一元运算符</h3><p><code>+</code> 正号不会对数字产生影响，<code>-</code> 负号可以对数字取反</p>
<p>对于非 Number 类型的值，会将其先转换为 Number 再运算（可用于 Number 强制类型转换）</p>
<pre><code>result = 1 + &quot;2&quot; + 3;   //结果是“123”
result = 1 + +&quot;2&quot; + 3;   //结果是6</code></pre>
<p>自增/减分为两种：后<code>++</code>（<code>a++</code>）或后<code>--</code>（<code>a--</code>）和前<code>++</code>（<code>++a</code>）或前<code>--</code>（<code>--a</code>），两种值不同</p>
<p>— <code>a++</code>和<code>a--</code>的值等于原变量的值（自增/减前的值）</p>
<p>— <code>++a</code>和<code>--a</code>的值等于原变量新值（自增/减后的值）</p>
<pre><code>var a = 20;
console.log(a++ + ++a + a);  //结果为 20 + 22 + 22
var b = 20;
b = b++;   //结果为 20，因为 b++ 的值为 20</code></pre>
<h3 id="（3）条件（三元）运算符"><a href="#（3）条件（三元）运算符" class="headerlink" title="（3）条件（三元）运算符"></a>（3）条件（三元）运算符</h3><p>语法 <code>条件表达式 ? 语句1 : 语句2;</code>，若条件表达式是非布尔值，则会将其转换为布尔值再比较</p>
<h3 id="（4）逻辑运算符"><a href="#（4）逻辑运算符" class="headerlink" title="（4）逻辑运算符"></a>（4）逻辑运算符</h3><p><code>!</code> 对非布尔值进行运算都会将其转换为布尔值，然后再取反（可用于 Boolean 强制类型转换）</p>
<p>JS 中的 “与&amp;&amp;” 属于短路的 “与”，（即若第一个值为 false 则不会再检查第二个）</p>
<p>JS 中的 “或||” 属于短路的 “或”，（即若第一个值为 true 则不会再检查第二个）</p>
<p>对于非布尔值进行与或运算都会将其转换为布尔值，并返回转换前的值</p>
<p>与运算：若两个值都为 true，则返回后面的值，若两个值中有 false，则返回靠前的 false（即若第一个值为 true 则必然返回第二个值，若第一个值为 false 则直接返回第一个值）</p>
<p>或运算：若两个值都为 false，则返回后面的值，若两个值中有 true，则返回靠前的 true（即若第一个值为 false 则必然返回第二个值，若第一个值为 true 则直接返回第一个值）</p>
<h3 id="（5）关系运算符"><a href="#（5）关系运算符" class="headerlink" title="（5）关系运算符"></a>（5）关系运算符</h3><p>对于非数值进行 &gt; &gt;= &lt; &lt;= 比较时，会将其转换为数字然后再比较</p>
<p>若比较符号两侧都是字符串时不会将其转换为数字，而会分别比较字符串中字符的 Unicode 编码，比较字符编码时是一位一位比较，若两位一样则比较下一位，否则直接返回比较结果（可利用该特性对英文进行排序，比较中文没有意义）</p>
<p>在比较两个字符串型的数字时，一定要转型，转型后比较的就是数字大小，否则会一位一位比较字符串编码</p>
<p>任何值和 NaN 做任何比较都是 false</p>
<pre><code>1 &gt; true     //false
1 &gt;= true     //true
10 &gt; null     //true
10 &gt; &quot;hello&quot;  //false 相当于比较 10 &gt; NaN</code></pre>
<h3 id="（6）相等运算符"><a href="#（6）相等运算符" class="headerlink" title="（6）相等运算符"></a>（6）相等运算符</h3><p>当使用 <code>==</code> 或 <code>!=</code> 比较时若值的类型不同，则会自动进行类型转换，将其转换为相同类型后再比较</p>
<p>undefined 衍生自 null，所以这两个值做相等判断时会返回 true</p>
<p>NaN 不和任何值相等，包括它本身，通过 <code>isNaN()</code> 函数判断一个值是否是 NaN</p>
<pre><code>&quot;1&quot; == 1      //true，转为 Number 比较
true == &quot;1&quot;   //true，二者都转为 Number
null == 0     //false 注意
undefined == null  //true
Nan == Nan    //false</code></pre>
<p><code>===</code> 全等，和 <code>==</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 false；<code>!==</code> 不全等，和 <code>!=</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 true</p>
<pre><code>undefined === null  //false</code></pre>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>使用 <code>,</code> 可同时声明多个变量并赋值，如<code>var a=1,b=2,c=3</code></p>
<h2 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h2><p>运算符优先如下图，越靠上优先级越高</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p>
<h2 id="6、代码块"><a href="#6、代码块" class="headerlink" title="6、代码块"></a>6、代码块</h2><p>JS 中可使用 <code>&#123;&#125;</code> 为语句分组，同一个 <code>&#123;&#125;</code> 中的语句称为一个代码块，要么都执行，要么都不执行</p>
<p>JS 中的代码块只有分组的作用，没有其他用途，代码块内部的内容在外部是完全可见的</p>
<p>代码块后不用写 <code>;</code></p>
<h2 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h2><p>语句分类：条件判断语句、条件分支语句、循环语句</p>
<p>switch…case 语句中的条件判断是采用全等</p>
<p>for 循环中 <code>()</code> 内三个部分都可以省略，也可以写在外部，若在 for 循环中不写任何表达式，只写两个 <code>;</code> 是个死循环，慎用</p>
<p>可为循环语句创建一个 label，来标识当前循环，用法为 <code>标签名:循环语句</code>，使用 break 或 continue 语句时，可在 break 或 continue 后跟着一个 label，此时 break 将会结束指定的循环，或 continue 将会跳过当前的指定循环，而不是最近的循环</p>
<pre><code>outer:
for(var i=0;i&lt;5;i++)&#123;
    语句...
    for(var j=0;j&lt;5;j++)&#123;
        break outer;  //此时 break 结束的是外层循环
    &#125;
&#125;</code></pre>
<h2 id="8、对象"><a href="#8、对象" class="headerlink" title="8、对象"></a>8、对象</h2><p>基本数据类型创建的变量都是独立的，不能成为一个整体</p>
<p>对象不是基本数据类型，而是引用数据类型，是复合数据类型</p>
<p>除了基本数据类型外一切都是对象，网页中看到的所有都是对象</p>
<h3 id="（1）对象的分类"><a href="#（1）对象的分类" class="headerlink" title="（1）对象的分类"></a>（1）对象的分类</h3><p><strong>内建对象</strong></p>
<p>由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用，如 Math、String、Number、Boolean、Function、Object 等</p>
<p><strong>宿主对象</strong></p>
<p>由 JS 的运行环境提供的对象，主要指由浏览器提供的对象，如 BOM、DOM，这是两组对象，由许多对象组成，如 console、document 都是由浏览器创建提供的，是宿主对象</p>
<p><strong>自定义对象</strong></p>
<p>由开发人员自己创建的对象</p>
<h3 id="（2）创建对象"><a href="#（2）创建对象" class="headerlink" title="（2）创建对象"></a>（2）创建对象</h3><p>使用 <code>new</code> 关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数</p>
<p>使用 <code>typeof</code> 检查一个对象时，会返回 object</p>
<h4 id="使用工厂方法创建对象"><a href="#使用工厂方法创建对象" class="headerlink" title="使用工厂方法创建对象"></a>使用工厂方法创建对象</h4><pre><code>function createPerson(name,age,gender)&#123;
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    obj.sayName = function()&#123;
        alert(this.name);
    &#125;
    return obj;
&#125;
var obj1 = createPerson(&quot;xxx&quot;,18,&quot;男&quot;); </code></pre>
<h4 id="创建构造函数来创建对象"><a href="#创建构造函数来创建对象" class="headerlink" title="创建构造函数来创建对象"></a>创建构造函数来创建对象</h4><p>使用同一个构造函数创建的对象称为一类对象，也将一个构造函数称为一个类，将通过构造函数创建的对象称为该类的实例</p>
<p>使用 <code>instanceof</code> 可检查一个对象是否是一个类的实例，<code>对象 instanceof 构造函数</code> 返回布尔值，所有对象都是 Object 的后代，所以任何对象和 Object 做 instanceof 检查时都会返回 true</p>
<p>构造函数就是一个普通函数，不同的是构造函数习惯上首字母大写。</p>
<p><strong>构造函数和普通函数的区别：</strong>普通函数直接调用，而构造函数需要使用 new 关键字调用</p>
<p><strong>构造函数执行流程：</strong></p>
<ol>
<li><p>立刻创建一个新的对象</p>
</li>
<li><p>将新建的对象设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象</p>
</li>
<li><p>逐行执行函数中的代码</p>
</li>
<li><p>将新建的对象作为返回值返回</p>
<p> function Person(name,age,gender){</p>
<pre><code> this.name = name;
 this.age = age;
 this.gender = gender;
 this.sayName = function()&#123;
     alert(this.name);
 &#125;</code></pre>
<p> }<br> var per = new Person(“xxx”,18,”男”); </p>
</li>
</ol>
<p><strong>构造函数的方法定义</strong></p>
<p>在构造函数内部创建的方法，每执行一次构造函数就会创建一个新的相同方法，所有实例的该方法都是唯一的，这没有必要，所以可使所有对象共享同一个方法</p>
<p>方式一：将方法定义到全局作用域中</p>
<p>但是将函数定义到全局作用域中会污染了全局作用域的命名空间，并且也很不安全，容易被另一个程序猿覆盖</p>
<p>方式二：使用原型对象</p>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><p><code>var 对象名 = new Object();</code> 或 <code>var 对象名 = &#123;&quot;属性名1&quot;:属性值,属性名n:属性值&#125;;</code> 创建对象，第二种方式的对象也叫对象字面量，对象字面量的属性名可加引号也可不加，但若使用一些特殊名字时必须加引号</p>
<p><code>对象.属性名 = 属性值;</code> 向对象添加属性，对象的属性名不强制要求遵守标识符的规范，但尽量按照标识符的规范</p>
<p><code>对象[&quot;属性名&quot;] = 属性值;</code> 向对象添加属性，对于使用特殊的属性名时，不能采用 <code>.</code> 的方式操作</p>
<p><code>对象.属性名;</code> 读取对象中的属性，若读取对象中没有的属性不会报错，而会返回 undefined</p>
<p><code>对象[&quot;属性名&quot;]</code> 读取对象中的属性，这种方式更灵活，因为 <code>[]</code> 中可以传变量，而 <code>.</code> 的方式操作属性会需要准确的属性名。此外，对于使用 <code>对象[&quot;属性名&quot;] = 属性值;</code> 赋值的属性只能用这种方式读取属性</p>
<p><code>对象.属性名 = 新值;</code> 修改对象的属性值</p>
<p><code>delete 对象.属性名;</code> 删除对象的属性</p>
<p><code>&quot;属性名&quot; in 对象</code> 检查对象或其原型中是否含有某属性</p>
<p><code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查对象自身是否含有某属性</p>
<p>枚举对象的属性</p>
<pre><code>for(var 变量 in 对象)&#123;xxx&#125;
对象中有几个属性循环体就会执行几次，其中每次执行时就把对象中的一个属性名赋值给变量</code></pre>
<p>JS 对象的属性值可以是任意的数据类型，甚至也可以是一个对象（如函数）</p>
<p>若函数作为一个对象的属性，则称该函数是这个对象的方法，调用该函数称为调用对象的方法</p>
<h2 id="9、基本数据类型和引用数据类型"><a href="#9、基本数据类型和引用数据类型" class="headerlink" title="9、基本数据类型和引用数据类型"></a>9、基本数据类型和引用数据类型</h2><p>JS 中的变量都是保存到栈内存中，基本数据类型直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量</p>
<p>对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新空间，而变量保存的是对象的内存地址（对象的引用），若两个变量保存的是同一个对象引用，当通过一个变量修改该对象属性时，另一个也会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="基本数据类型和引用数据类型"></p>
<p>但是当两个变量表示同一个对象时，把其中一个变量值设为 null 后另一个变量依然指向对象不会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="基本数据类型和引用数据类型1"></p>
<p>当比较两个基本数据类型时就是比较它们的值，而比较两个引用数据类型时比较的是内存地址，即使两个对象内容一样，但地址不同依然会返回 false</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="基本数据类型和引用数据类型2"></p>
<h2 id="10、函数"><a href="#10、函数" class="headerlink" title="10、函数"></a>10、函数</h2><p>函数也是一个对象，是一个具有功能的对象，使用 <code>typeof</code> 检查一个函数对象时会返回 function</p>
<p><code>var 变量名 = new Function();</code> 使用构造函数创建函数对象，可将要封装的代码以字符串的形式传递给构造函数，如 <code>var fun = new Function(&quot;console.log(&#39;hello world&#39;)&quot;);</code>，但开发中很少使用构造函数来创建一个函数对象</p>
<p><code>function 函数名([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数声明创建一个函数</p>
<p><code>var 函数名 = function([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数表达式创建函数，相当于声明一个匿名函数并赋值给变量</p>
<p><code>函数对象();</code> 调用函数</p>
<p><code>(function([形参1,形参n])&#123;xxx&#125;)([形参1,形参n])</code> 匿名函数定义完立即被调用，这种函数称为立即执行函数，立即执行函数往往只会执行一次</p>
<p>函数声明中的形参相当于在函数内部声明了相应变量</p>
<p><strong>调用函数时解析器不会检查实参的类型</strong>，所以要注意是否有可能会接收到非法参数，若有可能则需要对参数进行类型检查</p>
<p><strong>调用函数时解析器不会检查实参的数量</strong>，多余的参数不会被赋值，若实参的数量少于形参的数量，则没有对应实参的形参将是 undefined</p>
<p>函数中的参数可以是另一个函数，当实参中的函数是 <code>函数名()</code> 表示调用函数，使用的是函数的返回值，当实参中的函数是 <code>函数名</code> 表示函数对象，相当于直接使用函数对象</p>
<p>若函数的 return 可以返回任意类型的值，若 return 语句后不跟任何值或不写 return 语句，相当于返回 undefined</p>
<h1 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h1><p>JS 中有两种作用域：全局作用域、函数作用域</p>
<h2 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h2><p>直接编写在 <code>&lt;script&gt;</code> 标签中的 JS 代码都在全局作用域，全局作用域中的变量都是全局变量，在页面任意部分都能访问到</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁</p>
<p>全局作用域中有一个全局对象 window，代表一个浏览器的窗口，由浏览器创建可直接使用</p>
<p>在全局作用域中创建的变量都会作为 window 对象的属性保存，创建的函数都会作为 window 对象的方法</p>
<p><strong>变量声明提前：</strong>使用 var 关键字声明的变量，会在所有代码执行之前被声明（但不一定会赋值），但若声明变量时不使用 var 关键字，则变量不会被声明提前</p>
<pre><code>console.log(a);
var a = 123;  //该行对变量 a 的声明实际上会在最开头，只是在这一行被赋值</code></pre>
<p><strong>函数声明提前：</strong>使用函数声明形式 <code>function 函数()&#123;&#125;</code> 创建的函数会在所有代码执行之前被创建，所以可以在函数声明前调用。但是使用函数表达式 <code>var 变量 = function()&#123;&#125;</code> 创建的函数不会被声明提前，所以不能在声明前调用</p>
<h2 id="2、函数作用域"><a href="#2、函数作用域" class="headerlink" title="2、函数作用域"></a>2、函数作用域</h2><p>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，它们之间相互独立</p>
<p>当在函数作用域中操作一个变量时会先在自身作用域中寻找，若有就直接使用，若没有则向上一级作用域中寻找，直到找到全局作用域，若全局作用域中依然没有找到，则会报错 ReferenceError</p>
<p>在函数中要访问全局变量可使用 window 对象，<code>window.变量名</code></p>
<p>在函数作用域中也有声明提前的特性，使用 var 关键字声明的变量会在函数中所有代码执行之前被声明。函数声明也会在函数中所有代码执行之前执行。定义形参相当于在函数作用域中声明了变量</p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    var c = 10;
&#125;
func();  //此时会输出 “undefined”，因为在 func 函数中var c 变量会声明提前，但是执行到 console 语句时函数作用域中的 c 变量还未被赋值</code></pre>
<p>在函数中不使用 var 声明的变量都会成为全局变量 </p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    c = 10;
&#125;
func();  //此时会输出 1，因为函数中 c 没有使用 var 关键字所以不会提前声明，所以向上一级中找 c</code></pre>
<h1 id="四、this"><a href="#四、this" class="headerlink" title="四、this"></a>四、this</h1><p>解析器在调用函数每次都会向函数内部传递一个隐含的参数 this</p>
<p>this 指向一个对象，这个对象称为函数执行的上下文对象</p>
<p>根据函数<strong>调用方式</strong>的不同，this 会指向不同的对象</p>
<p>— 以函数的形式（<code>函数名()</code>，也相当于 <code>window.函数名()</code>）调用时，this 永远是 window</p>
<p>— 以方法的形式（<code>对象.方法名()</code>）调用时，this 就是调用方法所属的那个对象</p>
<p>— 在构造函数中调用时，this 就是新创建的那个对象</p>
<p>— 使用 call 和 apply 调用时，this 是指定的那个对象</p>
<p>— 在事件响应函数中，this 指向响应函数所绑定的对象（普通情况下）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— addEventListener() 中 this 指向绑定事件的对象</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— attachEvent() 中 this 指向 window</p>
<h1 id="五、原型对象"><a href="#五、原型对象" class="headerlink" title="五、原型对象"></a>五、原型对象</h1><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>创建的每个函数，解析器都会向函数中添加一个属性 prototype，这个属性对应着一个原型对象</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><p>若函数作为普通函数调用 prototype 没有任何作用，但当以构造函数形式调用时，它所实例化的对象都会有个隐含属性指向该构造函数的原型对象，可通过 <code>__proto__</code> 来访问该属性</p>
<h2 id="原型对象中的属性、方法"><a href="#原型对象中的属性、方法" class="headerlink" title="原型对象中的属性、方法"></a>原型对象中的属性、方法</h2><p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，可将对象中共有的内容（属性、方法）统一设置到原型对象中</p>
<p>当访问对象的属性或方法时会先在对象自身中寻找，若有则直接使用，若没有则去原型对象中寻找</p>
<pre><code>function Person(name,age,gender)&#123;
    this.name = name;
    this.age = age;
    this.gender = gender;
&#125;
Person.prototype.sayName = function()&#123;
    alert(this.name);
&#125;
var per = new Person(&quot;xxx&quot;,18,&quot;男&quot;); 
per.sayName();</code></pre>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="原型对象"></p>
<p>使用 <code>&quot;属性名&quot; in 对象实例</code> 检查对象中是否含有某属性时，若对象中没有但是原型中有也会返回 true</p>
<p>使用 <code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查的是对象自身中是否含有该属性</p>
<p>原型对象也是对象，所以它也有原型，当使用一个对象的属性或方法时，先在自身中寻找，若没有则去原型对象中寻找，若依然没有则去原型的原型中寻找，直到找到 Object 对象的原型</p>
<p>Object 对象的原型没有原型，若在 Object 中依然没有找到，则返回 undefined。Object 的 <code>__proto__</code> 是 null</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt="原型的原型"></p>
<h2 id="修改原型对象中的方法"><a href="#修改原型对象中的方法" class="headerlink" title="修改原型对象中的方法"></a>修改原型对象中的方法</h2><p>当在页面中打印对象时实际上是输出对象的 toString() 方法的返回值，若不希望输出 [Object Object]，可为当前对象实例添加一个 toString() 方法，或者修改对象原型的 toString()方法</p>
<pre><code>per.toString() = function()&#123; //但该方法只对当前实例有效
    return &quot;xxx&quot;
&#125;
Person.prototype.toString = function()&#123;  //该方法对该对象的所有实例有效
    return &quot;xxxx&quot;
&#125;</code></pre>
<h1 id="六、垃圾回收（GC）"><a href="#六、垃圾回收（GC）" class="headerlink" title="六、垃圾回收（GC）"></a>六、垃圾回收（GC）</h1><p>程序运行过程中会产生垃圾，垃圾积攒过多后会导致程序运行速度过慢</p>
<p>垃圾：当一个对象没有任何的变量或属性对它进行引用，此时将永远无法操作该对象，这是这种对象就是一个垃圾，这种对象过多会占用大量内存空间导致程序运行变慢，须进行清理</p>
<p>JS 中有自动垃圾回收机制，由浏览器、JS 引擎将这些垃圾对象自动从内存中销毁，我们不需要也不能进行垃圾回收操作</p>
<p>我们需要做的只是要将不再使用的对象设置为 null 即可</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="垃圾回收"></p>
<h1 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h1><p>数组也是个内建对象，和普通对象不同的是普通对象使用字符串作为属性名，而数组使用数字作为索引操作元素</p>
<p>数组的存储性能比普通对象好，开发中常使用数组存储数据</p>
<p>数组中的元素可以是任意数据类型，也可以是对象（函数、数组等）</p>
<p>使用 typeof 检查一个数组时会返回 object</p>
<h2 id="1、数组对象的操作"><a href="#1、数组对象的操作" class="headerlink" title="1、数组对象的操作"></a>1、数组对象的操作</h2><p><code>var 数组名 = new Array(元素1,元素2,...,元素n)</code> 或 <code>var 数组名 = new Array(数组长度)</code> 使用构造函数创建数组对象</p>
<p><code>var 数组名 = [元素1,元素2,...,元素n]</code> 使用字面量创建数组对象</p>
<p><code>数组名[索引] = 值</code> 向数组中添加元素</p>
<p><code>数组名[索引]</code> 读取数组中的元素，若读取不存在的索引不会报错而是返回 undefined</p>
<p><code>数组名.length</code> 设置或获取数组的最大索引+1，即使数组中不连续；通过 length 设置数组长度时，若修改的长度大于原长度则多出部分会空出来，若小于原长度则多出部分会被移除</p>
<p><code>数组名[数组名.length] = 值</code> 向数组最后添加元素</p>
<h2 id="2、数组的方法"><a href="#2、数组的方法" class="headerlink" title="2、数组的方法"></a>2、数组的方法</h2><h3 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a>添加与删除</h3><p><code>push(元素1,元素2,...,元素n)</code> 向数组末尾添加一个或多个元素，并返回数组的新长度</p>
<p><code>pop()</code> 删除数组的最后一个元素，并返回被删除的元素</p>
<p><code>unshift(第一个元素,第二个元素,...,第n个元素)</code> 向数组开头添加一个或多个元素，并返回数组的新长度，新数组中新增元素的顺序和传参顺序一致</p>
<p><code>shift()</code> 删除数组的第一个元素，并返回被删除的元素</p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><code>数组名.forEach(function(value,index,当前数组))</code> 遍历数组（只支持 IE8 以上的浏览器），需要一个函数作为参数（这种由我们创建不由我们调用的称为回调函数）</p>
<p>数组中有几个元素函数就会执行几次，每次执行时浏览器会将遍历到的元素以实参形式传进来，浏览器会在回调函数中传递三个参数：(当前正遍历的元素, 当前正遍历元素的索引, 正在遍历的数组)</p>
<h3 id="数组片段获取"><a href="#数组片段获取" class="headerlink" title="数组片段获取"></a>数组片段获取</h3><p><code>slice(开始位置,结束位置)</code> 从某个已有的数组返回选定的元素，第二个参数可选，左闭右开，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>splice(开始位置,删除个数,添加元素1,添加元素n)</code> 删除元组并向数组添加新元素，<strong>会修改原数组</strong>，并返回被删除的元素，添加的元素会自动插入开始位置，并且顺序与参数传入顺序一致</p>
<h3 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h3><p><code>数组1.concat(数组2,数组n,元素1,元素n)</code> 连接两个或多个数组，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>数组.join(连接符)</code> 该方法将数组转换为字符串，方法<strong>不会影响原数组</strong>，默认使用 <code>,</code> 作为连接符</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>数组.reverse()</code> 用来反转数组，该方法<strong>直接修改原数组</strong></p>
<p><code>数组.sort()</code> 对数组中元素排序，该方法<strong>直接修改原数组</strong>，默认按照 Unicode 编码排序，所以对数组排序会得到错误结果（1开头都会排在前面）</p>
<p>可在 sort() 中添加回调函数指定排序规则，回调函数中需定义两个形参，浏览器根据回调函数返回值决定元素顺序（返回大于0，元素会交换位置，返回小于等于0，元素位置不变）</p>
<pre><code>数组.sort(function(a,b)&#123;
    return a-b;  //升序排列
&#125;)</code></pre>
<h1 id="八、call-和-apply"><a href="#八、call-和-apply" class="headerlink" title="八、call 和 apply"></a>八、call 和 apply</h1><p>call 和 apply 都是函数对象的方法，需要通过函数对象（不带括号的函数名）调用</p>
<h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>调用函数执行：当对函数调用 call() 和 apply() 都会调用函数执行</p>
<p>修改函数的 this：调用 call() 和 apply() 可将一个对象指定为第一个参数，此时这个对象会成为函数执行时的 this（原先 <code>函数名()</code> 函数调用时的 this 指向 window）</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>call() 方法可将实参在对象之后依次传递</p>
<p>apply() 方法需要将实参封装到一个数组中统一传递</p>
<pre><code>function fun()&#123;
    console.log(this)
&#125;
var obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
var obj2=&#123;name: &quot;obj2&quot;&#125;
fun.call(obj);  //this 指 obj，apply 同理
obj.sayName.call(obj);  //alert 的是 obj，apply 同理
obj.sayName.apply(obj2);  //alert 的是 obj2，call 同理

function fun(a,b)&#123;
    console.log(a);
    console.log(b);
&#125;
obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
fun.call(obj,2,3);
fun.apply(obj,[2,3]);</code></pre>
<h1 id="九、arguments"><a href="#九、arguments" class="headerlink" title="九、arguments"></a>九、arguments</h1><p>在调用函数时，浏览器每次都会传递两个隐含参数：（1）函数的上下文对象 this（2）封装实参的对象 arguments</p>
<p>arguments 是一个类数组对象，可以通过索引来操作数据，也可以获取长度（arguments.length）</p>
<p>调用函数时，传递的实参都会在 arguments 中保存，即使不定义形参也可通过 arguments 来使用实参（如 arguments[0] 表示第一个实参）</p>
<p>arguments 中有个属性叫 callee，该属性对应当前正在指向的函数对象</p>
<pre><code>function fun(a,b)&#123;
    console.log(arguments.callee == fun);  //输出 true
&#125;</code></pre>
<h1 id="十、Date-对象"><a href="#十、Date-对象" class="headerlink" title="十、Date 对象"></a>十、Date 对象</h1><p>Date 对象也是一个内建对象</p>
<p><code>var 变量 = new Date();</code> 使用构造函数创建 Date 对象，会封装为当前代码执行的时间</p>
<p><code>var 变量 = new Date(&quot;月/日/年 时:分:秒&quot;);</code> 创建指定时间的对象</p>
<p><code>Date对象实例.getDate();</code> 获取当前日期对象的日</p>
<p><code>Date对象实例.getDay();</code> 获取当前日期对象的星期几，会返回 0-6 表示周日-周六</p>
<p><code>Date对象实例.getMonth();</code> 获取当前日期对象的月，会返回 0-11 表示1月-12月</p>
<p><code>Date对象实例.getFullYear();</code> 获取当前日期对象的年</p>
<p><code>Date对象实例.getTime();</code> 获取当前日期对象的时间戳，时间戳指从格林威治标准时间1970年1月1日0时0分0秒到当前日期所花费的毫秒数</p>
<pre><code>var d = new Date(&quot;1/1/1970 0:0:0&quot;);
console.log(d.getTime());  //输出为 -28800000，因为系统使用的是北京时间，和格林威治标准时间相差八小时</code></pre>
<p><code>Date.now();</code> 获取当前时间戳</p>
<p>计算机底层在保存时间时使用的都是时间戳</p>
<p>可使用时间戳测试代码的执行性能</p>
<h1 id="十一、Math"><a href="#十一、Math" class="headerlink" title="十一、Math"></a>十一、Math</h1><p>Math 和其他对象（如 Date）不同，它不是一个构造函数，它属于工具类，封装了数学运算相关的属性和方法</p>
<p><code>Math.PI</code> 圆周率</p>
<p><code>Math.abs(数字)</code> 计算绝对值</p>
<p><code>Math.ceil(数字)</code> 向上取整，小数位有就自动进 1</p>
<p><code>Math.floor(数字)</code> 向下取整</p>
<p><code>Math.round(数字)</code> 四舍五入取整</p>
<p><code>Math.random()</code> 生成 0~1 之间（不包括 0 和 1）的随机数  </p>
<p><code>Math.round(Math.random()*x)</code> 生成 0~x 之间（包括 0 和 x）的随机整数    </p>
<p><code>Math.round(Math.random()*(y-x)+x)</code> 生成 x~y 之间（包括 x 和 y）的随机整数</p>
<p><code>Math.max(数字1,数字2,...,数字n)</code> 取最大值</p>
<p><code>Math.min(数字1,数字2,...,数字n)</code> 取最小值 </p>
<p><code>Math.pow(x,y)</code> x 的 y 次幂</p>
<p><code>Math.sqrt(数字)</code> 开方</p>
<h1 id="十二、包装类"><a href="#十二、包装类" class="headerlink" title="十二、包装类"></a>十二、包装类</h1><p>JS 中提供了三个包装类将基本数据类型转换为对象：</p>
<p><code>String()</code> 将基本数据类型字符串转换为 String 对象</p>
<p><code>Number()</code> 将基本数据类型数字转换为 Number 对象</p>
<p><code>Boolean()</code> 将基本数据类型布尔值转换为 Boolean 对象</p>
<p>转换成对象后可添加属性</p>
<p>实际应用中不会使用基本数据类型的对象，若使用基本数据类型的对象，在做比较时可能会有不可预料的结果</p>
<p>方法和属性只能添加给对象，不能添加给基本数据类型</p>
<p>但是当对基本数据类型的值调用属性或方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法，调用后再转换回基本数据类型，如基本数据类型调用 toString() 方法</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>在底层字符串是以字符数组的形式保存的，可使用索引和 length</p>
<p><code>字符串.charAt(索引)</code> 返回指定位置的字符，<strong>不会影响原字符串</strong></p>
<p><code>字符串.charCodeAt(索引)</code> 返回指定位置字符的 Unicode 编码 </p>
<p><code>String.fromCharCode(十进制编码或 0x十六进制)</code> 根据字符 Unicode 编码获取字符 </p>
<p><code>字符串.concat(字符串1,字符串2,字符串n)</code> 连接两个或多个字符串,<strong>不会影响原字符串</strong></p>
<p><code>字符串.indexOf(字符,开始检索位置)</code> 返回字符在字符串中第一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.lastIndexOf(字符,开始检索位置)</code> 返回字符在字符串中最后一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.slice(开始位置,结束位置)</code> 截取字符串，左闭右开，<strong>不会影响原字符串</strong>，若省略第二个参数则默认是字符串末尾，可使用负值参数</p>
<p><code>字符串.substring(开始位置,结束位置)</code> 截取字符串，和 slice 类似，左闭右开，，<strong>不会影响原字符串</strong>，但该方法不能接收负值参数，若传递负值默认使用 0，并且会自动调整参数为升序</p>
<p><code>字符串.substr(开始位置,截取长度)</code> 截取字符串，<strong>不会影响原字符串</strong>，但 ECMAScript 没有对该方法标准化，所以不建议使用</p>
<p><code>字符串.split(分割符)</code> 将字符串拆分为数组，若传递一个空串作为参数，则会拆分出字符串中的每个字符，也可传正则表达式</p>
<p><code>字符串.toUpperCase()</code> 字符串转为大写，<strong>不会影响原字符串</strong></p>
<p><code>字符串.toLowerCase()</code> 字符串转为小写，<strong>不会影响原字符串</strong></p>
<h1 id="十三、正则表达式"><a href="#十三、正则表达式" class="headerlink" title="十三、正则表达式"></a>十三、正则表达式</h1><p>正则表达式用于定义一些字符串的规则，计算机可根据正则表达式，检查一个字符串是否符合规则，或将字符串中符合规则的内容提取出来</p>
<p>正则表达式是个对象，使用 typeof 检查正则对象，会返回 object</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><p><code>var 变量 = new RegExp(正则表达式,匹配模式)</code> 创建正则表达式对象，匹配模式可选值有 <code>&quot;i&quot;</code> 忽略大小写，<code>&quot;g&quot;</code> 全局匹配模式，可设置多个匹配模式，且顺序无要求，这种创建方式更灵活，因为参数中可传变量</p>
<p><code>var 变量 = /正则表达式/匹配模式</code> 使用字面量创建正则表达式，如 <code>var 变量 = /a/i;</code>，在正则表达式中使用 <code>|</code>或 <code>[]</code> 表示或，使用 <code>[^xxx]</code> 表示除了 xxx 以外的内容，这种创建方式更简单</p>
<h2 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h2><p><code>正则对象.test(待检查字符串)</code> 检查字符串是否符合正则表达式规则，返回布尔值</p>
<pre><code>var reg = new RegExp(&quot;a&quot;);  //该正则表达式可检查一个字符串中是否含有 a，默认严格区分大小
console.log(reg.test(&quot;abc&quot;)); //返回 true，因为含有 a

var reg = new RegExp(&quot;ab&quot;,&quot;i&quot;);  //该正则表达式可检查一个字符串中是否含有 ab，忽略大小写
console.log(reg.test(&quot;Abc&quot;)); //返回 true，因为含有 ab

var reg = /a|b|c/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[abc]/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[a-z]/;  //检查字符串中是否有任意小写字母
var reg = /[A-Z]/;  //检查字符串中是否有任意大写字母
var reg = /[A-z]/;  //检查字符串中是否有任意字母
var reg = /[0-9]/;  //检查字符串中是否有任意数字
var reg = /a[bde]c/;  //检查字符串中是否有 abc 或 adc 或 aec
var reg = /[^ab]/;  //检查字符串中是否有除了 ab 以外的内容
var reg = /[^0-9]/;  //检查字符串中是否有除了数字以外的内容</code></pre>
<h2 id="字符串和正则相关方法"><a href="#字符串和正则相关方法" class="headerlink" title="字符串和正则相关方法"></a>字符串和正则相关方法</h2><pre><code>字符串.split(/[A-z]/); 根据任意字母拆分字符串，该方法即使不指定全局匹配也会全都拆分 
字符串.search(/a[bde]c/); 搜索字符串中是否含有指定内容，返回第一次出现索引或 -1，设置全局匹配无效
字符串.match(/[A-z]/gi); 根据正则表达式，从字符串中将符合条件的内容提取出来，默认只找第一个符合要求的内容，可设置为全局匹配 g 模式这样可找符合要求的所有内容，返回数组
字符串.replace(被替换内容,新的内容); 
字符串.replace(/[a-z]/ig,&quot;&quot;);  //可删除所有字母</code></pre>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>通过量词可设置内容出现的次数</p>
<p>量词只对它前边的一个内容起作用</p>
<p><code>&#123;n&#125;</code> 正好出现 n 次</p>
<p><code>&#123;n,m&#125;</code> 出现 n~m 次</p>
<p><code>&#123;n,&#125;</code> 出现 n 次以上</p>
<p><code>n+</code> 至少出现 1 次 n，相当于 <code>&#123;1,&#125;</code></p>
<p><code>n*</code> 出现 0 次或多次 n，相当于 <code>&#123;0,&#125;</code></p>
<p><code>n?</code> 出现 0 次或 1 次 n，相当于 <code>&#123;0,1&#125;</code></p>
<p><code>^n</code> 以 n 开头</p>
<p><code>n$</code> 以 n 结尾</p>
<p><code>^n|n$</code> 以 n 开头或以 n 结尾</p>
<p><code>^n$</code> 字符串只能是 n</p>
<pre><code>var reg = /a&#123;3&#125;/;  字符串中连续出现 3 次 a
var reg = /(ab)&#123;3&#125;/;  字符串中连续出现 3 次 ab
var reg = /ab+c/;  字符串中 abc，其中 b 至少有一个
var reg = /^a/;  字符串中是否以 a 开头
var reg = /a$/;  字符串中是否以 a 结尾</code></pre>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><code>.</code> 表示任意字符，除了换行和行结束符</p>
<p><code>\w</code> 表示任意字母、数字、_</p>
<p><code>\W</code> 除了字母、数字、_，相当于 <code>[^A-z0-9_]</code></p>
<p><code>\d</code> 任意数字，相当于 [0-9_]</p>
<p><code>\D</code> 除了数字，相当于 [^0-9_]</p>
<p><code>\s</code> 表示空格</p>
<p><code>\S</code> 除了纯空格</p>
<p><code>\b</code> 表示单词边界，标识是个独立的单词</p>
<p><code>\B</code> 除了单词边界</p>
<p>正则表达式中使用 <code>\</code> 作为转义字符</p>
<p>注意：使用构造函数时，由于它的参数是一个字符串，而 \ 是字符串中转义字符，若使用 \ 则需使用 <code>\\</code> 代替</p>
<pre><code>var reg = /\\/;
reg.test(&quot;b.\&quot;);  //返回 false，因为 \ 转义的是 &quot;
reg.test(&quot;b.\\&quot;);  //返回 true
var reg = new RegExp(&quot;\\.&quot;);  //相当于 var reg = /\./;
var reg = new RegExp(&quot;\\\\&quot;);  //相当于 var reg = /\\/;</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>去除字符串中所有空格</p>
<pre><code>字符串.replace(/\s/g,&quot;&quot;)</code></pre>
<p>去除字符串开头的所有空格</p>
<pre><code>字符串.replace(/^\s*/,&quot;&quot;)</code></pre>
<p>去除字符串末尾的所有空格</p>
<pre><code>字符串.replace(/\s*$/,&quot;&quot;)</code></pre>
<p>去除字符串前后的所有空格</p>
<pre><code>字符串.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre>
<p>检查手机号是否合法：（1）以 1 开头（2）第二位 3-9 任意数字（3）第三位以后任意 9 个数字</p>
<pre><code>var reg = /^1[3-9][0-9]&#123;9&#125;$/  </code></pre>
<p>电子邮箱匹配：任意字母数字下划线.任意字母数字下划线（可有可无） @ 任意字母数字下划线.任意字母数字.任意字母（2-5位）.任意字母（2-5位）</p>
<pre><code>var reg = /^\w&#123;3,&#125;(\.\w+)*@[A-z0-9]+(\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/</code></pre>
<h1 id="十四、DOM"><a href="#十四、DOM" class="headerlink" title="十四、DOM"></a>十四、DOM</h1><h2 id="1、DOM"><a href="#1、DOM" class="headerlink" title="1、DOM"></a>1、DOM</h2><p>DOM（文档对象模型）是宿主对象，JS 中通过 DOM 对 HTML 文档进行操作</p>
<p>— 文档：整个 HTML 网页文档</p>
<p>— 对象：网页中的每个部分都转换为一个对象</p>
<p>— 模型：使用模型表示对象之间的关系，方便获取对象，DOM 树</p>
<h2 id="2、节点"><a href="#2、节点" class="headerlink" title="2、节点"></a>2、节点</h2><p>节点：构成网页的最基本的组成部分（最基本单元），网页中每一部分都可称为节点（如：html 标签、属性、文本、注释、整个文档等），但它们具体类型不同，节点类型不同，则其属性和方法也不同。</p>
<p>常用节点分为四类：</p>
<p>— 文档节点：整个 HTML 文档</p>
<p>— 元素节点：HTML 文档中的 HTML 标签</p>
<p>— 属性节点：元素的属性，并非元素节点的子节点，而是元素节点的一部分</p>
<p>— 文本节点：HTML 标签中的文本内容（任意非 HTML 的文本）</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>节点的共有属性：nodeName、nodeType、nodeValue</p>
<table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<p>浏览器已提供文档节点对象，该对象是 window 的属性，可在页面中直接使用，是全局变量。通过document 对象可在整个文档访问内查找节点对象，并可以通过该对象创建各种节点对象</p>
<h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><p>获取元素节点，都通过 document 对象调用</p>
<pre><code>document.getElementById(&quot;xxx&quot;)   通过 id 获取一个元素节点对象
document.getElementsByTagName(&quot;xxx&quot;)  通过标签名获取一组元素节点对象
document.getElementsByName(&quot;xxx&quot;)   通过 name 属性获取一组元素节点对象
document.documentElement;  获取 html 根标签
document.body;  获取 body 标签，保存的是 body 的引用
document.all;  代表页面中的所有元素
document.getElementsByTagName(&quot;*&quot;);  获取页面中的所有元素，相当于 document.all
document.getElementsByClassName(&quot;xxx&quot;);  根据元素的 class 属性值查询一组元素节点对象，但该方法不支持 IE8 及以下浏览器
document.querySelector(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法只返回唯一一个元素，若有多个满足条件的元素，则返回第一个，IE8也支持
document.querySelectorAll(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法返回符合条件的元素数组</code></pre>
<h3 id="获取-修改元素属性"><a href="#获取-修改元素属性" class="headerlink" title="获取/修改元素属性"></a>获取/修改元素属性</h3><p>获取元素属性：<code>元素.属性名</code>，注意 class 属性不能采用这种方式，因为 class 是 JS 中的保留字</p>
<p>读取 class 属性时需要使用 <code>元素.className</code></p>
<h3 id="获取-修改元素内的文本节点"><a href="#获取-修改元素内的文本节点" class="headerlink" title="获取/修改元素内的文本节点"></a>获取/修改元素内的文本节点</h3><p>修改获取到的元素节点对象属性：<code>变量.innerHTML = &quot;xxx&quot;</code>，注意 innerHTML 对自结束标签没有意义</p>
<p>或者先获取元素的文本子节点，再获取其 nodeValue 就是文本内容，如 <code>var 变量 = 元素对象.firstChild; console.log(变量.nodeValue)</code></p>
<p>注：<code>innerText</code> 可获取元素内部的文本内容，和 <code>innerHTML</code> 类似，不同的是它会自动将 html 标签去除只留下文本内容</p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><p>通过具体元素节点调用</p>
<pre><code>getElementsByTagName(&quot;xxx&quot;)  [方法]，返回当前节点的指定标签名后代节点，注意调用对象
childNodes  [属性]，表示当前节点的所有子节点（包括元素节点、文本节点等），注意 DOM 标签间的空白也会当成一个文本节点（IE8以上和其他浏览器）
children  [属性]，表示当前元素的所有子元素（而非节点，因此不会包含空格换行的文本节点）
firstChild  [属性]，表示当前节点的第一个子节点（包括空白文本节点）
firstElementChild  [属性]，表示当前节点的第一个子元素（不包括空白文本节点），IE8不支持
lastChild  [属性]，表示当前节点的最后一个子节点</code></pre>
<h3 id="获取元素节点的父节点和兄弟节点"><a href="#获取元素节点的父节点和兄弟节点" class="headerlink" title="获取元素节点的父节点和兄弟节点"></a>获取元素节点的父节点和兄弟节点</h3><p>通过具体的节点调用</p>
<pre><code>parentNode  [属性]，表示当前节点的父节点
previousSibling  [属性]，表示当前节点的前一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的前一个兄弟元素（不包括空白文本节点）
nextSibling  [属性]，表示当前节点的后一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的后一个兄弟元素（不包括空白文本节点）</code></pre>
<h3 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h3><pre><code>document.createElement(&quot;标签名&quot;);  可创建一个元素节点对象，并返回创建好的对象
document.createElement(&quot;文本内容&quot;); 可创建一个文本节点对象，并返回新节点
父节点.appendChild(子节点);  可向父节点中添加一个新的子节点
父节点.insertBefore(新子节点,指定的旧子节点);  在指定的子节点前面插入新的子节点
父节点.replaceChild(新子节点,指定的旧子节点);  使用新子节点替换已有子节点
父节点.removeChild(子节点);  删除子节点，相当于 子节点.parentNode.removeChild(子节点)
使用 innerHTML 也可以完成 DOM 的增删改相关操作，但这种方法有时候动静太大</code></pre>
<h2 id="3、文档加载"><a href="#3、文档加载" class="headerlink" title="3、文档加载"></a>3、文档加载</h2><p>浏览器加载页面时，按照自上向下顺序加载，读取到一行就运行一行</p>
<p>事件 JS 代码编写位置的三种情况：</p>
<p>（1）若将 <code>&lt;script&gt;</code> 标签写到页面上边 <code>&lt;head&gt;</code> 里，在代码执行时页面还没加载，则 DOM 对象也没有加载会导致无法获取 DOM 对象</p>
<p>（2）将 JS 代码编写到页面下部就是为了可以在页面加载完后再执行，这样性能也更好</p>
<p>（3）将事件写在 <code>onload</code> 事件中，<code>onload</code> 事件会在整个页面加载完成后才触发，确保代码执行时所有 DOM 对象已经加载完毕，支持该事件的对象有 image，layer，window，<code>window.onload = function()&#123;xxx&#125;</code></p>
<h2 id="4、利用-DOM-修改-CSS-样式"><a href="#4、利用-DOM-修改-CSS-样式" class="headerlink" title="4、利用 DOM 修改 CSS 样式"></a>4、利用 DOM 修改 CSS 样式</h2><h3 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式"></a>操作内联样式</h3><p><code>元素.style.样式名</code> 读取样式</p>
<p><code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<p>通过 style 属性设置和读取的都是<strong>内联样式</strong>，无法读取样式表中的样式</p>
<p>若 CSS 样式名中含有 <code>-</code>，这种名称在 JS 中是不合法的，如 background-color，需要将这种样式名改为驼峰命名法（去掉 -，将 - 后的字母大写）</p>
<p>因为内联样式有较高优先级，所以通过 JS 修改的样式往往会立即显示，但不会覆盖添加了 <code>!important</code> 的样式</p>
<pre><code>box1.style.width = &quot;200px&quot;;
box1.style.backgroundColor = &quot;red&quot;;</code></pre>
<h3 id="通过类修改样式"><a href="#通过类修改样式" class="headerlink" title="通过类修改样式"></a>通过类修改样式</h3><p>可通过修改元素的 class 属性间接修改样式，<code>元素对象.className = &quot;xxx&quot;</code> 或 <code>元素对象.className += &quot; xxx&quot;</code>（注意新类前面的空格），这样只需修改一次即可同时修改多个样式，浏览器只需重新渲染页面一次，性能较好，并且这种方式可以使表现和行为进一步分离</p>
<h3 id="读取元素样式"><a href="#读取元素样式" class="headerlink" title="读取元素样式"></a>读取元素样式</h3><p>（1）<code>元素.currentStyle.样式名&quot;</code> </p>
<p>获取元素当前正在显示的样式（只有 IE 浏览器支持）</p>
<p>该方法不能修改样式</p>
<p>（2）<code>元素.getComputedStyle(要获取样式的元素，伪元素)</code> </p>
<p>获取元素当前正在显示的样式，第二个参数一般都传 null，该方法返回一个封装了当前元素对应样式的对象</p>
<p>该方法不能修改样式</p>
<p>所有浏览器及 IE9 以上支持</p>
<p>（3）<code>元素.getComputedStyle(要获取样式的元素，伪元素).样式名</code> </p>
<p>获取元素当前正在显示的样式的值，若获取的样式没有设置，则会获取其真实值而非默认值，如若没有设置 width，不会获取到 auto，而会获取其真实宽度</p>
<p>该方法不能修改样式</p>
<p>不支持 IE8 及以下浏览器</p>
<p>（4）同时支持 IE8 和其他浏览器</p>
<p>可通过判断是否有 getComputedStyle 方法，若没有就用 currentStyle</p>
<pre><code>if(window.getComputedStyle)&#123;  
//注意这里需要加 window. 若不加是表示寻找变量，找不到就会报错，而加上表示寻找 window 对象的属性，找不到也不会报错而是返回 undefined
    return getComputedStyle(obj,null)
&#125;else&#123;
    return obj.currentStyle.样式名
&#125;</code></pre>
<h3 id="其他样式相关属性"><a href="#其他样式相关属性" class="headerlink" title="其他样式相关属性"></a>其他样式相关属性</h3><p><code>元素.clientWidth</code> 获取元素的可见宽度（包含内容区和内边距）</p>
<p><code>元素.clientHeight</code> 获取元素的可见高度（包含内容区和内边距）</p>
<p>上述两个属性获取到的值都是不带 px 单位的数字，可直接用于计算，并且是只读的，不能通过该属性修改样式</p>
<p><code>元素.offsetWidth</code> 获取元素的可见宽度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetHeight</code> 获取元素的可见高度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetParent</code> 获取当前元素的定位父元素，获取离当前元素最近的开启了定位的祖先元素，若所有祖先元素都没有开启定位，则返回 body</p>
<p><code>元素.offsetLeft</code> 当前元素相对于其定位父元素的水平偏移量</p>
<p><code>元素.offsetTop</code> 当前元素相对于其定位父元素的垂直偏移量</p>
<p><code>元素.scrollHeight</code> 元素整个滚动区域的高度</p>
<p><code>元素.scrollWidth</code> 元素整个滚动区域的宽度</p>
<p><code>元素.scrollLeft</code> 元素水平滚动条移动的距离</p>
<p><code>元素.scrollTop</code> 元素垂直滚动条移动的距离</p>
<p>onsrcoll 该事件会在元素滚动条滚动时触发</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<h1 id="十五、事件"><a href="#十五、事件" class="headerlink" title="十五、事件"></a>十五、事件</h1><p>事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间（如点击、鼠标移动、按下键盘、关闭窗口等）</p>
<p>JS 与 HTML 间的交互通过事件实现</p>
<p>在事件响应函数中，响应函数给谁绑定的 this 就是谁</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可在事件对应的属性中设置 JS 代码，当事件被触发时这些代码会执行</p>
<p>绑定事件的方式：</p>
<pre><code>方式一：
&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;xxx&#39;)&quot;&gt;按钮&lt;/button&gt;

方式二：
var btn = document.getElementById(&quot;元素id&quot;)
btn.onclick = function()&#123;xxx&#125;</code></pre>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数（除 IE8 及以下浏览器以外）</p>
<p>IE8 及以下浏览器中，是将事件对象作为 window 对象的属性保存的</p>
<p>在事件对象中封装了当前事件相关的一切信息，如鼠标坐标、键盘哪个键被按下、鼠标滚轮滚动的方向</p>
<p><code>event.clientX</code> 鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>window.event.clientX</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>event.clientY</code> 鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>window.event.clientY</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>event.pageX</code> 鼠标指针相对于<strong>整个页面</strong>的水平坐标，但在 IE8 中不支持</p>
<p><code>event.pageY</code> 鼠标指针相对于<strong>整个页面</strong>的垂直坐标，但在 IE8 中不支持</p>
<p><code>event.target</code> 表示触发事件的对象，而非事件所绑定的对象，区别于在响应函数中的 this 是指事件所绑定的对象</p>
<p>兼容不同浏览器的两种方式：</p>
<pre><code>元素.事件如onmousemove = function(event)&#123;
    if(!event)&#123;                     //方式一
        event = window.event;
    &#125;
    event = event || window.event;  //方式二，更常用
&#125;</code></pre>
<h2 id="事件冒泡（Bubble）"><a href="#事件冒泡（Bubble）" class="headerlink" title="事件冒泡（Bubble）"></a>事件冒泡（Bubble）</h2><p>冒泡指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件（如都是 onclick ）也会被触发</p>
<p>在开发中大部分情况冒泡是有用的，若不希望发生事件冒泡可通过事件对象的 cancelBubble 属性设置为 true 来取消冒泡</p>
<pre><code>元素对象.onclick = function(event)&#123;
    event = event || window.event;
    event.cancelBubble = true;
&#125;</code></pre>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><p>事件的委派指将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>通过事件委派可以只绑定一次事件即可应用到多个元素上，即使是后添加的元素</p>
<p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</p>
<p>触发事件的对象是期望的元素则执行，否则不执行，可通过判断 <code>if (event.target.className == &#39;xxx&#39;)</code> 来实现</p>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>（1）元素对象.事件 = 函数</p>
<p>当使用 <code>元素对象.事件 = 函数</code> 的形式绑定响应函数时只能同时为一个元素的一个事件绑定一个响应函数，若为同一事件绑定多个响应函数，则后面的会覆盖前面的</p>
<p>（2）addEventListener()</p>
<p>通过该方法也可为元素绑定响应函数，IE8 及以下浏览器不支持，在 IE8 中可使用 attachEvent() 来实现</p>
<p>参数：</p>
<p>— 事件的字符串（不要加on）</p>
<p>— 回调函数（当事件触发时会被调用）</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<pre><code>元素对象.addEventListener(&quot;click&quot;,function()&#123;&#125;,false);</code></pre>
<p>使用 addEventListener() 可以为一个元素的相同事件同时绑定多个响应函数，当事件被触发时，响应函数将会按照函数的绑定顺序执行</p>
<p>addEventListener() 中的 this，是绑定事件的对象</p>
<p>（3）attachEvent()</p>
<p>该方法功能和 addEventListener() 类似，也可以同时为一个事件绑定多个处理函数，不同的是该方法在 IE8 中支持，但在其他浏览器中不支持，并且它是后绑定的先执行，执行顺序和 addEventListener() 相反</p>
<p>参数：</p>
<p>— 事件的字符串（要加on）</p>
<p>— 回调函数</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<p>由于 attachEvent() 中的回调函数是由浏览器调用，所以 attachEvent() 中的 this 是 window</p>
<p>（4）兼容所有浏览器</p>
<pre><code>function bind(obj,eventStr,callback)&#123; //(要绑定的事件对象,去掉 on 的事件字符串,回调函数)
    if(obj.addEventListener)&#123;  //大部分浏览器兼容的方式
        obj.addEventListener(eventStr,callback,false);
    &#125;else&#123;  //IE8及以下浏览器
        obj.attachEvent(&quot;on&quot;+eventStr,function()&#123;
            callback.call(obj);
            //因为 this 是谁由调用方式决定，因为加匿名函数前 callback 由浏览器调用，所以外面加个匿名函数，在函数内来指定 callback 由谁调用
        &#125;);
    &#125;
&#125;</code></pre>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>关于事件传播，网景公司和微软公司由不同的理解和设计</p>
<p>微软认为事件应该是由内向外传播，当事件触发时应先触发当前元素的事件，再向当前元素的祖先元素上传播，即事件应该在冒泡阶段执行</p>
<p>网景公司认为事件应该由外向内传播，当事件触发时，应先触发当前元素的最外层祖先元素的事件，再向内传播给后代元素（即事件捕获）</p>
<p>W3C 综合了两个公司的方案，将事件传播分成了三个阶段</p>
<p>（1）捕获阶段：从最外层的祖先元素（大部分浏览器从 window 开始），向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>（2）目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>
<p>（3）冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>
<p>若希望在捕获阶段就触发事件，可以将 addEventListener() 的第三个参数设置为 true，一般情况下不会希望在捕获阶段触发事件，所以这个参数一般是 false</p>
<p>在 IE8 及以下浏览器中没有捕获阶段</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<p>onmousemove 该事件会在鼠标在元素中移动时被触发</p>
<p>onmousedown 鼠标按下</p>
<p>onmouseup 鼠标松开，可用于取消其他事件，如</p>
<pre><code>元素对象.onmouseup = function()&#123;
    对象.onmousemove = null;
    对象.onmouseup = null;
&#125;</code></pre>
<p><code>元素对象.setCapture()</code> 设置元素对鼠标按下相关事件进行捕获，该元素会把下一次所有鼠标按下相关的事件捕获到自身上（该方法只有 IE 支持，在火狐中调用不会报错，但 chrome 会报错）</p>
<p><strong>鼠标拖拽元素的例子：</strong></p>
<pre><code>box.onmousedown = function(event)&#123;  //box是开启一个绝对定位的 div
    box.setCapture &amp;&amp; box.setCapture();  //设置捕获代替解决 IE8 不支持 return false
    event = event || window.event;
    val ol = event.clientX - box.offsetLeft;
    val ot = event.clientY - box.offsetTop;
    document.onmousemove = function(event)&#123;
        event = event || window.event;
        val left = event.clientX - ol;
        val top = event.clientY - ot;
        box.style.left = left + &quot;px&quot;;
        box.style.top = top + &quot;px&quot;;
    &#125;
    document.onmouseup = function()&#123;
        box.onmousemove = null;
        box.onmouseup = null;
        box.releaseCapture &amp;&amp; box.releaseCapture();  //鼠标松开时取消对事件的捕获
    &#125;
    return false;  //因为拖拽时浏览器默认会去搜索引擎中搜索内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）
&#125;</code></pre>
<h2 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h2><p>onmousewheel 在鼠标滚轮滚动时触发（火狐不支持该属性）</p>
<p>火狐中滚轮滚动可使用 DOMMouseScroll 来绑定滚动事件，且该事件需要通过 addEventListener() 函数来绑定</p>
<p>event.wheelDelta 获取滚轮滚动的方向，往上为正，往下为负（火狐不支持该属性）</p>
<p>火狐中通过 event.detail 来获取滚动方向，往上为负，往下为正</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>当滚轮滚动时，若浏览器有滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为，若使用 addEventListener() 绑定响应函数应使用 event.preventDefault() 取消默认行为(IE8 不支持preventDefault)</p>
<p><strong>随滚轮滚动时元素高度改变的例子：</strong></p>
<pre><code>box.onnmousewheel = function(event)&#123;
    event = event || window.event;
    if(event.wheelDelta&gt;0 || event.wheelDelta&lt;0)&#123;
        //向上滚
        box.style.height = box.clientHeight - 10 + &quot;px&quot;;
    &#125;else&#123;
        //向下滚
        box.style.height = box.clientHeight + 10 + &quot;px&quot;;
    &#125;
    event.preventDefault &amp;&amp; event.preventDefault();
    return false;
&#125;
box.addEventListener(&quot;DOMMouseScroll&quot;,box.onnmousewheel);  //兼容火狐</code></pre>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>onkeydown 某个键盘按键被按下，若一直按着按键不松手事件会一直被触发。当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点（这是为了防止误操作发生）其他次会很快触发</p>
<p>onkeyup 某个键盘按键被松开</p>
<p>event.keyCode 获取按键的 Unicode 编码从而判断哪个按键被按下，数字 0-9 对应编码 48-57</p>
<p>altKey、ctrlKey、shiftKey 判断 alt、ctrl、shift 是否被按下</p>
<p>注意键盘事件一般都会绑定给可以获取焦点的对象（如 input）或者是 document，一般不给 div 绑定</p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123;
        console.log(&quot;ctrl和y都被按下&quot;)
    &#125;
    if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57)&#123;
        return false;  //不能输入数字
    &#125;
&#125;
document.onkeyup = function()&#123;
&#125;</code></pre>
<p><strong>根据方向键移动 div 的例子：</strong></p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    var speek = 10;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;</code></pre>
<h1 id="十六、BOM"><a href="#十六、BOM" class="headerlink" title="十六、BOM"></a>十六、BOM</h1><p>BOM（浏览器对象模型），BOM 可以使我们可以通过 JS 操作浏览器，DOM 是操作网页文档的，在 BOM 中提供了一组对象来完成对浏览器的操作</p>
<p>BOM 对象有：Window、Navigator、Location、History、Screen</p>
<p>（1）Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象</p>
<p>（2）Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器</p>
<p>由于历史原因 Navigator 对象中的大部分属性都已经不能识别浏览器了，一般只会使用 userAgent 来判断浏览器的信息，userAgent 是个包含用来描述浏览器信息内容的字符串</p>
<p>注意 IE11 中已经将微软和 IE 相关的表示去掉，所以不能通过 userAgent 识别是否是 IE 浏览器</p>
<p>若通过 userAgent 不能判断，还可通过一些浏览器中特有的对象来判断浏览器信息，如 ActiveXObject 是 IE 独有的</p>
<pre><code>var ua = navigator.userAgent;
if(/firefox/i.test(ua))&#123;
    console.log(&quot;火狐&quot;);
&#125;else if(/chrome/i.test(ua))&#123;
    console.log(&quot;chrome&quot;);
&#125;else if(/msie/i.test(ua))&#123;
    console.log(&quot;IE&quot;);
&#125;else if(&quot;ActiveXObject&quot; in window)&#123;
    console.log(&quot;IE11&quot;);
&#125;</code></pre>
<p>（3）Location：当前浏览器的地址栏信息，通过 Location 可获取地址栏信息或操作浏览器跳转页面</p>
<p>若直接打印 location 可获取地址栏的信息（当前页面的完整路径）</p>
<p>location = “xxxx” 直接将属性修改为一个完整的路径或相对路径则页面会自动跳转到该路径，<strong>并会生成相应的历史记录</strong></p>
<p>location.assign(“路径”) 用来跳转到其他页面，作用和直接修改 location 一样</p>
<p>location.reload() 重新加载当前页面，作用和刷新一样，若传递 true 作为参数则会强制清空缓存刷新页面</p>
<p>location.replace(“路径”) 使用新的页面替换当前页面，调用完毕也会跳转页面，<strong>但不会生成历史记录</strong>，不能使用回退按钮回退</p>
<p>（4）History：代表浏览器的历史记录，可通过该对象操作浏览器的历史记录，由于保护隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，且该操作只在当次访问时有效</p>
<p>history.length 可获取到当次访问的链接数量</p>
<p>history.back() 可用来回退到上一个页面，和浏览器中的回退按钮一样</p>
<p>history.forward() 可跳转到下一个页面，和浏览器的前进按钮一样</p>
<p>history.go(整数) 可跳转到指定的页面，需要整数作为参数</p>
<p>— 1 表示向前跳转一个页面，相当于 forward()</p>
<p>— 2 表示向前跳转两个页面</p>
<p>— -1 表示向后跳转一个页面</p>
<p>— -2 表示向后跳转两个页面</p>
<p>（5）Screen：代表用户的屏幕信息，通过该对象可获取到用户的显示器的相关信息（在移动端用的多）</p>
<p>这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用</p>
<h1 id="十七、定时器"><a href="#十七、定时器" class="headerlink" title="十七、定时器"></a>十七、定时器</h1><p>setInterval(回调函数,调用间隔) 是 window 对象的方法，将回调函数每隔一段时间执行一次，第二个参数的单位是毫秒，会返回 Number 类型的返回值，该返回值作为定时器的唯一标识</p>
<p>注意在开启定时器前一般需要先使用 clearInterval(xx) 将当前元素上的其他定时器关闭</p>
<p>clearInterval(定时器标识) 关闭定时器，可接收任意参数，若参数是一个有效的定时器标识则停止对应定时器，若不是一个有效标识，则什么也不做</p>
<pre><code>var num = 1;
var timer = setInterval(function()&#123;
    num++;
    console.log(num)
    if(num == 11)&#123;
        clearInterval(timer);
    &#125;
&#125;,1000);</code></pre>
<p>setTimeout(回调函数,延时时间) 演示调用一个函数不马上执行，而是隔一段时间后再执行，而且只会执行一次</p>
<p>clearTimeout(延时器标识) 关闭一个延时调用</p>
<p>延时调用和定时调用实际上可以互相代替的，注意定时调用会执行多次，而延时调用只会执行一次</p>
<p><strong>根据方向键移动 div 并解决第一次按下时延时的例子：</strong></p>
<pre><code>var speek = 10;
var dir = 0;
setInterval(function()&#123;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;)
document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;else&#123;
        speed = 10;  //松开 ctrl 不加速
    &#125;
    dir = event.keyCode;
&#125;
document.onkeyup = function()&#123;  //松开按键时，div 不再移动
    dir = 0;
&#125;</code></pre>
<h1 id="十八、JSON"><a href="#十八、JSON" class="headerlink" title="十八、JSON"></a>十八、JSON</h1><p>JS 中的对象只有 JS 自己认识，其他语言都不认识</p>
<p>JSON（JavaScript Object Notation，JS 对象表示法）是一个特殊格式的<strong>字符串</strong>，该字符串可被任意的语言识别，并且可转换为任意语言中的对象，JSON 在开发汇总主要用于数据的交互</p>
<p>JSON 和 JS 对象的格式一样，但是 JSON 字符串中的属性名必须加双引号</p>
<p>JSON 分类：</p>
<p>— 对象{}</p>
<p>— 数组[]</p>
<p>JSON 中允许的值有字符串、数值、布尔值、null、普通对象（不包括函数对象）、数值六种</p>
<p>通过工具类 JSON 来互换 JSON 字符串与 JS 中的对象（IE7 及一下浏览器不支持）</p>
<p>json –&gt; js 对象</p>
<pre><code>JSON.parse(JSON字符串)
eval(&quot;(&quot;+JSON字符串+&quot;)&quot;)  //IE7中，但不建议使用
通过引入外部的 js 文件（自定义的 JSON 对象）来处理  //兼容 IE7</code></pre>
<p>js 对象 –&gt; json</p>
<pre><code>JSON.stringify(js对象)</code></pre>
<p>eval() 可用来执行一段字符串形式的 JS 代码，并将执行结果返回，若 eval() 执行的字符串中含有 {}，它会将 {} 当成代码块，若不希望将其当成代码块解析，需在字符串前后各加一个 ()</p>
<p>但在开发中尽量不要使用 eval()，因为它的执行性能比较差，并且有安全隐患</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>1、把 JS 写到外部文件中通过外部文件引入可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>2、JS 中每条语句以 <code>;</code> 结尾，若没写分号浏览器会自动添加，但是会消耗一些系统资源，有时浏览器会加错分号</p>
<p>3、把 JS 代码写在 HTML 下方，加载完页面后加载</p>
<p>4、使用 <code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式时，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p><code>console.time(&quot;计时器的名字&quot;)</code> 可用来开启计时器</p>
<p><code>console.timeEnd(&quot;计时器的名字&quot;)</code> 可用来终止计时器</p>
<p>往表格 <code>&lt;table&gt;</code> 里使用 appendChild 添加 <code>&lt;tr&gt;</code> 时会添加在 <code>&lt;tbody&gt;</code> 外部，因此需要获取 tbody 对象后对它使用 appendChild 来添加 tr</p>
<p>对于使用 for 循环遍历元素来给元素添加响应函数，需要注意 for 循环会在页面加载完成后立即执行，而响应函数会在被点击时才执行，当响应函数执行时，for 循环早已执行完毕</p>
<p>浏览器的默认行为</p>
<pre><code>对于表单、超链接等，若不想点击后跳转或提交可在响应函数的最后添加 return false 取消默认行为

拖拽时浏览器默认会去搜索引擎中所有内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）

当滚轮滚动时，若浏览器由滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为

在文本框（如 input）中输入内容属于 onkeydown 的默认行为，可通过 return flase 取消默认行为，取消后输入内容不会出现在文本框中</code></pre>
<p>注意若使用 addEventListener() 方法绑定响应函数时取消默认行为不能用 <code>return false</code>，需要使用 event.preventDefault() 来取消默认行为</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode笔记</title>
    <url>/2021/12/01/LeetCode%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h2><a id="more"></a>

<p>在原数组中删除中某一元素，并返回最终数组的长度（忽略新长度后面的元素）</p>
<pre><code>解法一：

可使用快指针（用于遍历原数组）和慢指针（当前在原数组中填入元素的位置）来实现

时间复杂度：O(n)O(n)，其中 nn 为序列的长度。我们只需要遍历该序列至多两次。

空间复杂度：O(1)O(1)。我们只需要常数的空间保存若干变量。

解法二：（优化）

使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。避免了需要保留的元素的重复赋值操作。</code></pre>
<p>对于有序数组应想到二分查找，时间复杂度为 O(log n)</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>less学习笔记</title>
    <url>/2021/12/15/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>less 是一门 css 的预处理语言，less 是 css 增强版，通过 less 可以编写更少的代码实现更强大的样式</p>
<a id="more"></a>

<p>less 语法大体上和 css 一致，但 less 中增添了许多对 css 的扩展</p>
<p>在 less 中添加了许多新特性，如虽然在原生 css 中支持变量，但是对不同浏览器的兼容性不好，有的浏览器不支持，而通过 less 浏览器对变量、minxin 等都可支持</p>
<p>此外 less 中可以使用 <code>@import</code> 引入其他 less 文件有助于样式模块化</p>
<p>浏览器无法直接执行 less 代码，必须先将 less 转换为 css（如 VSCode 中 Easy LESS 插件可将 less 自动编译为 css），再由浏览器执行</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>变量声明：<code>@变量名:xxx;</code></p>
<p>使用变量：<code>@变量名</code></p>
<p>变量在 less 中属于块级作用域，延迟加载</p>
<p>— 当变量作为类名或属性名或一部分值使用时，通过<code>@&#123;变量名&#125;</code></p>
<p>— 直接使用另一个属性的值 <code>$参考的属性</code>（v3.0.0后支持）</p>
<p>— less 中样式可以嵌套，当表示当前层的元素本身时使用 <code>&amp;</code> 表示，表示子元素时使用<code>&gt;子元素&#123;&#125;</code></p>
<p>— 当前元素有与其他元素共有的部分时，用 <code>当前元素:extend(有相同样式的元素)&#123;&#125;</code>，关键字 all 表示继承所有父类的相关声明块</p>
<pre><code>#test&#123;
    &amp;:extend(.father all)
&#125;
//相当于
#test:extend(.father all)&#123;&#125;

实质上将 .father 选择器和 #test 组合成一个选择器，声明块使用 .father 的</code></pre>
<p>注意父类不能定义成混合（继承不灵活但性能高，混合灵活（因为可以传参）但性能低）</p>
<p>— 对其他元素样式进行引用，相当于直接复制其他元素样式 <code>元素选择器();</code>，这种方式性能比上一种差，因为要先复制</p>
<p>— 解决上个问题，可使用类选择器时可在选择器后添加一个括号，实际上就创建了一个mixins（相当于是个混合函数），即这部分样式不是自己用，而是专门给别人用</p>
<p>引入其他 less 文件，通过 <code>@import &quot;xxx.less;&quot;</code>，该功能可用于样式模块化，如将定义变量、定义动画、定义布局、整合的 less 文件分开，方便后期维护</p>
<p>less 中所有数值都可以直接进行运算，如 + - * /</p>
<p>当重复声明时，使用时依据就近原则，使用最近声明的值</p>
<p>可先使用后声明</p>
<pre><code>@a:100px;
@b:#bfa;
@c:box2;
@d:color;
.box1&#123;
    width: @a;
    @&#123;d&#125;: @b;
    background-@&#123;d&#125;:@b;
&#125;
.@&#123;c&#125;&#123;
    width: @a;
    background-image: url(&quot;@&#123;C&#125;/1.png&quot;);
&#125;
.p2:extend(.p1)&#123;
    color:red;
&#125;
.p3&#123;
    .p1();  //mixins，直接对指定样式进行引用
&#125;
.p4()&#123;  //创建了一个mixins
    width:100px;
    height:100px;
&#125;
.test(@w:100px,@h,@bg-color)&#123;  //调用混合函数，可指定默认值
    width: @w;
    height: @h;
    border: 1px solid @bg-color;
&#125;
div&#123;
    .test(200px,300px,#bfa);  //调用混合函数，按顺序传递参数，或.test(@bg-color:#bfa,@h:300px,@2:200px);
&#125;
.span&#123;
    color: average(red,blue);  //使用 less 定义好的混合函数
&#125;
body:hover&#123;
    background-color: darken(#bfa,20%); //使用 less 定义好的混合函数，当鼠标移入 body 时颜色加深20%
&#125;</code></pre>
<h1 id="less-的避免编译"><a href="#less-的避免编译" class="headerlink" title="less 的避免编译"></a>less 的避免编译</h1><p><code>~&quot;不会被编译的内容&quot;</code></p>
<h1 id="VSCode-中的插件-Easy-LESS"><a href="#VSCode-中的插件-Easy-LESS" class="headerlink" title="VSCode 中的插件 Easy LESS"></a>VSCode 中的插件 Easy LESS</h1><p>Easy LESS 插件可将 less 自动编译为 css，但是在浏览器中检查页面样式时显示的依然时 css 文件中的代码位置，可在插件中设置如下内容，设置后浏览器中调试样式显示的时在 less 文件中的代码位置</p>
<pre><code>&quot;less.compile&quot;:&#123;
    &quot;compress&quot;: false,  //true =&gt; remove surplus whitespace
    &quot;sourceMap&quot;: true,  //true =&gt; generate source maps(.css.map files)
    &quot;out&quot;: true,   //false =&gt; DON&#39;T output .css files(overidable per-file)
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>HTML+CSS学习笔记</title>
    <url>/2021/12/08/HTML-CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="网页特点"><a href="#网页特点" class="headerlink" title="网页特点"></a>网页特点</h1><p>优点：（1）无需安装（2）无需更新（3）跨平台</p>
<a id="more"></a>

<h1 id="网页组成"><a href="#网页组成" class="headerlink" title="网页组成"></a>网页组成</h1><p>W3C标准制定网页由结构（HTML）+样式（CSS）+行为（JS）组成</p>
<p><code>&lt;head&gt;</code> 中包含的是网页的元数据，浏览器或搜索引擎根据这些元数据解析网页</p>
<p>注释不能嵌套</p>
<h1 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h1><h2 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h2><p>文档声明通过标签 <code>&lt;!doctype&gt;</code> 用于告知浏览器当前网页的版本（如HTML 4、HTML5、XHTML等），不区分大小写</p>
<p>HTML5文档声明：<code>&lt;!doctype html&gt;</code></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>内存中一个小格子为 1 位，内存中无法操作 bit ，最小可操作单位为 1 byte（字节）= 8 bit</p>
<pre><code>8 bit = 1 byte（字节）
1024 byte = 1 kb（千字节）
1024 kb = 1 mb（兆字节）
1024 mb = 1 gb（吉字节）
1024 gb = 1 tb（特字节）
1024 tb = 1 pb</code></pre>
<p>所有数据在计算机中以二进制存储，包括文本、图片、音频等。编码解码采用的规则称为字符集，如ASCII（美国7位）、ISO88591（欧洲 8位）、GB2312（中国）、GBK（中国 GB2312的扩展）、UTF-8（万国码）</p>
<p>字符集说明写在 <code>&lt;meta&gt;</code> 标签里，如 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>，从而避免乱码问题</p>
<h2 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h2><p><code>&lt;meta&gt;</code> 标签用于设置网页中的元数据，用于浏览器或搜索引擎解析网页。<code>&lt;meta&gt;</code> 没有结束标签</p>
<p>常用属性有 name（指定数据的名称，如keywords、description）+ content（指定数据的内容）、http-equiv（网页重定向）+ content、charset（指定网页的字符集）</p>
<p>例子</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;购物,网上购物&quot;&gt;
为网页设置关键字，当在搜索引擎中搜索 “购物” 时会推荐该网站

&lt;meta name=&quot;description&quot; content=&quot;这是网站的描述&quot;&gt;
为网站设置描述，该描述会显示在搜索引擎搜索的结果中

&lt;meta http-quiv=&quot;refresh&quot; content=&quot;秒数,url=https://www.baidu.com&quot;&gt;
为网站设置定时重定向，当到达相应秒数后网页会跳转到相应路径</code></pre>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><h3 id="块元素、行内元素、替换元素"><a href="#块元素、行内元素、替换元素" class="headerlink" title="块元素、行内元素、替换元素"></a>块元素、行内元素、替换元素</h3><h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><p>在页面中独占一行的元素称为块（block）元素。</p>
<p>如 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;blockquote&gt;</code>（表示一个长引用，会换行缩进，对比<code>&lt;q&gt;</code>）</p>
<p>— 块元素一般用于网页布局</p>
<p>— 一般会在块元素中放行内元素，块元素中基本什么都能放</p>
<p>— <code>&lt;p&gt;</code> 中不能放任何块元素，若写错，浏览器在解析时会自动修正</p>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p>在页面中不会独占一行的元素称为行内（inline）元素。</p>
<p>如 <code>&lt;em&gt;</code>（斜体）、<code>&lt;strong&gt;</code>（加粗）、<code>&lt;q&gt;</code>（短引用，不换行加引号，对比 <code>&lt;blockquote&gt;</code>）、<code>&lt;a&gt;</code>（超链接）</p>
<p>— 行内元素主要用于包裹文字</p>
<p>— 行内元素中不会放块元素，<strong>但是 <code>&lt;a&gt;</code> 可嵌套除它自身外的任何元素</strong></p>
<h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>如 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code></p>
<h3 id="布局标签（结构化语义标签）"><a href="#布局标签（结构化语义标签）" class="headerlink" title="布局标签（结构化语义标签）"></a>布局标签（结构化语义标签）</h3><p>如以下 HTML5 新增标签</p>
<pre><code>&lt;header&gt;  表示网页头部
&lt;main&gt;    表示网页主体（一个页面只有一个 &lt;main&gt;）
&lt;footer&gt;  表示网页底部
&lt;nav&gt;     表示网页导航
&lt;aside&gt;   表示网页中与主体相关的其他内容（侧边栏）
&lt;article&gt; 表示一个独立的文章
&lt;section&gt; 表示一个独立的区块，以上标签都不合适时用 &lt;section&gt;</code></pre>
<p>与 <code>&lt;section&gt;</code> 类似的有 <code>&lt;div&gt;</code>（没有语义，表示区块）和 <code>&lt;span&gt;</code>（没有语义，行内元素）</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>1、无序列表 <code>&lt;ul&gt;</code> + <code>&lt;li&gt;</code>（列表项，块元素）</p>
<p>2、有序列表 <code>&lt;ol&gt;</code> + <code>&lt;li&gt;</code>（列表项）</p>
<p>3、定义列表 <code>&lt;dl&gt;</code> + <code>&lt;dt&gt;</code>（表示定义的内容）+ <code>&lt;dd&gt;</code>（对内容进行解释说明）</p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><code>&lt;a&gt;</code>为行内元素</p>
<p>超链接通过设置属性 href 可跳转至其他网页，或在当前网页中进行跳转。</p>
<p><code>href=&quot;#&quot;</code> 跳转至页面顶部</p>
<p><code>href=&quot;#目标元素的id&quot;</code> 跳转至页面相应元素处</p>
<p><code>href=&quot;javascript:;&quot;</code> 可作为超链接路径的占位符点击后什么也不会发生</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><code>&lt;img&gt;</code> 是替换元素（显示内容并非代码里写的内容，而是利用引入内容进行替换），介于块元素和行内元素之间，兼具两者特点（既能设置宽高，又不会独占一行）</p>
<p>在 <code>&lt;img&gt;</code> 中 alt 属性默认情况不会显示，部分浏览器在图片无法加载时会显示，并且搜索引擎会根据 alt 中内容来识别图片</p>
<p>图片一般有jpeg、jpg、gif、png、webp</p>
<pre><code>jpeg/jpg：支持颜色较丰富，不支持透明效果，不支持动图

gif：支持颜色较少，支持简单透明，支持动图

png：支持颜色丰富，支持复杂透明，不支持动图

webp：谷歌新推出的专门用于表示网页中图片的一种格式，具备其他图片格式的所有优点，而且文件还很小。缺点：兼容性不好

base64：将图片使用base64编码，将图片转换为字符，在 src 中通过字符的形式引入图片。一般需要和网页一起加载的图片用 base64，否则其他格式图片是在浏览器向后端请求网页后再次发送图片资源的请求</code></pre>
<p>原则：效果一样，用小的；效果不一样，用效果好的</p>
<h3 id="引入音频-视频"><a href="#引入音频-视频" class="headerlink" title="引入音频/视频"></a>引入音频/视频</h3><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p><code>&lt;audio&gt;</code>标签来引入音频，可在<code>&lt;audio&gt;</code>内添加 src 属性，也可在标签中间添加 <code>&lt;source src=&quot;xxx&quot;&gt;</code>来引入相应文件。</p>
<p>还包括属性 controls（音频文件引入时默认不允许用户控制播放，加入该属性允许用户控制）、autoplay（打开页面时是否自动播放，大部分浏览器考虑到用户体验不会自动播放）、loop（是否循环播放）</p>
<p><strong>考虑浏览器兼容问题：</strong></p>
<p>（1）当浏览器不支持 <code>&lt;audio&gt;</code> 时显示文字提示</p>
<p>（2）当浏览器不支持某种格式音频文件时使用另一种格式的音频文件</p>
<p>（3）老版本浏览器不支持 <code>&lt;audio&gt;</code> 时，可使用 <code>&lt;embed&gt;</code>，包括属性src、<code>type=&quot;audio/mp3&quot;</code>、width、height</p>
<pre><code>&lt;audio src=&quot;./xxx.mp3&quot; controls autoplay loop&gt;&lt;/audio&gt;

（1）浏览器支持 &lt;audio&gt; 时显示音频，不支持时显示文字提示
（2）浏览器会从上至下选择一个音频文件
    &lt;audio controls&gt;
        该浏览器不支持音频播放 
        &lt;source src=&quot;./xxx.mp3&quot;&gt;
        &lt;source src=&quot;./xxx.ogg&quot;&gt;
    &lt;/audio&gt;
（3）让所有浏览器都可显示音频，支持&lt;audio&gt;时用&lt;audio&gt;，并从&lt;source&gt;获取音频文件，不支持&lt;audio&gt;时会选&lt;embed&gt;
    &lt;audio controls&gt; 
        &lt;source src=&quot;./xxx.mp3&quot;&gt;
        &lt;source src=&quot;./xxx.ogg&quot;&gt;
        &lt;embed src=&quot;./xxx.mp3&quot; type=&quot;audio/mp3&quot;&gt;
    &lt;/audio&gt;</code></pre>
<h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p>通过标签 <code>&lt;video&gt;</code>，使用方式和音频差不多，注意 <code>&lt;embed&gt;</code> 中<code>type=&quot;video/mp4&quot;</code></p>
<h3 id="内联框架-lt-iframe-gt"><a href="#内联框架-lt-iframe-gt" class="headerlink" title="内联框架&lt;iframe&gt;"></a>内联框架<code>&lt;iframe&gt;</code></h3><p><code>&lt;iframe&gt;</code>用于向当前页面引入一个其他页面，页面中将会有个窗口显示其他网页，其中 src 属性设置要引入的网页路径，frameborder 属性设置内联框架是否有边框（取值为 0 或 1）</p>
<p>缺点：内联框架中的网页不会被搜索引擎检索，因此对 SEO 也没有什么好处</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><code>&lt;table&gt;&lt;/table&gt;</code> 表示表格（块元素），<code>&lt;tr&gt;</code> 表示一行（块元素），，<code>&lt;td&gt;</code> 表示一列（行内元素）</p>
<p>在 <code>&lt;td&gt;</code> 中设置属性 <code>colspan=&quot;合并的列数&quot;</code> 可横向合并单元格，<code>rowspan=&quot;合并的行数&quot;</code> 可纵向合并单元格</p>
<p>可以将表格分为如下三部分，通过定义这三部分后，表格头部、主体、底部在代码中的书写顺序无要求，最终显示为表头-主体-底部</p>
<pre><code>`&lt;thead&gt;` 头部
`&lt;tbody&gt;` 主体
`&lt;tfoot&gt;` 底部</code></pre>
<p>在这三部分中间可添加行列 <code>&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</code>，还可添加 <code>&lt;th&gt;</code> 表示头部单元格代替 <code>&lt;td&gt;</code> ，如 <code>&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;</code>， <code>&lt;th&gt;</code> 中的文字会加粗居中</p>
<p>表格中通过 <code>&lt;caption&gt;&lt;/caption&gt;</code> 创建标题</p>
<p><strong>注：若表格中没有使用 tbody 而是直接使用 tr，浏览器会自动创建一个 tbody，并将 tr 全都放到 tbody 中，因此 tr 不是 table 的子元素</strong></p>
<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p><code>border-spacing: xxpx;</code> 指定边框间的距离</p>
<p><code>border-collapse: collapse;</code> 设置边框的合并</p>
<pre><code>如表格外边框与单元格边框间有间距，可通过
table&#123;
    border: 1px solid black;
    border-spacing: 0px;
&#125;
td&#123;
    border: 1px solid black;
&#125;
消除间隙，但此时是把两者边框间距设为 0，实际边框为 1+1=2px
可通过如下属性设置边框合并
table&#123;
    border: 1px solid black;
    border-collapse: collapse;
&#125;
td&#123;
    border: 1px solid black;
&#125;
此时也没有间隙，且两者边框合并后实际边框为 1px</code></pre>
<p><code>vertical-align</code> 设置 <code>&lt;td&gt;</code> 中的元素对齐方式，默认情况下元素在 <code>&lt;td&gt;</code> 中是垂直居中的。可选值有 top、bottom、middle（默认） 等</p>
<p>注：在 <code>&lt;td&gt;</code> 中是所有元素都能通过 <code>vertical-align</code> 设置，而其他元素中 <code>vertical-align</code> 只会影响文字</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p><code>&lt;form&gt;</code> 声明表单，属性有 <code>action</code>（表单要提交的服务器地址）</p>
<pre><code>表单内容
文本框
    &lt;input type=&quot;text&quot; name=&quot;服务器根据name获取相应数据&quot;&gt;
密码           
    &lt;input type=&quot;password&quot; name=&quot;服务器根据name获取相应数据&quot;&gt;
提交按钮  
    &lt;input type=&quot;submit&quot; value=&quot;按钮上的文字&quot;&gt;
    或&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
普通按钮
    &lt;input type=&quot;button&quot; value=&quot;按钮上的文字&quot;&gt;
    或&lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt;
重置按钮
    &lt;input type=&quot;reset&quot;&gt;
    或&lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;
单选按钮
    &lt;input type=&quot;radio&quot; name=&quot;xxx&quot; value=&quot;向服务器发送的数据&quot; checked&gt;
    通过相同的 name 属性限制相同 name 只能选一个，checked 表示默认选中
多选框
    &lt;input type=&quot;checkbox&quot; name=&quot;xxx&quot; value=&quot;向服务器发送的数据&quot; checked&gt;
    checked 表示默认选中
下拉列表
    &lt;select name=&quot;xxx&quot;&gt;
        &lt;option value=&quot;向服务器发送的数据&quot; selected&gt;选项一&lt;/option&gt;
        &lt;option value=&quot;向服务器发送的数据&quot;&gt;选项二&lt;/option&gt;
    &lt;/select&gt;
    selected 表示默认选中
颜色选择框（浏览器兼容性不好）
    &lt;input type=&quot;color&quot;&gt;
电子邮件输入框，会检查输入格式（浏览器兼容性不好）
    &lt;input type=&quot;email&quot;&gt;

表单中元素的属性
autocomplete=&quot;on或off&quot; 开启或关闭自动补全
readonly      将表单项设置为只读，无法修改，但数据会提交
disabled      将表单项设为禁用，数据不会提交
autofocus     设置表单项自动获取焦点</code></pre>
<p>数据要提交到服务器中，必须为元素指定 name 属性值</p>
<p>若给表单项添加 <code>disabled = &quot;disabled&quot;</code> 则表单项将变成不可用状态</p>
<h1 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h1><p>网页实际上是一个多层结构，通过 CSS（层叠样式表）为每层设置样式</p>
<p>设置 CSS 方法:</p>
<p>（1）内联/行内样式：在标签内部通过 style 属性设置元素样式。只能对一个标签起作用</p>
<p>（2）内部样式表：在 <code>&lt;head&gt;</code> 的 <code>&lt;style&gt;</code> 中通过CSS选择器选中元素并为其设置样式 。只能对一个页面起作用，不能跨页面复用</p>
<p>（3）外部样式表：编写到外部 CSS 文件里，通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx.css&quot;&gt;</code> 引入。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="1、基本选择器"><a href="#1、基本选择器" class="headerlink" title="1、基本选择器"></a>1、基本选择器</h3><h4 id="（1）元素选择器"><a href="#（1）元素选择器" class="headerlink" title="（1）元素选择器"></a>（1）元素选择器</h4><p>根据标签名选中指定元素，如 <code>p&#123;&#125; div&#123;&#125;</code></p>
<h4 id="（2）id-选择器"><a href="#（2）id-选择器" class="headerlink" title="（2）id 选择器"></a>（2）id 选择器</h4><p>根据元素的 id 选中一个元素，如 <code>#box&#123;&#125; #element&#123;&#125;</code></p>
<h4 id="（3）类选择器"><a href="#（3）类选择器" class="headerlink" title="（3）类选择器"></a>（3）类选择器</h4><p>根据元素的 class 属性选中一组元素，如 <code>.box&#123;&#125; .element&#123;&#125;</code></p>
<p>class 可以重复使用，通过 class 属性为元素分组，也可同时为一个元素指定多个 class 属性</p>
<h4 id="（4）通配选择器"><a href="#（4）通配选择器" class="headerlink" title="（4）通配选择器"></a>（4）通配选择器</h4><p>选中页面所有元素，如 <code>*&#123;&#125;</code></p>
<h3 id="2、复合选择器"><a href="#2、复合选择器" class="headerlink" title="2、复合选择器"></a>2、复合选择器</h3><h4 id="（1）交集选择器"><a href="#（1）交集选择器" class="headerlink" title="（1）交集选择器"></a>（1）交集选择器</h4><p>选中同时符合多个条件的元素，如 <code>选择器1选择器2选择器n&#123;&#125;</code></p>
<p>注意：交集选择器中若有元素选择器，必须使用元素选择器开头</p>
<h4 id="（2）选择器分组（并集选择器）"><a href="#（2）选择器分组（并集选择器）" class="headerlink" title="（2）选择器分组（并集选择器）"></a>（2）选择器分组（并集选择器）</h4><p>同时选择多个选择器对应的元素，如 <code>选择器1,选择器2,选择器n&#123;&#125;</code></p>
<h3 id="3、关系选择器"><a href="#3、关系选择器" class="headerlink" title="3、关系选择器"></a>3、关系选择器</h3><h4 id="（1）子元素选择器"><a href="#（1）子元素选择器" class="headerlink" title="（1）子元素选择器"></a>（1）子元素选择器</h4><p>选中指定父元素的指定子元素，语法 <code>父元素 &gt; 子元素&#123;&#125;</code></p>
<h4 id="（2）后代元素选择器"><a href="#（2）后代元素选择器" class="headerlink" title="（2）后代元素选择器"></a>（2）后代元素选择器</h4><p>选中指定元素内的指定后代元素，语法 <code>祖先 后代&#123;&#125;</code></p>
<h4 id="（3）选择下一个兄弟元素"><a href="#（3）选择下一个兄弟元素" class="headerlink" title="（3）选择下一个兄弟元素"></a>（3）选择下一个兄弟元素</h4><p>语法 <code>兄 + 弟&#123;&#125;</code></p>
<h4 id="（4）选择下边所有兄弟元素"><a href="#（4）选择下边所有兄弟元素" class="headerlink" title="（4）选择下边所有兄弟元素"></a>（4）选择下边所有兄弟元素</h4><p>语法 <code>兄 ~ 弟&#123;&#125;</code></p>
<h3 id="4、属性选择器"><a href="#4、属性选择器" class="headerlink" title="4、属性选择器"></a>4、属性选择器</h3><p>[属性名] 选择含有指定属性的元素</p>
<p>[属性名=属性值] 选择含有指定属性和属性值的元素</p>
<p>[属性名^=属性值] 选属性值以指定值开头的元素</p>
<p>[属性名$=属性值] 选属性值以指定值结尾的元素</p>
<p>[属性名*=属性值] 选属性值中含有某值的元素</p>
<p>[属性名~=属性值] 选属性中可有多个值，但其中有一个为指定的值</p>
<p>[属性名|=属性值] 选属性值以 某值 或 某值- 开头</p>
<h3 id="5、伪类选择器"><a href="#5、伪类选择器" class="headerlink" title="5、伪类选择器"></a>5、伪类选择器</h3><p>伪类（不存在的类/特殊的类）用来描述一个元素的<strong>特殊状态</strong>，如：第一个子元素、被点击的元素、鼠标移入的元素</p>
<h4 id="（1）子元素伪类1"><a href="#（1）子元素伪类1" class="headerlink" title="（1）子元素伪类1"></a>（1）子元素伪类1</h4><p><code>:first-child</code>  第一个子元素</p>
<p><code>:last-child</code>  最后一个子元素</p>
<p><code>:nth-child(第几个)</code>  选中第n个子元素，特殊值：n（子元素全选）、2n 或 even（选中偶数位的子元素）、2n+1 或 odd（选中奇数位的子元素）</p>
<p><strong>注：以上伪类都是根据其父元素的所有子元素进行排序</strong></p>
<h4 id="（2）子元素伪类2"><a href="#（2）子元素伪类2" class="headerlink" title="（2）子元素伪类2"></a>（2）子元素伪类2</h4><p><code>:first-of-type</code>、<code>:last-of-type</code>、<code>:nth-of-type()</code> 这三种伪类与上述功能相似，<strong>不同是这三种是在同类型子元素中排序</strong></p>
<pre><code>如
&lt;ul&gt;
    &lt;span&gt;xxx&lt;/span&gt;
    &lt;li&gt;xxx&lt;/li&gt;
    &lt;li&gt;xxx&lt;/li&gt;
&lt;/ul&gt;

设置样式
ul &gt; li:first-child&#123;
    color:red;   //对第一个 &lt;li&gt; 不生效，因为 &lt;span&gt; 才是第一个子元素
&#125;
ul &gt; li:first-of-type&#123;
    color:red;   //对第一个 &lt;li&gt; 生效
&#125;</code></pre>
<h4 id="（3）否定伪类"><a href="#（3）否定伪类" class="headerlink" title="（3）否定伪类"></a>（3）否定伪类</h4><p>否定伪类 <code>:not()</code>，将符合条件的元素从选择器中去除</p>
<pre><code>ul &gt; li:not(:nth-of-type(3))&#123;
    color:red;   //除了第三个 &lt;li&gt; 外，其他 &lt;li&gt; 变为红色
&#125;</code></pre>
<h4 id="（4）超链接伪类"><a href="#（4）超链接伪类" class="headerlink" title="（4）超链接伪类"></a>（4）超链接伪类</h4><p><code>:link</code> 表示正常链接/没访问过的链接</p>
<p><code>:visited</code> 表示访问过的链接</p>
<p>由于保护隐私原因，<code>:visited</code> 伪类只能修改链接颜色，无法修改大小、背景等。</p>
<p>以上两种是超链接独有的伪类</p>
<h4 id="（5）其他伪类"><a href="#（5）其他伪类" class="headerlink" title="（5）其他伪类"></a>（5）其他伪类</h4><p><code>:hover</code> 表示鼠标移入的状态</p>
<p><code>:active</code> 表示鼠标点击时</p>
<h3 id="6、伪元素选择器"><a href="#6、伪元素选择器" class="headerlink" title="6、伪元素选择器"></a>6、伪元素选择器</h3><p>伪元素（不真实存在的元素/特殊的元素）用来描述一个元素的<strong>特殊位置</strong></p>
<p><code>::first-letter</code>  第一个字母</p>
<p><code>::first-line</code>  第一行</p>
<p><code>::selection</code>  鼠标选中的内容</p>
<p><code>::before</code> 元素的开始，必须结合 <code>content</code> 属性， <code>content</code> 中添加的内容鼠标无法选中</p>
<p><code>::after</code> 元素的最后，必须结合 <code>content</code> 属性</p>
<pre><code>如
div::before&#123;
    content:&#39;xxx&#39;;
    color:red;
&#125;
会在 &lt;div&gt; 元素前添加字符串 &#39;xxx&#39;，并且该添加的部分为红色</code></pre>
<p><strong>伪元素默认是一个行内元素</strong></p>
<h2 id="样式继承"><a href="#样式继承" class="headerlink" title="样式继承"></a>样式继承</h2><p>样式继承是发生在祖先和后代之间的，为一个元素设置的样式会同时应用到其后代元素上</p>
<p>但部分样式如背景（图片、颜色）相关、布局相关等的样式不会被继承</p>
<h2 id="样式冲突与选择器权重"><a href="#样式冲突与选择器权重" class="headerlink" title="样式冲突与选择器权重"></a>样式冲突与选择器权重</h2><p><strong>样式冲突：</strong>当通过不同选择器，选中<strong>相同元素</strong>，并为<strong>相同样式</strong>设置不同值时，就发生了样式冲突</p>
<p>发生样式冲突时，应用哪个样式由选择器权重（优先级）决定</p>
<p><strong>选择器权重</strong>如下，从上至下递减：</p>
<pre><code>1. 内联样式       优先级：1,0,0,0
2. id 选择器      优先级：0,1,0,0
3. 类和伪类选择器  优先级：0,0,1,0
4. 元素选择器      优先级：0,0,1,0
5. 通配选择器      优先级：0,0,0,0
6. 继承的样式      没有优先级</code></pre>
<p>比较优先级时遵循以下<strong>原则</strong>：</p>
<p>（1）比较优先级时，需要将针对该元素的所有选择器的优先级进行相加计算，优先级越高，越优先显示（分组选择器中每个元素是独立计算互不影响）</p>
<p>（2）选择器的累加不会超过其最大数量级，对同一元素设置多个类累加后再高也不会超过 id 选择器</p>
<p>（3）若优先级计算后相等，则优先使用靠下的样式</p>
<p>（4）在某个样式后添加 <code>!important</code>，此时该样式会获取最高优先级，甚至超过内联样式（慎用）</p>
<h2 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h2><p><strong>使用外部样式表，可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户体验</strong></p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h3><p><strong>像素：</strong>不同屏幕像素大小不同，像素越小屏幕显示越清晰，同样像素值在不同设备下显示效果不同</p>
<p><strong>百分比：</strong>可将属性值设置为相对其父元素属性的百分比</p>
<p><strong>em：</strong>相对于元素的字体大小计算的，em会根据字体大小变化而改变，如 1 em = 1 font-size，默认情况下 font-size = 16 px</p>
<p><strong>rem：</strong>是相对与根元素 <code>&lt;html&gt;</code> 的字体大小来计算的</p>
<p><strong>vw：</strong>是相对于视口宽度（viewport width）计算，1 vw = 1% 视口宽度，100 vw = 100% 视口宽度（移动端都支持，PC 端新版浏览器支持）</p>
<p><strong>vw 与 百分比：</strong>百分比参照的是父元素的宽高，参照物是会一直改变的，而 vw 参照的总是视口宽度</p>
<h3 id="颜色单位"><a href="#颜色单位" class="headerlink" title="颜色单位"></a>颜色单位</h3><p>颜色名称：可通过颜色英文名来设置颜色</p>
<p>RGB：通过三原色调配出不同颜色，此处指光的三原色，每种颜色范围为 0-255（0%-100%），全 0 为黑色，全为 255 表示白色</p>
<p>RGBA：在 rgb 基础上增加一个透明度，1 表示完全不透明，0 表示完全透明</p>
<p>十六进制 RGB：共六位，两位两位分别对应R、G、B，范围为 00-ff，若两位两位重复可简写，如 #aabbcc 可简写为 #abc</p>
<p>HSL/HSLA 值：</p>
<p>H（色相，对应一个色环，红橙黄绿蓝靛紫一圈最后转回红，取值为0-360）</p>
<p>S（饱和度，取值为0%-100%，取值为 0% 时为灰色）</p>
<p>L（亮度，取值为0%-100%，当取值为 0% 时为黑色，取值为 100% 时为白色）</p>
<p>A（透明度，取值为0-1，和 RGBA 类似）</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>网页是一个立体多层结构，最底下的一层称为文档流，文档流是网页的基础，创建的元素默认都是在文档流中排列</p>
<p>在文档流中</p>
<p>—块元素：</p>
<pre><code>会在页面中独占一行（自上向下垂直排列）
默认宽度是把父元素填满，是父元素的全部
默认高度是被子元素内容撑开</code></pre>
<p>—行内元素：</p>
<pre><code>不会在页面中独占一行（自左向右水平排列），一行容不下会自动换行
默认宽度和高度是被子元素内容撑开，无法设置宽高</code></pre>
<h3 id="盒模型-盒子模型-框模型（box-model）"><a href="#盒模型-盒子模型-框模型（box-model）" class="headerlink" title="盒模型/盒子模型/框模型（box model）"></a>盒模型/盒子模型/框模型（box model）</h3><p>CSS 将页面中所有元素都设置为一个矩形的盒子</p>
<p>盒子 = 内容区（content）+ 内边距（padding）+ 边框（border）+ 外边距（margin）</p>
<p><strong>盒子的可见大小由内容区、内边距和边框共同决定</strong></p>
<h4 id="（1）内容区"><a href="#（1）内容区" class="headerlink" title="（1）内容区"></a>（1）内容区</h4><p>元素中所有的子元素和文本内容都在内容区中排列，大小由 width 和 height 属性设置</p>
<h4 id="（2）边框"><a href="#（2）边框" class="headerlink" title="（2）边框"></a>（2）边框</h4><p>边框大小会影响到整个盒子大小，至少设置三个样式</p>
<pre><code>宽度 border-width，默认为 3px
颜色 border-color，默认使用 color（实际上指定的是前景的颜色如字体、边框等，区别于背景） 的颜色
样式 border-style，默认为none，取值有solid（实线）、dotted（点状虚线）、dashed（虚线）、double（双线）

四个值：上       右       下     左
三个值：上       左右     下
两个值：上下     左右
一个值：上下左右

单独指定某一边样式：border-top/right/bottom/left-width/color/style

简写：将三种属性写在一行用空格隔开，没有顺序要求
如border: 10px green solid;
border-top：10px solid red;</code></pre>
<p><strong>outline 与 border 的区别：</strong></p>
<p>outline 用来设置元素的轮廓线，用法与 border 一样，但是 outline 不会影响可见区域大小，不会挤走其他元素，会覆盖在其他元素上，不占用其余空间，即不会影响页面布局</p>
<p><strong>盒子阴影</strong></p>
<p>box-shadow 同样不会影响页面布局</p>
<pre><code>第一个值 水平偏移量，正值向右移动，负值向左移动

第一个值 垂直偏移量，正值向下移动，负值向上移动

第三个值 阴影的模糊半径

第四个值 阴影的颜色</code></pre>
<p><strong>盒子圆角</strong></p>
<p>border-radius、border-top/bottom-left/right-radius 会通过设置圆角的圆半径来形成圆角效果。</p>
<pre><code>border-top-left-radius:50px 100px; //椭圆角，两个值分别为 x、y 轴半径
border-radius 取值规则如下
    四个值：左上       右上        右下   左下
    三个值：左上       右上/左下    右下
    两个值：左上/右下   右上/左下
    一个值：四个角
设置椭圆角 border-radius: 20px / 40px;
设置元素为圆形 border-radius: 50%;</code></pre>
<h4 id="（3）内边距"><a href="#（3）内边距" class="headerlink" title="（3）内边距"></a>（3）内边距</h4><p>内边距为内容区和边框间的距离，有四个方向的内边距。</p>
<p>内边距的设置会影响盒子的大小，背景颜色会延伸到内边距。当有四个值时规则和 border 相同分别表示“上右下左”</p>
<h4 id="（4）外边距"><a href="#（4）外边距" class="headerlink" title="（4）外边距"></a>（4）外边距</h4><p>外边距不会影响盒子可见大小，但会影响位置以及盒子实际占用空间。也有四个方向外边距</p>
<p>元素在页面中是按照自左向右的顺序排列，<strong>若设置左和上边距则会移动元素自身，而设置下和右边距会移动其他元素</strong></p>
<p>默认情况下设置 <code>margin-right</code> 不会产生任何效果</p>
<h4 id="（5）水平布局"><a href="#（5）水平布局" class="headerlink" title="（5）水平布局"></a>（5）水平布局</h4><p>元素水平方向的位置由 margin-left、border-left、padding-left、width、padding-right、border-right、margin-right 共同决定</p>
<p>其中 width（默认为 auto）、margin-left、margin-right 这三个属性可以设置为 auto</p>
<p>一个元素在其父元素中，水平布局必须满足以下等式</p>
<pre><code>margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 父元素（更准确应为包含块）内容区宽度（width）</code></pre>
<p>其中可设置为 auto 的值有 margin、width</p>
<p>若相加结果等式不成立，则称为过度约束，则等式会自动调整</p>
<p>— 在这七个值没有为 auto 的情况下，浏览器会自动调整 margin-right 值使等式成立；</p>
<p>— 若某个值为 auto 的情况，则浏览器会自动调整值为 auto 的属性值以使等式成立</p>
<p>— 若将一个宽度和一个外边距设为 auto 或三个值都设置为 auto，则宽度会调整为最大，设置为 auto 的外边距会自动为 0</p>
<p>— 若将两个外边距设置为 auto，宽度为固定值，则会将外边距设置为相同的值，即元素在父元素中水平居中</p>
<h4 id="（6）垂直布局"><a href="#（6）垂直布局" class="headerlink" title="（6）垂直布局"></a>（6）垂直布局</h4><h5 id="1-当父元素没有设置高度时，默认父元素高度是被内容撑开"><a href="#1-当父元素没有设置高度时，默认父元素高度是被内容撑开" class="headerlink" title="1. 当父元素没有设置高度时，默认父元素高度是被内容撑开"></a>1. 当父元素没有设置高度时，默认父元素高度是被内容撑开</h5><h5 id="2-处理子元素从父元素中溢出："><a href="#2-处理子元素从父元素中溢出：" class="headerlink" title="2. 处理子元素从父元素中溢出："></a>2. 处理子元素从父元素中溢出：</h5><pre><code>通过设置
overflow
overflow-x（处理水平方向溢出）
overflow-y（处理垂直方向溢出）

取值有
visible（默认值，溢出依然显示）
hidden（裁剪溢出内容）
scroll（生成水平和竖直两个滚动条）
auto（根据需要生成滚动条）</code></pre>
<h5 id="3-垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。"><a href="#3-垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。" class="headerlink" title="3. 垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。"></a>3. 垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象。</h5><p>如上面的 div1 设置 margin-bottom:100px; 下面的 div2 设置 margin-top:100px; 则两个 div 间的距离为 100px</p>
<p><strong>对于兄弟元素（对于开发有利，一般不需要处理）</strong></p>
<p>— 兄弟元素间的<strong>相邻</strong>的<strong>垂直</strong>外边距会取两者间绝对值较大的值（包括正负）</p>
<p>— 若兄弟元素间外边距一正一负，则取两者的和</p>
<p>对于父子元素（会影响页面布局，需处理）</p>
<p><strong>父子元素间的外边距，子元素的会传递给父元素（上边距）</strong></p>
<p><strong>处理方式一</strong>：不使用外边距</p>
<p>通过内边距代替，在父元素中设置 padding-top，并且父元素的高度 height 也要调整减去 padding-top 的值</p>
<p><strong>处理方式二：</strong>不让外边距相邻</p>
<p>在父元素中设置 border，同时调整父元素和子元素的 height</p>
<p><strong>处理方式三：</strong>不让外边距相邻</p>
<p>在父元素中设置一个子元素，把父元素与带有 margin-top 的子元素隔开，具体使用如下</p>
<pre><code>父元素::before&#123;
    content:&#39;&#39;;
    display:table;
&#125;</code></pre>
<h4 id="（7）行内元素盒模型"><a href="#（7）行内元素盒模型" class="headerlink" title="（7）行内元素盒模型"></a>（7）行内元素盒模型</h4><p>行内元素不支持设置宽度和高度</p>
<p>行内元素可以设置 padding、margin、border，但是垂直方向的 padding、margin、border 不会影响页面布局（即不会把其他元素挤开），但是可能会覆盖住其他元素</p>
<p>水平方向相邻的 padding、margin 不会折叠，会直接相加</p>
<h4 id="（8）行内元素与块元素间的转换"><a href="#（8）行内元素与块元素间的转换" class="headerlink" title="（8）行内元素与块元素间的转换"></a>（8）行内元素与块元素间的转换</h4><p>通过 <code>&lt;display&gt;</code> 来设置元素显示类型</p>
<pre><code>可选值：
    inline        将元素设置为行内元素
    block         将元素设置为块元素
    inline-block  将元素设置为行内块元素（既可设置宽度和高度又不会独占一行），但是会像文字一样元素的换行会在页面中显示一个空格
    table         将元素设置为一个表格
    none          元素不在页面中显示，且不占位，隐藏元素</code></pre>
<h4 id="（9）盒子大小"><a href="#（9）盒子大小" class="headerlink" title="（9）盒子大小"></a>（9）盒子大小</h4><p>默认盒子可见大小由内容区 + 内边距 + 边框共同决定</p>
<p>通过设置 <code>box-sizing</code> 属性可更改盒子尺寸的计算方式，即设置 width 和 height 属性的作用</p>
<pre><code>可选值有
    content-box：默认值，此时 width 和 height 用来设置内容区大小
    border-box：此时 width 和 height 用来设置整个盒子可见区域大小，即 width 和 height 表示内容区 + 内边距 + 边框的总大小</code></pre>
<h2 id="浏览器默认样式"><a href="#浏览器默认样式" class="headerlink" title="浏览器默认样式"></a>浏览器默认样式</h2><p>由于默认样式未知，且不同浏览器的默认样式不同，因此编写网页时要去除浏览器默认样式</p>
<pre><code>如*&#123;
    margin:0;
    padding:0;
&#125;
ul&#123;
    list-style:none; //去除无需列表前的小黑点
&#125;</code></pre>
<p>但上述方式去除可能会有残留</p>
<p>可通过引入外部重置样式表来去除浏览器默认样式 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./reset.css&quot;&gt;</code></p>
<p>可在<a href="https://meyerweb.com/eric/tools/css/reset/">该网站</a>获取，内容如下</p>
<pre><code>/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video &#123;
    margin: 0;
    padding: 0;
    border: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
&#125;
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section &#123;
    display: block;
&#125;
body &#123;
    line-height: 1;
&#125;
ol, ul &#123;
    list-style: none;
&#125;
blockquote, q &#123;
    quotes: none;
&#125;
blockquote:before, blockquote:after,
q:before, q:after &#123;
    content: &#39;&#39;;
    content: none;
&#125;
table &#123;
    border-collapse: collapse;
    border-spacing: 0;
&#125;</code></pre>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>通过 float 属性设置元素浮动，此时水平布局的等式不需要强制成立。</p>
<p>但是元素设置浮动后会完全从文档流中脱离，不再占用文档流的位置，所以元素下边还在文档流中的元素会自动向上移动，但若文档流中的元素是文字则会环绕浮动元素</p>
<p>通过浮动可制作水平布局</p>
<h3 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h3><p>（1）浮动元素会完全脱离文档流，不再占据文档流中的位置</p>
<p>（2）设置浮动后元素会向父元素的左侧或右侧移动</p>
<p>（3）浮动元素默认不会从父元素中移出，即不能跨出父元素边界</p>
<p>（4）浮动元素向左或向右移动时不会超过前边的其他浮动元素</p>
<p>（5）若浮动元素上边是一个没有浮动的元素，则浮动元素无法上移</p>
<p>（6）浮动元素不会超过它上边的浮动的兄弟元素，最多和兄弟一样高</p>
<p>（7）浮动元素不会盖住文字，文字会自动环绕在浮动元素周围，可利用该特性设置文字环绕图片效果</p>
<h3 id="脱离文档流的特点"><a href="#脱离文档流的特点" class="headerlink" title="脱离文档流的特点"></a>脱离文档流的特点</h3><h4 id="1、块元素"><a href="#1、块元素" class="headerlink" title="1、块元素"></a>1、块元素</h4><p>（1）块元素不再独占一行</p>
<p>（2）脱离文档流后，块元素的宽度和高度默认都被内容撑开</p>
<h4 id="2、行内元素"><a href="#2、行内元素" class="headerlink" title="2、行内元素"></a>2、行内元素</h4><p>行内元素脱离文档流后会变成块元素，特点和脱离文档流后的块元素一样，且可设置宽高</p>
<p><strong>脱离文档流后，不再需要区分块和行内元素了</strong></p>
<h3 id="浮动的问题"><a href="#浮动的问题" class="headerlink" title="浮动的问题"></a>浮动的问题</h3><h4 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h4><p>在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会完全脱离文档流，则会无法撑起父元素高度，导致父元素的高度丢失。父元素高度丢失后其下方元素会自动上移，导致页面布局混乱</p>
<h4 id="解决高度塌陷：BFC（Block-Formatting-Context）块级格式化环境"><a href="#解决高度塌陷：BFC（Block-Formatting-Context）块级格式化环境" class="headerlink" title="解决高度塌陷：BFC（Block Formatting Context）块级格式化环境"></a>解决高度塌陷：BFC（Block Formatting Context）块级格式化环境</h4><p>BFC 是一个 CSS 中的一个隐含属性，可为一个元素开启 BFC，开启 BFC 后该元素会变成一个独立的布局区域</p>
<p><strong>元素开启 BFC 后的特点：</strong></p>
<pre><code>1、开启 BFC 的元素不会被浮动元素所覆盖，下边文档流中的元素会跑到浮动元素旁边
2、开启 BFC 的父元素，其子元素和父元素外边距不会重叠，即给子元素设置 margin-top 后不会影响父元素
3、开启 BFC 的元素可以包含浮动的子元素，即不会发生高度塌陷</code></pre>
<p><strong>开启 BFC 的方式：</strong></p>
<pre><code>1、设置父元素的浮动 float（不推荐）
2、将父元素设置为行内块元素（不推荐）
3、将父元素的 overflow 设置为非 visible 的值，如 `overflow:hidden;`或`overflow:auto;`，从而使其可以包含住浮动的子元素</code></pre>
<h4 id="解决高度塌陷：clear（较完美，无副作用）"><a href="#解决高度塌陷：clear（较完美，无副作用）" class="headerlink" title="解决高度塌陷：clear（较完美，无副作用）"></a>解决高度塌陷：clear（较完美，无副作用）</h4><p>通过在父元素的最后添加一个子元素，并为该子元素设置 <code>clear:both;</code> 则父元素会依靠添加的这个子元素撑起，在该子元素上方其实浏览器自动为其添加了外边距，使其不受浮动的兄弟元素的影响，设置方式如下</p>
<pre><code>父元素::after&#123;
    content:&#39;&#39;;
    display:block;  //由于伪元素默认是行内元素会环绕在浮动元素周围，依然无法撑起父元素，所以要将其转为块元素，或者使用 display:table;
    clear:both;
&#125;</code></pre>
<h3 id="解决浮动对其他元素的影响"><a href="#解决浮动对其他元素的影响" class="headerlink" title="解决浮动对其他元素的影响"></a>解决浮动对其他元素的影响</h3><p>clear 属性可清除浮动元素对当前元素产生的影响</p>
<pre><code>可选值
    left：清除左侧浮动元素（即 float:left 的元素）对当前元素的影响
    right：清除右侧浮动元素（即 float:right 的元素）对当前元素的影响
    both：清除两侧中最大影响的那侧</code></pre>
<p>原理：设置清除浮动以后，浏览器会自动为元素<strong>添加相应外边距</strong>，使其位置不受其他元素的影响。如 div1 在 div3 上方，给 div1 设置 float 属性后原本 div3 会上移并被 div1 覆盖住，但给 div3 设置 <code>clear:left;</code> 后浏览器会自动为 div3 添加 margin-top，值为 div1 的高度，使得 div3 还在原本的位置不会上移</p>
<h3 id="自定义clearfix类同时解决外边距重叠与高度塌陷"><a href="#自定义clearfix类同时解决外边距重叠与高度塌陷" class="headerlink" title="自定义clearfix类同时解决外边距重叠与高度塌陷"></a>自定义clearfix类同时解决外边距重叠与高度塌陷</h3><pre><code>通过给类 clearfix 添加属性
.clearfix::before,.clearfix::after&#123;
    content: &#39;&#39;;
    display: table;
    clear: both;
&#125;</code></pre>
<p>给需要解决外边距重叠与高度塌陷的父元素的 class 属性中添加 clearfix 即可使用上述样式解决问题</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>使用 position 属性设置定位</p>
<pre><code>可选值
    static    默认值，元素是静止的，没有开启定位
    relative  开启元素的相对定位
    absolute  开启元素的绝对定位
    fixed     开启元素的固定定位
    sticky    开启元素的粘滞定位</code></pre>
<h3 id="1、相对定位"><a href="#1、相对定位" class="headerlink" title="1、相对定位"></a>1、相对定位</h3><p>偏移量（offset）：当元素<strong>开启定位后</strong>，通过偏移量设置元素位置</p>
<p>— top/bottom/left/right：定位元素和定位位置上/下/左/右边的距离</p>
<p>定位元素垂直（水平）方向的位置由 top（left） 和 bottom（right） 两个属性控制，一般用其一</p>
<p>和 margin-right 等的区别是设置 right 移动的是元素自身，而 margin-right 是挤走其他元素</p>
<h4 id="相对定位特点"><a href="#相对定位特点" class="headerlink" title="相对定位特点"></a>相对定位特点</h4><p>（1）元素开启相对定位后，若不设置偏移量，元素不会发生任何变化</p>
<p>（2）相对定位是参照<strong>元素自身原本在文档流中的位置</strong>进行定位的</p>
<p>（3）相对定位会提升元素的层级，层级会高于文档流中的元素</p>
<p>（4）相对定位不会使元素脱离文档流（因为它在文档流中还占据位置）</p>
<p>（5）相对定位不会改变元素的性质，块还是块（如元素原来位置是否还独占一行，宽高是否改变，是否还能设置宽高），行内元素还是行内元素</p>
<h3 id="2、绝对定位"><a href="#2、绝对定位" class="headerlink" title="2、绝对定位"></a>2、绝对定位</h3><p>包含块（containing block）：</p>
<p>— 正常情况下，包含块是离当前元素最近的祖先块元素，如 <code>&lt;div&gt;&lt;span&gt;&lt;em&gt;hello&lt;/em&gt;&lt;/span&gt;&lt;/div&gt;</code> 其中 <code>&lt;em&gt;</code> 的包含块是 <code>&lt;div&gt;</code></p>
<p>— 绝对定位时，包含块是离当前元素最近的开启了定位的祖先元素，若所有祖先元素都没开启定位，则相对于根元素进行定位，根元素就是它的包含块（<code>&lt;html&gt;</code>是根元素，也称为初始包含块）</p>
<h4 id="绝对定位特点"><a href="#绝对定位特点" class="headerlink" title="绝对定位特点"></a>绝对定位特点</h4><p>（1）开启绝对定位后，若不设置偏移量，元素的位置不会发生变化</p>
<p>（2）开启绝对定位后，元素会从文档流中脱离</p>
<p>（3）绝对定位会使元素提升一个层级</p>
<p>（4）绝对定位会改变元素的性质，行内变成块，块的宽高变为被内容撑开</p>
<p>（5）绝对定位元素是相对于其<strong>包含块</strong>进行定位的</p>
<h4 id="绝对定位元素的位置"><a href="#绝对定位元素的位置" class="headerlink" title="绝对定位元素的位置"></a>绝对定位元素的位置</h4><p><strong>水平布局：</strong></p>
<p>元素开启绝对定位后水平布局等式需添加 left 和 right，即应满足等式 </p>
<pre><code>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 包含块内容区宽度</code></pre>
<p><strong>垂直布局：</strong></p>
<p>之前垂直方向的等式不强制满足，但元素开启绝对定位后垂直布局必须满足等式 </p>
<pre><code>top + margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom + bottom = 包含块内容区高度</code></pre>
<p>其中可设置为 auto 的值有 margin、width/height、left/top、right/bottom</p>
<p>当发生过度约束（等式不成立）时，</p>
<p>— 若 9 个值中没有 auto 则自动调整 right/bottom 以使等式满足</p>
<p>— 因为 left 和 right 的值默认是 auto，所以若不知道 left 和 right 时若等式不满足，则会自动调整这两个值</p>
<p>— 若显式设置了 left 或 right 为 auto，若还有其他属性如 margin 类设为 auto，也会去自动调整 left 或 right，而不是 margin</p>
<p>— 若 <code>left=0; right=0;</code> 其他值有 auto 则自动调整 auto 的值以使等式满足</p>
<p>元素水平居中：</p>
<pre><code>方式一：
    父元素 position:relative;
    子元素 
    position:absolute;
    left=0; 
    right=0; 
    margin-left=auto; 
    margin-right=auto
方式二：
    父元素
    display:flex; 
    justify-content:center; </code></pre>
<p>元素垂直居中：</p>
<pre><code>方式一：
    父元素 position:relative;
    子元素 
    position:absolute;
    top=0; 
    bottom=0; 
    margin-top=auto; 
    margin-bottom=auto
方式二：
    父元素
    display: table-cell;   //将元素设置为单元格&lt;td&gt;
    vertical-align: middle;
方式三：
    父元素
    display:flex; 
    align-items:center;`</code></pre>
<p>元素水平 + 垂直居中：</p>
<pre><code>方式一：    
    父元素 position:relative;
    子元素 
    position:absolute;
    left=0; 
    right=0; 
    top=0; 
    bottom=0; 
    margin-left=auto; 
    margin-right=auto
    margin-top=auto; 
    margin-bottom=auto
方式二：
    父元素
    display:flex; 
    justify-content:center; 
    align-items:center;`</code></pre>
<p>也可通过表格 table 实现</p>
<p>也可通过 绝对定位 + transform 实现</p>
<p>也可通过弹性盒 flex 实现</p>
<h3 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h3><p>固定定位是一种特殊的绝对定位，固定定位大部分特点都和绝对定位一样（如脱离文档流，元素性质改变，行内元素变为块元素，块元素宽高变为由内容撑开，不设置偏移量位置不会变），唯一不同的是固定定位永远参照浏览器的<strong>视口</strong>进行定位</p>
<p>对于开启固定定位的元素水平布局满足以下等式</p>
<pre><code>left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 视口宽度</code></pre>
<p><strong>如设置元素贴在某元素右边</strong></p>
<p>无法通过直接设置 right 等值进行定位，因为视口宽度不固定，此时可先设置 <code>right=50%;</code> 并设置 <code>margin-right: -(被贴元素宽度/2+元素宽度)</code> 即可，不能设置任何关于 left 的值，left 默认是 auto，通过这个 auto 会自动计算不同视口宽度下的对应的值，而为了元素往右需要增大 left，因此需要减小 margin-left，但是 margin-left 为正值且越大元素才会向右移，这互相矛盾了，所以需要通过设置 margin-right，并且 margin-right 不是移动元素自身而是挤其他元素，其值越负表示右移，因此最合适</p>
<h3 id="4、粘滞定位（浏览器兼容性不好）"><a href="#4、粘滞定位（浏览器兼容性不好）" class="headerlink" title="4、粘滞定位（浏览器兼容性不好）"></a>4、粘滞定位（浏览器兼容性不好）</h3><p>粘滞定位和相对定位的特点基本一致，不同的是粘滞定位可以在元素到达某个位置（如通过 top 等属性设置，在到达离顶端多少的位置把它定住）时将其固定</p>
<h3 id="5、元素层级"><a href="#5、元素层级" class="headerlink" title="5、元素层级"></a>5、元素层级</h3><p>对于开启定位元素，可通过 <code>z-index</code> 属性指定元素的层级，<code>z-index</code> 需要一个整数为参数，值越大元素的层级越高越优先显示</p>
<p>但是祖先元素的层级再高也不会盖住后代元素，因为祖先元素层级高了后代元素也会跟着高所以无法覆盖</p>
<p>只要是开启定位且没有设置 <code>z-index</code> 的元素的层级都一样</p>
<p>若元素层级一样，则优先显示代码中靠下的元素</p>
<h2 id="弹性盒-伸缩盒-flex（CSS3）"><a href="#弹性盒-伸缩盒-flex（CSS3）" class="headerlink" title="弹性盒/伸缩盒 flex（CSS3）"></a>弹性盒/伸缩盒 flex（CSS3）</h2><p>要使用弹性盒，必须先将一个元素设置为弹性容器</p>
<h3 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h3><p>通过 <code>display</code> 来设置弹性容器</p>
<pre><code>display: flex;         设置块级弹性容器，独占一行（用得多）
display: inline-flex;  设置为行内弹性容器，不会独占一行</code></pre>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><p>1、flex-direction 指定容器中弹性元素的排列方式以及主轴</p>
<pre><code>可选值
    row 默认值，弹性元素在容器中从左向右水平排列，主轴自左向右
    row-reverse  弹性元素在容器中从右向左反向水平排列，主轴自右向左
    column  弹性元素自上向下纵向排列，主轴自上向下
    column-reverse  弹性元素自下向上反向纵向排列，主轴自下向上</code></pre>
<p>主轴：弹性元素的排列方向称为主轴</p>
<p>侧轴：与主轴垂直方向称为侧轴</p>
<p>justifyxxxxx属性与主轴有关，alignxxxxx属性与辅轴有关</p>
<p>2、flex-wrap 设置弹性元素在弹性容器中是否自动换行</p>
<pre><code>可选值
    nowrap 默认值，不会自动换行
    wrap 元素沿着辅轴方向自动换行
    wrap-reverse 元素沿着辅轴反方向换行</code></pre>
<p>3、flex-flow 是 flex-direction 和 flex-wrap 的简写属性</p>
<pre><code>如 flex-flow: row wrap;</code></pre>
<p>4、justify-content 如何分配<strong>主轴</strong>上的空白空间，即主轴上元素如何排列</p>
<pre><code>可选值
    flex-start 元素沿着主轴起边排列
    flex-end 元素沿着主轴终边排列
    center 元素居中排列，空白会在两边
    space-around 空白分布到元素两侧，元素之间的距离会稍微大，是两边距离的两倍，因为中间空白是两个元素两边空白相加的结果
    space-evenly 空白分布到元素的单侧，此时两边与元素中间空白大小相同（浏览器兼容不好）
    space-between 空白均匀分布到元素之间</code></pre>
<p>5、align-items 元素在<strong>辅轴</strong>上如何对齐</p>
<pre><code>可选值
    stretch  默认值，将一行内元素的高度设置为相同的值
    flex-start  元素不会拉伸，元素沿着辅轴起边排列
    flex-end  元素不会拉伸，元素沿着辅轴终边排列
    center  元素在辅轴居中对齐
    baseline 基线对齐（当字大小不同时基线不同）</code></pre>
<p>6、align-content 辅轴上空白空间的分布</p>
<pre><code>可选值
    flex-start
    flex-end
    center 元素垂直居中排列，空白会在两边
    space-around
    space-evenly（浏览器兼容不好）
    space-between</code></pre>
<h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><p>弹性容器的直接子元素是弹性元素/弹性项</p>
<p>弹性元素可以同时是弹性容器</p>
<h4 id="相关属性-1"><a href="#相关属性-1" class="headerlink" title="相关属性"></a>相关属性</h4><p>1、flex-grow 指定弹性元素的伸展系数，即指定当父元素有多余空间时子元素如何伸展，父元素的剩余空间会按照比例进行分配</p>
<pre><code>flex-grow:0;  子元素不伸展
flex-grow:1或2或3等;</code></pre>
<p>2、flex-shrink 指定弹性元素的收缩系数，即指定当父元素中空间不足以容纳所有子元素时，如何对子元素进行收缩。缩减多少是根据缩减系数和元素大小来计算</p>
<pre><code>flex-shrink: 1;  默认值，等比例收缩
flex-shrink: 0;  当为 0 时不会收缩，子元素可能会超过父元素
flex-shrink: 2或3等;  可是其他整数</code></pre>
<p>3、align-self 用来覆盖当前弹性元素上的 align-items</p>
<p>4、flex-basis 指定元素在主轴上的基础长度，若主轴是横向的，该值指定的是元素的宽度，若主轴是纵向的，该值指定的是元素的高度</p>
<pre><code>可选值
    auto 默认值，表示参考元素自身的高度或宽度
    具体数值  若传递了一个具体数值，则以该值为准</code></pre>
<p>5、flex 设置弹性元素 flex-grow，flex-shrink，flex-basis 样式的简写。<code>flex: 增长系数 缩减系数 基础长度</code></p>
<pre><code>可选值
    增长系数 缩减系数 基础长度
    initial  表示 flex: 0 1 auto 只能减
    auto   表示 flex: 1 1 auto  能增能减
    none   表示 flex: 0 0 auto  不能增不能减</code></pre>
<p>6、order 决定弹性元素的排列顺序</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体是属于矢量图（放大后不会失真）</p>
<p>1、color 设置前景色（如字体、边框颜色）</p>
<p>2、font-size 字体大小</p>
<pre><code>单位：em，相对于当前元素的 font-size
     rem，相对于根元素的 font-size</code></pre>
<p><strong>注意：网页中字体大小最小是 12px，不能设置一个比 12 像素还小的字体</strong></p>
<p>3、font-family 字体族</p>
<pre><code>可选值（不是具体字体，而是对字体分类）：
    serif      衬线字体
    sans-serif 非衬线字体
    monospace  等宽字体（有利于上下行对其）
    cursice    草书字体
    fantasy    虚幻字体
以上只是指定字体的类别，浏览器会自动使用该类别下的字体，指定类别后具体用哪种字体由浏览器决定</code></pre>
<p>font-family 可同时指定多个字体，多个字体间用 <code>,</code> 隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推</p>
<p>4、font-face 可将服务器中的字体直接提供给用户使用，</p>
<pre><code>@font-face&#123;
    font-family:&#39;myfont&#39;; //这里是指给字体起的名字，而非字体类别
    src:url(&#39;./xxx/xxx.ttf&#39;) format(&quot;truetype&quot;),
        url(&#39;./xxx/xxx.ttf&#39;); //服务器中字体的路径,format()不是必须
&#125;
font-family:myfont;</code></pre>
<p>问题：（1）加载速度（2）版权（但 font-family 中没有版权问题，因为 font-family 只是建议字体，具体用不用看用户电脑中是否安装；但 font-face 会涉及版权问题，因为是你提供的字体）（3）字体文件格式，如 <code>.ttf</code></p>
<p>5、字体属性简写</p>
<p><code>font</code> 属性可设置字体相关所有属性，语法：<code>font: 其他样式（加粗、斜体等） 字体大小/行高 字体族</code>，字体大小和字体族必写，若行高省略不写不表示不设置，而是使用默认值</p>
<pre><code>font:50px/2 &#39;Times New Roman&#39;,Times,serif;

line-height:2;
font:50px &#39;Times New Roman&#39;,Times,serif;

以上写法，两倍行高不生效，因为在 font中设置 50px 后面没有指定行高则会使用默认行高，会覆盖前面设置的 line-height:2;，可将 line-height:2; 移至 font 下方则可生效，如下

font:50px &#39;Times New Roman&#39;,Times,serif;
line-height:2;</code></pre>
<p>6、文字对齐</p>
<p>水平对齐：text-align，可选值：left（左对齐）、right（右对齐）、center（居中对齐）、justify（两端对齐）</p>
<p>垂直对齐：vertical-align，可选值：baseline（默认值，文字基线对齐）、top（顶部对齐）、bottom（底部对齐）、middle（居中对齐，是指与字母 x 的中间对齐）</p>
<p>注意：添加图片时，下方会由小缝隙，可通过设置图片的样式 <code>vertical-align:非baseline的值</code>来消除缝隙</p>
<p>7、其他文本样式</p>
<p>text-decoration</p>
<pre><code>可选值 
none
underline（下划线）
line-through（删除线）
overline（上划线）
如
text-decoration: underline red dotted; //下划红虚线</code></pre>
<p>white-space</p>
<pre><code>可选值
normal（自动换行）
nowrap（不换行）
pre（保留空白，原本多个空格仅显示为一个空格，设置为 pre 后会保留多个空格）</code></pre>
<p>设置省略号</p>
<pre><code>white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;</code></pre>
<h3 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h3><p>图标可以通过图片引入，但是图片文件大小本身比较大，且不灵活（如放大缩小、改颜色）。还可以把图标设置为字体，通过 font-face 引入字体，这样可以通过使用字体的形式使用图标</p>
<p>图标字体库：<a href="https://fontawesome.com/">Font Awesome</a>、<a href="https://www.iconfont.cn/">阿里 iconfont</a></p>
<p><strong>font awesome 使用方法：</strong></p>
<p>（1）官网下载软件并解压</p>
<p>（2）将 css 和 webfont 文件夹移动到项目中，且放同一级目录下</p>
<p>（3）将 css 文件夹中 all.css文件引入网页中 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx/all.css&quot;&gt;</code></p>
<p>（4）方法一：直接通过类名使用图标字体，在标签中添加 <code>class=&quot;fas&quot;</code> 或 <code>class=&quot;fab&quot;</code>，并通过 <code>font-size</code>、<code>color</code> 属性改变图标大小、颜色，如</p>
<pre><code>&lt;i class=&quot;fas 具体图标对应类&quot;&gt;&lt;/i&gt;
（`&lt;i&gt;`可换，图标类可换，但 fas 或 fab 是固定的）</code></pre>
<p>方法二：通过伪元素设置图标，在 content 中设置 <code>\图标编码</code>（在 font awesome 文档中查找），并设置字体样式，如</p>
<pre><code>对于 fas 类
font-family:&#39;font Awesome 5 Brands&#39;;
对于 fab 类
font-family:&#39;font Awesome 5 Free&#39;;
font-weight:900;</code></pre>
<p>方法三：通过实体使用，<code>&amp;#x字体编码;</code>，如</p>
<pre><code>&lt;span class=&quot;fas或fab&quot;&gt;&amp;#x图标编码;&lt;/span&gt;</code></pre>
<p><strong>阿里 iconfont 使用方法：</strong></p>
<p>（1）在官网选择图标加入“购物车”，在“购物车”中点击“添加指项目”，在“图标管理”-&gt;“我的项目”中点击“下载至本地”，并解压</p>
<p>（2）将解压后所有文件移动到项目中，且放同一级目录下</p>
<p>（3）将 css 文件夹中 all.css文件引入网页中 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx/iconfont.css&quot;&gt;</code></p>
<p>（4）方法一：直接通过类名使用图标字体，在标签中添加 <code>class=&quot;iconfont 图标类名&quot;</code>如</p>
<pre><code>&lt;i class=&quot;fas 具体图标对应类&quot;&gt;&lt;/i&gt;</code></pre>
<p>方法二：通过伪元素设置图标，在 content 中设置 <code>\图标编码</code>，以及 <code>font-family:&#39;iconfont&#39;;</code></p>
<p>方法三：通过实体引入图标，设置 <code>class=&quot;iconfont&quot;</code>以及<code>&amp;#x字体编码;</code>，如</p>
<pre><code>&lt;i class=&quot;iconfont&quot;&gt;&amp;#x图标编码;&lt;/i&gt;
修改样式
i.iconfont&#123;
    font-size:100px;
&#125;</code></pre>
<p><strong>Unicode 编码中的字符使用方法：</strong></p>
<p>可在 html 中通过 <code>&amp;#十进制编码;</code> 使用</p>
<p>也可在 js 中通过 <code>\u十六进制编码</code> 使用</p>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><p>行高指文字占有的实际高度，可通过 <code>line-height</code> 设置，<code>line-height</code> 可直接指定大小（px，em），也可设置为整数，表示行高为字体大小的相应倍数，默认是 1.333</p>
<p>字体框指字体存在的格子，设置 <code>font-size</code> 是在设置字体框的高度</p>
<p><strong>行高用处：</strong></p>
<p>行高会在字体框的上下平均分配，因此可以通过设置 <code>line-height</code> 和 <code>height</code> 相等使单行文字在一个元素中垂直居中 </p>
<p>行高还可用于设置文字行间距，行间距 = 行高 - 字体大小</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1、background-color（设置背景颜色）、background-image（设置背景图片）</p>
<p>2、background-repeat：设置背景重复方式</p>
<pre><code>可选值
repeat    默认值，背景会沿 x、y 轴双方向重复
repeat-x  沿着 x 轴方向重复
repeat-y  沿着 y 轴方向重复
no-repeat 背景图片不重复</code></pre>
<p>3、background-position：设置背景图片位置</p>
<pre><code>可选值一：top left right bottom center，需要同时指定两个值，若只写一个，则第二个值默认为 center 如
background-position:top left;    //左上角
background-position:center left; //左侧中间
background-position:center center;  //正中间

可选值二：通过 水平方向偏移量 垂直方向偏移量设置，如
background-position:50px 300px;
background-position:-50px 300px;</code></pre>
<p>4、background-clip：设置背景范围</p>
<pre><code>可选值
border-box  默认值，背景会出现在边框下边
padding-box 背景不会出现在边框，只出现在内容区和内边距
content-box 背景只出现在内容区</code></pre>
<p>5、background-origin：设置背景图片的偏移量计算的原点</p>
<pre><code>可选值
padding-box  默认值，此时 background-position 从内边距处开始计算
content-box  此时背景图片的偏移量从内容区开始计算
border-box   此时背景图片的偏移量从边框处开始计算</code></pre>
<p>6、background-size：设置背景图片大小，</p>
<pre><code>可选值
宽度 高度  若只写一个，则第二个值默认是 auto
cover     图片的比例不变，图片较小边为 100% 来将元素填满，大的边可能显示不全
contain   图片比例不变，将图片在元素中完整显示，图片较大边为 100%，使图片全部显示，此时元素可能不会被填满</code></pre>
<p>7、background-attachment：设置背景图片是否跟随元素移动</p>
<pre><code>可选值
scroll   默认值，背景图片会跟随元素移动
fixed    背景图片会固定在页面中，不会跟随元素移动</code></pre>
<p>8、background：背景相关所有属性的简写</p>
<pre><code>如 background:#bfa url(&#39;./img.jpg&#39;) center center/contain border-box content-box no-repeat fixed; 
无顺序要求，也没有哪个属性是必须写的
但是 background-size 只能写在 background-position 后，并用 / 隔开
background-clip 要写在 background-origin 后</code></pre>
<h3 id="雪碧图（CSS-Sprite）"><a href="#雪碧图（CSS-Sprite）" class="headerlink" title="雪碧图（CSS-Sprite）"></a>雪碧图（CSS-Sprite）</h3><p>雪碧图：将多个小图片统一保存到大图片中，通过 background-position 来切换显示的图片，这样图片会同时加载到网页中，从而有效避免出现闪烁问题，该技术称为 CSS-Sprite</p>
<h4 id="雪碧图使用步骤"><a href="#雪碧图使用步骤" class="headerlink" title="雪碧图使用步骤"></a>雪碧图使用步骤</h4><p>1、确定使用的图标及其大小</p>
<p>2、根据测量结果创建一个元素</p>
<p>3、将雪碧图设置为元素的背景图片</p>
<p>4、设置偏移量以显示正确图片</p>
<h4 id="雪碧图特点"><a href="#雪碧图特点" class="headerlink" title="雪碧图特点"></a>雪碧图特点</h4><p>一次性将多个图片加载到页面中，降低请求的次数，加快访问速度，提升用户体验</p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>渐变的特质是图片，不是颜色，其很多特点和 background-image 相似，而非 background-color，通过 background-image 设置</p>
<h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><pre><code>线性渐变1
linear-gradient(渐变方向,开始的颜色 正颜色开始位置,中间颜色2 正颜色开始位置,中间颜色n,结束的颜色)
渐变方向可为 to left、to right、to bottom、to top、to top left、xxxdeg（deg表示度数）、xxturn（转多少圈，如.5）等，也可省略，默认是180deg/to bottom
颜色开始位置也可省略
如
background-image: linear-gradient(red 50px,yellow 100px); //红色向黄色从上往下渐变，红色从 50px 开始，上面也自动填充为红色，黄色从 100px 开始
background-image: linear-gradient(to right,red,yellow); //红色向黄色从左往右渐变

线性渐变2
repeating-linear-gradient(渐变方向,开始的颜色 开始颜色的位置,结束的颜色 结束颜色的位置)
通过设置渐变发生在 ‘开始颜色的位置’ 到 ‘结束颜色的位置’ 之间，范围也只有这么大，其他区域就重复这部分渐变
此时 background-repeat:no-repeat 无效</code></pre>
<h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h4><p>径向渐变即放射性效果，默认情况下径向渐变的形状根据元素形状来计算</p>
<pre><code>radial-gradient(大小 at 圆心位置, 颜色1 位置1, 颜色2 位置2, 颜色n 位置n)，只有颜色是必须写的
大小可选值
    xxxpx xxxpx     径向 x 轴半径 径向 y 轴半径
    circle          圆形
    ellipse         椭圆形
    closest-side    渐变会覆盖到元素最近的边
    farthest-side   渐变会覆盖到元素最远的边
    closest-corner  渐变会覆盖到元素最近的角    
    farthest-corner 渐变会覆盖到元素最远的角
位置可选值
    xxxpx xxxpx     圆心 x 位置 圆心 y 位置
    top
    bottom
    left
    right
    center    
如
background-image: radial-gradient(100px 100px,red,yellow);
background-image: radial-gradient(100px 100px at 100px 100px,red,yellow);
background-image: radial-gradient(100px 100px at center center,red,yellow);
background-image: radial-gradient(ellipse,red,yellow);</code></pre>
<h2 id="样式切换过渡"><a href="#样式切换过渡" class="headerlink" title="样式切换过渡"></a>样式切换过渡</h2><p><code>transition</code> 用于为样式设置过渡效果</p>
<p>支持过渡的属性：大部分属性都支持，其值是个能计算的值的属性</p>
<p>过渡有四个属性</p>
<p>（1）<code>transition-property</code> 指定要执行过渡的属性，多个属性间用<code>,</code>隔开，若所有属性都要过渡，则用 <code>all</code> 关键字。要出现过渡效果还需要搭配 <code>transition-duration</code></p>
<p>（2）<code>transition-duration</code> 指定过渡的持续时间，单位有 s 和 ms</p>
<p>（3）<code>transition-timing-function</code> 过渡的时序函数，指定过渡的执行方式，可选值有<br>— ease        默认值，先加速再减速</p>
<p>— linear      匀速运动</p>
<p>— ease-in     加速运动</p>
<p>— ease-out    减速运动</p>
<p>— ease-in-out 先加速后减速</p>
<p>— cubic-bezier(xx,xx,xx,xx)  贝塞尔曲线，可在<a href="https://cubic-bezier.com/">官网</a>查看不同参数的效果</p>
<p>— step(步数,执行时间点)      分步执行过渡效果，第二个值可选，<code>end</code> 表示在时间结束时执行过渡（默认值），<code>start</code> 表示在时间开始时执行过渡</p>
<p>— transition-delay   过渡效果的延迟，等待一段时间后再执行过渡</p>
<p>过渡属性简写 <code>transition</code> 可同时设置过渡相关所有属性，无顺序要求，但若要写延迟，则持续时间要写在延迟时间之前</p>
<pre><code>transition: height 0.3s;  //当元素高度发生变化时需要 0.3s 进行切换，但变化前后的高度不能有 auto 值
transition: all 0.3s;  //当元素样式发生变化时所有变化的样式需要 0.3s 进行切换
transition: 2s margin-left 1s cubic-bezier(.24,.95,.82,-0.88);</code></pre>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><strong>动画与过渡的异同：</strong>动画和过渡类似，都可以实现动态效果，但是过渡需在某个属性发生变化时才会触发，而动画可自动触发动态效果</p>
<p>设置动画效果，需先设置关键帧，关键帧设置了动画执行的每一个步骤</p>
<pre><code>元素选择器&#123;
    animation-name:动画名；//对当前元素生效的关键帧名字
    animation-duration: 2s; //动画执行时间
    animation-delay: 1s;
    animation-timing-function: ease-in-out;
    animation-iteration-count: infinite;  //动画执行的次数，取值为数值或 infinite（无限次）
    animation-direction: normal; //动画运行的方向，
         normal（默认值）表示从 from 向 to 运行，每次都是这样
        reverse 表示从 to 向 from 执行，每次都是这样
        alternate 从 from 向 to 开始，重复执行时动画反向执行
        alternate-reverse 从 to 向 from 开始，重复执行时动画反向执行
    animation-play-state //设置动画的执行状态，
        running 动画执行
        paused  动画暂停
    animation-fill-mode  //动画填充模式
        none（默认值）表示动画执行完毕元素回到原来位置
        forwards 动画执行完毕元素会停止在动画结束位置
        backwards 动画延时等待时，元素就会处于开始位置
        both 结合了 forwards 和 backwards
&#125;
@keyframe 动画名&#123;
    from&#123;
        margin-left: 0;
    &#125;   //动画开始位置，也可用 0%&#123;&#125; 表示
    40%&#123;
        xxxx;
    &#125;  //可选项
    to&#123;
        margin-left: 700px;
    &#125;  //动画结束位置，也可用 100%&#123;&#125; 表示
&#125;</code></pre>
<p>动画属性简写 <code>animation</code> 可同时设置动画相关所有属性，无顺序要求，但若要写延迟，则持续时间要写在延迟时间之前</p>
<h2 id="变形平移"><a href="#变形平移" class="headerlink" title="变形平移"></a>变形平移</h2><p>transform 用来设置元素的变形效果</p>
<p>注意变形不会影响页面布局，即元素改变位置但不对其他元素产生影响，不会挤走其他元素，同时也没脱离文档流</p>
<h3 id="1、平移"><a href="#1、平移" class="headerlink" title="1、平移"></a>1、平移</h3><pre><code>translateX(xxx) 沿着 x 轴方向平移，可设置像素或百分比
translateY(xxx) 沿着 y 轴方向平移，可设置像素或百分比
translateZ(xxx) 沿着 z 轴方向平移，可设置像素或百分比
百分比是相对于自身计算的</code></pre>
<h3 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h3><pre><code>rotateX(xxxdeg或xxxturn) 沿着 x 轴方向旋转
rotateY(xxxdeg或xxxturn) 沿着 y 轴方向旋转
rotateZ(xxxdeg或xxxturn) 沿着 z 轴方向旋转</code></pre>
<h3 id="3、缩放"><a href="#3、缩放" class="headerlink" title="3、缩放"></a>3、缩放</h3><pre><code>scaleX(xxx) 水平方向缩放
scaleY(xxx) 垂直方向缩放
scale(xxx) 双方向缩放
scaleZ(xxx) z轴方向缩放，对立体元素才会看到效果</code></pre>
<p>z轴平移属于立体效果（近大远小），默认情况下网页不支持透视，若需要看见效果必须要设置网页的视距</p>
<pre><code>html&#123;
    perspective: 800px;  //设置当前网页视距（人眼与网页的距离），一般为 800-1200px
&#125;</code></pre>
<p>元素变形默认是 2D 效果，若要 3D 变形效果需设置 <code>transform-style:preserve-3d</code> 搭配 <code>transform</code></p>
<p><code>backface-visibility</code> 可设置旋转后背面效果，可选值：visible、<br>hidden</p>
<p><code>transform-origin: xxxpx xxxpx;</code> 设置变形原点，默认值 center</p>
<p><code>transform</code>中可同时设置平移和旋转，用空格隔开，写的顺序不同效果不同</p>
<p><strong>利用变形可设置鼠标移入时元素浮出效果</strong>，如</p>
<pre><code>元素选择器&#123;
    transition: all .3s;  //设置过渡
&#125;
元素选择器:hover&#123;
    transform:translateY(-4px);  //鼠标移入时元素向上移
    box-shadow: 0 0 10px rgba(0,0,0,.3)
&#125;</code></pre>
<h2 id="CSS-中的变量与计算（浏览器兼容不太好）"><a href="#CSS-中的变量与计算（浏览器兼容不太好）" class="headerlink" title="CSS 中的变量与计算（浏览器兼容不太好）"></a>CSS 中的变量与计算（浏览器兼容不太好）</h2><p>CSS 原生支持变量设置</p>
<p>变量：通过 <code>--变量名;</code> 声明变量，使用时通过 <code>var(--变量名)</code></p>
<p>计算：通过 <code>calc(表达式)</code>进行属性值计算，如 <code>width: calc(200px/2);</code></p>
<h2 id="页面适配"><a href="#页面适配" class="headerlink" title="页面适配"></a>页面适配</h2><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>前端开发中像素分为 CSS 像素和物理像素两种，浏览器在显示网页时需将 CSS 像素转为物理像素然后呈现</p>
<p>一个 CSS 像素由几个物理像素显示是由浏览器决定，默认情况下在 PC 端，1 个 CSS 像素 = 1 个物理像素</p>
<p>浏览器开发者工具中的像素大小表示的是视口大小（CSS 像素）</p>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="像素比"><a href="#像素比" class="headerlink" title="像素比"></a>像素比</h4><p>视口就是屏幕中用来显示网页的区域</p>
<p>可通过查看视口大小来改变 CSS 像素和物理像素的比值</p>
<p>— 默认情况下</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;视口宽度 1920px（CSS像素），1920px（物理像素）</p>
<p>— 浏览器放大两倍时</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;视口宽度 960px（CSS像素），1920px（物理像素），此时 CSS 像素 : 物理像素 = 1 : 2</p>
<h4 id="改变视口"><a href="#改变视口" class="headerlink" title="改变视口"></a>改变视口</h4><p>每款移动设备设计时都有一个最佳像素比，一般只需将像素比设置为该值即可得到最佳效果，将像素比设置为最佳像素比的视口大小，称其为完美视口</p>
<p>可通过 <code>&lt;meta&gt;</code> 设置视口大小</p>
<pre><code>设置完美视口
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
其中 device-width 表示设备的宽度（完美视口），initial-scale=1.0 也表示完美视口，都写上是为了保险起见</code></pre>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>不同屏幕的单位像素大小不同，像素越小屏幕越清晰</p>
<p>智能手机的像素点远小于计算机的像素点，在<a href="https://material.io/resources/devices/">该网站</a>可查看不同设备的分辨率</p>
<p>如 24 寸显示器：1920 x 1080，iPhone 6：750 x 1334（物理像素）</p>
<p>默认情况下移动端的网页会将视口设置为 980 像素（CSS像素），以确保 PC 端的网页可以在移动端正常访问，但若网页宽度超过 980 像素，则移动端的浏览器会自动对网页缩放以完整显示网页，所以大部分 PC 端网站都可在移动端正常浏览，但用户体验不太好，因此一般会设计两套网页</p>
<p>默认情况下移动端像素比为 CSS 像素 : 物理像素 = 980 : 移动端宽度，如当 980 像素的视口在 iPhone 6 的 750 x 1334 的屏幕中显示时 1 个 CSS = 零点几个物理像素</p>
<h4 id="单位-1"><a href="#单位-1" class="headerlink" title="单位"></a>单位</h4><p>使用 vw 作为单位，vw 相对于视口宽度计算，100 vw = 整个视口宽度</p>
<p>vw 在移动端浏览器中基本都支持</p>
<p>移动端设计图宽度一般为 750px 或 1125px</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;100vw = 750px，即0.1333333333333vw = 1px</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;6.4vw = 48px</p>
<h4 id="vw适配"><a href="#vw适配" class="headerlink" title="vw适配"></a>vw适配</h4><p>由于在编写网页时换算 px 与 vw 较为麻烦，设计图中某元素vw = 100vw * (设计图某元素px/设计图宽度)px，因此可结合 rem 来进行适配</p>
<pre><code>对于 750px 大小的设计图
0.1333333vw = 设计图中 1px，但是不能设置小于 12px 的字体大小，所以扩大 40 倍
5.3333vw = 设计图中 40px
html&#123;
    font-size: 5.3333vw;  //所以 1rem = 设计图中40px
&#125;
此时要显示设计图中 48 * 35 px 的块
.box&#123;
    width: 1.2rem;     //48/40 = 1.2 rem
    height: 0.875rem;  //35/40 = 0.875 rem
&#125;</code></pre>
<p>为了在写代码时更方便计算可使用 less 写样式，可在代码中直接写表达式</p>
<pre><code>html&#123;
    font-size:100vw / 750 * 40;
&#125;
.box&#123;
    width: 48/40rem;
    height: 35/40rem;
&#125;</code></pre>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>网页可根据不同的设备或窗口大小呈现出不同布局，使用响应式布局可使一个网页适用于所有设备</p>
<p>响应式设计的网页（1）移动端优先（2）渐进增强</p>
<p>注意：在移动端不能去设置鼠标移入后的效果（即 hover，因为是触屏），所以该效果需要通过 js 实现</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>通过媒体查询，可为不同设备（如有屏幕设备等，不是指 PC 和移动端）或设备不同状态来分别设置</p>
<p>可通过在样式中使用 <code>@media 媒体类型&#123;&#125;</code> 进行媒体查询，可通过 <code>,</code> 连接多个媒体类型表示或，用 <code>and</code> 表示与，也可在媒体类型前加 <code>only</code>（主要是为了兼容一些老版本浏览器，因为老版本浏览器不认识 only，会直接忽略这一部分）</p>
<h4 id="1、媒体类型（即设备类型）"><a href="#1、媒体类型（即设备类型）" class="headerlink" title="1、媒体类型（即设备类型）"></a>1、媒体类型（即设备类型）</h4><p>— all 所有设备</p>
<p>— print 打印设备</p>
<p>— screen 带屏幕的设备</p>
<p>— speech 屏幕阅读器</p>
<pre><code>@media all&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media print,screen&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media only screen&#123;
    body&#123;
        background-color: #bfa;
    &#125;
&#125;</code></pre>
<h4 id="2、媒体特性"><a href="#2、媒体特性" class="headerlink" title="2、媒体特性"></a>2、媒体特性</h4><p>— width 视口宽度 <code>@media(width:xxxpx)&#123;&#125;</code> </p>
<p>— height 收口高度</p>
<p>— min-width 视口的最小宽度（视口大于指定宽度时生效）<code>@media(min-width:xxxpx)&#123;&#125;</code> </p>
<p>— max-width 视口的最大宽度（视口小于指定宽度时生效）<code>@media(max-width:xxxpx)&#123;&#125;</code> </p>
<pre><code>@media (width:500px)&#123;  //视口宽度为 500 px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media (min-width:500px)&#123;  //视口宽度大于 500 px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media (min-width:500px),(max-width:300px)&#123;  //视口宽度大于 500 px 或小于 300px 时生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media only screen (min-width:500px) and (max-width:700px)&#123;  //视口宽度大于 500 px 且小于 700px 的有屏设备生效
    body&#123;
        background-color: #bfa;
    &#125;
&#125;
@media not only screen (min-width:500px) and (max-width:700px)&#123;&#125; //not 是对后面的整体作否定</code></pre>
<p><strong>断点：</strong>样式切换的分界点，称其为断点，网页会在该点发生变化，</p>
<p>一般常用断点有：</p>
<p>— 小于768（超小屏幕） max-width:768px</p>
<p>— 大于768（小屏幕） min-width:768px</p>
<p>— 大于992（中型屏幕） min-width:992px</p>
<p>— 大于1200（大屏幕） min-width:1200px</p>
<h1 id="SEO-与-性能"><a href="#SEO-与-性能" class="headerlink" title="SEO 与 性能"></a>SEO 与 性能</h1><p>1、标题标签</p>
<p>标题标签有 <code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code> 重要性递减，搜索引擎检索时首先看 <code>&lt;title&gt;</code> 判断网站主要内容，接着看 <code>&lt;h1&gt;</code>，<code>&lt;h1&gt;</code> 在网页中的重要性仅次于 <code>&lt;title&gt;</code> ，一般一个页面只有一个 <code>&lt;h1&gt;</code>，一般只会用 <code>&lt;h1&gt;</code> - <code>&lt;h3&gt;</code></p>
<p>2、浏览器在解析网页时会自动对网页中不符合规范的内容进行修正，这会影响性能</p>
<p>如：（1）标签写在 <code>&lt;html&gt;</code> 外部（2）根元素 <code>&lt;html&gt;</code> 中出现除 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 以外的子元素（3）<code>&lt;p&gt;</code> 中嵌套了块元素</p>
<p>3、样式加载</p>
<p>当使用外部样式表时，浏览器第一次加载完该 css 文件或后会保存在浏览器的缓存中，下一个页面加载同一 css 文件时无需向服务器请求，直接在浏览器缓存中读取</p>
<p>4、雪碧图</p>
<p>浏览器加载外部资源（如图片）是按需加载，用则加载，不用则不加载，可通过雪碧图一次性将多个图片加载到页面中，降低请求的次数，加快访问速度，提升用户体验</p>
<p>5、<code>text-indent</code> 用于设置文字缩进，可用于文字隐藏，这样可以在设置一些标题供浏览器搜索但不在页面中显示</p>
<p>6、加快加载速度</p>
<p>为了使项目上线时加载速度尽量快，需删除代码中的注释以及无用的换行等，可通过在 VSCode 中安装插件 JS &amp; CSS Minifier，选中要压缩的文件，按 F1，并输入 <code>Minify:Document</code>，则该插件会对文件进行压缩生成 <code>xxx.min.css</code> 或 <code>xxx.min.js</code> 文件，在 html 代码中 <link> 引入时换成压缩后的文件</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1、<code>&lt;hgroup&gt;</code> 用于标题分组，将一组相关的标题同时放入<code>&lt;hgroup&gt;</code> 中</p>
<p>2、隐藏元素可通过 display 或 visibility 或 opacity 属性进行设置</p>
<p>设置 <code>display:none;</code> 元素不在页面中显示，且不占位置</p>
<p>设置<code>visibility:hidden;</code> 元素不在页面中显示，但依然占据位置</p>
<p>（<code>visibility:visible;</code> 为默认值，元素在页面中正常显示）</p>
<p>3、文字在父元素中垂直居中：将父元素的 line-height 设置为和父元素 height 一样的值</p>
<p>4、子元素在父元素中垂直居中：</p>
<p><strong>方式一：</strong>子元素开启绝对定位，父元素也开启定位后，在子元素中设置 <code>top=0; bottom=0; margin-top=auto; margin-bottom=auto</code>（但这种方式只适用于大小确定的元素）</p>
<p><strong>方式二：</strong>将父元素设置为<code>&lt;td&gt;</code>单元格，<code>display: table-cell; vertical-align: middle;</code></p>
<p><strong>方式三：</strong>对于大小不确定的元素，可通过绝对定位配合 transform 设置水平或垂直居中，<code>position: absolute; left:50%; top:50%; transform: translateX(-50%) translateY(-50%);</code></p>
<p><strong>方式四：</strong>通过弹性盒 flex 来设置，<code>display:flex; justify-content:center; align-items:center;</code></p>
<p>5、图片闪烁问题————雪碧图</p>
<p>如超链接中若以背景图片表示不同状态下的显示效果，则 <code>:link</code> 会首先加载，而 <code>:hover</code>、<code>:active</code> 会在指定状态触发时才会加载，可能就会出现空白一闪的情况</p>
<p>解决：通过雪碧图来解决， 如将超链接三种状态的背景图片并排放在一张图里，通过 background-position 属性设置不同状态下显示背景图片的位置</p>
<p>6、当屏幕宽度缩小时，为了不让窗口宽度过小导致布局混乱，可给 body 设置 <code>min-width: xxxpx;</code>，当窗口小于 min-width 时 body 不会再缩小</p>
<p>7、轮播图</p>
<p>方法一：通过 CSS 实现轮播图</p>
<p>对图片开启绝对定位脱离文档流，使得多张图片摞在一起，当要显示哪一图片时设置该图片 z-index 即可</p>
<p>8、标签页或收藏栏中小图标</p>
<p>网站图标一般存储于根目录，名为 <code>favicon.ico</code>，通过 <code>&lt;link rel=&quot;icon&quot; href=&quot;./favicon.ico&quot;&gt;</code> 引入</p>
<p>9、动画</p>
<p>方式一：雪碧图 + 样式过渡 transition</p>
<p>方式二：通过 animation 属性</p>
<p>10、一般给 <code>&lt;body&gt;</code> 设置 background-color 是给 <code>&lt;html&gt;</code> 设置，因此要看 body 的真实大小要通过 border</p>
<p>11、设置透明度可通过 <code>opacity:0.5;</code>，但在 IE8 中需要使用 <code>filter: alpha(opacity=50)</code></p>
<p>12、H5 本地存储技术</p>
<p>（1）sessionStorage（会话存储）</p>
<p>特点：</p>
<pre><code>--- 生命周期：浏览器打开到关闭的过程

--- 大小：5M

--- 保存的位置：浏览器端

--- 写：setItem(&#39;key&#39;,value)

--- 读：getItem(&#39;key&#39;)

--- 删除：removeItem(&#39;key&#39;)</code></pre>
<p>（2）localStorage（永久存储）</p>
<p>特点：</p>
<pre><code>--- 生命周期：永久，除非人为删除

--- 大小：5M 甚至更大

--- 保存的位置：浏览器端

--- 写：setItem(&#39;key&#39;,value)

--- 读：getItem(&#39;key&#39;)

--- 删除：removeItem(&#39;key&#39;)</code></pre>
<p>（3）cookie</p>
<p>作用：用于浏览器和服务器端进行通信的</p>
<p>特点：</p>
<pre><code>--- 生命周期：

    --- 会话 cookie：浏览器打开到关闭的过程

    --- 人为设置 cookie：人为设置的时间

--- 大小：4kb

--- 每次发送请求都携带，导致占用带宽

--- 保存的位置：浏览器端

--- cookie 容易被截获，不安全</code></pre>
<p>若 sessionStorage、localStorage 中不存在某对象，会返回 null，处理使用 JSON 转化读取除的内容不存在的情况：</p>
<pre><code>JSON.parse(localStorage.getItem(&#39;xxx&#39;) || &#39;[]&#39;);</code></pre>
<p>13、在 html 文件中</p>
<p><code>&lt;head&gt;</code> 里针对 IE 浏览器的一个特殊配置：让 IE 浏览器以最高的渲染级别渲染页面</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></pre>
<p><code>&lt;body&gt;</code> 里当浏览器不支持 js 时 noscript 中的元素会被渲染</p>
<pre><code>&lt;noscript&gt;xxxxx&lt;/noscript&gt;</code></pre>
<p>13、请将类为”left”的div元素和类为”right”的div元素在同一行上向左浮动，且清除父级div元素内部的浮动：给父级设置 <code>display:inline-block</code> 或 <code>overflow:hidden</code> 或 <code>height:子元素高度;clear:both;</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记2</title>
    <url>/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="一、JS-基础的深入"><a href="#一、JS-基础的深入" class="headerlink" title="一、JS 基础的深入"></a>一、JS 基础的深入</h1><a id="more"></a>

<h2 id="1、数据"><a href="#1、数据" class="headerlink" title="1、数据"></a>1、数据</h2><h3 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h3><p>判断数据类型的方法有 typeof、instanceof、===</p>
<p>typeof 返回的是字符串类型的数据类型表达</p>
<p>— 可以判断：undefined、数值、字符串、布尔值、函数</p>
<p>— 不能判断：null 与 object（因为都会返回’object’）、object 与 array</p>
<p>instanceof 用于判断对象的具体类型（数组、函数等）</p>
<p>=== 可以判断：undefined、null（因为这两种数据类型只有一种值）</p>
<pre><code>var a1 = &#123;
    a2:[1,&#39;a&#39;,console.log],
    a3:function()&#123;&#125;
&#125;
a1 instanceof Object //true
a1.a2 instanceof Object //true
a1.a2 instanceof Array //true
a1.a3 instanceof Object //true
a1.a3 instanceof Function //true
typeof a1.a3 === &#39;function&#39;  //true</code></pre>
<h3 id="undefined-和-null-的区别"><a href="#undefined-和-null-的区别" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>undefined 代表定义了未赋值，null 表示定义并赋值了，值为null</p>
<h3 id="什么时候为变量赋值为-null"><a href="#什么时候为变量赋值为-null" class="headerlink" title="什么时候为变量赋值为 null"></a>什么时候为变量赋值为 null</h3><p>初始赋值为 null，表明其将要赋值为对象</p>
<p>结束前赋值为 null 为了释放对象在内存中的位置，让变量指向的对象成为垃圾对象（被垃圾回收器回收）</p>
<h3 id="变量类型与数据类型"><a href="#变量类型与数据类型" class="headerlink" title="变量类型与数据类型"></a>变量类型与数据类型</h3><p>数据类型分为基本类型和对象类型，变量的类型（变量内存值的类型）分为基本类型（保存的是基本类型数据）和引用类型（保存的是地址值）</p>
<h2 id="2、数据、变量与内存"><a href="#2、数据、变量与内存" class="headerlink" title="2、数据、变量与内存"></a>2、数据、变量与内存</h2><h3 id="什么是数据"><a href="#什么是数据" class="headerlink" title="什么是数据"></a>什么是数据</h3><p>存储在内存中代表特定信息的东西，本质上是 01 串</p>
<p>数据的特点：可传递，可运算</p>
<p>一切皆数据，函数也是数据</p>
<p>内存中所有操作的目标是数据，如算术运算、逻辑运算、赋值、运行函数</p>
<h3 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h3><p>内存条通电后产生的可存储数据的临时空间</p>
<p>内存的产生和死亡：内存条（电路板）–&gt; 通电 –&gt; 产生内存空间 –&gt; 存储数据 –&gt; 处理数据 –&gt; 断电 –&gt; 内存空间和数据消失</p>
<p>分配内存：声明变量和函数或创建对象时，JS 引擎会自动分配一定大小的内存来存放对应数据</p>
<p>释放内存：清空内存中的数据，表示内存可以再分配使用（内存不释放就不能复用）</p>
<p>一块内存有两个数据：内部存储的数据和地址值</p>
<p>内存分类：栈和堆</p>
<p>— 栈：存全局变量、局部变量、标识对象的变量（如函数名），空间较小</p>
<p>— 堆：对象（如数组、函数），空间较大</p>
<h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量是可变化的量，由变量名和变量值组成</p>
<p>每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据</p>
<h3 id="数据、内存、变量之间的关系"><a href="#数据、内存、变量之间的关系" class="headerlink" title="数据、内存、变量之间的关系"></a>数据、内存、变量之间的关系</h3><p>内存是一个容器，用来存储程序运行需要操作的数据的临时空间</p>
<p>变量（变量名、变量值）是内存的标识，通过变量找到对应内存，进而操作（读/写）内存中的数据</p>
<h3 id="var-a-xxx，-a-内存中保存的是什么？"><a href="#var-a-xxx，-a-内存中保存的是什么？" class="headerlink" title="var a = xxx， a 内存中保存的是什么？"></a>var a = xxx， a 内存中保存的是什么？</h3><p>（1）xxx 是基本数据类型，a 保存的是这个数据 </p>
<p>（2）xxx 是对象，保存的是对象的地址值</p>
<p>（3）xxx 是一个变量，保存的是 xxx 的内存内容（可能是基本数据类型，也可能是地址值）</p>
<pre><code>var b = &#39;abc&#39;
var a = b   //a 保存的是 &#39;abc&#39;
b = &#123;&#125;
a = b    //a 保存的是 b 中的内存内容，只是 b 的内存内容存的对象地址值</code></pre>
<h3 id="引用变量赋值"><a href="#引用变量赋值" class="headerlink" title="引用变量赋值"></a>引用变量赋值</h3><p>n 个引用变量指向同一个对象，通过一个变量修改对象内部数据，其他所有变量看到的是修改之后的数据</p>
<p>n 个引用变量指向一个对象，让其中一个引用变量指向另一个对象，其他所有引用变量依然指向前一个对象</p>
<pre><code>var a = &#123;age:10&#125;
var b = a
b.age = 12  //此时 a.age 也变为 12
function fn(obj)&#123;
    obj.age = &#39;15&#39;
&#125;
fn(a)  //此时 a.age 和 b.age 都变为 15

var c = &#123;age:12&#125;
var d = c
c = &#123;name:&#39;BOB&#39;,age:13&#125;  //c 相当于重新开辟了新的空间创建了个新的对象，此时 c 和 d 指向两个对象，d.age 还是 12

var e = &#123;age:12&#125;
function fun(obj)&#123;
    obj = &#123;age:15&#125;  //相当于创建一个新对象，obj 存的地址改变
&#125;
fun(e)  // 此时 e.age 还是12，函数中的 obj 会变成垃圾被回收</code></pre>
<h3 id="在-JS-调用函数时传递变量参数时，是值传递还是引用传递"><a href="#在-JS-调用函数时传递变量参数时，是值传递还是引用传递" class="headerlink" title="在 JS 调用函数时传递变量参数时，是值传递还是引用传递"></a>在 JS 调用函数时传递变量参数时，是值传递还是引用传递</h3><p>理解1：都是值（包括基本值或地址值）传递</p>
<p>理解2：可能是值传递，也可能是引用传递（即传地址值，注意不是地址，而是表示地址的值）</p>
<pre><code>var a = 3
function fn(a)&#123;
    a = a + 1
&#125;
console.log(a)   // a 还是 3
function fn2(obj)&#123;
    console.log(obj.name)
&#125;
var obj = &#123;name:&#39;tom&#39;&#125;
fn2(obj)</code></pre>
<h3 id="JS-引擎如何管理内存"><a href="#JS-引擎如何管理内存" class="headerlink" title="JS 引擎如何管理内存"></a>JS 引擎如何管理内存</h3><p>（1）内存生命周期</p>
<p>— 分配小内存空间，等到它的使用权</p>
<p>— 存储数据，可以对它反复进行操作</p>
<p>— 释放小内存空间，清空内存中数据，内存可再被分配复用</p>
<p>（2）释放内存</p>
<p>局部变量（为执行函数分配的栈空间内存）：函数执行完自动释放</p>
<p>对象（存储对象的堆空间内存）：先成为垃圾对象（即先把指向对象的变量设为 null，即内存没有引用指向时） —&gt; 由垃圾回收器回收</p>
<p>全局变量在运行时不会释放</p>
<pre><code>var a = 3
var obj = &#123;&#125;  //此时共占用 3 个小内存，分别被 a、obj、obj 所指向对象占用
obj = null   //此时 obj 指向的对象成为垃圾对象，而 obj 变量所占内存没有释放</code></pre>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>多个数据的封装体（集合体），用来保存多个数据的容器</p>
<p>一个对象代表现实中的一个事物</p>
<p>对象类型的数据有 Object、Function（可执行）、Array（内部数据有序）</p>
<h3 id="为什么要用对象"><a href="#为什么要用对象" class="headerlink" title="为什么要用对象"></a>为什么要用对象</h3><p>统一管理多个数据</p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><p>对象由属性和方法组成</p>
<p>属性：由属性名（字符串）和属性值（任意类型）组成</p>
<p>方法：是一种特别的属性，属性值是函数的属性</p>
<h3 id="如何访问对象内部数据"><a href="#如何访问对象内部数据" class="headerlink" title="如何访问对象内部数据"></a>如何访问对象内部数据</h3><p><code>.属性名</code>：编码简单，有时不能用</p>
<p><code>[&#39;属性名&#39;]</code>：编码复杂，能通用</p>
<h3 id="什么时候必须使用-‘属性名’-的方式获取属性"><a href="#什么时候必须使用-‘属性名’-的方式获取属性" class="headerlink" title="什么时候必须使用[‘属性名’]的方式获取属性"></a>什么时候必须使用[‘属性名’]的方式获取属性</h3><p>— 属性名包含特殊字符：- 空格</p>
<p>— 使用变量表示属性名</p>
<h2 id="4、函数"><a href="#4、函数" class="headerlink" title="4、函数"></a>4、函数</h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h3><p>实现特定功能的 n 条语句的封装体</p>
<p>只有函数是可执行的，其他类型的数据不能执行</p>
<p>函数也是对象</p>
<h3 id="为什么要用函数"><a href="#为什么要用函数" class="headerlink" title="为什么要用函数"></a>为什么要用函数</h3><p>提高代码复用</p>
<p>便于阅读交流</p>
<h3 id="如何定义函数"><a href="#如何定义函数" class="headerlink" title="如何定义函数"></a>如何定义函数</h3><p>— 函数声明 <code>function fn()&#123;&#125;</code></p>
<p>— 表达式 <code>var fn = function()&#123;&#125;</code></p>
<h3 id="如何调用（执行）函数"><a href="#如何调用（执行）函数" class="headerlink" title="如何调用（执行）函数"></a>如何调用（执行）函数</h3><p><code>test()</code> 直接调用</p>
<p><code>对象.方法名()</code> 通过对象调用</p>
<p><code>new 函数名()</code> new 调用</p>
<p><code>函数对象.call(对象实例)</code> 或 <code>函数对象.apply(对象实例)</code> 让一个函数成为指定任意对象的方法进行调用</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="什么函数才是回调函数"><a href="#什么函数才是回调函数" class="headerlink" title="什么函数才是回调函数"></a>什么函数才是回调函数</h4><p>1）定义的 2）没有显式调用 3）但最终它在某个时刻或某个条件下执行了</p>
<h4 id="常见的回调函数"><a href="#常见的回调函数" class="headerlink" title="常见的回调函数"></a>常见的回调函数</h4><p>— dom 事件回调函数（如 点击 onclick、获取焦点等），this 是发生事件的 dom 元素</p>
<p>— 定时器（如setTimeout）回调函数，this 是 window</p>
<p>— ajax 请求回调函数</p>
<p>— 生命周期回调函数</p>
<h3 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式 IIFE"></a>立即执行函数表达式 IIFE</h3><p>IIFE 全称是 Immediately-Invoked Function Expression，可理解为匿名函数自调用</p>
<p>作用：隐藏内部实现，不会污染外部（全局）命名空间，可用它来编码 js 模块</p>
<pre><code>;(function()&#123;  //匿名函数自调用，前面的分号是为了防止上一行后没有分号把下面都连一块，所以使用分号分隔开
    var a = 1;
    function test()&#123;
        console.log(++a)
    &#125;
    window.$ = function()&#123;  //向外暴露一个全局函数
        return&#123;
            test:test
        &#125;
    &#125;
&#125;)()
$().test()  //输出 2</code></pre>
<h3 id="函数中的-this"><a href="#函数中的-this" class="headerlink" title="函数中的 this"></a>函数中的 this</h3><h4 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h4><p>任何函数本质上都是通过某个对象调用的，若没有直接指定就是window</p>
<p>所有函数内部都有一个变量 this</p>
<p>this 的值是调用函数的当前对象</p>
<h4 id="如何确定-this-的值"><a href="#如何确定-this-的值" class="headerlink" title="如何确定 this 的值"></a>如何确定 this 的值</h4><p>函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是 window</p>
<p>对象实例.函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是对象实例</p>
<p>new 函数名()&nbsp;&nbsp;&nbsp;&nbsp;this 是新创建的对象</p>
<p>函数对象.call(对象实例)&nbsp;&nbsp;&nbsp;&nbsp;this 是参数中的对象实例</p>
<pre><code>function Person(color)&#123;
    console.log(this)
    this.color = color
    this.getColor = function()&#123;
        console.log(this)
    &#125;
&#125;
Person(&#39;red&#39;)              //this 是 window
var p = new Person(&#39;red&#39;)  //this 是 p
p.getColor()               //this 是 p
var obj = &#123;&#125;
p.getColor.call(obj)       //this 是 obj
var test = p.getColor
test()                     //this 是 window
function fun1()&#123;
    function fun2()&#123;
        console.log(this)
    &#125;
    fun2()                 //this 是 window
&#125;
fun1()                     //this 是 window</code></pre>
<h2 id="5、JS-语句中的分号"><a href="#5、JS-语句中的分号" class="headerlink" title="5、JS 语句中的分号"></a>5、JS 语句中的分号</h2><p>是否加分号是编码风格的问题，看个人喜好（如 vue.js 框架源码中没用分号）</p>
<p>必须加分号的情况：</p>
<p>— 小括号开头的前一条语句</p>
<p>— 中括号开头的前一条语句</p>
<p>上面的情况以防万一可以在行首加分号</p>
<pre><code>;(function()&#123;&#125;)()
;[1,3].forEach(function()&#123;&#125;)</code></pre>
<h1 id="二、函数高级"><a href="#二、函数高级" class="headerlink" title="二、函数高级"></a>二、函数高级</h1><h2 id="1、原型与原型链"><a href="#1、原型与原型链" class="headerlink" title="1、原型与原型链"></a>1、原型与原型链</h2><h3 id="函数的-prototype-属性"><a href="#函数的-prototype-属性" class="headerlink" title="函数的 prototype 属性"></a>函数的 prototype 属性</h3><p>每个函数都有一个 prototype 属性（在函数定义时创建函数对象，并添加 prototype 属性 <code>this.prototype = &#123;&#125;</code>）它默认指向一个 Object 空对象（没有我们指定的属性），prototype 指向的对象即称为原型对象</p>
<p>原型对象（即 prototype 所指向的）中有一个属性 constructor，它指向函数对象</p>
<pre><code>Date.prototype.constructor === Date  //true
function Fun()&#123;&#125;
Fun.prototype.constructor === Fun   //true
Fun.prototype.test = function()&#123;&#125;
var fun = new Fun()
fun.test()</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="原型对象"></p>
<p>如上图构造函数（左边）和原型对象（右边）相互引用</p>
<h3 id="给原型对象添加属性（一般都是方法）"><a href="#给原型对象添加属性（一般都是方法）" class="headerlink" title="给原型对象添加属性（一般都是方法）"></a>给原型对象添加属性（一般都是方法）</h3><p>作用：函数的所有对象实例自动拥有原型中的属性（方法）</p>
<h3 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h3><p>每个函数都有一个 prototype，即显式原型属性，在定义函数时自动添加的 <code>this.prototype = &#123;&#125;</code>，默认指向一个空的 Object 实例对象（但是 Object 不满足）</p>
<p>每个实例对象都有一个 <code>__proto__</code>，称为隐式原型属性，创建对象时自动添加的 <code>this.__proto__ = 构造函数.prototype</code>，默认为构造函数的 ptototype 属性值</p>
<p>对象的隐式原型的值为其对应的构造函数的显式原型的值</p>
<p>程序员能直接操作显式原型，但不能直接操作隐式原型（ES6 之前）</p>
<pre><code>function Fn()&#123;&#125;    //定义构造函数，内部语句：this.prototype = &#123;&#125;，this 指函数对象
Fn.prototype       //显式原型属性

var fn = new Fn()  //内部语句：this.__proto__ = Fn.prototype，this 指 fn
fn.__proto__       //隐式原型属性
Fn.prototype === fn.__proto__  //true

Fn.prototype.test = function()&#123;&#125;
fn.test()</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%98%BE%E5%BC%8F%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B.png" alt="显式隐式原型"></p>
<p>（prototype 是给构造函数使用（读/写），<code>__proto__</code> 是给对象实例使用（读））</p>
<p><strong>记住：实例对象的隐式原型 <code>__proto__</code> = 构造函数的显式原型 <code>prototype</code></strong></p>
<h3 id="原型链（别名隐式原型链）"><a href="#原型链（别名隐式原型链）" class="headerlink" title="原型链（别名隐式原型链）"></a>原型链（别名隐式原型链）</h3><p>访问一个对象属性时，先在自身属性中查找，找到返回；若没有，再沿着 <code>__proto__</code> 这条链向上查找，找到返回；若最终没有找到，返回 undefined</p>
<p>作用：查找对象的属性（方法）</p>
<pre><code>function Fn = function()&#123;
    this.test1 = function()&#123;&#125;
&#125;
Fn.prototype.test2 = function()&#123;&#125;
var fn = new Fn()
fn.test1()
fn.test2()
fn.toString()
fn.test3()  //报错函数 not define</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<h3 id="构造函数、原型、实例对象的关系"><a href="#构造函数、原型、实例对象的关系" class="headerlink" title="构造函数、原型、实例对象的关系"></a>构造函数、原型、实例对象的关系</h3><p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB1.png" alt="构造函数-原型-实例关系1"></p>
<p>所有函数都是 Function 的实例（包含 Function）</p>
<p>所有函数的 <code>__proto__</code> 都是一样的，因为构造函数都是 Function()</p>
<p>function Foo(){} 等价于 var Foo = new Function()</p>
<p>注意 Function = new Function()</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB2.png" alt="构造函数-原型-实例关系2"></p>
<p>上图中 Foo 是 Function 的实例对象，Object 是 Function 的实例对象，Function 的实例对象和构造函数都是它自己，Function 的原型是 Object 的实例对象</p>
<pre><code>Foo.prototype instanceof Object   //true
Object.prototype instanceof Object  //false
Function.prototype instanceof Object  //true</code></pre>
<h3 id="原型链补充"><a href="#原型链补充" class="headerlink" title="原型链补充"></a>原型链补充</h3><p>（1）函数的显式原型指向的对象默认是空 Object 实例对象（但 Object 不满足）</p>
<pre><code>Foo.prototype instanceof Object   //true
Object.prototype instanceof Object  //false
Function.prototype instanceof Object  //true</code></pre>
<p>（2）所有函数都是 Function 的实例（包含 Function）</p>
<pre><code>Function.__proto__ === Function.prototype</code></pre>
<p>（3）Object 的原型对象是原型链的尽头</p>
<pre><code>Object.prototype.__proto__  //是 null</code></pre>
<h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h3><p>读取对象属性值时，会自动到原型链中查找</p>
<p>设置对象的属性值时，不会查找原型链，若当前对象中没有该属性，则直接添加该属性</p>
<p>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.prototype.setName = function(name)&#123;
    this.name = name
&#125;
var p1 = new Person(&#39;aa&#39;,12)
p1.setName(&#39;bb&#39;)  //此时 p1 实例中有两个属性 name（为 bb） 和 age
var p2 = new Person(&#39;cc&#39;,12)
p2.setName(&#39;dd&#39;)  //此时 p2 实例中有两个属性 name（为 dd） 和 age

p1.__proto__ === p2.__proto__   //true</code></pre>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>A实例对象 instanceof B构造函数</code> 若 B 函数的显式原型对象在 A 对象的（隐式）原型链上，返回 true，否则返回 false</p>
<p>Function 是通过 new 自己产生的实例</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof.png" alt="instanceof"></p>
<pre><code>Object instanceof Function  //true
Object instanceof Object  //true
Function instanceof Function  //true
Function instanceof Object  //true
function Foo()&#123;&#125;
Object instanceof Foo  //false</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof1.png" alt="instanceof1"></p>
<h3 id="相关例子"><a href="#相关例子" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>function A()&#123;&#125;
A.prototype.n = 1
var b = new A()
A.prototype = &#123;n:2,m:3&#125;
var c = new A()
console.log(b.n, b.m, c.n, c.m)  //1 undefined 2 3</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E4%BE%8B%E5%AD%901.png" alt="例子1"></p>
<pre><code>function Foo()&#123;&#125;
Object.prototype.a = function()&#123;&#125;
Function.prototype.b = function()&#123;&#125;
var f1 = new Foo()
f1.a()  //不报错
f1.b()  //报错
Foo.a()   //不报错
Foo.b()   //不报错</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/instanceof1.png" alt="instanceof1"></p>
<h2 id="2、执行上下文与执行上下文栈"><a href="#2、执行上下文与执行上下文栈" class="headerlink" title="2、执行上下文与执行上下文栈"></a>2、执行上下文与执行上下文栈</h2><h3 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h3><p>变量声明提升：通过 var 定义的变量，在定义语句之前就可以访问到，只是值为 undefined</p>
<p>函数声明提升：<strong>通过 function 声明的函数</strong>，在声明语句之前就可以直接调用，值为函数对象</p>
<pre><code>console.log(a)  //输出 undefined，变量提升
fn1()   //可调用，函数提升
fn2()   //不能调用，变量提升
var a = 3
function fn1()&#123;&#125;
var fn2 = function()&#123;&#125;</code></pre>
<p>变量提升和函数提升的产生过程：</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>代码根据其位置可分为全局代码和函数（局部）代码</p>
<p>执行上下文的个数 = 调用的函数数量 + 1（指 window）</p>
<h4 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h4><p>（1）在全局代码前将 window 确定为全局执行上下文</p>
<p>（2）对全局数据进行预处理</p>
<p>&nbsp;&nbsp;&nbsp;— var 定义的全局变量=undefined，并添加为 window 的属性</p>
<p>&nbsp;&nbsp;&nbsp;— function 声明的全局函数创建好函数对象，并添加为 window 的方法</p>
<p>&nbsp;&nbsp;&nbsp;— this 赋值为 window</p>
<p>（3）开始执行全局代码</p>
<h4 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h4><p>只有在调用函数的时候才会生成执行上下文</p>
<p>（1）在调用函数，准备执行函数体前，创建对应的函数执行上下文对象（封闭的虚拟对象，是栈内存中的一片区域，里面存放局部变量、形参、arguments等）</p>
<p>（2）对局部数据进行预处理</p>
<p>&nbsp;&nbsp;&nbsp;— 形参=实参，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— arguments=实参列表，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— var 定义的局部变量=undefined，并添加为执行上下文的属性</p>
<p>&nbsp;&nbsp;&nbsp;— function 声明的函数创建好函数对象，并添加为执行上下文的方法</p>
<p>&nbsp;&nbsp;&nbsp;— this 赋值为调用函数的对象</p>
<p>（3）开始执行函数体代码</p>
<pre><code>function fn(a1)&#123;
    console.log(a1)  //2
    console.log(a2)  //undefined
    a3()             //a3()执行
    console.log(this)  //this 指 window
    console.log(arguments)  //伪数组[2,3]
    var a2 = 3
    function a3()&#123;
        console.log(&#39;a3()执行&#39;)
    &#125;
&#125;
fn(2,3)</code></pre>
<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>（1）在全局代码执行前，JS 引擎会创建一个栈来存储管理所有的执行上下文对象</p>
<p>（2）在全局执行上下文（window）确定后，将其添加到栈中（压栈）</p>
<p>（3）在函数执行上下文创建后，将其添加到栈中（压栈）</p>
<p>（4）在当前函数执行完成后，将栈顶的对象移除（出栈）</p>
<p>（5）当所有的代码执行完后，栈中只剩下 window</p>
<pre><code>                    //1.进入全局执行上下文
var a = 10
var bar = function(x)&#123;
    var b = 5
    foo(x+b)          //3.进入 foo 执行上下文
&#125;
var foo = function(y)&#123;
    var c = 5
    console.log(a+c+y)
&#125;
bar(10)               //2.进入 bar 函数执行上下文</code></pre>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88.png" alt="执行上下文栈"></p>
<p>栈底一定是 window，当前运行的总是栈顶的上下文对象</p>
<h3 id="相关例子-1"><a href="#相关例子-1" class="headerlink" title="相关例子"></a>相关例子</h3><p>1</p>
<pre><code>var a = 3
function fn()&#123;
    console.log(a)
    var a = 4  //a 在 console.log 前声明 a，在此行才赋值
&#125;
fn()  //输出 undefined，因为在 fn 函数中</code></pre>
<p>2</p>
<pre><code>console.log(&#39;gb:&#39;+i)
var i = 1
foo(1)
function foo(i)&#123;
    if(i === 4)&#123;return&#125;
    console.log(&#39;fb:&#39;+i)
    foo(i+1)
    console.log(&#39;fe:&#39;+i)
&#125;
console.log(&#39;ge:&#39;+i)</code></pre>
<p>代码依次输出 gb:undefined、fb:1、fb:2、fb:3、fe:3、fe:2、fe:1、ge:1，整个过程中产生了 5 个执行上下文</p>
<p>3</p>
<pre><code>function a()&#123;&#125;
var a
console.log(typeof a)  //输出 &#39;function&#39;</code></pre>
<p>先执行变量提升，再执行函数提升</p>
<p>4</p>
<pre><code>if(!(b in window))&#123;  //此处判断为 !true 即 false
    var b = 1
&#125;
console.log(b)   //输出 undefined</code></pre>
<p>5</p>
<pre><code>var c = 1
function c(c)&#123;
    console.log(c)
    var c =3
&#125;
c(2)   //此处会报错</code></pre>
<p>上述代码会报错，因为上述代码相当于</p>
<pre><code>var c
function c(c)&#123;
    console.log(c)
    var c =3
&#125;
c = 1
c(2)   //此处会报错</code></pre>
<h2 id="3、作用域与作用域链"><a href="#3、作用域与作用域链" class="headerlink" title="3、作用域与作用域链"></a>3、作用域与作用域链</h2><p>作用域是一个代码所在的区域，它是静态的（执行上下文对象是在执行调用的时候才产生是动态的），在编写代码时就确定了</p>
<p>作用域分为全局作用域、函数作用域</p>
<p>没有块作用域（即在大括号内声明的变量在外面也可见，但 ES6 有，Java 中也有）</p>
<pre><code>if(true)&#123;var c =3;&#125;  //大括号内的 c 在外面也可见，没有块作用域
console.log(c)</code></pre>
<p>作用域的作用：隔离变量，不同作用域下同名变量不会冲突</p>
<p>作用域的个数 = 定义的函数数量 + 1（指全局）</p>
<h3 id="作用域与执行上下文的区别"><a href="#作用域与执行上下文的区别" class="headerlink" title="作用域与执行上下文的区别"></a>作用域与执行上下文的区别</h3><p>（1）全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</p>
<p>全局执行上下文环境是在全局作用域确定之后，js 代码马上执行之前创建</p>
<p>函数执行上下文是在调用函数时，函数体代码执行之前创建</p>
<p>（2）作用域是静态的，只要函数定义好就一直存在，且不会再变化</p>
<p>执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放</p>
<h3 id="作用域与执行上下文的联系"><a href="#作用域与执行上下文的联系" class="headerlink" title="作用域与执行上下文的联系"></a>作用域与执行上下文的联系</h3><p>执行上下文环境（对象）是从属于所在的作用域</p>
<p>全局上下文环境 ==&gt; 全局作用域</p>
<p>函数上下文环境 ==&gt; 对应的函数作用域</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链是多个上下级关系的作用域形成的链，它的方向是从下向上的（从内到外），即嵌套的作用域产生的由内向外的链</p>
<p>作用域链作用：查找变量时就是沿着作用域链来查找的</p>
<p>查找一个变量的查找规则：</p>
<p>— 1.在当前作用域的执行上下文中查找对应的属性，若有直接返回，否则进入 2</p>
<p>— 2.在上一级作用域的执行上下文中查找对应的属性，若有直接返回，否则进入 3</p>
<p>— 3.再次执行 2 的相同操作，直到全局作用域，若还找不到就抛出找不到的异常</p>
<h3 id="相关例子-2"><a href="#相关例子-2" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>var x = 10
function fn()&#123;
    console.log(x)
&#125;
function show(f)&#123;
    var x = 20
    f()
&#125;
show(fn)  //会输出 10</code></pre>
<p>上述代码会输出 10</p>
<pre><code>var fn = function()&#123;
    console.log(fn)
&#125;
fn()  //会输出 fn 函数</code></pre>
<p>上述代码会输出 fn 函数</p>
<pre><code>var obj = &#123;
    fn2: function()&#123;
        console.log(fn2)
    &#125;
&#125;</code></pre>
<p>上述代码会报错 fn2 is not defined，因为在当前作用域先找 fn2 没有，再去外部全局作用域找也没有</p>
<pre><code>var obj = &#123;
    fn2: function()&#123;
        console.log(this.fn2)
    &#125;
&#125;</code></pre>
<p>上述代码不会报错，会输出 obj 对象中的 fn2 方法</p>
<h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2><p>例子：分别点击三个按钮弹出相应的数字</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    var btn = btns[i]
    btn.onclick = function()&#123;
        alert(&#39;第&#39;+(i+1)+&#39;个&#39;)
    &#125;
&#125;</code></pre>
<p>上述代码在点击所有按钮时都是弹出 ‘第4个’</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    var btn = btns[i]
    btn.index = i  //将 btn 所对应的下标保存在 btn 上
    btn.onclick = function()&#123;
        alert(&#39;第&#39;+(this.index+1)+&#39;个&#39;)
    &#125;
&#125;</code></pre>
<p>上述代码可正常实现功能</p>
<pre><code>var btns = document.getElementsByTagName(&#39;button&#39;)
for(var i = 0,length = btns.length; i &lt; length; i++)&#123;
    (function(i)&#123;
        var btn = btns[i]
        btn.onclick = function()&#123;
            alert(&#39;第&#39;+(i+1)+&#39;个&#39;)
        &#125;
    &#125;)(i)
&#125;</code></pre>
<p>上述代码利用闭包实现功能</p>
<h3 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h3><p>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（包括函数）时，就产生了闭包，如</p>
<pre><code>function fn1()&#123;
    var a = 2
    var b = &#39;abc&#39;
    function fn2()&#123;  //闭包
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()</code></pre>
<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>理解1：闭包是嵌套的内部函数</p>
<p>理解2：包含被引用变量（函数）的对象</p>
<p>注意：闭包存在于嵌套的内部函数中</p>
<h3 id="产生闭包的条件"><a href="#产生闭包的条件" class="headerlink" title="产生闭包的条件"></a>产生闭包的条件</h3><p>（1）函数嵌套</p>
<p>（2）内部函数引用了外部函数的数据（变量/函数），并执行内部函数定义就会产生闭包（不用调用内部函数，但必须调用外部函数）</p>
<p>外部函数执行几次（内部函数就创建几次）就产生几个闭包，和内部函数执行几次没有关系</p>
<pre><code>function fn1()&#123;
    var a = 2   //在此处打断点就已产生闭包，因为变量提升和函数提升，已执行 fn2 函数定义
    var b = &#39;abc&#39;
    function fn2()&#123;  //闭包
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()

function fn1()&#123;
    var a = 2   //在此处打断点就还未产生闭包，因为变量提升但 fn2 变量还未赋值为函数，所以函数定义未执行
    var b = &#39;abc&#39;
    var fn2 = function()&#123;  //闭包，闭包中有 a 没有 b
        console.log(a)
    &#125;
    fn2()
&#125;
fn1()</code></pre>
<h3 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h3><p>（1）将函数作为另一个函数的返回值</p>
<pre><code>function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;  //闭包
        a++
        console.log(a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4</code></pre>
<p>上述代码只产生一次闭包，并且在调用 f() 时闭包没有消失 </p>
<p>（2）将函数作为实参传递给另一个函数调用</p>
<pre><code>function showDelay(msg,time)&#123;
    setTimeout(function()&#123;  //此处产生闭包，因为内部函数使用了外部函数的 msg，产生闭包的原因和 setTimeout 以及 time 变量无关
        alert(msg)
    &#125;,time)
&#125;
showDelay(&#39;xxx&#39;,2000)</code></pre>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>（1）使用函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）</p>
<p>（2）让函数外部可以操作（读写）到函数内部的数据（变量/函数）</p>
<pre><code>function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;
        a++
        console.log(a)
    &#125;
    var fn3 = function()&#123;
        a--
        console.log(a)
    &#125;
    return fn3
&#125;
fn1()  //此时 fn1 内部的对象 fn2、fn3 都成为垃圾对象，局部变量也不存在了
var f = fn1()  //fn1 执行完后 fn2 就不存在了，闭包中只有 a，fn3 本身也不存在，但 fn3 不成为垃圾对象，因为 f 指向了 fn3
f()  //输出 1
f()  //输出 0</code></pre>
<p>总结：函数执行完后，函数内部声明的局部变量一般不存在，只有存在于闭包中的变量才可能存在（前提是闭包中的函数对象没有成为垃圾对象，被引用的局部变量才存在）</p>
<p>在函数外部不能直接访问函数内部的局部变量，但可以通过闭包让外部操作它</p>
<h3 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h3><p>产生：在嵌套内部<strong>函数定义执行完</strong>时就产生了（不是在调用时）</p>
<p>死亡：在嵌套的内部函数成为垃圾对象时</p>
<pre><code>function fn1()&#123;
    //此时闭包就已经产生了（因为函数提升，内部函数对象已经创建了）
    var a = 2
    function fn2()&#123;  //闭包
        a++
        console.log(a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4
f = null  //此时闭包死亡（因为包含闭包的函数对象 fn2 成为垃圾对象）

function fn1()&#123;
    var a = 2
    var fn2 = function()&#123;
        a++
        console.log(a)
    &#125;  //此时闭包才产生，因为此时才执行完函数定义
    return fn2
&#125;
var f = fn1()
f()  //输出 3
f()  //输出 4
f = null   //此时闭包死亡（因为包含闭包的函数对象 fn2 成为垃圾对象）</code></pre>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>闭包可用于定义 JS 模块：</p>
<p>— 具有特定功能的 js 文件</p>
<p>— 将所有的数据和功能都封装在一个函数内部（私有的）</p>
<p>— 只向外暴露一个包含 n 个方法的对象或函数</p>
<p>— 模块的使用者只需通过模块暴露的对象调用方法来实现对应的功能</p>
<p>定义和使用模块的方式一：</p>
<pre><code>定义一个模块 myModule.js
function myModule()&#123;
    //私有数据
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    return &#123;
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var module = myModule()
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<p>定义和使用模块的方式二（这种方式更方便）：</p>
<pre><code>定义一个模块 myModule.js
(function()&#123;
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    window.module = &#123;  //通过 window 向外暴露
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;)()

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<p>定义和使用模块的方式三（这种方式有利于代码压缩，即把变量名自动转为单个字母表示）：</p>
<pre><code>定义一个模块 myModule.js
(function(w)&#123;
    var msg = &#39;xxx&#39;
    //操作数据的函数
    function fn1()&#123;  //闭包
        console.log(msg.toUpperCase())
    &#125;
    function fn2()&#123;  //闭包
        console.log(msg.toLowerCase())
    &#125;
    //向外暴露对象（给外部使用的方法）
    w.module = &#123;  //通过 window 向外暴露
        fn1:fn1,
        fn2:fn2
    &#125;
&#125;)(window)

在另一个文件中
&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    module.fn1()
    module.fn2()
&lt;/script&gt;</code></pre>
<h3 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h3><p>闭包缺点：</p>
<p>（1）函数执行完后，函数内的局部变量没有释放，占用内存事件会变长</p>
<p>（2）容易造成内存泄露</p>
<p>解决：</p>
<p>（1）能不用闭包就不用</p>
<p>（2）及时释放，将指向内部函数的变量设为 null，让内部函数成为垃圾对象，进而回收闭包</p>
<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><p>（1）内存溢出：一种程序运行出现的错误，错误原因是当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误</p>
<p>（2）内存泄露：占用的内存没有及时释放（但程序不出错），内存泄露积累多了就容易导致内存溢出</p>
<p>常见的内存泄露：</p>
<p>— 意外的全局变量</p>
<p>— 没有及时清理的计时器或回调函数</p>
<p>— 闭包</p>
<pre><code>function fn()&#123;
    a = 3  //意外的全局变量
&#125;
fn()

setInterval(function()&#123;  //启动循环定时器后不清理
    console.log(&#39;xxx)
&#125;,1000)

function fn1()&#123;
    var a =4
    function fn2()&#123;
        console.log(++a)
    &#125;
    return fn2
&#125;
var f = fn1()
f()</code></pre>
<h3 id="相关例子-3"><a href="#相关例子-3" class="headerlink" title="相关例子"></a>相关例子</h3><pre><code>var name = &quot;The window&quot;
var obj = &#123;
    name:&#39;My object&#39;
    fn:function()&#123;
        return function()&#123;
            return this.name;
        &#125;
    &#125;
&#125;
alert(obj.fn()())</code></pre>
<p>输出 The window，因为相当于直接调用 fn 里的匿名函数，上面代码中没有闭包，有函数嵌套，但内部函数没有引用外部函数变量</p>
<pre><code>var name = &quot;The window&quot;
var obj = &#123;
    name:&#39;My object&#39;
    fn:function()&#123;
        var that = this
        return function()&#123;
            return that.name;
        &#125;
    &#125;
&#125;
alert(obj.fn()())</code></pre>
<p>输出 My object，直接调用 fn 里的匿名函数，但是输出的是 that 对象的 name，上面代码中有闭包，有函数嵌套，且内部函数引用外部函数变量 that</p>
<pre><code>function fun(n,o)&#123;
    console.log(o)
    return&#123;
        fun:function(m)&#123; //闭包，因为 n 引用了外部函数 fun 中的 n
            return fun(m,n)  //这里的 fun 函数是只最外面第一行的 fun 函数
        &#125;
    &#125;
&#125;
var a = fun(0);  //undefined，因为没有给形参 o 赋值，此时闭包里的 n 是 0 
a.fun(1);    //0，函数执行产生了新的闭包，但马上消失，因为没有变量来接收 a.fun(1) 返回值
a.fun(2);    //0
a.fun(3);    //0
var b = fun(0).fun(1).fun(2).fun(3);  //undefined,0，1，2
var c = fun(0).fun(1);  //undefined,0
c.fun(2);  //1
c.fun(3);  //1</code></pre>
<h1 id="三、面向对象高级"><a href="#三、面向对象高级" class="headerlink" title="三、面向对象高级"></a>三、面向对象高级</h1><h2 id="1、对象创建模式"><a href="#1、对象创建模式" class="headerlink" title="1、对象创建模式"></a>1、对象创建模式</h2><h3 id="方式一：构造函数"><a href="#方式一：构造函数" class="headerlink" title="方式一：构造函数"></a>方式一：构造函数</h3><p>Object 构造函数（new Object()）模式：先创建空 Object 对象，再动态添加属性/方法</p>
<p>适用场景：起始时不确定对象内部数据</p>
<p>问题：语句太多</p>
<h3 id="方式二：对象字面量模式"><a href="#方式二：对象字面量模式" class="headerlink" title="方式二：对象字面量模式"></a>方式二：对象字面量模式</h3><p>使用 {} 创建对象，同时指定属性/方法</p>
<p>适用场景：起始时对象内部数据是确定的</p>
<p>问题：如果创建多个对象有，重复代码</p>
<h3 id="方式三：工厂模式（较不常用）"><a href="#方式三：工厂模式（较不常用）" class="headerlink" title="方式三：工厂模式（较不常用）"></a>方式三：工厂模式（较不常用）</h3><p>通过工厂函数（返回一个对象的函数都可以称为工厂函数）动态创建对象并返回</p>
<p>适用场景：需要创建多个对象</p>
<p>问题：对象没有一个具体的类型，都是 Object 类型</p>
<pre><code>function createPerson(name,age)&#123;
    var obj = &#123;
        name:name,
        age:age,
        setName:function(name)&#123;
            this.name = name
        &#125;
    &#125;
    return obj
&#125;</code></pre>
<h3 id="方式四：自定义构造函数模式"><a href="#方式四：自定义构造函数模式" class="headerlink" title="方式四：自定义构造函数模式"></a>方式四：自定义构造函数模式</h3><p>自定义构造函数，通过 new 创建对象</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<p>问题：每个对象都有相同的数据，浪费内存</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
    this.setName = function(name)&#123;
        this.name = name
    &#125;
&#125;</code></pre>
<h3 id="方式五：构造函数-原型的组合模式"><a href="#方式五：构造函数-原型的组合模式" class="headerlink" title="方式五：构造函数+原型的组合模式"></a>方式五：构造函数+原型的组合模式</h3><p>自定义构造函数，通过在函数中初始化，方法添加到原型上</p>
<p>适用场景：需要创建多个类型确定的对象</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.prototype.setName = function(name)&#123;
    this.name = name
&#125;</code></pre>
<h2 id="2、继承模式"><a href="#2、继承模式" class="headerlink" title="2、继承模式"></a>2、继承模式</h2><h3 id="方式一：原型链继承（得到方法）"><a href="#方式一：原型链继承（得到方法）" class="headerlink" title="方式一：原型链继承（得到方法）"></a>方式一：原型链继承（得到方法）</h3><p>步骤</p>
<p>— 定义父类型构造函数</p>
<p>— 给父类型的原型添加方法</p>
<p>— 定义子类型构造函数</p>
<p>— 创建父类型的实例对象赋值为子类型的原型</p>
<p>— 将子类型原型的构造属性设置为子类型</p>
<p>— 给子类型原型添加方法</p>
<p>— 创建子类型的对象：可以调用父类型的方法</p>
<pre><code>//父类型
function Supper()&#123;
    this.supprop = &#39;supper&#39;
&#125;
Supper.prototype.showSupperProp = function()&#123;
    console.log(this.supprop)
&#125;
//子类型
function Sub()&#123;
    this.subprop = &#39;sub&#39;
&#125;
//子类型的原型为父类型的一个实例对象
Sub.prototype = new Supper()
//让子类型的原型的 constructor 指向子类型
Sub.prototype.constructor = Sub //若没有这条语句则 constructor 指向 Supper
Sub.prototype.showSubProp = functioin()&#123;
    console.log(this.subprop)
&#125;
var sub = new Sub()
sub.showSupperProp()
sub.showSubProp()</code></pre>
<p>关键：子类型的原型为父类型的一个实例对象</p>
<h3 id="方式二：借用构造函数继承（得到属性）"><a href="#方式二：借用构造函数继承（得到属性）" class="headerlink" title="方式二：借用构造函数继承（得到属性）"></a>方式二：借用构造函数继承（得到属性）</h3><p>步骤：</p>
<p>— 定义父类型构造函数</p>
<p>— 定义子类型构造函数</p>
<p>— 在子类型构造函数中调用父类型的构造</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
function Student(name,age,price)&#123;
    Person.call(this,name,age)  //相当于 this.Person(name,age)
    this.price = price
&#125;
var s = new Student(&#39;xx&#39;,12,10000)</code></pre>
<p>关键：在子类型构造函数中通过 call() 调用父类型构造函数</p>
<h3 id="方式三：组合继承"><a href="#方式三：组合继承" class="headerlink" title="方式三：组合继承"></a>方式三：组合继承</h3><p>原型链 + 借用构造函数的组合继承</p>
<p>步骤：</p>
<p>— 利用原型链实现对父类型对象的方法继承</p>
<p>— 利用 call() 借用父类型构造函数初始化相同属性</p>
<pre><code>function Person(name,age)&#123;
    this.name = name
    this.age = age
&#125;
Person.protorype.setName = function(name)&#123;
    this.name = name
&#125;
function Student(name,age,price)&#123;
    Person.call(this,name,age)  //为了得到属性
    this.price = price
&#125;
Student.prototype = new Person()  //为了能看到父类型原型的方法
Student.protorype.constructor = Student //为了修正 constructor 属性
Student.prototype.setPrice = function(price)&#123;
    this.price = price
&#125;
var s = new Student(&#39;xx&#39;,12,10000)
s.setName(&#39;yyy&#39;)
s.setPrice(12000)
console.log(s.name,s.age,s.price)  //输出 yyy 12 12000</code></pre>
<h1 id="四、线程机制与事件机制"><a href="#四、线程机制与事件机制" class="headerlink" title="四、线程机制与事件机制"></a>四、线程机制与事件机制</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><p>进程（process）：程序的一次执行，占有独有的内存空间，各个应用程序间内存空间相互独立，可通过 Windows 任务管理器查看进程</p>
<p>线程（thread）：线程是进程内一个独立的执行单元，是程序执行的一个完整流程，是 CPU的最小调度单元</p>
<pre><code>进程负责为程序的运行提供必备的环境

（进程相当于工厂中的车间）

线程是计算机中的最小计算单位，线程负责执行进程中的程序

（线程相当于工厂的工人）

JS、浏览器是单线程</code></pre>
<p>程序是单线程还是多线程是看一个进程内有多少线程</p>
<p>应用程序必须运行在某个进程的某个线程上</p>
<p>一个进程中至少有一个运行的线程，主线程，进程启动后自动创建</p>
<p>一个进程中可以同时运行多个线程，会说程序是多线程运行的</p>
<p>一个进程内的数据可以供其中的多个线程直接共享</p>
<p>多个进程之间的数据是不能直接共享的</p>
<p>线程池（thread pool）：保存多个线程对象的容器，实现线程对象的反复利用</p>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><p>多进程运行：一个应用程序可以同时启动多个实例运行</p>
<p>多线程：在一个进程内，同时有多个线程运行</p>
<p>CPU 的核数可对应同时运行的线程数</p>
<h3 id="比较单线程与多线程"><a href="#比较单线程与多线程" class="headerlink" title="比较单线程与多线程"></a>比较单线程与多线程</h3><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>优点：</strong></p>
<p>能有效提升 CPU 利用率</p>
<p><strong>缺点：</strong></p>
<p>（1）创建多线程开销</p>
<p>（2）线程间切换开销</p>
<p>（3）死锁与状态同步问题</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p><strong>优点：</strong>顺序编程简单易懂</p>
<p><strong>缺点：</strong>效率低</p>
<p>js 是单线程运行的，但使用  H5 中的 Web Workers 可以多线程运行</p>
<p>浏览器是多线程运行的</p>
<p>浏览器有单进程和多进程，单进程的有 Firefox、老版 IE，多进程的有 chrome、新版 IE，可通过在浏览器打开多个标签后在任务管理器中查看是单进程还是多进程</p>
<h2 id="2、浏览器内核"><a href="#2、浏览器内核" class="headerlink" title="2、浏览器内核"></a>2、浏览器内核</h2><p>浏览器内核：支撑浏览器运行的最核心的程序</p>
<h3 id="不同浏览器的内核不同"><a href="#不同浏览器的内核不同" class="headerlink" title="不同浏览器的内核不同"></a>不同浏览器的内核不同</h3><p>— Chrome、Safari：webkit</p>
<p>— Firefox：Gecko</p>
<p>— IE：Trident</p>
<p>— 360、搜狗等国内浏览器：Trident + webkit</p>
<h3 id="内核组成模块"><a href="#内核组成模块" class="headerlink" title="内核组成模块"></a>内核组成模块</h3><p><strong>主线程中：</strong></p>
<p>— js 引擎模块（也是程序）：负责 js 程序的编译（运行前动态编译）与运行，因此 js 代码在主线程中运行（使用了 Web Worker 另说）</p>
<p>— html,css 文档解析模块：负责页面文本的解析（读文本-按一定规则拆解）</p>
<p>— DOM/CSS 模块：负责 DOM/CSS 在内存中的相关处理（把标签转换为对象，页面在内存中是个 DOM 对象树）</p>
<p>— 布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</p>
<p>……</p>
<p><strong>分线程中：</strong></p>
<p>— 定时器模块：负责定时器的管理</p>
<p>— DOM 事件响应模块：负责事件的管理</p>
<p>— 网络请求模块：负责 ajax 请求</p>
<h2 id="3、定时器引发的思考"><a href="#3、定时器引发的思考" class="headerlink" title="3、定时器引发的思考"></a>3、定时器引发的思考</h2><h3 id="定时器真的是定时执行的吗？"><a href="#定时器真的是定时执行的吗？" class="headerlink" title="定时器真的是定时执行的吗？"></a>定时器真的是定时执行的吗？</h3><p>定时器并不能保证真正定时执行</p>
<p>一般会延迟一点（可以接受），也可能延迟很长时间（不能接受）</p>
<p>若在主线程执行了一个长时间的操作，可能导致延时才处理</p>
<h3 id="定时器回调函数是在分线程中执行的吗？"><a href="#定时器回调函数是在分线程中执行的吗？" class="headerlink" title="定时器回调函数是在分线程中执行的吗？"></a>定时器回调函数是在分线程中执行的吗？</h3><p>定时器回调函数是在主线程中执行的，js 是单线程的，所有 js 代码都是在主线程中执行（无论是回调函数还是非回调函数）</p>
<h3 id="定时器是如何实现的？"><a href="#定时器是如何实现的？" class="headerlink" title="定时器是如何实现的？"></a>定时器是如何实现的？</h3><p>事件循环模型</p>
<h2 id="4、JS-是单线程执行的"><a href="#4、JS-是单线程执行的" class="headerlink" title="4、JS 是单线程执行的"></a>4、JS 是单线程执行的</h2><p>js 是单线程执行的，回调函数也是在主线程，H5 提出了实现多线程的方案（Web Worker）</p>
<p>只有主线程能更新界面</p>
<h3 id="证明-js-执行是单线程的"><a href="#证明-js-执行是单线程的" class="headerlink" title="证明 js 执行是单线程的"></a>证明 js 执行是单线程的</h3><p>setTimeout() 的回调函数是在主线程执行的，定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</p>
<pre><code>setTimeout(function()&#123;
    console.log(&#39;22&#39;)
&#125;,2000)
setTimeout(function()&#123;
    console.log(&#39;11&#39;)
&#125;,1000)
function fn()&#123;console.log(&#39;fn&#39;)&#125;
fn()
console.log(&#39;alert之前&#39;)
alert(&#39;----&#39;) //暂停当前主线程执行，同时暂停计时，点击确定后恢复程序执行和计时
console.log(&#39;alert之后&#39;)</code></pre>
<h3 id="为什么-js-要用单线程模式，而不用多线程模式"><a href="#为什么-js-要用单线程模式，而不用多线程模式" class="headerlink" title="为什么 js 要用单线程模式，而不用多线程模式"></a>为什么 js 要用单线程模式，而不用多线程模式</h3><p>JavaScript 的单线程与它的用途有关，作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题（如同时对一个对象更新和删除）</p>
<h3 id="代码分类"><a href="#代码分类" class="headerlink" title="代码分类"></a>代码分类</h3><p>代码分类：初始化代码、回调代码</p>
<p>初始化执行代码（同步代码）：包含绑定 DOM 事件监听，设置定时器，发送 ajax 请求的代码</p>
<p>回调执行代码（异步代码）：处理回调逻辑</p>
<h3 id="js-引擎执行代码的基本流程"><a href="#js-引擎执行代码的基本流程" class="headerlink" title="js 引擎执行代码的基本流程"></a>js 引擎执行代码的基本流程</h3><p>（1）先执行初始化代码：包含一般代码和以下一些特别的代码</p>
<p>— 设置定时器</p>
<p>— 绑定监听</p>
<p>— 发生 ajax 请求</p>
<p>上述三种情况都包含回调函数，回调函数是异步执行</p>
<p>（2）后面在某个时可才会执行回调代码</p>
<pre><code>setTimeout(function()&#123;
    console.log(&#39;22&#39;)
&#125;,0)
console.log(&#39;alert之前&#39;)
alert(&#39;----&#39;) //暂停当前主线程执行，同时暂停计时，点击确定后恢复程序执行和计时
console.log(&#39;alert之后&#39;)

输出
alert之前
弹出----
alert之后
22  //即使 setTimeout 的时间设为 0，回调函数也在初始化代码都执行结束后才会执行</code></pre>
<h2 id="5、-浏览器的事件循环（轮询）模型"><a href="#5、-浏览器的事件循环（轮询）模型" class="headerlink" title="5、 浏览器的事件循环（轮询）模型"></a>5、 浏览器的事件循环（轮询）模型</h2><p>模型的两个重要组成部分：</p>
<p>— 事件（定时器/DOM 事件/Ajax）管理模块</p>
<p>— 回调队列</p>
<h3 id="事件驱动模型（event-driven-interaction-model）"><a href="#事件驱动模型（event-driven-interaction-model）" class="headerlink" title="事件驱动模型（event-driven interaction model）"></a>事件驱动模型（event-driven interaction model）</h3><p>如下图所示</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"></p>
<p>如上图所示最左侧的栈中表示初始化代码执行，栈中是一些执行上下文对象，回调函数交给右侧的不同管理模块处理，右侧表示在分线程上执行的不同管理模块，各模块不由 js 引擎执行（在主线程执行），而是由浏览器负责，管理模块把回调函数插入下方队列待执行</p>
<h3 id="模型运转流程"><a href="#模型运转流程" class="headerlink" title="模型运转流程"></a>模型运转流程</h3><p>（1）执行初始化代码，将事件回调函数交给对应模块管理</p>
<p>（2）当事件发生时，管理模块会将回调函数及其数据添加到回调队列中</p>
<p>（3）只有当初始化代码执行完后，才遍历读取队列中的回调函数执行</p>
<h3 id="执行栈（execution-stack）"><a href="#执行栈（execution-stack）" class="headerlink" title="执行栈（execution stack）"></a>执行栈（execution stack）</h3><p>所有代码都在此空间中执行</p>
<h3 id="浏览器内核（browser-core）"><a href="#浏览器内核（browser-core）" class="headerlink" title="浏览器内核（browser core）"></a>浏览器内核（browser core）</h3><p>js 引擎模块（在主线程处理）</p>
<p>其他模块（在主/分线程处理）</p>
<h3 id="回调队列"><a href="#回调队列" class="headerlink" title="回调队列"></a>回调队列</h3><p>callback queue 也称为任务队列（task queue）/消息队列（message queue）/事件队列（event queue）</p>
<h3 id="事件轮询（event-loop）"><a href="#事件轮询（event-loop）" class="headerlink" title="事件轮询（event loop）"></a>事件轮询（event loop）</h3><p>从任务队列中循环取出回调函数放入执行栈中一个接一个处理</p>
<h3 id="请求响应模型（request-response-model）"><a href="#请求响应模型（request-response-model）" class="headerlink" title="请求响应模型（request-response model）"></a>请求响应模型（request-response model）</h3><p>浏览器向服务器发送请求，服务器接收请求，并处理请求，并返回响应数据，浏览器接收响应数据并渲染</p>
<h2 id="6、H5-Web-Workers（多线程）"><a href="#6、H5-Web-Workers（多线程）" class="headerlink" title="6、H5 Web Workers（多线程）"></a>6、H5 Web Workers（多线程）</h2><p>H5 规范提供了 js 分线程的实现，名为 Web Workers，是一个 JavaScript 多线程解决方案（js 原本是单线程运行的）</p>
<p>这样可以将一些大计算量的代码交由 Web Worker 给分线程运行而不冻结用户界面，但是子线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JavaScript 单线程的本质</p>
<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Worker：构造函数，加载分线程执行的 js 文件</p>
<p>Worker.prototype.onmessage：用于接收另一个线程的回调函数</p>
<p>Worker.prototype.postMessage：向另一个线程发送消息</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建在分线程执行的 js 文件</p>
<p>在主线程中的 js 中发消息并设置回调</p>
<p>主线程中</p>
<pre><code>//创建一个 Worker 对象并向它传递将在新线程中执行的脚本的 URL
var worker = new Worker(&#39;worker.js&#39;)
//绑定接收消息的监听，主线程接收 worker 分线程传来的数据函数
worker.onmessage = function(event)&#123; //也可写在 postMessage 后面，因为只有在初始化代码执行完后才有可能执行回调函数
    console.log(event.data)
&#125;
//主线程向 worker 分线程发送数据
woreker.postMessage(&quot;hello world&quot;)</code></pre>
<p>分线程代码文件中</p>
<pre><code>var onmessage = function (event)&#123;  //不能用函数声明
    var msg = event.data  //通过 event.data 获得发送来的数据
    postMessage(&#39;ok&#39;)  //将获取到的数据发送回主线程
&#125;</code></pre>
<p>分线程中的全局变量不是 window，而是它自己的全局变量，所以在分线程中无法操作 DOM 元素（document相关）不能更新界面，也无法使用 alert（window 的方法）等</p>
<p><img src="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/webworker.png" alt="webworker"></p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>（1）慢，因为增加了消息传输</p>
<p>（2）Worker 内代码不能操作 DOM（更新 UI），因为全局对象不是 window</p>
<p>（3）不能跨域加载 JS</p>
<p>（4）不是每个浏览器都支持这个新特性</p>
<h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h1><p>1、定义在对象中的属性变量不是私有的，因为外部可直接操作，只有定义在函数内的变量才可能是私有的（闭包另说），因为函数有作用域</p>
<p>2、找变量是通过作用域链，找对象的属性是通过原型链</p>
<p>3、变量找不到会报错，属性找不到会返回 undefined，如找变量 a 找不到会报错，找 window.a 找不到会返回 undefined</p>
<p>4、new 一个对象背后做了什么？</p>
<p>— 创建一个空对象</p>
<p>— 给对象设置 <code>__proto__</code>，值为构造函数对象的 prototype 属性值（即 <code>this.__proto__ = Fn.prototype</code>）</p>
<p>— 执行构造函数体（给对象添加属性/方法）</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery笔记</title>
    <url>/2021/12/29/jQuery%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、jQuery-基础"><a href="#一、jQuery-基础" class="headerlink" title="一、jQuery 基础"></a>一、jQuery 基础</h1><p>jQuery 是一个 JS 函数库（write less, do more），封装了 BOM 和 DOM 的一些函数、对象、方法等，如 CRUD（增删改查）、Ajax，使用 jQuery 的网站超过 90%，jQuery 是中大型 WEB 项目开发首选</p>
<a id="more"></a>

<h2 id="1、jQuery-的用途"><a href="#1、jQuery-的用途" class="headerlink" title="1、jQuery 的用途"></a>1、jQuery 的用途</h2><p>HTML 元素选择（选择器）（方便快速查找 DOM 元素）</p>
<p>HTML 元素操作（如增删改）</p>
<p>CSS 操作</p>
<p>HTML 事件处理</p>
<p>JS 动画效果</p>
<p><strong>链式调用</strong>（如 a().b().c()）（通过在方法或函数（除了获取数据的方法）中最后返回 this（jQuery 对象），来实现可链式调用）</p>
<p><strong>读写合一</strong>（方法中不传参表示读，传参表示写），若 jQuery 对象中包含多个 dom 元素，则统一读时只读第一个，写时是对所有元素写</p>
<p><strong>隐式遍历</strong>（$(‘#box&gt;li’).click(function(){}) 会对 box 下所有 li 加监听）</p>
<p>浏览器兼容</p>
<p>易扩展插件</p>
<p>ajax 封装</p>
<p>……</p>
<h2 id="2、jQuery-的不同版本"><a href="#2、jQuery-的不同版本" class="headerlink" title="2、jQuery 的不同版本"></a>2、jQuery 的不同版本</h2><p>1.x：用的最多，因为兼容老版本 IE，文件更大</p>
<p>2.x：部分 IE8 及以下不支持，文件小，执行效率更高</p>
<p>3.x：完全不再支持 IE8 及以下版本，提供了一些新的 API，提供不包含 ajax/动画 API 的版本</p>
<p>两种 js 库库文件：.js 和 .min.js</p>
<p>.js 文件是开发版（测试版）</p>
<p>.min.js 文件是生产版（压缩版），去掉空格、换行，并把变量都转成单个字母的形式</p>
<h2 id="3、引入-jQuery"><a href="#3、引入-jQuery" class="headerlink" title="3、引入 jQuery"></a>3、引入 jQuery</h2><p>jQuery 库的大体结构如下</p>
<pre><code>(functon(window)&#123;
    var jQuery = function()&#123;
        return new jQuery.fn.init(xxx)
    &#125;
    window.$ = window.jQuery = jQuery
&#125;)(window)</code></pre>
<p>引入 jQuery 后相当于给 window 添加了两个属性 window.jQuery 和 window.$，两个的含义相同，表示的是一个函数，并且调用 jQuery 库返回的是一个对象</p>
<p>有两种引入 jQuery 的方式：服务器本地库引入、CDN 远程库引入</p>
<p>服务器本地库引入是把 jQuery 库文件保存在服务器中的文件夹下，使用 <code>&lt;script type=&quot;type/javascript&quot; src=&quot;./jquery-1.12.13.js&quot;&gt;&lt;/script&gt;</code> 引入 jQuery</p>
<p>CDN 远程库在项目上线时，一般使用比较靠谱的 CDN 资源库，减轻服务器负担，如免费的 CDN 资源库 <a href="www.bootcdn.cn">bootcdn</a> </p>
<h2 id="4、使用-jQuery"><a href="#4、使用-jQuery" class="headerlink" title="4、使用 jQuery"></a>4、使用 jQuery</h2><p>把 jQuery 函数 当作函数使用 <code>$(xxxx)</code>，把 jQuery 函数当作对象使用 <code>$.xxx()</code>，如 $.each，$.trim</p>
<p>jQuery 函数是 jQuery 库向外暴露的，直接可用，而 jQuery 对象是执行 jQuery 函数产生的</p>
<p>jQuery 对象（<code>$xxx</code>）包含所有匹配的 n 个 DOM 元素的伪数组对象，是执行 <code>$()</code> 返回的就是 jQuery 对象</p>
<h3 id="（1）jQuery-核心函数（-jQuery）"><a href="#（1）jQuery-核心函数（-jQuery）" class="headerlink" title="（1）jQuery 核心函数（$/jQuery）"></a>（1）jQuery 核心函数（$/jQuery）</h3><p>jQuery 库向外直接暴露的就是 jQuery 函数 $/jQuery，引入 jQuery 库后，直接使用即可</p>
<pre><code>jQuery === $   //true </code></pre>
<p><strong>参数类型：</strong></p>
<p>1）参数为函数：当 DOM 加载完成后，执行此回调函数</p>
<pre><code>$(function()&#123;&#125;)  //绑定文档加载完成的监听</code></pre>
<p>2）参数为选择器字符串：查找所有匹配的标签，并将它们封装成 jQuery 对象</p>
<pre><code>$(&#39;#btn&#39;).click(function()&#123;&#125;)  //绑定点击事件监听，在回调函数中的 this 依然指向发生事件的 dom 元素 &lt;button&gt;</code></pre>
<p>3）参数为 DOM 对象：将 DOM 对象封装成 jQuery 对象</p>
<pre><code>$(&#39;#btn&#39;).click(function()&#123;   //绑定点击事件监听，在回调函数中的 this 依然指向发生事件的 dom 元素 &lt;button&gt;
    alert($(this).html())  //参数为 DOM 对象，封装成 jQuery 对象后就可以调用 jQuery 的方法
&#125;)  </code></pre>
<p>4）参数为 html 标签字符串：创建标签对象并封装成 jQuery 对象</p>
<pre><code>$(&#39;&lt;input type=&quot;text&quot;&gt;&#39;).appendTo(&quot;div&quot;)  //把 &lt;input&gt; 插入 &lt;div&gt; 中</code></pre>
<h3 id="（2）jQuery-核心对象"><a href="#（2）jQuery-核心对象" class="headerlink" title="（2）jQuery 核心对象"></a>（2）jQuery 核心对象</h3><p>执行 jQuery 函数 <code>$()</code> 返回的对象为 jQuery （核心）对象，一般名称前会加 $，通过 <code>$obj.xxx()</code> 使用</p>
<p>如 <code>var $btn = $(&#39;#btn&#39;)</code></p>
<p>jQuery 对象内部包含的是 DOM 元素对象（一个或多个）的伪数组对象（能获取 length 且可用下标访问的对象）</p>
<p>jQuery 对象拥有很多有用的属性和方法，让程序员能方便地操作 dom</p>
<h5 id="jQuery-对象的属性和方法"><a href="#jQuery-对象的属性和方法" class="headerlink" title="jQuery 对象的属性和方法"></a>jQuery 对象的属性和方法</h5><p>1）基本行为</p>
<p><code>length</code> 或 <code>size()</code>，返回 jQuery 对象内包含的 dom 元素的个数</p>
<p><code>[index]</code> 或 <code>get(index)</code>，返回的是对应位置的 dom 元素</p>
<p><code>each()</code>，遍历 jQuery 对象内包含的 dom 元素，如下</p>
<p><code>$.each(数组,function(index,item)&#123;&#125;)</code> 或 <code>数组.each(function(index,item)&#123;&#125;)</code> 隐式遍历数组，回调函数中第一个参数为数组中元素下标，第二个参数为遍历的数组中的当前元素</p>
<p><code>index()</code>，得到在所在兄弟元素中的下标</p>
<pre><code>var $buttons = $(&#39;button&#39;)
$buttons.each(function(index,domEle)&#123;
    console.log(index,domEle.innerHTML)
    console.log(this)  //this 表示数组中当前 dom 元素对象 domEle
&#125;)

$(&#39;#btn3&#39;).index()  //第三个按钮是所有按钮中的第几个</code></pre>
<p>2）属性</p>
<p>操作内部标签的属性或值</p>
<p>3）CSS</p>
<p>操作标签的样式</p>
<p>4）文档</p>
<p>对标签进行增删改操作</p>
<p>5）筛选</p>
<p>根据指定的规则过滤内部的标签</p>
<p>6）事件</p>
<p>处理事件监听相关</p>
<p>7）效果</p>
<p>实现一些动画效果</p>
<h1 id="二、jQuery-函数"><a href="#二、jQuery-函数" class="headerlink" title="二、jQuery 函数"></a>二、jQuery 函数</h1><h2 id="1、选择器"><a href="#1、选择器" class="headerlink" title="1、选择器"></a>1、选择器</h2><p>选择器本身只是一个有特定语法规则的字符串，没有实质用处</p>
<p>它的基本语法规则使用的就是 CSS 的选择器语法，并对其进行了扩展</p>
<p>只有调用 <code>$()</code>，并将选择器作为参数传入才能起作用</p>
<p><code>$(选择器)</code> 的作用：根据选择器规则在整个文档中查找所有匹配的标签的数组，并封装成 jQuery 对象返回</p>
<p>选择器分类：基本选择器、层次选择器、过滤选择器、表单选择器</p>
<h3 id="（1）基本选择器"><a href="#（1）基本选择器" class="headerlink" title="（1）基本选择器"></a>（1）基本选择器</h3><p>基本选择器是最常用的选择器</p>
<p><code>#id</code>、<code>element</code>、<code>.类</code>、<code>*</code>、<code>选择器1,选择器2,选择器n</code>、<code>选择器1选择器2选择器n</code></p>
<pre><code>$(&#39;#div1&#39;).css(&#39;background&#39;,&#39;red&#39;)
或
$(&#39;#div1&#39;).css(&#123;&#39;background&#39;:&#39;red&#39;&#125;)</code></pre>
<h3 id="（2）层次选择器"><a href="#（2）层次选择器" class="headerlink" title="（2）层次选择器"></a>（2）层次选择器</h3><p>层次选择器用于查找子元素、后代元素、兄弟元素</p>
<p><code>祖先元素 后代元素</code>，<code>父元素 &gt; 子元素</code>，<code>兄元素 + 弟元素</code>（兄元素后紧跟着的某类型弟元素），<code>兄元素 ~ 弟元素们</code>（兄元素后所有的某类型弟元素）</p>
<h3 id="（3）过滤选择器"><a href="#（3）过滤选择器" class="headerlink" title="（3）过滤选择器"></a>（3）过滤选择器</h3><p>过滤选择器是在原有选择器匹配的元素中进一步进行过滤，既不是找子元素也不是找兄弟元素</p>
<p>多个过滤选择器不是同时执行，而是依次执行</p>
<p><code>:first</code> 第一个</p>
<p><code>:last</code>  最后一个</p>
<p><code>:eq(index)</code> 根据下标找出某个</p>
<p><code>:not(selector)</code>  排除某些</p>
<p><code>:lt</code> 下标小于</p>
<p><code>:gt</code> 下标大于</p>
<p><code>:odd</code> 奇数元素</p>
<p><code>:even</code>  偶数元素</p>
<p><code>:hidden</code>  隐藏</p>
<p><code>:visible</code>  显示</p>
<p><code>[属性名]</code>  某个属性</p>
<p><code>[属性名=属性值]</code>  某属性为某值的元素</p>
<pre><code>$(&#39;div:not(.box)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择所有 class 属性不为 box 的div（这里包含没有 class 属性的元素）
$(&#39;li:lt(3):gt(0)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择第二个和第三个 li 元素
$(&#39;li:gt(0):lt(3)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //这里选出来是第二三四个 li 元素，而不是第二个和第三个 li 元素，因为先执行 :gt(0)，在选出的元素里再执行 :lt(3)
$(&#39;li:contains(&#39;xxx&#39;)&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择内容为 xxx 的 li 元素
$(&#39;li:hidden&#39;).length  //选择隐藏的 li 个数
$(&#39;li:hidden&#39;).length[0]  //选择第一个隐藏的 li
$(&#39;li[title]&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择有 title 属性的 li
$(&#39;li[title=xxx]&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择有title 属性值为 xxx 的 li</code></pre>
<h3 id="（4）表单选择器"><a href="#（4）表单选择器" class="headerlink" title="（4）表单选择器"></a>（4）表单选择器</h3><p><code>:input</code> 所有表单项，包括 <code>&lt;select&gt;</code> 等</p>
<p><code>:text</code>、<code>:checkbox</code>、<code>:radio</code>、<code>:checked</code>（选中的项）</p>
<pre><code>$(&#39;:text:disabled&#39;).css(&#39;background&#39;,&#39;red&#39;)  //选择不可用的文本输入框
$(&#39;:checkbox:checked&#39;).length  //多选框选择的个数
$(&#39;:submit&#39;)  //提交按钮
$(&#39;select&gt;option:selected&#39;).html()  //所选下拉框的文本内容
$(&#39;select&#39;).val()  //所选下拉框 option 的 value 属性值</code></pre>
<p>表单</p>
<p>表单对象属性</p>
<h2 id="2、-工具（把-jQuery-函数当对象使用）"><a href="#2、-工具（把-jQuery-函数当对象使用）" class="headerlink" title="2、$工具（把 jQuery 函数当对象使用）"></a>2、$工具（把 jQuery 函数当对象使用）</h2><p><code>$.each()</code> 遍历数组或对象中的数据</p>
<pre><code>$.each(数组,function(index,item)&#123;&#125;) 隐式遍历数组，回调函数中第一个参数为数组中元素下标，第二个参数为遍历的数组中的当前元素

$.each(对象,function(key,value)&#123;&#125;)  //遍历对象</code></pre>
<p><code>$.trim()</code> 去除字符串两边的空格</p>
<pre><code>$.trim(字符串) 去除两端的空格，和字符串本身的方法 `字符串.trim()` 效果相同</code></pre>
<p><code>$.type(obj)</code> 得到数据的类型</p>
<pre><code>$.type($)  //返回 &#39;function&#39;</code></pre>
<p><code>$.isArray(obj)</code> 判断是否是数组</p>
<pre><code>$.isArray($(&#39;body&#39;))  //false</code></pre>
<p><code>$.isFunction(obj)</code> 判断是否是函数</p>
<pre><code>$.isFunction($)  //true</code></pre>
<p><code>$.parseJSON(json)</code> 解析 json 字符串转换为 js 对象/数组</p>
<pre><code>var json = &#39;&#123;&quot;nsme&quot;:&quot;xxx&quot;,age:12&#125;&#39;  //其中 json 对象就是 &#123;&#125;
$.parseJSON(json)  //json 对象转为 js 对象，返回 js 对象
var json = &#39;[&#123;&quot;nsme&quot;:&quot;xxx&quot;,age:12&#125;,&#123;&quot;nsme&quot;:&quot;yyy&quot;,age:10&#125;]&#39;  //其中 json 数组就是 []
$.parseJSON(json)  //json 对象转为 js 数组，返回 js 数组</code></pre>
<h2 id="3、属性"><a href="#3、属性" class="headerlink" title="3、属性"></a>3、属性</h2><p>操作标签的属性、标签体文本</p>
<p><code>attr(&#39;属性名&#39;)</code> 或 <code>attr(&#39;属性名&#39;,&#39;属性值&#39;)</code>：读写非布尔值的标签属性或自定义属性</p>
<p><code>prop(&#39;属性名&#39;)</code> 或 <code>prop(&#39;属性名&#39;,属性值)</code> 读写布尔值的标签属性或标签的固有属性</p>
<p><code>removeAttr(&#39;属性名&#39;)</code> 或 <code>removeProp(&#39;属性名&#39;)</code> 删除属性</p>
<p><code>addClass(&#39;class值&#39;)</code> 添加 class 属性值</p>
<p><code>removeClass(&#39;class值&#39;)</code>  移除指定 class 值</p>
<p><code>html()</code> 或 <code>html(&#39;xxx&#39;)</code> 读写标签体文本</p>
<p><code>val()</code> 或 <code>val(&#39;xxx&#39;)</code>：读写标签的 value</p>
<p><code>$(&#39;:text&#39;).val()</code> 得到输入框 <input> 的文本</p>
<p><code>$(&#39;:text&#39;).val(&#39;xxx&#39;)</code>  设置输入框 <input> 的文本</p>
<pre><code>$(&#39;div:first&#39;).attr(&#39;title&#39;)
$(&#39;div&#39;).attr(&#39;name&#39;,&#39;xxx&#39;)
$(&#39;div&#39;).addClass(&#39;class值&#39;)
$(&#39;div&#39;).removeClass(&#39;xxx&#39;)  //移除所有 div 的 class 为 xxx 的 class
$(&#39;li:first&#39;).html(&#39;&lt;h1&gt;xxx&lt;/h1&gt;&#39;)  //设置第一个 li 的标签体为 &lt;h1xxx&lt;/h1&gt;
$(&#39;div&#39;).removeClass(&#39;xxx&#39;)</code></pre>
<h3 id="attr-和-prop-的区别"><a href="#attr-和-prop-的区别" class="headerlink" title="attr 和 prop 的区别"></a>attr 和 prop 的区别</h3><p>（1）prop 多用在标签的固有属性、布尔值属性上，如 a 标签的 href，class，selected，checked 等</p>
<p>（2）attr 多用在自定义属性上</p>
<p>（3）jQuery 中用 attr 获取布尔值属性，且布尔值属性在标签体内没有定义的时候会得到 undefined</p>
<h1 id="三、jQuery-对象"><a href="#三、jQuery-对象" class="headerlink" title="三、jQuery 对象"></a>三、jQuery 对象</h1><h2 id="1、CSS"><a href="#1、CSS" class="headerlink" title="1、CSS"></a>1、CSS</h2><h3 id="设置-style-样式"><a href="#设置-style-样式" class="headerlink" title="设置 style 样式"></a>设置 style 样式</h3><p><code>jQuery对象.css(&#39;属性&#39;)</code> 或 <code>jQuery对象.css(&#39;属性&#39;,&#39;值&#39;)</code> 或 <code>jQuery对象.css(&#123;多个样式对&#125;)</code>：读写样式，返回的仍然是当前的 jQuery 对象，方法最后返回的是 this</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>offset()</code>：获取相对于页面左上角的位置，返回的对象包含 top 和 left 两个整数，该方法只对可见元素有效，（读）</p>
<p><code>offset(&#123;top:xx,left:xx&#125;)</code>：设置相对于页面左上角的位置（写）</p>
<p><code>position()</code>：获取相对于父元素左上角的位置，返回的对象包含 top 和 left 两个整数，（只能读）</p>
<p><code>scrollTop()</code>：读取/设置滚动条的 Y 坐标</p>
<p><code>$(document.body).scrollTop()+$(document.documentElement).scrollTop()</code>：读取页面滚动条的 Y 坐标（兼容 chrome 和 IE）</p>
<p><code>$(&#39;html,body&#39;).scrollTop(60)</code>：滚动到指定位置（兼容 chrome 和 IE）</p>
<p>滚动条回到顶部的例子</p>
<pre><code>//瞬间回到顶部
$(&#39;#btn&#39;).click(function()&#123;
    $(html,body).scrollTop(0)
&#125;)

//平滑地回到顶部
$(&#39;#btn&#39;).click = function()&#123;
    var $page = $(&#39;html&#39;,&#39;body&#39;)  //这里是用于后面设置，不能用于读取，因为有两个值
    var distance = $(&#39;html&#39;).scrollTop() + $(&#39;body&#39;).scrollTop()  //总距离
    var time = 500  //总时间
    var intervalTime = 50  //间隔时间
    var itemDistance = distance/(time/intervalTime)  //单位时间运动距离
    var intervalId = setInterval(function()&#123;
        distance -= itemDistance
        if(distance&lt;=0)&#123;
            distance = 0
            clearInterval(intervalId)
        &#125;
        $page.scrollTop(distance)
    &#125;,intervalTime)
&#125;</code></pre>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>（1）内容尺寸</p>
<p>height()：height</p>
<p>width()：width</p>
<p>（2）内部尺寸</p>
<p>innerHeight()：height+padding</p>
<p>innerWidth()：width+padding</p>
<p>（3）外部尺寸</p>
<p>outerHeight(false/true)：height+padding+border，若是 true 加上 margin，默认是 false</p>
<p>outerWidth(false/true)：width+padding+border，若是 true 加上 margin，默认是 false</p>
<h2 id="2、筛选————过滤和查找"><a href="#2、筛选————过滤和查找" class="headerlink" title="2、筛选————过滤和查找"></a>2、筛选————过滤和查找</h2><p>对包含多个 dom 元素的 jQuery 对象进行过滤是找出对象中的一个或多个元素，并封装成新的 jQuery 对象返回；</p>
<p>而查找是指查找对象内部某元素的父母、子孙后代或兄弟元素，并封装成新的 jQuery 对象返回</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p><code>first()</code>：jQuery 对象中的第一个 dom 元素组成的 jQuery 对象，返回的是 jQuery 对象（<code>last()</code>、<code>eq(index)</code>同理）</p>
<p>注意 <code>jQuery对象.first()</code> 返回的是 jQuery 对象，而 <code>jQuery对象[0]</code> 返回的是对象中包含的的第一个 dom 元素</p>
<p><code>filter(&#39;[属性名]=xxx&#39;)</code> 过滤出属性为某值的元素，（对当前元素提要求）</p>
<p><code>filter(&#39;[属性名]!=xxx&#39;)</code> 或 <code>not(&#39;[属性名]=xxx&#39;)</code> 过滤出没有某属性以及属性不为某值的元素，（对当前元素提要求并取反）</p>
<p><code>filter(&#39;[属性名][属性名]!=xxx&#39;)</code> 过滤出有某属性并且属性值不为某值的元素</p>
<p><code>has(&#39;标签名&#39;)</code> 过滤出元素中有子标签的元素，（对子元素提要求）</p>
<pre><code>var $lis = $(&#39;ul&gt;li&#39;)
$lis.first().css(&#39;background&#39;,&#39;red&#39;)  //相当于 $lis[0].style.background = &#39;red&#39;
$lis.filter(&#39;[title=hello]&#39;)  //title 属性为 hello 的 li
$lis.not(&#39;[title=hello]&#39;)  //title 属性不为 hello 的 li
$lis.filter(&#39;[title][title!=hello]&#39;) //有 title 属性且title 属性不为 hello，相当于 $lis.filter(&#39;[title]&#39;).filter(&#39;[title!=hello]&#39;)
$lis.has(&#39;span&#39;) //有 span 子标签的 li</code></pre>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>children(&#39;条件&#39;)</code> 查找子元素（直接子元素，而非后代） </p>
<p><code>find(&#39;条件&#39;)</code> 查找后代元素</p>
<p><code>parent()</code> 查找父元素</p>
<p><code>preAll(&#39;条件&#39;)</code> 前面的所有的符合条件的兄弟元素</p>
<p><code>nextAll(&#39;条件&#39;)</code> 后面所有的符合条件的兄弟元素</p>
<p><code>siblings(&#39;条件&#39;)</code> 前后所有的兄弟元素</p>
<pre><code>var $ul = $(&#39;ul&#39;)
$ul.children(&#39;span:eq(1)&#39;)  //ul 下的第 2 个 span 子标签
$ul.find(&#39;span:eq(1)&#39;)  //ul 下的第 2 个 span 后代标签
$ul.parent()  // ul 的父元素
var $li = $(&#39;#aa&#39;)
$li.preAll(&#39;li&#39;)  //id 为 aa 的 li 标签前面的所有 li
$li.siblings(&#39;li&#39;)  //id 为 aa 的 li 标签的所有兄弟 li</code></pre>
<h2 id="3、文档处理（CUD-增删改）"><a href="#3、文档处理（CUD-增删改）" class="headerlink" title="3、文档处理（CUD 增删改）"></a>3、文档处理（CUD 增删改）</h2><h3 id="（1）添加元素"><a href="#（1）添加元素" class="headerlink" title="（1）添加元素"></a>（1）添加元素</h3><h4 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h4><p><code>append(content)</code> 向当前匹配的所有元素内部的最后插入指定内容</p>
<p><code>$(content).appendTo($父)</code> 向当前匹配的所有元素内部的最后插入指定内容，和上面效果相同</p>
<p><code>prepend(content)</code> 向当前匹配的所有元素内部的最前面插入指定内容</p>
<p><code>$(content).prependTo($父)</code> 向当前匹配的所有元素内部的最前面插入指定内容，和上面效果相同</p>
<h4 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h4><p><code>before(content)</code> 将指定内容插入到当前所有匹配元素的前面</p>
<p><code>after(content)</code> 将指定内容插入到当前所有匹配元素的后面替换节点</p>
<h3 id="（2）删除元素"><a href="#（2）删除元素" class="headerlink" title="（2）删除元素"></a>（2）删除元素</h3><p><code>empty()</code> 删除所有匹配元素的子元素，父元素本身还在，等价于 <code>$(&#39;父 &gt; *&#39;).remove()</code></p>
<p><code>remove()</code> 删除所有匹配的元素（包括父元素本身和其下子元素）</p>
<pre><code>$(&#39;#ul2&#39;).empty()
相当于 $(&#39;#ul2&gt;*&#39;).remove()</code></pre>
<h3 id="（3）替换元素"><a href="#（3）替换元素" class="headerlink" title="（3）替换元素"></a>（3）替换元素</h3><p><code>replaceWith(content)</code> 用指定内容替换所有匹配的标签删除节点</p>
<p><code>replaceAll(选择器)</code> 用指定元素替换所有匹配的标签删除节点</p>
<pre><code>var $ul1 = $(&#39;#ul1&#39;)
$ul1.append(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //相当于 $(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;).appenTo($ul1)
$ul1.prepend(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //相当于 $(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;).prepenTo($ul1)
$ul1.children(&#39;li[title=hello]&#39;).before(&#39;&lt;span&gt;xxx&lt;/span&gt;&#39;)  //在 id 为 ul1 的 ul 下的 li（title 为 hello）的前面添加 span
$(&#39;#ul2&gt;li[title=hello]&#39;).replaceWith(&#39;&lt;p&gt;xxx&lt;/p&gt;&#39;)//在 id 为 ul2 的 ul 下的 li（title 为 hello）全部替换为 p</code></pre>
<h2 id="4、事件处理"><a href="#4、事件处理" class="headerlink" title="4、事件处理"></a>4、事件处理</h2><h3 id="（1）绑定事件"><a href="#（1）绑定事件" class="headerlink" title="（1）绑定事件"></a>（1）绑定事件</h3><p>方式一：<code>jQuery对象.事件名(function()&#123;&#125;)</code>，这种方式好写但并不通用，有些事件没有这种绑定方法</p>
<p>方式二：<code>jQuery对象.on(&#39;事件名1 事件名n&#39;,function()&#123;&#125;)</code></p>
<p>优缺点：方式一编码方便，但只能加一个监听，且有的事件监听不支持</p>
<p>方式二编码不方便，可以添加多个监听，且更通用</p>
<p>常用：click、mouseenter/mouseleave、mouseover/mouseout、focus/blur</p>
<pre><code>$(&#39;#image&#39;).on(&#39;load&#39;,function()&#123;&#125;) //监听图片加载完成，这时只能用 on</code></pre>
<h4 id="绑定鼠标点击事件"><a href="#绑定鼠标点击事件" class="headerlink" title="绑定鼠标点击事件"></a>绑定鼠标点击事件</h4><p>方式一：<code>jQuery对象.click(function()&#123;&#125;)</code></p>
<p>方式二：<code>jQuery对象.on(&#39;click&#39;,function()&#123;&#125;)</code></p>
<h4 id="绑定鼠标移入移出事件"><a href="#绑定鼠标移入移出事件" class="headerlink" title="绑定鼠标移入移出事件"></a>绑定鼠标移入移出事件</h4><p>方式一：<code>jQuery对象.mouseenter(function()&#123;&#125;)</code> 和 <code>jQuery对象.mouseleave(function()&#123;&#125;)</code></p>
<p>方式二：<code>jQuery对象.on(&#39;mouseenter&#39;,function()&#123;&#125;)</code> 和 <code>jQuery对象.on(&#39;mouseleave&#39;,function()&#123;&#125;)</code></p>
<p>方式三：<code>jQuery对象.hover(function()&#123;console.log(&#39;鼠标移入，绑定在mouseenter&#39;)&#125;,function()&#123;console.log(&#39;鼠标移出，绑定在mouseleave&#39;)&#125;)</code></p>
<h3 id="（2）解除事件绑定"><a href="#（2）解除事件绑定" class="headerlink" title="（2）解除事件绑定"></a>（2）解除事件绑定</h3><p><code>jQuery对象.off(&#39;事件名&#39;)</code></p>
<h3 id="（3）事件坐标"><a href="#（3）事件坐标" class="headerlink" title="（3）事件坐标"></a>（3）事件坐标</h3><p>event.clientX、event.clientY 相对于视口的左上角</p>
<p>event.pageX、event.pageY 相对于页面的左上角</p>
<p>event.offsetX、event.offsetY 相对于事件元素左上角</p>
<pre><code>$(#btn).click(function(event)&#123;
    console.log(event.clientX,event.clientY) //原点为窗口左上角
    console.log(event.pageX,event.pageY) //原点为页面左上角
    console.log(event.offsetX,event.offsetY) //原点为事件元素左上角
&#125;)</code></pre>
<h3 id="（4）事件相关处理"><a href="#（4）事件相关处理" class="headerlink" title="（4）事件相关处理"></a>（4）事件相关处理</h3><h4 id="停止事件冒泡"><a href="#停止事件冒泡" class="headerlink" title="停止事件冒泡"></a>停止事件冒泡</h4><p><code>event.stopPropagation</code> 点击子元素，父元素点击监听不响应</p>
<h4 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h4><p><code>event.preventDefault()</code> 阻止事件默认行为</p>
<pre><code>$(&#39;#test&#39;).click(function(event)&#123;
    if(Date.now()%2===0)&#123;
        event.preventDefault()
    &#125;
&#125;)</code></pre>
<h4 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a>mouseover 和 mouseenter 的区别</h4><p>mouseover 在移入子元素时也会重新触发一次，mouseout 同理</p>
<p>mouseenter 只在移入当前元素时才触发，mouseleave 同理，hover() 使用的就是 mouseenter() 和 mouseleave()</p>
<p>若不存在子元素则 mouseover 和 mouseenter 没有区别</p>
<h4 id="on-‘click’-fun-和-click-fun-的区别"><a href="#on-‘click’-fun-和-click-fun-的区别" class="headerlink" title="on(‘click’,fun) 和 click(fun) 的区别"></a>on(‘click’,fun) 和 click(fun) 的区别</h4><p>on 方法通用，但编码麻烦</p>
<p>click 方法编码简单，但有的事件没有对应的方法</p>
<h3 id="（5）事件委托-事件代理-事件委派"><a href="#（5）事件委托-事件代理-事件委派" class="headerlink" title="（5）事件委托/事件代理/事件委派"></a>（5）事件委托/事件代理/事件委派</h3><p>绑定事件监听的问题：新加的元素没有监听</p>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>— 将多个子元素的事件监听委托给父辈元素处理</p>
<p>— 事件监听是加在父辈元素上，但事件发生在子元素上</p>
<p>— 当操作任何一个子元素时，事件会冒泡到父辈元素</p>
<p>— 父元素不会直接处理事件，而是根据 event.target 得到发生事件的子元素，通过这个子元素来调用事件回调函数（回调函数中的 this 指发生事件的子元素）</p>
<h4 id="使用事件委托的好处"><a href="#使用事件委托的好处" class="headerlink" title="使用事件委托的好处"></a>使用事件委托的好处</h4><p>添加新的子元素，自动有事件响应处理</p>
<p>减少事件监听的数量（如从 n 个减为 1 个）</p>
<h4 id="jQuery-的事件委托-API"><a href="#jQuery-的事件委托-API" class="headerlink" title="jQuery 的事件委托 API"></a>jQuery 的事件委托 API</h4><p>设置事件委托：</p>
<p>（1）$(父元素选择器).delegate(子元素选择器,事件名,回调函数)</p>
<p>（2）$(父元素选择器).on(事件名,子元素选择器,回调函数)</p>
<p>（3）在 1.7 及以下还可以使用 live 函数，但在 1.7 以上已被废除</p>
<p>移除事件委托：$(父元素选择器).undelegate(事件名)，若不加事件名参数表示移除对应的所有事件</p>
<h1 id="四、动画效果"><a href="#四、动画效果" class="headerlink" title="四、动画效果"></a>四、动画效果</h1><h2 id="1、淡入淡出"><a href="#1、淡入淡出" class="headerlink" title="1、淡入淡出"></a>1、淡入淡出</h2><p>淡入淡出通过不断改变元素的透明度来实现</p>
<p><code>fadeIn()</code> 带动画的显示</p>
<p><code>fadeOut()</code> 带动画隐藏</p>
<p><code>fadeToggle()</code> 带动画切换显示/隐藏</p>
<p>可选参数有速度、切换效果、回调函数</p>
<p>— 速度：slow、normal、fast、毫秒数</p>
<p>— 切换效果：swing（默认）、linear</p>
<p>— 回调函数：在动画完成时执行</p>
<h2 id="2、滑动"><a href="#2、滑动" class="headerlink" title="2、滑动"></a>2、滑动</h2><p>滑动动画通过不断改变元素的高度实现</p>
<p><code>slideDown()</code> 带动画的展开</p>
<p><code>slideUp()</code> 带动画的收缩</p>
<p><code>slideToggle()</code> 带动画的切换展开/收缩</p>
<p>可选参数有速度、切换效果、回调函数</p>
<h2 id="3、显示与隐藏"><a href="#3、显示与隐藏" class="headerlink" title="3、显示与隐藏"></a>3、显示与隐藏</h2><p>显示与隐藏通过不断改变宽度、高度、透明度来实现，默认是没有动画</p>
<p><code>show()</code> （不）带动画的显示</p>
<p><code>hide()</code> （不）带动画的隐藏</p>
<p><code>toggle()</code> （不）带动画的切换显示/隐藏</p>
<p>可选参数有速度、切换效果、回调函数</p>
<h2 id="4、自定义动画"><a href="#4、自定义动画" class="headerlink" title="4、自定义动画"></a>4、自定义动画</h2><p><code>jQuery对象.animate(&#123;样式设置&#125;,毫秒数)</code>，其中样式可不写单位，若写单位需要将数值和单位加引号</p>
<pre><code>$(&#39;#div1&#39;)  //宽度先变为200px，高度再变为200px
    .animate(&#123;
        width:200
    &#125;,1000)
    .animate(&#123;
        height:200
    &#125;,1000)
$(&#39;#div1&#39;).animate(&#123;  //移动距离为（100，50）
    left:&#39;+=100&#39;,
    top:&#39;+=50&#39;
&#125;,1000)
$(&#39;#div1&#39;).animate(&#123;  //移动距离为（-100，-20）
    left:&#39;-=100&#39;,
    top:&#39;-=50&#39;
&#125;,1000)</code></pre>
<h2 id="5、停止动画"><a href="#5、停止动画" class="headerlink" title="5、停止动画"></a>5、停止动画</h2><p><code>jQuery对象.stop()</code> 停止动画</p>
<h1 id="五、多库共存"><a href="#五、多库共存" class="headerlink" title="五、多库共存"></a>五、多库共存</h1><p>问题：如果有两个库都有 $，就存在冲突</p>
<p>解决：jQuery 库可以通过 <code>jQuery.noConflict()</code> 释放 $ 的使用权，让另一个库可以正常使用，此时 jQuery 库只能使用 jQuery 了</p>
<h1 id="六、onload-与-ready"><a href="#六、onload-与-ready" class="headerlink" title="六、onload 与 ready"></a>六、onload 与 ready</h1><p><code>$(function($)&#123;&#125;)</code></p>
<p><code>$(document).ready(function()&#123;&#125;)</code></p>
<p><code>window.onload = function()&#123;&#125;</code></p>
<p>上面三种方式基本等价，其中回调函数会在 DOM 加载完成时运行</p>
<p>注意 <code>$(function($)&#123;&#125;)</code> 和 document.ready 等价，表示文档（结构）加载完毕，而 window.onload 表示整个页面（包括图片等）加载完毕</p>
<h2 id="window-load-与-document-ready-区别"><a href="#window-load-与-document-ready-区别" class="headerlink" title="window.load 与 $(document).ready()区别"></a>window.load 与 $(document).ready()区别</h2><p>window.load 中包括页面的图片加载完后才会回调（晚），且只能有一个监听回调，后面加的监听回调会覆盖前面的</p>
<p>$(document).ready() 等同于 $(function(){})，页面加载完就回调（早），且可以有多个监听回调</p>
<pre><code>window.onload = function()&#123;  //不执行，被下面的 window.onload 覆盖
    console.log(&#39;onload1&#39;)
&#125;
window.onload = function()&#123;  //执行
    console.log(&#39;onload2&#39;)
&#125;
$(function()&#123;                //执行
    console.log(&#39;ready1&#39;)
&#125;)
$(function()&#123;                //也执行
    console.log(&#39;ready2&#39;)
&#125;)</code></pre>
<h1 id="七、jQuery插件"><a href="#七、jQuery插件" class="headerlink" title="七、jQuery插件"></a>七、jQuery插件</h1><h2 id="1、扩展插件"><a href="#1、扩展插件" class="headerlink" title="1、扩展插件"></a>1、扩展插件</h2><p><code>jQuery.extend</code> 是扩展 jQuery 对象本身（即jQuery 函数对象）的工具方法（扩展 $ 的方法），调用时 <code>$.新方法()</code></p>
<p><code>jQuery.fn.extend</code> 是扩展 jQuery 对象（jQuery 元素集）的功能方法（扩展 $() 返回值的方法），调用时 <code>$(xxx).新方法()</code></p>
<p>注意：自定义的插件文件要在 jQuery 后引入</p>
<h3 id="（1）扩展-jQuery-的工具方法"><a href="#（1）扩展-jQuery-的工具方法" class="headerlink" title="（1）扩展 jQuery 的工具方法"></a>（1）扩展 jQuery 的工具方法</h3><p><code>$.extend(object)</code>，其中 this 指 $，使用 <code>$.xxx()</code> 调用</p>
<h3 id="（2）扩展-jQuery-对象的方法"><a href="#（2）扩展-jQuery-对象的方法" class="headerlink" title="（2）扩展 jQuery 对象的方法"></a>（2）扩展 jQuery 对象的方法</h3><p><code>$.fn.extend(object)</code>，其中 this 指 jQuery 对象，使用 <code>$obj.xxx()</code> 调用</p>
<pre><code>编写插件文件 myjQuery-plugin.js
(function()&#123;
    $.extend(&#123;          //给 $ 添加工具方法
        min:function(a,b)&#123;
            return a &lt; b ? a : b
        &#125;,
        max:function(a,b)&#123;
            return a &gt; b ? a : b
        &#125;,
        leftTrim:function(str)&#123;
            return str.replace(/^\s+/,&#39;&#39;)
        &#125;,
        rightTrim:function(str)&#123;
            return str.replace(/\s+$/,&#39;&#39;)
        &#125;
    &#125;)
    $.fn.extend(&#123;      //给 jQuery 对象添加功能方法
        checkAll:function()&#123;
            this.prop(&#39;checked&#39;,true) //this 是 jQuery 对象
        &#125;,
        unCheckAll:function()&#123;
            this.prop(&#39;checked&#39;,false)
        &#125;,
        reverseCheck:function()&#123;
            this.each(function()&#123; //this 是 jQuery 对象
                this.checked = !this.checked   //this 是 dom 元素
            &#125;)
        &#125;,
    &#125;)
&#125;)()
在其他 js 文件中使用插件
&lt;script src=&quot;./jquery-1.10.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  //先引入 jQuery
&lt;script src=&quot;./myjQuery-plugin.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  //引入自定义的插件文件
&lt;script type=&quot;text/javascript&quot;&gt;
    console.log($.min(1,2),$.max(2,1))
&lt;/script&gt;</code></pre>
<h2 id="2、jQuery-插件"><a href="#2、jQuery-插件" class="headerlink" title="2、jQuery 插件"></a>2、jQuery 插件</h2><p>jQuery 插件是基于 jQuery 编写的扩展库，在<a href="http://plugins.jquery.com/">官网</a>可查看相关 jQuery 插件</p>
<p>常用的有 jquery-validation（表单验证插件）、jquery UI、laydate（日期控件，该控件其实不属于 jQuery 插件）</p>
<h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><h4 id="jquery-validation"><a href="#jquery-validation" class="headerlink" title="jquery-validation"></a>jquery-validation</h4><p>先在<a href="http://plugins.jquery.com/">官网</a>下载相应插件，并把有用文件拷贝在项目文件夹下，然后利用 <code>&lt;script&gt;</code> 引入 jQuery 和 插件库</p>
<pre><code>&lt;form id=&quot;myForm&quot; action=&quot;xxx&quot;&gt;
    &lt;p&gt;用户名（必须，最小6位）：&lt;input name=&quot;username&quot; type=&quot;text&quot; required minlength=&quot;6&quot;&gt;&lt;/p&gt;
    &lt;p&gt;密码（必须，6-8位）：&lt;input id=&quot;password&quot; name=&quot;password1&quot; type=&quot;password&quot; required minlength=&quot;6&quot; maxlength=&quot;8&quot;&gt;&lt;/p&gt;
    &lt;p&gt;确认密码：&lt;input name=&quot;password2&quot; type=&quot;password&quot; equalTo=&quot;#password&quot;&gt;&lt;/p&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/p&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.validate.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //声明式验证：程序员只需声明各种验证规则，也可自定义验证错误信息
    $(&#39;#myForm&#39;).validate(&#123;  //对此表单开启验证
        messages:&#123;  //自定义错误提示（可选）
            username:&#123;  //使用表单项的 name 值
                required:&#39;用户名是必须的&#39;,
                minlength:&#39;用户名至少6位&#39;
            &#125;,
            password1:&#123;  //使用表单项的 name 值
                required:&#39;密码是必须的&#39;,
                minlength:&#39;密码至少6位&#39;,
                maxlength:&#39;密码最多6位&#39;
            &#125;,
            password2:&#123;
                equalTo:&#39;必须与密码相同&#39;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<h4 id="jquery-UI"><a href="#jquery-UI" class="headerlink" title="jquery UI"></a>jquery UI</h4><p>在<a href="http://jqueryui.com/">官网</a>下载插件，并把 jquery.js、jquery-ui.js、jquery-ui.css 三个文件拷贝至项目文件夹</p>
<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;jquery-ui.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;手风琴Accordion效果&lt;/h2&gt;  &lt;!--以下结构是从插件的index.html中拷贝来的--&gt;
    &lt;div id=&quot;accordion&quot;&gt;
        &lt;h3&gt;First&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
        &lt;h3&gt;Second&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
        &lt;h3&gt;Third&lt;/h3&gt;
        &lt;div&gt;xxxxx&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-ui.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    $(&#39;#accordion&#39;).accordion()  //开启样式效果
&lt;/script&gt;</code></pre>
<h4 id="laydate"><a href="#laydate" class="headerlink" title="laydate"></a>laydate</h4><p>在<a href="http://www.layui.com/laydate/">官网</a>下载插件，把 need 文件夹、skins 文件夹、laydate.js 文件拷贝至项目文件夹中并放在同一目录下</p>
<pre><code>&lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;laydate.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--方式一--&gt;
    &lt;input placeholder=&quot;请输入日期&quot; class=&quot;laydate-icon&quot; onclick=&quot;&quot;laydate()&gt;
    &lt;!--方式二--&gt;
    &lt;input class=&quot;laydate-icon&quot; id=&quot;demo&quot; value=&quot;xxx&quot;&gt;   
    &lt;script&gt;
        ;!function()&#123;
            laydate(&#123;
                elem:&#39;#demo&#39;
            &#125;)
        &#125;()
    &lt;/script&gt;
    &lt;!--方式三--&gt;
    &lt;input class=&quot;laydate-icon&quot; id=&quot;test&quot;&gt;
    &lt;script&gt;
        laydate(&#123;
            elem:&#39;#test&#39;,
            format:&#39;YYYY/MM&#39;,  //分隔符可以任意定义，该例子只显示年月
            festival:true,   //显示节日
            choose:function(datas)&#123;  //选择完日期的回调
                alert(datas);
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h1 id="八、jQuery-文档结构图"><a href="#八、jQuery-文档结构图" class="headerlink" title="八、jQuery 文档结构图"></a>八、jQuery 文档结构图</h1><p><img src="/2021/12/29/jQuery%E7%AC%94%E8%AE%B0/jQuery%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="jQuery文档结构图"></p>
<h1 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h1><p>1、伪数组</p>
<p>伪数组是 Object 对象，有 length 属性和数值下标属性，但不是数值（即 伪数组 instanceof Array 结果为 false），没有数组特别的方法（如 forEach()、push()、pop()、splice()等）</p>
<p>自定义一个伪数组</p>
<pre><code>var w = &#123;&#125;
w.length = 0
w[0] = &#39;xxx&#39;
w.length = 1
w[1] = 123
w.length = 2
for(var i=0;i&lt;w.length;i++)&#123;  //可循环遍历元素
    var obj = w[i]
    console.log(i,obj)
&#125;
console.log(w.forEach)  //会返回 undefined</code></pre>
<p>2、轮播图</p>
<p>要实现循环切换，需在最后一张图片（5.jpg）后添加一张第一张图片（1.jpg），在第一张图片（1.jpg）前面添加最后一张图片（5.jpg）</p>
<p>若到达最后一张图片（5.jpg），则跳转到最左边第 2 张图片（1.jpg），若到达最左边的图片（5.jpg），则跳转到最右边的第 2 张图片（5.jpg）</p>
<p>还需注意快速点击时的bug（即正在翻页时点击向上或向下翻页），可在代码中设置标识判断当前是否正在翻页，翻页结束后更新标识值</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Bootstrap学习笔记</title>
    <url>/2022/01/05/Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、引入-bootstrap"><a href="#一、引入-bootstrap" class="headerlink" title="一、引入 bootstrap"></a>一、引入 bootstrap</h1><a id="more"></a>

<pre><code>&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap.min.css&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>可在<a href="https://v3.bootcss.com/getting-started/#template">官网的文档</a>中引入基本模板，然后开始使用 bootstrap</p>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><p>bootstrap 首先将 box-sizing 设置为 border-box</p>
<p>在 bootstrap 中为了增强跨浏览器表现的一致性，使用 Normalize.css （可在 GitHub 上搜到）重置样式，也可使用<a href="https://cssreset.com/">cssreset</a>上的重置样式库</p>
<h2 id="1、容器"><a href="#1、容器" class="headerlink" title="1、容器"></a>1、容器</h2><p>容器两侧都有 15px 的 padding</p>
<h3 id="（1）流体容器"><a href="#（1）流体容器" class="headerlink" title="（1）流体容器"></a>（1）流体容器</h3><p>container-fluid 流体容器，相当于一个弹性盒，width 为 auto</p>
<h3 id="（2）固定容器"><a href="#（2）固定容器" class="headerlink" title="（2）固定容器"></a>（2）固定容器</h3><p>固定容器 container 分为三个阈值 768、992、1200，在 xs、sm、md、lg 都具备时</p>
<p>视口大小 &lt; 768 时，（xs 移动手机），width = auto，此时相当于流体容器</p>
<p>768 &lt; 视口大小 &lt; 992 时，（sm 平板），width = 750 = 720 + 槽宽30</p>
<p>992 &lt; 视口大小 &lt; 1200 时，（md 中屏pc），width = 970 = 940 + 槽宽30</p>
<p>视口大小 &gt;= 1200 时，（lg 大屏pc），width = 1170 = 1140 + 槽宽30</p>
<p>严格上说，sm 表示视口大小 &gt;= 768，md 表示视口大小 &gt;= 992，lg 表示视口大小 &gt;= 1200，代码执行时移动（小屏）优先，大屏下的样式写在小屏后会覆盖小屏的样式</p>
<p>若只有 sm，则表示视口大小 &gt;= 768</p>
<h2 id="2、栅格系统"><a href="#2、栅格系统" class="headerlink" title="2、栅格系统"></a>2、栅格系统</h2><p>栅格系统由固定容器、行、列组成，默认每行由 12 列组成</p>
<p>栅格是基于浮动的，本质上用的是 float</p>
<p>在栅格中通过 col-lg-pull-x 表示 left，col-lg-push-x 表示 right，col-lg-offset-x 表示 margin-left，其中 x 表示 0-12 的整数，md、sm、xs 同理</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-10&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;col-lg-2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-4&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;col-lg-8&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="栅格系统源码"><a href="#栅格系统源码" class="headerlink" title="栅格系统源码"></a>栅格系统源码</h3><p>源码可在 <a href="https://www.bootcss.com/">bootstrap官网</a>下载</p>
<pre><code>//固定容器
.container&#123;
    container-fixed();
    ...
&#125;
//流体容器
.container-fluid&#123;
    container-fixed();
&#125;
//行
.row&#123;
    .make-row();
&#125;
//列
.make-grid-columns();
.make-grid(xs);  //移动优先
@media(min-width:@screen-sm-min)&#123;
    .make-grid(sm);
&#125;
@media(min-width:@screen-md-min)&#123;
    .make-grid(md);
&#125;
@media(min-width:@screen-lg-min)&#123;
    .make-grid(lg);
&#125;</code></pre>
<h4 id="固定容器和流体容器的公共样式"><a href="#固定容器和流体容器的公共样式" class="headerlink" title="固定容器和流体容器的公共样式"></a>固定容器和流体容器的公共样式</h4><pre><code>.container-fixed(@gutter:@grid-gutter-width)&#123;  //@grid-gutter-width 表示槽宽，默认为 30px
    margin-right:auto;
    margin-left:auto;
    padding-left:floor((@gutter/2));  // 15px
    padding-right:ceil((@gutter/2));  // 15px
    &amp;:extend(.clearfix all);
&#125;
//其中 .clearfix 内容如下
.clearfix()&#123;
    &amp;:before,
    &amp;:after&#123;
        content:&quot;&quot;;
        display:table;
    &#125;
    &amp;:after&#123;
        clear:both;
    &#125;
&#125;</code></pre>
<h4 id="固定容器的特定样式"><a href="#固定容器的特定样式" class="headerlink" title="固定容器的特定样式"></a>固定容器的特定样式</h4><pre><code>@media(min-width:@screen-sm-min)&#123;
    width:@container-sm;
&#125;
@media(min-width:@screen-md-min)&#123;
    width:@container-md;
&#125;
@media(min-width:@screen-lg-min)&#123;
    width:@container-lg;
&#125;
//上述媒体查询必须从小到大，当屏幕大于 1200 时前两种媒体查询也会读到，但前面会被最后一个覆盖，若屏幕小于 768 时，则三种媒体查询都不会读到，width 则为默认值 auto</code></pre>
<h4 id="行"><a href="#行" class="headerlink" title="行"></a>行</h4><p>行两侧都有 -15px 的 margin</p>
<pre><code>.make-row(@gutter:@grid-gutter-width)&#123;
    margin-left:ceil((@gutter/-2));  //-15px
    margin-right:floor((@gutter/-2));  //-15px
    &amp;:extend(.clearfix all);
&#125;</code></pre>
<h4 id="列"><a href="#列" class="headerlink" title="列"></a>列</h4><p>公共样式：列两侧都有 15px 的 padding，开启相对定位</p>
<p>float</p>
<p>width：1~12个级别</p>
<p>left、right（列排序）：0~12，0:auto</p>
<p>margin-left（列偏移）：0~12</p>
<p>在列排序中注意阈值上样式的设置不能跳跃，即例如不能设置完 col-lg-push-x 后直接设置  col-sm-push-x，中间的 col-md-push-x 也需设置</p>
<p>第一步：.make-grid-columns()</p>
<pre><code>.make-grid-columns()&#123;
    .col(@index)&#123;
        @item:~&quot;.col-xs-@&#123;index&#125;,.col-sm-@&#123;index&#125;,.col-md-@&#123;index&#125;,.col-lg-@&#123;index&#125;&quot;;
        .col((@index + 1),@item)  //此处不是递归，因为形参个数不同
        //即.col(2,&quot;.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1&quot;)
    &#125;
    .col(@index,@list) when (@index =&lt; @grid-columns)&#123;
        @item:~&quot;.col-xs-@&#123;index&#125;,.col-sm-@&#123;index&#125;,.col-md-@&#123;index&#125;,.col-lg-@&#123;index&#125;&quot;;
        .col((@index + 1),~&quot;@&#123;list&#125;,@&#123;item&#125;&quot;)  //此处是递归
        //即.col(3,&quot;.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2&quot;)
        //...
        //.col(13,str)
        //其中 str:
        //    .col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,
        //    .col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,
        //    ...
        //    .col-xs-12,.col-sm-12,.col-md-12,.col-lg-12,
    &#125;
    .col(@index,@list) when (@index &gt; @grid-columns)&#123;
        @&#123;list&#125;&#123;
            position:relative;
            min-height:1px;
            padding-left:ceil((@grid-gutter-width/2));
            padding-right:floor((@grid-gutter-width/2));
        &#125;
    &#125;//即str&#123;position:...&#125;，str作为选择器
    .col(1);
&#125;</code></pre>
<p>上面整体相当于执行了</p>
<pre><code>.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,
.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,
...
.col-xs-12,.col-sm-12,.col-md-12,.col-lg-12&#123;
    position: relative;
    min-height: 1px;
    padding-left: 15px;
    padding-right: 15px;
&#125;</code></pre>
<p>第二步：.make-grid(xs)</p>
<pre><code>.make-grid(@class)&#123;
    .float-grid-columns(@class); 
    //相当于 .col-xs-1,.col-xs-2,...,.col-xs-12&#123;
    //    float:left;
    //&#125;
    .loop-grid-columns(@grid-columns,@class,width); //从 12 递减到 1
    //相当于 .col-xs-12&#123;
    //    width:12/12;
    //&#125;
    //.col-xs-11&#123;
    //    width:11/12;
    //&#125;
    //...
    //.col-xs-1&#123;
    //    width:1/12;
    //&#125;
    .loop-grid-columns(@grid-columns,@class,pull);  //列排列，从 12 递减到 0
    .loop-grid-columns(@grid-columns,@class,push);  //列排列，从 12 递减到 0
    .loop-grid-columns(@grid-columns,@class,offset);  //列偏移，从 12 递减到 0
&#125;</code></pre>
<p>第二步中.float-grid-columns(@class)</p>
<pre><code>//其中
.float-grid-columns(@class)&#123;
    .col(@index)&#123;
        @item:~&quot;.col-@&#123;class&#125;-@&#123;index&#125;&quot;;
        .col((@index + 1),@item);
    &#125;
    .col(@index,@list) when (@index =&lt; @grid-columns)&#123;
        @item:~&quot;.col-@&#123;class&#125;-@&#123;index&#125;&quot;;
        .col((@index + 1),~&quot;@&#123;list&#125;,@&#123;item&#125;&quot;);
    &#125;
    .col(@index,@list) when (@index &gt; @grid-columns)&#123;
        @&#123;list&#125;&#123;
            float:left;  //本质使用 float
        &#125;
    &#125;
    .col(1);
&#125;</code></pre>
<p>第二步中.loop-grid-columns(@index,@class,@type)</p>
<pre><code>.loop-grid-columns(@index,@class,@type) when (@index &gt;= 0)&#123;
    .calc-grid-column(@index,@class,@type);
    .loop-grid-columns((@index-1),@class,@type);
&#125;
.calc-grid-column(@index,@class,@type) when (@type = width) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-@&#123;index&#125;&#123;
        width:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = push) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-push-@&#123;index&#125;&#123;
        left:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = push) and (@index = 0)&#123;  //调用 1 次
    .col-@&#123;class&#125;-push-0&#123;
        left:auto;
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = pull) and (@index &gt; 0)&#123;  //调用 12 次
    .col-@&#123;class&#125;-pull-@&#123;index&#125;&#123;
        right:percentage((@index/@grid-columns));
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = pull) and (@index = 0)&#123;  //调用 1 次
    .col-@&#123;class&#125;-pull-0&#123;
        right:auto;
    &#125;
&#125;
.calc-grid-column(@index,@class,@type) when (@type = offset)&#123;  //调用 13 次，index 为 0 时，margin-left 为 0
    .col-@&#123;class&#125;-offset-@&#123;index&#125;&#123;
        margin-left:percentage((@index/@grid-columns));
    &#125;
&#125;
//以 push 为例执行时相当于 .col-xs-push-12&#123;
//    left:12/12;
//&#125;
//.col-xs-push-11&#123;
//    left:11/12;
//&#125;
//...
//.col-xs-push-1&#123;
//    left:1/12;
//&#125;
//.col-xs-push-0&#123;
//    left:auto;
//&#125;</code></pre>
<h3 id="栅格组合"><a href="#栅格组合" class="headerlink" title="栅格组合"></a>栅格组合</h3><p>栅格组合即在一个列中写多个不同的栅格</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-10 col-md-6&quot;&gt;xxx&lt;/div&gt;
        &lt;div class=&quot;col-lg-2 col-md-6&quot;&gt;xxx&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>当 992 &lt; 视口大小 &lt; 1200 （md）时，布局为两列每列占 6 格，此时不执行 lg</p>
<p>栅格组合就是利用了 less 的递归</p>
<h3 id="栅格实例"><a href="#栅格实例" class="headerlink" title="栅格实例"></a>栅格实例</h3><p>lg 时每行 4 块、md 时每行 3 块、sm 时每行 2 块、xs 时每行 1 块，显示时按照 1234 顺序显示，但是缩小窗口时，1 会最先换到下一行（正常情况下是 4 先换行）</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-lg-3 col-lg-push-9 col-md-4 col-md-push-8 col-sm-6 col-sm-push-6&quot;&gt;
            ...
            4
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-push-3 col-md-4 col-md-pull-0 col-sm-6 col-sm-pull-6&quot;&gt;
            ...
            3
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-pull-3 col-md-4 col-md-pull-8 col-sm-6&quot;&gt;
            ...
            2
            ...
        &lt;/div&gt;
        &lt;div class=&quot;col-lg-3 col-lg-pull-9 col-md-4 col-sm-6&quot;&gt;
            ...
            1
            ...
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<h3 id="自定义栅格系统"><a href="#自定义栅格系统" class="headerlink" title="自定义栅格系统"></a>自定义栅格系统</h3><p>1、新建文件夹，并新建文件 custom.less</p>
<pre><code>@import &quot;mixin/clearfix.less&quot;;
@import &quot;mixin/grid.less&quot;;
@import &quot;mixin/grid-framework.less&quot;;
@import &quot;grid.less&quot;;
@import &quot;variables.less&quot;;
//以上是栅格系统相关源码</code></pre>
<p>注意 clearfix.less 中 .clearfix 后不能有空格、、括号</p>
<p>2、把 grid-framework.less 文件中的 col-xxx 全部重命名为自定义名字，如 custom-col-xxx</p>
<p>3、使用 Kaolo 软件对文件夹文件进行编译，会生成 custom.css、variable.css、mixin/clearfix.css、mixin/grid.css、mixin/grid-framework.css，只需用到其中的 custom.css</p>
<p>4、只需在 html 文件中引入 custom.css 即可使用</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;custom.css&quot;&gt;
&lt;style&gt;
    *&#123;
        box-sizing:border-box;
    &#125;
&lt;/style&gt;</code></pre>
<p>html 中通过 custom-col-xxx 使用自定义栅格</p>
<h3 id="栅格盒模型设计精妙之处"><a href="#栅格盒模型设计精妙之处" class="headerlink" title="栅格盒模型设计精妙之处"></a>栅格盒模型设计精妙之处</h3><p>容器两边具有 15px 的 padding</p>
<p>行两边有 -15px 的 margin</p>
<p>列中间两边有 15px 的 padding（必须）</p>
<p>为了维护槽宽的规则，列两边必须有 16px 的 padding</p>
<p>为了能使列嵌套行，行两边必须有 -15px 的 margin</p>
<p>为了让容器能包裹住行，容器两边必须有 15px 的 padding</p>
<p><a href="./Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%85%E6%A0%BC%E8%AE%BE%E8%AE%A1.png">栅格设计</a></p>
<h2 id="3、响应式工具"><a href="#3、响应式工具" class="headerlink" title="3、响应式工具"></a>3、响应式工具</h2><p>visible-xs、hidden-xs 视口大小 &lt; 768 时显示/隐藏</p>
<p>visible-sm、hidden-sm 768 &lt; 视口大小 &lt; 992 时显示/隐藏</p>
<p>visible-md、hidden-md 992 &lt; 视口大小 &lt; 1200 时显示/隐藏</p>
<p>visible-lg、hidden-lg 视口大小 &gt; 1200 时显示/隐藏</p>
<h2 id="4、bootstrap-定制化"><a href="#4、bootstrap-定制化" class="headerlink" title="4、bootstrap 定制化"></a>4、bootstrap 定制化</h2><p>方法一：在源码中修改，并重新编译入口文件 bootstrap.less 后，在 html 代码中使用新生成的 bootstrap.css 文件</p>
<p>方法二：新建 css 文件，在该文件中</p>
<pre><code>@import &quot;bootstrap.less&quot;;
//接下来写需要修改的部分
@grid-gutter-width:100px;  //如修改槽宽</code></pre>
<p>然后编译该 css 文件，并在 html 文件中使用</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax学习笔记</title>
    <url>/2022/01/07/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、AJAX"><a href="#一、AJAX" class="headerlink" title="一、AJAX"></a>一、AJAX</h1><p>AJAX（Asynchronous JavaScript and XML）即异步的 JS 和 XML</p>
<p>通过 AJAX 可在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据</p>
<a id="more"></a>

<p>AJAX 不是编程语言，而是一种将现有的标准组合在一起使用的新方式</p>
<p><strong>特点：</strong>可在不刷新网页的情况下向后端发送 http 请求，得到 http 响应，实现懒加载效果（用则加载不用则步加载）提高网页加载速度</p>
<h1 id="二、XML"><a href="#二、XML" class="headerlink" title="二、XML"></a>二、XML</h1><p>XML（）可扩展标记语言</p>
<p>XML 被设计用来传输（如服务器以 XML 形式返回数据给客户端）和存储数据（如可用来保存一些用户数据、订单数据、商品数据等）</p>
<pre><code>&lt;student&gt;
    &lt;name&gt;xxx&lt;/name&gt;
    &lt;age&gt;12&lt;/age&gt;
    &lt;gender&gt;男&lt;/gender&gt;
&lt;/student&gt;</code></pre>
<p>最初 AJAX 在数据交换时使用的是 XML，现在一般使用 JSON 格式</p>
<h2 id="XML-和-HTML-区别"><a href="#XML-和-HTML-区别" class="headerlink" title="XML 和 HTML 区别"></a>XML 和 HTML 区别</h2><p>XML 和 HTML 类似都是由标签组成</p>
<p>不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签，全都是自定义标签，用来表示数据</p>
<p>XML 被设计用来传输和存储数据，而 HTML 用来呈现数据</p>
<h2 id="AJAX-优缺点"><a href="#AJAX-优缺点" class="headerlink" title="AJAX 优缺点"></a>AJAX 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）可无需刷新页面与服务器端进行通信（这是创造 AJAX 的初衷）</p>
<p>（2）允许根据用户事件（如鼠标事件、键盘事件、表单事件、文档事件等）来更新部分页面内容</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>（1）没有浏览历史，不能回退</p>
<p>（2）存在跨域问题（同源）</p>
<p>（3）SEO 不友好，即源码（即响应体）第一次向服务器请求的数据中没有某元素，然后通过 AJAX 向服务端发请求后通过 JS 动态创建元素到页面中，则爬虫爬不到该元素</p>
<h1 id="三、HTTP-协议"><a href="#三、HTTP-协议" class="headerlink" title="三、HTTP 协议"></a>三、HTTP 协议</h1><p>HTTP 协议（hypertext transport protocol）即超文本传输协议，协议详细规定了浏览器和万维网服务器之间互相通信的规则</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报文包括四部分：请求行、请求头、空行、请求体</p>
<p>请求行：请求类型（如 GET/POST/…）、URL、HTTP 协议版本（如 HTTP/1.1）</p>
<p>请求头：Host、Cookie、Content-type、User-Agent</p>
<p>当请求类型为 GET 时请求体为空，为 POST 时请求体可不为空</p>
<pre><code>行  POST /bv?p=123 HTTP/1.1
头  Host: xxx.com
    Cookie: name=xxx
    Content-type: application/x-www-form-urlencoded
    User-Agent: chrome 83
空行
体  username=admin&amp;password=admin</code></pre>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>响应报文包括四部分：行、头、空行、体</p>
<p>响应行：HTTP 协议版本（如 HTTP/1.1）、响应状态码（如 200、301、302、303（301 - 303 重定向到服务器）、304（重定向到缓存）、404 找不到页面、403 Forbidden、401 未授权、500 服务器内部错误等，2xx都表示成功）、响应状态字符串（如 OK，与状态码对应）</p>
<p>响应头（对响应体作描述）：Content-type、Content-length、Content-encoding</p>
<pre><code>行  HTTP/1.1 200 OK
头  Content-type: text/html;charset=utf-8  表示请求体内容的类型
    Content-length: 2048
    Content-encoding: gzip
    ...
空行
体  &lt;html&gt;
        &lt;head&gt;&lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;xxx&lt;/h1&gt;
        &lt;/body&gt;
    &lt;/html&gt;</code></pre>
<h1 id="四、服务端的准备"><a href="#四、服务端的准备" class="headerlink" title="四、服务端的准备"></a>四、服务端的准备</h1><p>AJAX 需要向服务端发请求，所以需要准备服务端环境，安装 Node.js、使用 Express 框架搭建后端</p>
<h2 id="1、Node-js"><a href="#1、Node-js" class="headerlink" title="1、Node.js"></a>1、Node.js</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，是一个可以解析 js 代码的应用程序，通过 js 代码对计算机资源做一些操作</p>
<p>因为 AJAX 的应用当中需要一个服务端，所以需要安装 Node.js</p>
<h2 id="2、Express-框架的简单使用"><a href="#2、Express-框架的简单使用" class="headerlink" title="2、Express 框架的简单使用"></a>2、Express 框架的简单使用</h2><p>Express 是基于 Node.js 平台的 Web 开发框架</p>
<p>在终端</p>
<pre><code>//做初始化，npm 是 Node.js 平台下的包管理工具
npm init --yes  
//安装 express
npm i express</code></pre>
<p>js 代码</p>
<pre><code>//引入 express
const express = require(&#39;express&#39;);
//创建应用对象
const app = express();
//创建路由规则
//当请求头中的 URL 匹配时会执行下方函数中的回调函数
app.get(&#39;/请求头第二个字段URL&#39;,(request,response)=&gt;&#123;  //参数request是对请求报文的封装，response是对响应报文的封装
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<p>在终端启动服务</p>
<pre><code>node 文件名.js</code></pre>
<p>当 js 文件内容发生变化时需重新启动服务</p>
<h2 id="3、nodemon-自动重启服务工具"><a href="#3、nodemon-自动重启服务工具" class="headerlink" title="3、nodemon 自动重启服务工具"></a>3、nodemon 自动重启服务工具</h2><p>当 js 文件改变时 nodemon 可启动重启 node 应用</p>
<p>在终端安装</p>
<pre><code>npm install -g nodemon</code></pre>
<p>安装完 nodemon 后在启动服务需使用</p>
<pre><code>nodemon 文件名.js</code></pre>
<h1 id="五、原生-AJAX"><a href="#五、原生-AJAX" class="headerlink" title="五、原生 AJAX"></a>五、原生 AJAX</h1><h2 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h2><p>步骤：</p>
<p>— 1、创建对象，<code>new XMLHttpRequest()</code></p>
<p>— 2、初始化，<code>xhr.open(&#39;xxx&#39;,&#39;xxx&#39;)</code> 设置请求方法和 url，url 中设置参数 <code>?参数1=值&amp;参数2=值&amp;参数n=值</code></p>
<p>— 3、发送，<code>xhr.send()</code></p>
<p>— 4、事件绑定，<code>xhr.onreadystatechange</code> 处理服务端返回的结果</p>
<p>其中 readyState 是 xhr 对象中的属性，表示状态，有 5 个值：</p>
<pre><code>0（未初始化）
1（open方法已调用完毕）
2（send方法已调用完毕）
3（服务端返回了部分结果）
4（服务端返回了所有结果）</code></pre>
<p>例子（前端部分）</p>
<pre><code>const xhr = new XMLHttpRequest();  //创建对象
xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/server?a=1&amp;b=2&amp;c=3&#39;); //初始化
xhr.send();  //发送
xhr.onreadystatechange = function()&#123;  //事件绑定，会触发四次，0-1，1-2，2-3，3-4
    if(xhr.readyState === 4)&#123;  //服务端返回了所有结果
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;  //判断响应状态码
            //处理结果--行 头 空行 体
            console.log(xhr.status);  //状态码
            console.log(xhr.statusText);  //状态字符串
            console.log(xhr.getAllResponseHeaders());  //所有响应头
            console.log(xhr.response);  //响应体

        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="2、发送-POST-请求"><a href="#2、发送-POST-请求" class="headerlink" title="2、发送 POST 请求"></a>2、发送 POST 请求</h2><p>无参数的 post 请求与 get 类似，参考上面的例子，同时后端也需有相应路径下的 post 方法</p>
<h3 id="post-中设置请求体"><a href="#post-中设置请求体" class="headerlink" title="post 中设置请求体"></a>post 中设置请求体</h3><pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send(&#39;a=1&amp;b=2&amp;c=3&#39;);  //发送，设置请求体，请求体的内容可以任意
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //处理结果
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h3 id="post-中设置请求头"><a href="#post-中设置请求头" class="headerlink" title="post 中设置请求头"></a>post 中设置请求头</h3><p>一般会把身份校验信息放在头信息中</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);  //设置请求头
xhr.send(&#39;a=1&amp;b=2&amp;c=3&#39;);  //发送，设置请求体，请求体的内容可以任意
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //处理结果
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<p>若使用自定义请求头名，此时发送完 post 请求后还会再发送一个 options 请求，需在后端设置</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();   //创建应用对象
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;  //设置 all 方法可接收任意类型的请求
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //设置使所有类型头信息都能接受，从而允许那些自定义的头信息
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h2 id="3、传输-JSON-数据"><a href="#3、传输-JSON-数据" class="headerlink" title="3、传输 JSON 数据"></a>3、传输 JSON 数据</h2><p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();  //创建应用对象
//创建路由规则
app.get(&#39;/请求头第二个字段URL&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置响应头，设置允许跨域
    const data = &#123;
        name:&#39;xxx&#39;
    &#125;
    let str = JSON.stringfy(data);  //将对象进行字符串转换
    response.send(str);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<p>前端方式一：手动对数据转化</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            //方式一：手动对数据转化
            let data = JSON.parse(xhr.response);
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<p>前端方式一：（自动转换）设置响应体数据类型</p>
<pre><code>const xhr = new XMLHttpRequest(); 
//方式二：设置响应体数据类型
xhr.responseType = &#39;json&#39;;
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server&#39;);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="4、IE-缓存问题"><a href="#4、IE-缓存问题" class="headerlink" title="4、IE 缓存问题"></a>4、IE 缓存问题</h2><p>IE 浏览器会缓存 AJAX 的请求结果，下次发相同请求时使用的是本地的缓存结果而不是服务器返回的最新数据，不利于一些时效性要求比较高的场景</p>
<p>解决：</p>
<p>在前端中设置 url 时添加一个时间戳参数来表示每次发送的是不同请求</p>
<pre><code>const xhr = new XMLHttpRequest(); 
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server?t=&#39;+Date.now());  //通过 url 解决 IE 缓存问题
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="5、AJAX-请求超时和网络异常处理"><a href="#5、AJAX-请求超时和网络异常处理" class="headerlink" title="5、AJAX 请求超时和网络异常处理"></a>5、AJAX 请求超时和网络异常处理</h2><p>添加请求超时及网络异常处理，在前端添加</p>
<pre><code>const xhr = new XMLHttpRequest(); 
//设置超过 2s 为超时，则取消请求
xhr.timeout = 2000;
//超时回调
xhr.ontimeout = function()&#123;
    alert(&quot;网络异常，请稍后重试&quot;);
&#125;
//网络异常回调
xhr.onerror = function()&#123;
    alert(&quot;网络出问题了&quot;);
&#125;
xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
            console.log(xhr.response)
        &#125;else&#123;&#125;
    &#125;
&#125;</code></pre>
<h2 id="6、AJAX-取消请求"><a href="#6、AJAX-取消请求" class="headerlink" title="6、AJAX 取消请求"></a>6、AJAX 取消请求</h2><p>通过 xhr 对象的 abort 方法来取消请求 <code>xhr.abort()</code>（xhr 是XMLHttpRequest 对象实例）</p>
<h2 id="7、AJAX-请求重复发送问题"><a href="#7、AJAX-请求重复发送问题" class="headerlink" title="7、AJAX 请求重复发送问题"></a>7、AJAX 请求重复发送问题</h2><p>当服务器响应较慢时，用户可能多次重复发送相同请求，会增加服务器的压力，因此当多次发相同请求时可把前面未响应完成的请求取消</p>
<p>在前端添加一个标识变量来表示是否正在发送请求</p>
<pre><code>let xhr = null;
let isSending = false;  //是否正在发送请求
if(isSending)&#123;  //若正在发送请求，则取消该请求
    xhr.abort();
&#125;
xhr = new XMLHttpRequest(); 
isSending = true;
xhr.open(&#39;GET&#39;,&#39;http://127.0.0.1:8000/server);
xhr.send();
xhr.onreadystatechange = function()&#123;
    if(xhr.readyState === 4)&#123;
        isSending = false;
    &#125;
&#125;</code></pre>
<h1 id="六、jQuery-中使用-AJAX"><a href="#六、jQuery-中使用-AJAX" class="headerlink" title="六、jQuery 中使用 AJAX"></a>六、jQuery 中使用 AJAX</h1><h2 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h2><p><code>$get(url,[请求携带的参数],[载入成功时回调函数],[返回内容格式])</code></p>
<p>其中返回内容格式可以是 xml、html、script、json、text、_default</p>
<pre><code>$.get(&#39;http://127.0.0.1:8000/server&#39;,&#123;a:1,b:2&#125;,function(data)&#123;
    console.log(data)
&#125;,&#39;json&#39;)</code></pre>
<p>若使用 CDN 引入jQuery，在发送请求时出现警告 A cookie associated with a cross-site resource at <a href="http://bootcss.com/">http://bootcss.com/</a> was set without the ‘SameSite’ attibute….</p>
<p>可在引入时添加跨源请求的属性设置 <code>crossorigin=&quot;anonymous&quot;</code>，添加后向对于 src 资源请求时不会带当前域名下的 cookie</p>
<pre><code>&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<h2 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h2><p><code>$post(url,[请求携带的参数],[载入成功时回调函数],[返回内容格式])</code></p>
<pre><code>$.post(&#39;http://127.0.0.1:8000/server&#39;,&#123;a:1,b:2&#125;,function(data)&#123;
    console.log(data)
&#125;,&#39;json&#39;)</code></pre>
<h2 id="通用发送请求的方法"><a href="#通用发送请求的方法" class="headerlink" title="通用发送请求的方法"></a>通用发送请求的方法</h2><p>前端</p>
<pre><code>$.ajax(&#123;
    url: &#39;http://127.0.0.1:8000/server&#39;,
    data: &#123;a:1,b:2&#125;,   //参数
    type: &#39;GET&#39;,       //请求类型
    dataType: &#39;json&#39;,  //响应体结果类型，这样可直接解析json字符串
    success: function(data)&#123;  //成功的回调
        console.log(data);
    &#125;,
    timeout: 2000,  //设置超时时间
    error: function()&#123;  //失败的回调，包括超时、异常等
        console.log(&#39;错误&#39;);
    &#125;,
    headers: &#123;
        c:3,
        d:4
    &#125;
&#125;)</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置允许跨域
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //设置使所有类型头信息都能接受，从而允许那些自定义的头信息
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h1 id="七、axios"><a href="#七、axios" class="headerlink" title="七、axios"></a>七、axios</h1><p>axios 是目前最热门的 AJAX 工具库，也是 Vue 和 React 推荐的 AJAX 工具包</p>
<p>可在项目中使用 <code>npm install axios</code> 安装或使用 <code>&lt;script  crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;&gt;&lt;/script&gt;</code> 引入并使用</p>
<h2 id="get-请求-1"><a href="#get-请求-1" class="headerlink" title="get 请求"></a>get 请求</h2><pre><code>const axios = require(&#39;axios&#39;);  //通过 npm 方式安装需先引入 axios

axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;; //配置 baseURL，也可不配置，都写在请求的 url 里
axios.get(&#39;/server&#39;,&#123;
    params: &#123;  //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;
&#125;).then(value =&gt; &#123;  //数据返回和处理和 jQuery 不同，jQuery 使用回调函数，而 axios 是基于 promise
    console.log(value)
&#125;)</code></pre>
<h2 id="post-请求-1"><a href="#post-请求-1" class="headerlink" title="post 请求"></a>post 请求</h2><p><code>axios.post(url,&#123;请求体&#125;,&#123;其他配置&#125;)</code></p>
<pre><code>axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39;; //配置 baseURL，也可不配置，都写在请求的 url 里
axios.get(&#39;/server&#39;,&#123;
    e:5,       //请求体
    f:6
&#125;,&#123;
    params: &#123;  //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;
&#125;).then(value =&gt; &#123;  //数据返回和处理和 jQuery 不同，jQuery 使用回调函数，而 axios 是基于 promise
    console.log(value)
&#125;)</code></pre>
<h2 id="通用发送请求的方法-1"><a href="#通用发送请求的方法-1" class="headerlink" title="通用发送请求的方法"></a>通用发送请求的方法</h2><pre><code>axios(&#123;
    method: &#39;POST&#39;,
    url: &#39;http://127.0.0.1:8000/server&#39;,
    params: &#123;    //url 参数
        a:1,
        b:2
    &#125;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;,
    data: &#123;       //请求体
        e:5,
        f:6
    &#125;    
&#125;).then(response =&gt; &#123;
    console.log(response)
&#125;)</code></pre>
<h1 id="八、使用-fetch-函数发送请求"><a href="#八、使用-fetch-函数发送请求" class="headerlink" title="八、使用 fetch 函数发送请求"></a>八、使用 fetch 函数发送请求</h1><p>fetch 函数属于全局对象，返回一个 promise 对象，这个 promise 会在请求响应后被 resolve，并传回 Response 对象</p>
<pre><code>fetch(&#39;http://127.0.0.1:8000/server?c=1&#39;,&#123;
    method: &#39;POST&#39;,
    headers: &#123;   //请求头信息
        c:3,
        d:4
    &#125;,
    body: &#39;e=5&amp;f=6&#39;  //请求体，请求体可以是 Blob、BufferSource、Formdata、URLSearchParam 对象或字符串
&#125;).then(response =&gt; &#123;
    return response.text(); //获取响应体结果，不能直接看到响应体结果，需使用 return，若返回的是 json，则使用 return response.json()
&#125;).then(response =&gt; &#123;
    console.log(response)
&#125;)</code></pre>
<h1 id="九、跨域"><a href="#九、跨域" class="headerlink" title="九、跨域"></a>九、跨域</h1><h2 id="1、同源策略"><a href="#1、同源策略" class="headerlink" title="1、同源策略"></a>1、同源策略</h2><p>同源策略（Same-Origin Policy）最早由网景公司提出，是浏览器的一种安全策略</p>
<p>同源即当前网页的 URL 和 AJAX 请求的目标资源的 URL 的协议、域名、端口号完全相同</p>
<p>若违背同源策略就是跨域</p>
<p>AJAX 默认是遵循同源策略的，若不满足同源策略则无法直接发送 AJAX 请求</p>
<p>在同源情况下的请求中 url 可不用加协议、域名、端口（浏览器会自动加上），可简写为 <code>/xxx</code></p>
<h2 id="2、跨域的解决方案"><a href="#2、跨域的解决方案" class="headerlink" title="2、跨域的解决方案"></a>2、跨域的解决方案</h2><h3 id="（1）JSONP"><a href="#（1）JSONP" class="headerlink" title="（1）JSONP"></a>（1）JSONP</h3><p>JSONP（JSON with Padding）是一个非官方的跨域解决方案，只支持 get 请求</p>
<h4 id="JSONP-如何工作"><a href="#JSONP-如何工作" class="headerlink" title="JSONP 如何工作"></a>JSONP 如何工作</h4><p>在网页有一些标签天生具有跨域能力，如 img、link、iframe、script</p>
<p>JSONP 就是利用 script 标签的跨域能力来发送请求的，script 标签发送的是普通的 http 请求而非 ajax 请求，因此可以跨域</p>
<p>JSONP 的返回结果是一个定义好的函数的调用（即 js 代码，不能是字符串等数据），这样浏览器引擎才能解析并执行，若是自定义函数，需在前端代码中定义好，函数中的参数一般放要返回的数据内容</p>
<p>前端</p>
<pre><code>&lt;script&gt;
    function handle(data)&#123;
        console.log(data.a)
    &#125;
&lt;/script&gt;
&lt;script src=&quot;http://127.0.0.1:8000/server&quot;&gt;&lt;/script&gt;</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    const data = &#123;
        a:1
    &#125;
    response.send(&#39;console.log(&#39;xxx&#39;)&#39;);
    //或 response.end(&#39;handle($&#123;str&#125;)&#39;); //end 和 send 差不多，但 end 方法不会加特殊响应头
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h4 id="JSONP-的使用"><a href="#JSONP-的使用" class="headerlink" title="JSONP 的使用"></a>JSONP 的使用</h4><ol>
<li><p>动态创建一个 script 标签</p>
<p> var script = document.createElement(“script”);</p>
</li>
<li><p>设置 script 的 src，设置回调函数</p>
<p> script.src = ‘<a href="http://127.0.0.1:8000/sever&#39;">http://127.0.0.1:8000/sever&#39;</a>;</p>
</li>
<li><p>将 script 插入文档中</p>
<p> document.body.appendChild(script);</p>
</li>
</ol>
<h4 id="jQuery-发送-JSONP-请求"><a href="#jQuery-发送-JSONP-请求" class="headerlink" title="jQuery 发送 JSONP 请求"></a>jQuery 发送 JSONP 请求</h4><p>需在 url 参数中设置 <code>?callback=?</code>，发送请求时 jQuery 会注册一个函数作为 callback 参数的值，后端返回该函数的调用则前端就可以对数据做处理</p>
<p>前端</p>
<pre><code>$.getJSON(&#39;http://127.0.0.1:8000/sever?callback=?&#39;,function(data)&#123;
    console.log(data)
&#125;)</code></pre>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    const data = &#123;
        a:1
    &#125;
    let str = JSON.stringify(data);
    let cb = request.query.callback;
    response.end(&#39;$&#123;cb&#125;($&#123;str&#125;)&#39;)
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
<h3 id="（2）CORS"><a href="#（2）CORS" class="headerlink" title="（2）CORS"></a>（2）CORS</h3><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，CORS 是官方的跨域解决方案</p>
<p>CORS 的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p>
<h4 id="CORS-如何工作"><a href="#CORS-如何工作" class="headerlink" title="CORS 如何工作"></a>CORS 如何工作</h4><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应后会对该响应放行</p>
<p>后端</p>
<pre><code>const express = require(&#39;express&#39;);
const app = express();
app.all(&#39;/server&#39;,(request,response)=&gt;&#123;
    response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;*&#39;);  //设置允许跨域
    //或 response.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://127.0.0.1:5000&#39;);  //仅允许 http://127.0.0.1:5000 的网页可向该服务器发送跨域请求
    response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);  //可接收自定义头信息
    response.setHeader(&#39;Access-Control-Allow-Method&#39;,&#39;*&#39;);  //允许 get、post 等任意方法
    response.send(&#39;xxx&#39;);  //设置响应体
&#125;);
//监听端口启动服务
app.listen(8000,()=&gt;&#123;
    console.log(&quot;服务已启动，正在监听 8000 端口&quot;)
&#125;)</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>ES新特性学习笔记</title>
    <url>/2022/01/07/ES%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、ES-一些背景"><a href="#一、ES-一些背景" class="headerlink" title="一、ES 一些背景"></a>一、ES 一些背景</h1><a id="more"></a>

<p>ECMA（European Computer Manufactures Association）欧洲计算机制造商协会，该组织的目标是评估、开发和认可电信和计算机标准，1994 年后该组织改名为 Ecma 国际</p>
<p>ES（EcmaScript）是脚本语言的规范，是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。 ECMA-262 由 TC39（Technical Committee 39）委员会推进和维护</p>
<p>JavaScript 是 EcmaScript 的一种实现，ES 新特性其实指的是 JavaScript 新特性</p>
<p>ES 新特性语法简洁，功能丰富，框架开发应用（如 Vue、React、Angular）开发过程中需要用到大量的 ES6 新特性语法</p>
<h1 id="二、ES6-语法"><a href="#二、ES6-语法" class="headerlink" title="二、ES6 语法"></a>二、ES6 语法</h1><h2 id="1、let"><a href="#1、let" class="headerlink" title="1、let"></a>1、let</h2><p>特性：</p>
<p>（1）变量不能重复声明，而使用 var 可以重复声明</p>
<p>（2）块级作用域</p>
<p>ES5 中作用域分为全局作用域、函数作用域、eval 作用域（在 ES5 的严格模式中才会出现）</p>
<p>ES6 中引入块级作用域，即变量只在代码块中有效，出代码块就无效了，let 声明变量就是块级作用域</p>
<p>（3）不存在变量提升</p>
<p>不能在变量声明之前使用</p>
<p>（4）不影响作用域链</p>
<p>如函数作用域中没有找到某变量依然会向上一级作用域中找</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(var i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        items[i].style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>上述代码在点击时会报错 items[i] undefined，因为在点击时已经执行完 for 循环，执行点击的回调函数时在函数作用域中没有 i，则去上一级找，在全局下找到 i，并且 i 为 3，因此 items[i] 为 undefined</p>
<p>但若改成</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(var i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        this.style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>上述代码会出现预期效果</p>
<p>或者使用 let 声明变量 i</p>
<pre><code>let items = document.getElementsByClassName(&#39;item&#39;);
for(let i = 0; i &lt; items.length; i++)&#123;
    items[i].onclick = function()&#123;
        items[i].style.background = &#39;red&#39;;
    &#125;
&#125;</code></pre>
<p>此时代码也会出现预期效果，行点击的回调函数时在函数作用域中没有 i，则去上一级找，在代码块中找到相应的 i</p>
<h2 id="2、const-声明常量"><a href="#2、const-声明常量" class="headerlink" title="2、const 声明常量"></a>2、const 声明常量</h2><p>常量就是值不能修改的量</p>
<p>特点：</p>
<p>（1）一定要赋初始值</p>
<p>（2）一般常量名使用大写</p>
<p>（3）常量的值不能修改</p>
<p>（4）块级作用域</p>
<pre><code>&#123;
    const A = &#39;XX&#39;;
&#125;
console.log(A);   //此时会报错</code></pre>
<p>（5）对于数组和对象的元素进行修改不算对常量的修改，不会报错</p>
<p>因为仅对其元素修改并不会影响它保存的地址值</p>
<h2 id="3、变量的解构赋值"><a href="#3、变量的解构赋值" class="headerlink" title="3、变量的解构赋值"></a>3、变量的解构赋值</h2><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这称为解构赋值</p>
<h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><pre><code>const arr = [&#39;12&#39;,&#39;23&#39;,&#39;34&#39;,&#39;45&#39;];
let [a,b,c,d] = arr;  //则 a 为 12，b 为 23，c 为 34，d 为45</code></pre>
<h3 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h3><pre><code>const obj = &#123;
    name: &#39;xxx&#39;;
    age: 12;
    fun: function()&#123;&#125;
&#125;;
let &#123;name,age,fun&#125; = obj;</code></pre>
<h2 id="4、模板字符串"><a href="#4、模板字符串" class="headerlink" title="4、模板字符串"></a>4、模板字符串</h2><p>ES6 中引入新的声明字符串的方式：使用反引号</p>
<p>特点：</p>
<p>（1）内容中可以直接出现换行符</p>
<p>（2）变量拼接</p>
<pre><code>let a = &#39;123&#39;;
let b = `$&#123;a&#125;456`;  //b 为 123456</code></pre>
<h2 id="5、简化对象写法"><a href="#5、简化对象写法" class="headerlink" title="5、简化对象写法"></a>5、简化对象写法</h2><p>ES6 允许在大括号里直接写入变量和函数作为对象的属性和方法</p>
<pre><code>let name = &#39;xxx&#39;;
let fun = function()&#123;&#125;
const obj = &#123;
    name,
    fun,
    fun1()&#123;&#125;  //在 ES5 中是 fun1: function()&#123;&#125;
&#125;</code></pre>
<h2 id="6、箭头函数"><a href="#6、箭头函数" class="headerlink" title="6、箭头函数"></a>6、箭头函数</h2><p>ES6 允许使用箭头（=&gt;）定义函数</p>
<pre><code>//ES5
let fn = function(a,b)&#123;
    return a + b;
&#125;
//ES6
let fn = (a,b) =&gt; &#123;
    return a + b;
&#125;</code></pre>
<p>特性：</p>
<p>（1）this 是静态的，this始终指向函数声明时所在作用域下的 this 值</p>
<pre><code>function getName()&#123;
    console.log(this.name);
&#125;
let getName1 = () =&gt; &#123;
    console.log(this.name);
&#125;
window.name = &#39;aaa&#39;;
const obj = &#123;
    name: &#39;bbb&#39;;
&#125;
getName();  //输出 aaa
getName1();  //输出 aaa
getName.call(obj);  //输出 bbb
getName1.call(obj);  //输出 aaa</code></pre>
<p>（2）不能作为构造函数实例化对象</p>
<pre><code>let Person = (name,age) =&gt; &#123;
    this.name = name;
    this.age = age;
&#125;
let p = new Person(&#39;xx&#39;,12);
console.log(p);    //报错 Person is not a constructor</code></pre>
<p>（3）不能使用 arguments 变量</p>
<pre><code>let fn = () =&gt; &#123;
    console.log(arguments);
&#125;
fn(1,2,3);  //报错 arguments is not defined</code></pre>
<p>（4）箭头函数的简写</p>
<p>省略小括号 ———— 当形参只有一个的时候</p>
<pre><code>let add = n =&gt; &#123;return n+n;&#125;
console.log(add(1));</code></pre>
<p>省略大括号 ———— 当代码体只有一条语句时可省略大括号，此时 return 语句必须省略，语句的执行结果就是函数的返回值</p>
<pre><code>let pow = n =&gt; n * n;
console.log(pow(2));</code></pre>
<h3 id="箭头函数的使用例子"><a href="#箭头函数的使用例子" class="headerlink" title="箭头函数的使用例子"></a>箭头函数的使用例子</h3><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    setTimeout(function()&#123;
        this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>上述代码执行无效，因为定时器回调函数里的 this 指向 window，可改成如下</p>
<pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    let _this = this;
    setTimeout(function()&#123;
        _this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>上述代码可实现相应效果，也可通过箭头函数来解决</p>
<pre><code>let ele = document.getElementById(&#39;div1&#39;);
ele.addEventListener(&quot;click&quot;,function()&#123;
    setTimeout(() =&gt; &#123;
        this.style.background = &#39;red&#39;;
    &#125;,2000)
&#125;)</code></pre>
<p>因为箭头函数中的 this 始终指向 函数声明时作用域下（addEventListener 的回调函数作用域）的 this，因此定时器回调函数中的 this 指向事件元素</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>返回数组中的偶数元素</p>
<pre><code>const arr = [1,2,3,4,5,6]
//不使用箭头函数
const result = arr.filter(function(item)&#123;
    if(item % 2 === 0)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;);
//使用箭头函数
const result = arr.filter(item =&gt; item % 2 === 0)</code></pre>
<p><strong>总结：箭头函数适合与 this 无关的回调，如定时器中回调函数、数组的方法回调；箭头函数不适合与 this 有关的回调，如事件回调（this 一般需要指向事件元素）、对象的方法</strong></p>
<pre><code>var obj = &#123;
    name: &#39;xx&#39;;
    getName: function()&#123;
        this.name;  //这里 this 指向该对象，若使用箭头函数，则 this 指向外层作用域的 this（如 window）
    &#125;
&#125;</code></pre>
<h2 id="7、函数参数的默认值"><a href="#7、函数参数的默认值" class="headerlink" title="7、函数参数的默认值"></a>7、函数参数的默认值</h2><p>ES6 允许给函数参数赋值初始值</p>
<p>（1）形参初始值</p>
<p>具有默认值的参数一般位置要靠后</p>
<p>（2）与解构赋值结合</p>
<pre><code>function connect(&#123;host=&quot;127.0.0.1&quot;,username,password,port&#125;)&#123;&#125;
connect(&#123;
    username:&#39;root&#39;,
    password:&#39;root&#39;,
    port:3306
&#125;)</code></pre>
<h2 id="8、rest-参数"><a href="#8、rest-参数" class="headerlink" title="8、rest 参数"></a>8、rest 参数</h2><p>ES6 引入 rest 参数，形参中通过 <code>...标识符</code> 表示，用于获取函数的实参，返回数组，用来代替 arguments（返回的是对象），并且 rest 参数必须要放到参数最后</p>
<pre><code>function fn(a,b,...args)&#123;
    console.log(args);
&#125;
fn(1,2,3,4,5,6);  //输出数组[3,4,5,6]</code></pre>
<h2 id="9、扩展运算符"><a href="#9、扩展运算符" class="headerlink" title="9、扩展运算符"></a>9、扩展运算符</h2><p>扩展运算符 <code>...</code> 能将数组转换为逗号分隔的参数序列</p>
<pre><code>const arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
function fn()&#123;
    console.log(arguments);
&#125;
fn(arr);  //输出实参数组中只有一个元素，该元素是个数组
fn(...arr);  //输出实参数组中有三个元素，三个元素分别对应 arr 中三个元素</code></pre>
<p>注意 rest 参数是将 <code>...</code> 用在函数形参中，而扩展运算符是用在函数调用的实参中</p>
<p>扩展运算符的应用：</p>
<p>（1）数组的合并</p>
<pre><code>const arr1 = [1,2,3];
const arr2 = [4,5,6];
const arr = [...arr1,...arr2];</code></pre>
<p>（2）数组的克隆</p>
<pre><code>const arr1 = [1,2,3];
const arr2 = [...arr1];  </code></pre>
<p>注意：若元素中有引用类型数据是浅拷贝</p>
<p>（3）将伪数组转为真正的数组</p>
<pre><code>const divs = document.querySelectorAll(&#39;div&#39;);
const divarr = [...divs];</code></pre>
<p>（4）在函数中的使用</p>
<pre><code>function sun(...numbers)&#123;
    return numbers.reduce((preValue,currentValue)=&gt;&#123;
        return preValue + currentValue
    &#125;)
&#125;
console.log(sum(1,2,3,4)); //可求和</code></pre>
<p>（5）构造字面量对象时</p>
<pre><code>let per1 = &#123;name:&#39;xx&#39;,age:18&#125;
let per2 = &#123;...per1&#125;
console.log(...per1); //注意：这样会报错，对象不能展开，但只有外面加花括号&#123;...对象&#125;时可以展开里面的属性进行深拷贝，原对象中属性改变时拷贝的新对象中属性不变
per1.name = &#39;xxx1&#39;;
console.log(per2.name); //per2中 name 属性还是 xx
let per3 = &#123;...per1,name:&#39;xxx2&#39;,sex:&#39;male&#39;&#125;; //这时得到的 per3 是 &#123;name:&#39;xxx2&#39;,age:18,sex:&#39;male&#39;&#125;</code></pre>
<h2 id="10、Symbol"><a href="#10、Symbol" class="headerlink" title="10、Symbol"></a>10、Symbol</h2><p>ES6 引入了新的原始数据类型 Symbol 表示独一无二的值，是一种类似于字符串的数据类型</p>
<p>特点：</p>
<p>（1）Symbol 的值是唯一的，用来解决命名冲突的问题</p>
<p>（2）Symbol 值不能与其他数据进行运算（如加减乘除、拼接、比较等）</p>
<p>（3）Symbol 定义的对象属性不能使用 for…in 循环遍历，但可以使用 Reflect.ownKeys 来获取对象的所有键名</p>
<pre><code>let s1 = Symbol();       //这里把 Symbol 当成函数使用
let s2 = Symbol(&#39;aaa&#39;);  //其中传入的字符串为描述字符串
let s3 = Symbol(&#39;aaa&#39;);
console.log(s2 === s3);  //false
let s4 = Symbol.for(&#39;bbb&#39;);   //这里把 Symbol 当成函数对象，通过该方式创建，可通过描述字符串得出唯一的 Symbol 值
let s5 = Symbol.for(&#39;bbb&#39;); 
console.log(s4 === s5);  //true </code></pre>
<h3 id="通过-Symbol-给对象添加属性-方法"><a href="#通过-Symbol-给对象添加属性-方法" class="headerlink" title="通过 Symbol 给对象添加属性/方法"></a>通过 Symbol 给对象添加属性/方法</h3><p>方式一：</p>
<pre><code>let game = &#123;......&#125;
let methods = &#123;
    up: Symbol(),
    down: Symbol()
&#125;;
game[methods.up] = function()&#123;&#125;
game[methods.down] = function()&#123;&#125;</code></pre>
<p>通过 Symbol 来添加属性或方法更安全，避免与对象可能已存在的属性或方法冲突</p>
<p>方式二：</p>
<pre><code>let game1 = &#123;
    name:&#39;xxx&#39;,
    [Symbol(&#39;up&#39;)]:function()&#123;&#125;,
    [Symbol(&#39;down&#39;)]:function()&#123;&#125;
&#125;</code></pre>
<h3 id="Symbol-内置值"><a href="#Symbol-内置值" class="headerlink" title="Symbol 内置值"></a>Symbol 内置值</h3><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</p>
<p><strong>Symbol.hasInstance</strong></p>
<p>当其他对象使用 instanceof 运算符判断是否为该对象实例时会调用这个方法</p>
<p><strong>Symbol.isConcatSpreadable</strong></p>
<p>对象的 Symbol.isConcatSpreadable 属性是一个布尔值，表示该对象使用 Array.prototype.concat() 时是否可以展开</p>
<p><strong>Symbol.unscopables</strong></p>
<p>该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除</p>
<p><strong>Symbol.match</strong></p>
<p>当执行 str.match(myObject) 时，若该属性存在，会调用它，返回该方法的返回值</p>
<p><strong>Symbol.replace</strong></p>
<p>当该对象被 str.replace(myObject) 方法调用时，会返回该方法的返回值 </p>
<p><strong>Symbol.search</strong></p>
<p>当该对象被 str.search(myObject) 方法调用时，会返回该方法的返回值</p>
<p><strong>Symbol.split</strong></p>
<p>当该对象被 str.split(myObject) 方法调用时，会返回该方法的返回值</p>
<p><strong>Symbol.iterator</strong></p>
<p>对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器</p>
<p><strong>Symbol.toPrimitive</strong></p>
<p>该对象被转为原始类型的值，会调用该方法，返回该对象对应的的原始类型值</p>
<p><strong>Symbol.toStringTag</strong></p>
<p>在该对象上调用 toString 方法时，返回该方法的返回值</p>
<p><strong>Symbol.species</strong></p>
<p>创建衍生对象时，会使用该属性</p>
<h4 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h4><p>Symbol.hasInstance 这一个整体将作为其他普通对象的方法，可扩展对象功能，通过对它的设置可以改变对象在特定场景下的表现结果（其他内置值也是类似道理），当其他对象使用 instanceof 运算符判断是否为该对象实例时会调用这个方法</p>
<pre><code>class Person&#123;
    static [Symbol.hasInstance](param)&#123;
        console.log(param);  //输出 &#123;&#125;
        //return true;
    &#125;
&#125;
let o = &#123;&#125;
console.log(o instanceof Person);  //false，这个返回值会根据 Person 中 [Symbol.hasInstance](param)&#123;&#125; 方法的返回结果改变，若返回 true 则这里会输出 true</code></pre>
<h4 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h4><p>对象的 Symbol.isConcatSpreadable 属性是一个布尔值，表示该对象使用 Array.prototype.concat() 时是否可以展开</p>
<pre><code>const arr = [1,2,3];
const arr2 = [4,5,6];
console.log(arr.concat(arr2));  //输出[1,2,3,4,5,6]
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2));  //输出[1,2,3,[4,5,6]]</code></pre>
<h2 id="11、迭代器"><a href="#11、迭代器" class="headerlink" title="11、迭代器"></a>11、迭代器</h2><p>迭代器（Iterator）是一种接口（就是对象里的一个属性 Symbol.iterator，这是一个函数），为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator 接口就可以完成遍历操作</p>
<p>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要提供 <code>for...of</code> 消费</p>
<p>原生具备 iterator 接口（可用 for of 遍历）的数据有 Array、Arguments、Set、Map、String、TypedArray、NodeList</p>
<p><strong>注意：需要自定义遍历数据时要想到迭代器</strong></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>（1）创建一个指针对象，指向当前数据结构的起始位置</p>
<p>（2）第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p>
<p>（3）接下来不断调用 next 方法，指针一直向后移动，直到指向最后一个成员</p>
<p>（4）每调用 next 方法返回一个包含 value 和 done（布尔值，为 true 表示遍历完成） 属性的对象</p>
<pre><code>const arr = [1,2,3,4]
let iterator = arr[Symbol.iterator]();  //第（1）步
console.log(iterator.next());  //第（2）步，返回&#123;value:1,done:false&#125;
console.log(iterator.next());  //返回&#123;value:2,done:false&#125;
console.log(iterator.next());  //返回&#123;value:3,done:false&#125;
console.log(iterator.next());  //返回&#123;value:4,done:false&#125;
console.log(iterator.next());  //返回&#123;value:undefined,done:true&#125;</code></pre>
<h3 id="for…in-和-for…of区别"><a href="#for…in-和-for…of区别" class="headerlink" title="for…in 和 for…of区别"></a>for…in 和 for…of区别</h3><p>for(let i in items){} 遍历过程中这里的 i 表示键（数组中就是下标 0,1,2,…）</p>
<p>for(let i of items){} 遍历过程中这里的 i 表示值</p>
<h3 id="自定义遍历数据"><a href="#自定义遍历数据" class="headerlink" title="自定义遍历数据"></a>自定义遍历数据</h3><p>要遍历对象 obj 对象内的数组arr</p>
<pre><code>const obj = &#123;
    name:&#39;xx&#39;,
    arr:[1,2,3,4],
    [Symbol.iterator]()&#123;
        let index = 0;
        let _this = this;
        return &#123;  //因为 iterator 工作原理中第一步创建一个指针对象，所以返回需要是一个对象
            next:function()&#123;  //因为 iterator 工作原理中第二步调用对象的 next 方法，所以需要一个 next 方法
                if(index &lt; _this.arr.length)&#123;
                    const result = &#123;value: _this.arr[index], done:false&#125;
                    index++;
                    return result;
                &#125;else&#123;
                    return &#123;value: undefined, done:false&#125;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
for(let o of obj)&#123;
    console.log(o)
&#125;</code></pre>
<h2 id="12、生成器"><a href="#12、生成器" class="headerlink" title="12、生成器"></a>12、生成器</h2><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>异步操作有如文件操作、网络操作（ajax、request）、数据库操作等</p>
<p>在 ES6 之前异步编程是通过纯回调函数实现</p>
<pre><code>function * gen()&#123;
    console.log(&#39;hello&#39;)
&#125;
let iterator = gen();  //返回的是一个迭代器对象
console.log(iterator);   //此处并没有输出 hello
iterator.next();  //输出 hello</code></pre>
<p>在生成器中可以出现 yield 语句</p>
<pre><code>function * gen()&#123;
    console.log(&#39;111&#39;);
    yield &#39;aa&#39;;
    console.log(&#39;222&#39;);
    yield &#39;bb&#39;;
    console.log(&#39;333&#39;);
    yield &#39;cc&#39;;
    console.log(&#39;444&#39;);
&#125;
et iterator = gen();
iterator.next();  //输出 111
iterator.next();  //输出 222
iterator.next();  //输出 333
iterator.next();  //输出 444

function * gen()&#123;
    console.log(&#39;111&#39;);
    yield &#39;aa&#39;;
    console.log(&#39;222&#39;);
    yield &#39;bb&#39;;
    console.log(&#39;333&#39;);
    yield &#39;cc&#39;;
    console.log(&#39;444&#39;);
&#125;
et iterator = gen();
console.log(iterator.next());  //输出&#123;value:&#39;aa&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;bb&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;cc&#39;,done:false&#125;
console.log(iterator.next());  //输出&#123;value:&#39;undefined&#39;,done:true&#125;

for(let g of gen())&#123;
    console.log(g);  //会分别输出aa bb cc
&#125;</code></pre>
<p>next 方法可以传入实参，该实参将作为上一个 yield 语句的返回结果</p>
<pre><code>function * gen(arg)&#123;
    console.log(arg);
    let one = yield 111;
    console.log(one);
    let two = yield 222;
    console.log(two);
    let three = yield 333;
    console.log(three);
&#125;
et iterator = gen(&#39;AAA&#39;);
console.log(iterator.next());  //输出 AAA &#123;value:111,done:false&#125;
console.log(iterator.next(&#39;BBB&#39;));  //输出 BBB &#123;value:222,done:false&#125;
console.log(iterator.next(&#39;CCC&#39;));  //输出 CCC&#123;value:333,done:false&#125;
console.log(iterator.next(&#39;DDD&#39;));  //输出 DDD&#123;value:&#39;undefined&#39;,done:true&#125;</code></pre>
<h3 id="生成器实例"><a href="#生成器实例" class="headerlink" title="生成器实例"></a>生成器实例</h3><h4 id="例子1-1"><a href="#例子1-1" class="headerlink" title="例子1"></a>例子1</h4><p>1s 后控制台输出 111，2s 后输出 222，3s 后输出 333</p>
<p>方式一：使用定时器</p>
<pre><code>setTimeout(() =&gt; &#123;
    console.log(111);
    setTimeout(() =&gt; &#123;
        console.log(222);
        setTimeout(() =&gt; &#123;
            console.log(333);
        &#125;,3000);
    &#125;,2000);
&#125;,1000);</code></pre>
<p>若使用定时器实现会出现回调地狱，一层层不停回调，阅读、调试不方便，且容易重名</p>
<p>方式二：使用生成器</p>
<pre><code>function one()&#123;
    setTimeout(() =&gt; &#123;
        console.log(111);
        iterator.next();
    &#125;,1000)
&#125;
function two()&#123;
    setTimeout(() =&gt; &#123;
        console.log(222);
        iterator.next();
    &#125;,2000)
&#125;
function three()&#123;
    setTimeout(() =&gt; &#123;
        console.log(333);
        iterator.next();
    &#125;,3000)
&#125;
function * gen()&#123;
    yield one();
    yield two();
    yield three();
&#125;
let iterator = gen();
iterator.next();</code></pre>
<h4 id="例子2-1"><a href="#例子2-1" class="headerlink" title="例子2"></a>例子2</h4><p>第一秒获取用户数据，下一秒获取订单数据，下一秒获取商品数据</p>
<pre><code>function getUsers()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;用户数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function getOrders()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;订单数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function getGoods()&#123;
    setTimeout(() =&gt; &#123;
        let data = &#39;商品数据&#39;;
        iterator.next(data);
    &#125;,1000)
&#125;
function * gen()&#123;
    let users = yield getUsers();
    let orders = yield getOrders();
    let goods = yield getGoods();
&#125;
let iterator = gen();
iterator.next();</code></pre>
<h2 id="13、Promise"><a href="#13、Promise" class="headerlink" title="13、Promise"></a>13、Promise</h2><p>Promise 是 ES6 引入的异步编程的新解决方案，语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p>
<p>（1）Promise 构造函数</p>
<p>（2）Promise.prototype.then 方法</p>
<p>（3）Promise.prototype.catch 方法</p>
<pre><code>//实例化 Promise 对象
const p = new Promise(function(resolve,reject)&#123;  //通过 resolve 和 reject 函数改变 Promise 实例对象的状态
    setTimeout(function()&#123;  //把异步任务封装在 Promise 对象中
        let data = &#39;xxx&#39;;
        resolve(data); //调用 resolve 方法后 Promise 实例对象的状态就变为成功
        let err = &#39;错误&#39;;        
        reject(err);  //调用 resolve 方法后 Promise 实例对象的状态就变为失败
    &#125;,1000);
&#125;);
//Promise 实例对象状态改变后调用 then 方法
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value);
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.error(reason);
&#125;)</code></pre>
<h2 id="Promise-封装读取文件"><a href="#Promise-封装读取文件" class="headerlink" title="Promise 封装读取文件"></a>Promise 封装读取文件</h2><p>Promise 读取文件会使用到 Node.js 的 API</p>
<p>使用 fs 模块读取文件的原始方法：</p>
<pre><code>const fs = require(&#39;fs&#39;);
fs.readFile(&#39;./xxx.md&#39;, (err, data) =&gt; &#123;
    if(err) throw err;  //若失败抛出错误
    console.log(data.toString());  //若没有出错输出内容，其中 data 是一个 Buffer
&#125;);</code></pre>
<p>使用 Promise 封装</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    fs.readFile(&#39;./xxx.md&#39;, (err, data) =&gt; &#123;
        if(err) reject(err);
        resolve(data)
    &#125;);
&#125;);
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value.toString());
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.log(&quot;读取失败&quot;);
&#125;)</code></pre>
<h2 id="Promise-封装-AJAX-请求"><a href="#Promise-封装-AJAX-请求" class="headerlink" title="Promise 封装 AJAX 请求"></a>Promise 封装 AJAX 请求</h2><pre><code>const p = new Promise(function(resolve,reject)&#123;
    const xhr = new XMLHttpRequest(); 
    xhr.open(&#39;POST&#39;,&#39;http://127.0.0.1:8000/server);
    xhr.send();
    xhr.onreadystatechange = function()&#123;
        if(xhr.readyState === 4)&#123;
            if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
                resolve(xhr.response)
            &#125;else&#123;
                reject(xhr.status)
            &#125;
        &#125;
    &#125;
&#125;);
p.then(function(value)&#123;  //状态为成功时调用
    console.log(value);
&#125;,function(reason)&#123;     //状态为失败时调用
    consle.error(reason);
&#125;)</code></pre>
<h2 id="Promise-prototype-then-方法"><a href="#Promise-prototype-then-方法" class="headerlink" title="Promise.prototype.then 方法"></a>Promise.prototype.then 方法</h2><p>Promise.prototype.then 方法返回值也是一个 Promise 对象，该返回对象的状态由 then 里的回调函数的执行结果决定</p>
<p>若回调函数中返回的结果是非 Promise 类型的属性，则状态为成功，返回的值为成功时回调函数的返回值</p>
<p>若回调函数中返回 Promise 类型的对象，则内部的该 Promise 对象的返回状态就是外部 then 方法返回的 Promise 对象的状态</p>
<p>若回调函数中抛出错误，则 then 方法返回的 Promise 对象状态也为失败，值为出错的值</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
        let data = &#39;xxx&#39;;
        resolve(data);
    &#125;,1000);
&#125;);
const result = p.then(value =&gt; &#123;
    console.log(value);
    //1、返回非 Promise 类型
    //return 123; //或者直接没有 return 语句返回 undefined
    //2、返回 Promise 对象，则内部的该 Promise 对象的返回状态就是外部 then 方法返回的 Promise 对象的状态
    //return new Promise((resolve,reject)=&gt;&#123;
    //    resolve(&#39;ok&#39;); //外部 then 方法返回的 Promise 对象状态也为成功，且值为 ok
    //&#125;)
    //3、抛出错误，外部 then 方法返回的 Promise 对象状态也为失败，值为出错的值
    //throw new Error(&#39;出错&#39;);
&#125;, reason =&gt; &#123;
    consle.error(reason);
&#125;)</code></pre>
<p>因为 then 方法返回值也是一个 Promise 对象，所以可以进行链式调用，从而杜绝回调地狱</p>
<pre><code>p.then(value =&gt; &#123;

&#125;, reason =&gt; &#123;

&#125;).then(value =&gt;&#123;

&#125;, reason =&gt;&#123;

&#125;)</code></pre>
<h3 id="then-方法的链式调用"><a href="#then-方法的链式调用" class="headerlink" title="then 方法的链式调用"></a>then 方法的链式调用</h3><p>例子：按顺序读三个文件，并把三个文件内容合在一起后做输出</p>
<p>可通过 Promise 读取多个文件，Promise 可解决回调地狱</p>
<pre><code>const p = new Promise((resolve,reject) =&gt; &#123;
    fs.readFile(&#39;./文件1.md&#39;, (err, data) =&gt; &#123;
        resolve(data)
    &#125;);
&#125;);
p.then(value =&gt; &#123;  //状态为成功时调用
    return new Promise((resolve,reject) =&gt; &#123;
        fs.readFile(&#39;./文件2.md&#39;, (err, data) =&gt; &#123;
            resolve([value,data])
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    return new Promise((resolve,reject) =&gt; &#123;
        fs.readFile(&#39;./文件3.md&#39;, (err, data) =&gt; &#123;
            value.push(data);
            resolve(value);
        &#125;);
    &#125;);
&#125;).then(value =&gt; &#123;
    console.log(value.join(&#39;\r\n&#39;));
&#125;)</code></pre>
<h2 id="Promise-prototype-catch-方法"><a href="#Promise-prototype-catch-方法" class="headerlink" title="Promise.prototype.catch 方法"></a>Promise.prototype.catch 方法</h2><p>Promise.prototype.catch 方法其实算是一个语法糖，其实由 then 方法不指定第一个参数结果和 catch 方法一样</p>
<pre><code>const p = new Promise(function(resolve,reject)&#123;
    setTimeout(function()&#123;
        let err = &#39;错误&#39;;        
        reject(err); 
    &#125;,1000);
&#125;);
p.catch(function(reason)&#123;  //只需指定失败的回调
    console.warn(reason);
&#125;)</code></pre>
<h2 id="14、Set"><a href="#14、Set" class="headerlink" title="14、Set"></a>14、Set</h2><p>ES6 提供了新的数据结构 Set（集合），它类似于数组，但成员的值都是唯一的</p>
<p>集合实现了 iterator 接口，所以可使用扩展运算符和 for…of 进行遍历</p>
<p>集合的属性和方法：</p>
<p>size 属性返回会集合元素个数</p>
<p>add(xxx) 增加一个新元素，返回当前集合</p>
<p>delete(xxx) 删除元素，返回 boolean 值</p>
<p>has(xxx) 检测集合中是否包含某个元素，返回 boolean 值</p>
<p>clear() 清空集合中元素</p>
<pre><code>let s1 = new Set();
let s2 = new Set([1,2,3,1])  //会自动去重
console.loge(s2.size);  //输出3
for(let s of s2)&#123;
    console.log(s); //输出 1，2，3
&#125;</code></pre>
<h2 id="集合的使用"><a href="#集合的使用" class="headerlink" title="集合的使用"></a>集合的使用</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let result = [...new Set(arr)]</code></pre>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let result = [...new Set(arr)].filter(item =&gt; &#123;
    let s = new Set(arr1);  //4 5 6
    if(s.has(item))&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;)
//上述代码可简化为let result = [...new Set(arr)].filter(item =&gt; new Set(arr1).has(item));</code></pre>
<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><pre><code>let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let union = [...new Set([...arr,...arr2])]</code></pre>
<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>差集即对交集取反</p>
<pre><code>//arr - arr1
let arr = [1,2,3,4,5,4,3,2,1];
let arr1 = [4,5,6,5,6];
let diff = [...new Set(arr)].filter(item =&gt; !(new Set(arr1).has(item)));</code></pre>
<h2 id="15、Map"><a href="#15、Map" class="headerlink" title="15、Map"></a>15、Map</h2><p>ES6 提供了 Map 数据结构，它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键</p>
<p>Map 也实现了 iterator 接口，所以可使用扩展运算符和 for…of 进行遍历</p>
<p>Map 的属性和方法：</p>
<p>size 属性返回会 Map 元素个数</p>
<p>set(键,值) 增加一个新元素，返回当前 Map</p>
<p>delete(键) 删除元素</p>
<p>get(键) 返回键名对象的键值</p>
<p>has(xxx) 检测 Map 中是否包含某个元素，返回 boolean 值</p>
<p>clear() 清空集合中，返回 undefined</p>
<p>使用 iterator 遍历返回的结果每个元素是个数组 [键,值]</p>
<h2 id="16、class-类"><a href="#16、class-类" class="headerlink" title="16、class 类"></a>16、class 类</h2><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）作为对象的模板。通过 class 关键字可以定义类</p>
<p>基本上 ES6 的 class 可以看作只是一个语法糖，它绝大部分功能 ES5 都能做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>
<p>class 声明类</p>
<p>constructor 定义构造函数初始化</p>
<p>extends 继承父类</p>
<p>super 调用父级构造方法</p>
<p>static 定义静态方法和属性</p>
<p>父类方法可以重写</p>
<pre><code>//ES5 构造类
function Phone (brand,price)&#123;
    this.brand = brand;
    this.price = price;
&#125;
Phone.prototype.call = function()&#123;&#125;
let huawei = new Phone(&#39;华为&#39;,6000);
huawei.call()

//ES6
class Phone&#123;
    constructor(brand,price)&#123;  //构造方法，new 创建实例对象时会自动执行
        this.brand = brand;
        this.price = price;
    &#125;
    call()&#123;  //方法必须使用该语法，不能使用 ES5 中的 call: function()&#123;&#125;
    &#125;
&#125;
let oneplus = new Phone(&#39;1+&#39;,2000);</code></pre>
<h3 id="class-的静态成员"><a href="#class-的静态成员" class="headerlink" title="class 的静态成员"></a>class 的静态成员</h3><p>函数对象和实例对象的属性是不相通的，属于类的属性但不属于类实例的属性这种属性称为静态成员</p>
<p>ES5 中</p>
<pre><code>function Phone (brand,price)&#123;
    this.brand = brand;
    this.price = price;
&#125;
Phone.name = name; //静态成员
Phone.size = size; //静态成员
Phone.prototype.change = function()&#123;&#125;
let nokia = new Phone();
conosle.log(nokia.name);  //报错
console.log(nokia.size);  //报错
nokia.change();  //不报错</code></pre>
<p>ES6 中，通过 static 标注的属性或方法属于类而不属于类实例对象</p>
<pre><code>class Phone&#123;
    //静态属性
    static name = &quot;手机&quot;;
    static change()&#123;&#125;
&#125;
let nokia = new Phone();
conosle.log(nokia.name);  //输出 undefined
console.log(Phone.name);  //输出 手机</code></pre>
<h3 id="class-类对象继承"><a href="#class-类对象继承" class="headerlink" title="class 类对象继承"></a>class 类对象继承</h3><p>ES5 中使用原型链 + 借用构造函数的组合继承，可参考之前的<a href="https://beingjay.com/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/#more">博客中 3.2 部分</a></p>
<p>在 ES6 的 class 中使用 extends 继承父类</p>
<pre><code>//父类
class Phone&#123;
    constructor(brand,price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;
    //父类的成员属性
    call()&#123;
    &#125;
&#125;
//子类
class SmartPhone extends Phone&#123;
    //构造方法
    constructor(brand,price,color,size)&#123;
        super(brand,price);//super 就是父类中 constrctor 方法，通过 super 完成调用，相当于 ES5 中 Phone.call(this,brand,price);
        this.color = color;
        this.size = size;
    &#125;
    photo()&#123;&#125;
&#125;
const xiaomi = new SmartPhone(&#39;xx&#39;,1000,&#39;黑色&#39;,&#39;4.7inch&#39;);
xiaoomi.call();
xiaomi.photo();</code></pre>
<h4 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写"></a>子类对父类方法的重写</h4><pre><code>//父类
class Phone&#123;
    constructor(brand,price)&#123;
        this.brand = brand;
        this.price = price;
    &#125;
    //父类的成员属性
    call()&#123;
        console.log(&#39;call&#39;)
    &#125;
&#125;
//子类
class SmartPhone extends Phone&#123;
    //构造方法
    constructor(brand,price,color,size)&#123;
        super(brand,price);//super 就是父类中 constrctor 方法，通过 super 完成调用，相当于 ES5 中 Phone.call(this,brand,price);
        this.color = color;
        this.size = size;
    &#125;
    photo()&#123;&#125;
    call()&#123;  //重写父类中 call 方法
        console.log(&#39;call1&#39;);
    &#125;
&#125;
const xiaomi = new SmartPhone(&#39;xx&#39;,1000,&#39;黑色&#39;,&#39;4.7inch&#39;);
xiaomi.call();  //输出 call1</code></pre>
<p>注意：在 js 的 class 中子类不能直接调用父类的同名方法，普通成员方法中也不能使用 super() 去调用父类的同名方法</p>
<h3 id="class-中的-getter-和-setter"><a href="#class-中的-getter-和-setter" class="headerlink" title="class 中的 getter 和 setter"></a>class 中的 getter 和 setter</h3><pre><code>class Phone&#123;
    get price()&#123;  //对 price 属性的读取绑定了一个函数，只要读取实例对象里的 price 属性就会执行该函数，函数的返回值就是 price 属性的值
        console.log(&#39;price属性被读取了&#39;)
        return &#39;xxx&#39;
    &#125;
    get price(newVal)&#123;  //对 price 属性的进行赋值时就会调用该函数，且 setter 中必须有一个参数
        console.log(&#39;price属性被修改了&#39;)
    &#125;
&#125;
let s = new Phone();
console.log(s.price);  //，输出 “price属性被读取了” 以及 “xxx”
s.price = &#39;free&#39;;  //输出 “price属性被修改了”</code></pre>
<p>get 的使用场景：get 常用来对对象的动态属性（即属性值是变化的）做封装，如求整数、求平均数时</p>
<p>set：通过 set 可以添加更多的控制和判断，如判断给属性设置的值是否合法（如得是数字，结果传了字符串）若成功则赋值否则不赋值</p>
<h2 id="17、数值扩展"><a href="#17、数值扩展" class="headerlink" title="17、数值扩展"></a>17、数值扩展</h2><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>Number.EPSILON 属性值为 2.2204460492503130808472633361816-16 是 JavaScript 表示的最小精度</p>
<p>若两个数的差值小于 Number.EPSILON 则相等</p>
<pre><code>console.log(0.1 + 0.2 === 0.3)  //false
//0.1 + 0.2 的结果为 0.30000000000000004

function equal(a, b)&#123;
    if(Math.abs(a-b) &lt; Number.EPSILON)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;
console.log(equal(0.1 + 0.2, 0.3))  //true</code></pre>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>二进制 <code>0b</code> 开头，八进制 <code>0o</code> 开头，十六进制 <code>0x</code> 开头</p>
<h3 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite"></a>Number.isFinite</h3><p>Number.isFinite 检测一个数值是否为有限数</p>
<pre><code>console.log(Number.isFinite(100/0))  //false
console.log(Number.isFinite(Infinity))  //false</code></pre>
<h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN"></a>Number.isNaN</h3><p>Number.isNaN 检测一个数值是否为 NaN</p>
<p>在 ES5 中 isNaN() 是个单独的函数，在 ES6 中把它作为 Number 中的一个方法</p>
<pre><code>console.log(Number.isNaN(10))  //false</code></pre>
<h3 id="Number-parseInt-和-Number-parseFloat"><a href="#Number-parseInt-和-Number-parseFloat" class="headerlink" title="Number.parseInt 和 Number.parseFloat"></a>Number.parseInt 和 Number.parseFloat</h3><p>Number.parseInt 和 Number.parseFloat 把字符串转为整数、浮点数</p>
<p>在 ES5 中 parseInt() 和 parseFloat() 是个单独的函数，在 ES6 中也把它们作为 Number 中的一个方法</p>
<pre><code>console.log(Number.parseInt(&#39;10hello&#39;))  //输出 10</code></pre>
<h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><p>Number.isInteger 判断一个数是否为整数</p>
<pre><code>console.log(Number.isInteger(10))  //true</code></pre>
<h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc"></a>Math.trunc</h3><p>Math.trunc 将数字的小数部分抹掉</p>
<pre><code>console.log(Math.trunc(3.5))  //输出 3</code></pre>
<h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign"></a>Math.sign</h3><p>Math.sign 判断一个数为正数、负数还是零，分别输出1、0、-1</p>
<pre><code>console.log(Math.sign(100))  //输出 1
console.log(Math.sign(0))  //输出 0
console.log(Math.sign(-200))  //输出 -1</code></pre>
<h2 id="18、ES6-的对象方法扩展"><a href="#18、ES6-的对象方法扩展" class="headerlink" title="18、ES6 的对象方法扩展"></a>18、ES6 的对象方法扩展</h2><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>Object.is 判断两个值是否完全相等</p>
<pre><code>console.log(Object.is(10,10))  //true
console.log(Object.is(NaN,NaN))  //true
console.log(NaN === NaN)  //false</code></pre>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign(被覆盖的对象,覆盖的对象) 对象的合并，后者会覆盖前者的同名属性，若前者中有后者没有的属性则覆盖后依然存在，若后者有前者没有的属性则不会出现在合并后新对象中</p>
<pre><code>const config1 = &#123;
    host:&#39;localhost&#39;,
    port: 3306,
    name: &#39;root&#39;,
    pass: &#39;root&#39;,
    test: &#39;test&#39;
&#125;
const config2 = &#123;
    host:&#39;http://127.0.0.1&#39;,
    port: 33060,
    name: &#39;root1&#39;,
    pass: &#39;root1&#39;
&#125;
console.log(Object.assign(config1,config2))</code></pre>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf"></a>Object.setPrototypeOf</h3><p>Object.setPrototypeOf(对象实例, 原型对象) 设置原型对象</p>
<p>Object.getPrototypeOf(对象实例) 获取原型对象</p>
<pre><code>const obj1 = &#123;
    name:&#39;xx1&#39;
&#125;
const obj2 = &#123;
    arr: [1,2,3]
&#125;
Object.setPrototypeOf(obj1, obj2);
console.log(Object.getPrototypeOf(obj1)) //会输出 obj2</code></pre>
<h2 id="19、模块化"><a href="#19、模块化" class="headerlink" title="19、模块化"></a>19、模块化</h2><p>模块化是指将一个大的程序文件拆分成许多小的文件，然后将小文件组合起来实现功能</p>
<p>ES6 之前的模块化规范有 </p>
<p>1）CommonJS =&gt; NodeJS、Browserify（浏览器端打包工具）</p>
<p>2）AMD（针对浏览器） =&gt; requireJS</p>
<ol start="3">
<li>CMD（针对浏览器） =&gt; seaJS</li>
</ol>
<p>（左边是规范，右边是实现/产品）</p>
<h3 id="模块化好处"><a href="#模块化好处" class="headerlink" title="模块化好处"></a>模块化好处</h3><p>（1）防止命名冲突</p>
<p>（2）代码复用</p>
<p>（3）高维护性（如不同人员间的修改不冲突，升级只需对某个或某些模块升级）</p>
<h3 id="模块化语法"><a href="#模块化语法" class="headerlink" title="模块化语法"></a>模块化语法</h3><p>export 命令用于规定模块的对外接口，在模块文件中只需在需要暴露的数据或函数前添加 export 即可</p>
<h4 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h4><p>方式一：分别暴露</p>
<pre><code>export let school = &#39;xx&#39;;
export function teach()&#123;&#125;</code></pre>
<p>方式二：统一暴露</p>
<pre><code>let school = &#39;xx&#39;;
function teach()&#123;&#125;
export &#123;school,teach&#125;;</code></pre>
<p>方式三：默认暴露</p>
<pre><code>export default &#123;
    school: &#39;xx&#39;,
    teach: function()&#123;&#125;
&#125;</code></pre>
<h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><p>import 命令用于输入其他模块提供的功能</p>
<h5 id="通过-script-标签引入模块"><a href="#通过-script-标签引入模块" class="headerlink" title="通过 script 标签引入模块"></a>通过 script 标签引入模块</h5><p>方式一：通用的导入方式</p>
<pre><code>//对于分别暴露和统一暴露
&lt;script type=&quot;module&quot;&gt;
    import * as m1 from &quot;./m1.js&quot;
    console.log(m1)
&lt;/script&gt;

//对于默认暴露
&lt;script type=&quot;module&quot;&gt;
    import * as m3 from &quot;./m3.js&quot;
    m3.default.teach();  //注意使用方式
&lt;/script&gt;</code></pre>
<p>方式二：解构赋值形式</p>
<pre><code>//对于分别暴露和统一暴露
&lt;script type=&quot;module&quot;&gt;
    import &#123;school,teach&#125; from &quot;./m1.js&quot;
    import &#123;school as xx,teach&#125; from &quot;./m2.js&quot;
&lt;/script&gt;

//对于默认暴露
&lt;script type=&quot;module&quot;&gt;
    import &#123;default as m3&#125; from &quot;./m3.js&quot;
    m3.default.teach();
&lt;/script&gt;</code></pre>
<p>方式三：简便形式（只能针对默认暴露）</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
    import m3 from &quot;./m3.js&quot;
&lt;/script&gt;</code></pre>
<h5 id="通过入口文件引入模块"><a href="#通过入口文件引入模块" class="headerlink" title="通过入口文件引入模块"></a>通过入口文件引入模块</h5><p>新建一个入口文件 xxx.js，在该文件中对各模块进行引入和做一些操作</p>
<pre><code>import * as m1 from &quot;./m1.js&quot;;
import * as m2 from &quot;./m2.js&quot;;
import * as m3 from &quot;./m3.js&quot;;
console.log(m1);
m2.teach();
m3.default.change();</code></pre>
<p>然后在 html 文件中引入该入口文件</p>
<pre><code>&lt;script src=&quot;./xxx.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></pre>
<h5 id="引入-npm-安装的模块"><a href="#引入-npm-安装的模块" class="headerlink" title="引入 npm 安装的模块"></a>引入 npm 安装的模块</h5><p>和上面一样使用入口文件的方式引入模块，并在入口文件中编写相关操作的代码</p>
<p>如通过 <code>npm i jquery</code> 安装 jquery 包，在入口文件中引入并使用：</p>
<pre><code>import $ from &#39;jquery&#39;; //ES6 中的引入方式，相当于 CommonJS 中 const $ = require(&quot;jquery&quot;);
$(&#39;body&#39;).css(&#39;background&#39;,&#39;red&#39;);</code></pre>
<h3 id="ES6-模块化代码转换"><a href="#ES6-模块化代码转换" class="headerlink" title="ES6 模块化代码转换"></a>ES6 模块化代码转换</h3><p>因为并不是所有浏览器都兼容 ES6 新特性，所以需要对代码进行转换</p>
<p>babel 是一个 JavaScript 编译器，可以把 ES6 代码转换为 ES5</p>
<p>步骤：</p>
<p>（1）安装工具 babel-cli（babel 的命令行工具）、babel-preset-env（预设包，能把最新的 ECMAScript 特性转换为 ES5 语法）、browserify（打包工具）</p>
<pre><code>npm init --yes
npm i babel-cli babel-preset-env browserify -D</code></pre>
<p>-D 为开发依赖，为局部安装</p>
<p>（2）编译</p>
<p>前提：入口js文件、其他js源码放在一个目录下</p>
<pre><code>npx babel js代码文件夹 -d dist/js --presets=babel-preset-env</code></pre>
<p>其中 dist/js 为输出的文件夹</p>
<p>因为这里 babel 是局部安装，所以使用 npx babel 命令，若全局安装可直接使用 babel…</p>
<p>（3）打包</p>
<pre><code>npx browserify dist/js/入口文件.js -o dist/bundle.js</code></pre>
<p>（4）引入编译打包好的文件</p>
<pre><code>&lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;</code></pre>
<h1 id="三、ES7-新特性"><a href="#三、ES7-新特性" class="headerlink" title="三、ES7 新特性"></a>三、ES7 新特性</h1><h2 id="1、Array-prototype-includes"><a href="#1、Array-prototype-includes" class="headerlink" title="1、Array.prototype.includes"></a>1、Array.prototype.includes</h2><p>数组.includes(xxx) 方法用来检测数组中是否包含某个元素，返回布尔值</p>
<h2 id="2、指数操作符"><a href="#2、指数操作符" class="headerlink" title="2、指数操作符"></a>2、指数操作符</h2><p>在 ES7 中引入指数运算符 <code>**</code> 实现幂运算，相当于 Math.pow</p>
<pre><code>console.log(2 ** 10);  //1024</code></pre>
<h1 id="四、ES8-新特性"><a href="#四、ES8-新特性" class="headerlink" title="四、ES8 新特性"></a>四、ES8 新特性</h1><h2 id="1、async-和-await"><a href="#1、async-和-await" class="headerlink" title="1、async 和 await"></a>1、async 和 await</h2><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 函数的返回值为 promise 对象，promise 对象的结果由 async 函数执行的返回值决定</p>
<p>async 函数里 return 一个非 Promise 类型的值结果都是一个 Promise 对象，对象的值为 return 的相应的值</p>
<p>并且只要 async 函数 return 的不是一个 Promise 类型对象，都会返回成功的状态，即返回一个成功的 Promise 对象</p>
<p>若在 async 函数中抛出错误，则会返回一个失败的 Promise 对象</p>
<p>若在 async 函数中返回一个 Promise 对象，若 Promise 对象是成功的，则 async 函数也是成功的，且返回的 Promise 中 resolve 的值即为 async 函数返回对象成功的值，若 Promise 对象是失败的，则 async 函数也是失败的</p>
<pre><code>//return 一个非 Promise 类型的对象
async function fn1()&#123;
    return; //只要这里 return 的不是一个 Promise 类型对象，最后函数执行完都会返回一个成功的 Promise 对象
&#125;
//抛出错误
async function fn2()&#123;
    throw new Error(&#39;出错&#39;); //函数执行完会返回一个失败的 Promise 对象
&#125;
//return一个 Promise 对象
async function fn3()&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        resolve(&#39;成功&#39;);  //fn3 返回的结果也是成功的
    &#125;)
&#125;
//return一个 Promise 对象
async function fn4()&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        reject(&#39;失败&#39;);  //fn3 返回的结果也是失败的
    &#125;)
&#125;
const result = fn3();
result.then(value=&gt;&#123;
    console.log(value);  //输出 “成功”
&#125;,reason=&gt;&#123;
    console.log(reason);
&#125;)</code></pre>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await 必须写在 async 函数中，但 async 中可以没有 await</p>
<p>await 右侧的表达式一般为 promise 对象，await 返回的是 promise 成功的值，await 的 promise 失败了就会抛出异常，需要通过 try…catch 捕获处理</p>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
    resolve(&quot;xxxx&quot;)
&#125;)
async function main() &#123;
    try&#123;
        let result = await p;
        console.log(result);  //输出的就是 p 成功时的 xxx
    &#125;catch(e)&#123;
        console.log(e)
    &#125;
&#125;
main();</code></pre>
<h3 id="async-和-await-结合读取文件"><a href="#async-和-await-结合读取文件" class="headerlink" title="async 和 await 结合读取文件"></a>async 和 await 结合读取文件</h3><p>分别读取 3 个文件并输出</p>
<pre><code>const fs = require(&#39;fs&#39;);
function fn1()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件1.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

function fn2()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件2.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

function fn3()&#123;
    return new Promise(function(resolve,reject)&#123;
        fs.readFile(&#39;./文件3.md&#39;, (err, data) =&gt; &#123;
            if(err) reject(err);
            resolve(data)
        &#125;);
    &#125;);
&#125;

async function main()&#123;
    let data1 = await fn1();
    let data2 = await fn2();
    let data3 = await fn3();
    console.log(data1.toString());
    console.log(data2.toString());
    console.log(data3.toString());
&#125;
main();</code></pre>
<h3 id="async-和-await-结合发送-AJAX-请求"><a href="#async-和-await-结合发送-AJAX-请求" class="headerlink" title="async 和 await 结合发送 AJAX 请求"></a>async 和 await 结合发送 AJAX 请求</h3><pre><code>function fn(url)&#123;
    return new Promise(function(resolve,reject)&#123;
        const xhr = new XMLHttpRequest(); 
        xhr.open(&#39;GET&#39;,url);
        xhr.send();
        xhr.onreadystatechange = function()&#123;
            if(xhr.readyState === 4)&#123;
                if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;
                    resolve(xhr.response)
                &#125;else&#123;
                    reject(xhr.status)
                &#125;
            &#125;
        &#125;
    &#125;);
&#125;

async function main()&#123;
    let result = await fn(&#39;http://127.0.0.1/server&#39;);
    console.log(result);
&#125;
main();</code></pre>
<p>注意：axios 发送 AJAX 请求的返回结果就是一个 Promise 对象，所以通过 axios 发送请求，并利用 await 接收结果非常方便</p>
<h2 id="2、ES8-中对象方法的扩展"><a href="#2、ES8-中对象方法的扩展" class="headerlink" title="2、ES8 中对象方法的扩展"></a>2、ES8 中对象方法的扩展</h2><h3 id="Object-value-和-Object-entries"><a href="#Object-value-和-Object-entries" class="headerlink" title="Object.value 和 Object.entries"></a>Object.value 和 Object.entries</h3><p>Object.values() 方法返回一个给定对象的所有可枚举属性值的数组</p>
<p>Object.entries() 方法返回一个给定对象的自身可遍历属性的数组，数组中每个元素又是一个数组 [key,value]</p>
<pre><code>const obj = &#123;
    name: &#39;xx&#39;,
    arr1:[1,2,3]
&#125;
console.log(Object.entries(obj));  //输出 [[&#39;name&#39;, &#39;xx&#39;],[&#39;arr&#39;,[1,2,3]]]
const m = new Map(Object.entries(obj));
conosle.log(m.get(&#39;arr1&#39;));  //输出 [1,2,3]</code></pre>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>Object.getOwnPropertyDescriptors 返回指定对象所有自身属性的描述对象，通过描述对象可以对对象进行深拷贝</p>
<h1 id="五、ES9-新特性"><a href="#五、ES9-新特性" class="headerlink" title="五、ES9 新特性"></a>五、ES9 新特性</h1><h2 id="1、ES9-的扩展运算符与-rest-参数"><a href="#1、ES9-的扩展运算符与-rest-参数" class="headerlink" title="1、ES9 的扩展运算符与 rest 参数"></a>1、ES9 的扩展运算符与 rest 参数</h2><p>rest 参数与 spread 扩展运算符在 ES6 中已经引入，但是 ES6 中只针对数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p>
<pre><code>function connect(&#123;host,port,...user&#125;)&#123;
    console.log(user)  //除了 host 和 port 以外的参数都会存到 user 中，user 是个对象
&#125;
connect(&#123;
    host:&#39;127.0.0.1&#39;,
    port:3306,
    username: &#39;root&#39;,
    password:&#39;root&#39;,
    type:&#39;master&#39;
&#125;)


const obj1 = &#123;att1:&#39;1&#39;&#125;
const obj2 = &#123;att2:&#39;2&#39;&#125;
const obj3 = &#123;att3:&#39;3&#39;&#125;
const obj = &#123;...obj1,...obj2,...obj3&#125; //把三个对象中的属性都合并到对象 obj 中</code></pre>
<h2 id="2、ES9-的正则扩展"><a href="#2、ES9-的正则扩展" class="headerlink" title="2、ES9 的正则扩展"></a>2、ES9 的正则扩展</h2><h3 id="命名捕获分组"><a href="#命名捕获分组" class="headerlink" title="命名捕获分组"></a>命名捕获分组</h3><p>命名捕获分组就是可以给分组匹配的结果命名，方便对结果进行处理</p>
<pre><code>let str = &#39;&lt;a href=&quot;http://127.0.0.1&quot;&gt;标签文本&lt;/a&gt;&#39;
//没有命名捕获分组时
const reg = /&lt;a href=&quot;(.*)&quot;&gt;(.*)&lt;\/a&gt;/;
const result = reg.exec(str);
console.log(result);  //result 是个数组，result[0]是str，result[1]是 “http://127.0.0.1”，result[2]是 “标签文本”

//有命名捕获分组时
const reg = /&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;
const result = reg.exec(str);
console.log(result);  //result 中有个 groups 对象属性，该属性中有 url 和 text
console.log(result.groups.url);  //http://127.0.0.1
console.log(result.groups.text); //标签文本</code></pre>
<h3 id="反向断言"><a href="#反向断言" class="headerlink" title="反向断言"></a>反向断言</h3><p>断言：可以根据目标内容的前边和后边来做唯一性识别</p>
<p>正向断言：根据当前匹配的后边的内容来判断匹配的内容是否合法</p>
<pre><code>let str = &#39;JS12345哈哈哈789啦啦啦&#39;
//正向断言：提取789
const reg = /\d+(?=啦)/;  //通过789后边跟着 “啦” 判断
const result = reg.exec(str);</code></pre>
<p>反向断言：根据当前匹配的前边的内容来判断匹配的内容是否合法</p>
<pre><code>let str = &#39;JS12345哈哈哈789啦啦啦&#39;
//反向断言：提取789
const reg = /(?&lt;=哈)\d+/;  //通过789前边跟着 “哈” 判断
const result = reg.exec(str);</code></pre>
<h3 id="dotAll-模式"><a href="#dotAll-模式" class="headerlink" title="dotAll 模式"></a>dotAll 模式</h3><p>dot即 <code>.</code>，<code>.</code> 是元字符，表示除换行符以外的任意单个字符</p>
<p>通过添加模式修正符 <code>\\s</code> 可使 <code>.</code> 匹配任意字符，包括空格和换行，若用模式修正符 <code>\\gs</code> 则会全局匹配，这样方便通配可能出现多个空格多个换行的情况</p>
<p>例子：提取 a 标签和 p 标签中标签文本</p>
<pre><code>let str = `&lt;ul&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
            &lt;/ul&gt;`;
//没有使用dotAll
const reg = /&lt;li&gt;\s+&lt;a&gt;(.*?)&lt;\/a&gt;\s+&lt;p&gt;(.*?)&lt;\/p&gt;/;
const result = reg.exec(str);
console.log(result);
//使用dotAll
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;  //加 ? 是为了禁止贪婪
let result;
let data = [];
while(result = reg.exec(str))&#123;
    console.log(result);  //当匹配不到时是 NaN
    data.push(&#123;a:result[1],p:result[2]&#125;)
&#125;
console.log(data)</code></pre>
<h1 id="六、ES10-新特性"><a href="#六、ES10-新特性" class="headerlink" title="六、ES10 新特性"></a>六、ES10 新特性</h1><h2 id="1、ES10-的对象扩展方法-————-Object-fromEntries"><a href="#1、ES10-的对象扩展方法-————-Object-fromEntries" class="headerlink" title="1、ES10 的对象扩展方法 ———— Object.fromEntries"></a>1、ES10 的对象扩展方法 ———— Object.fromEntries</h2><p>Object.fromEntries 用于创建对象，参数为二维数组或 Map</p>
<pre><code>const result = Object.fromEntries([
    [&#39;name&#39;,&#39;xx&#39;],
    [&#39;arr&#39;,&#39;1,2,3,4&#39;]
])
const m = new Map()
m.set(&#39;name&#39;,&#39;xxx&#39;)
const result = Object.fromEntries(m);</code></pre>
<p>ES8 中 Object.entries 可将对象转化为二维数组</p>
<pre><code>cosnt arr = Object.entries(&#123;
    name: &#39;xxx&#39;
&#125;);  //返回一个数组，第一个元素为键名，第二个元素为键值</code></pre>
<p>因此 Object.fromEntries 和 Object.entries 相当于逆运算，前者将二维数组转化为对象，后者将对象转化为二维数组</p>
<h2 id="2、ES10-的字符串扩展方法-————-trimStart-和-trimEnd"><a href="#2、ES10-的字符串扩展方法-————-trimStart-和-trimEnd" class="headerlink" title="2、ES10 的字符串扩展方法 ———— trimStart 和 trimEnd"></a>2、ES10 的字符串扩展方法 ———— trimStart 和 trimEnd</h2><p>trimStart 和 trimEnd 用于指定清除字符串左侧或右侧空白字符</p>
<pre><code>let str = &#39;   hello   &#39;
console.log(str.trimStart());
console.log(str.trimEnd());</code></pre>
<h2 id="3、ES10-的数组扩展方法-————-flat-和-flatMap"><a href="#3、ES10-的数组扩展方法-————-flat-和-flatMap" class="headerlink" title="3、ES10 的数组扩展方法 ———— flat 和 flatMap"></a>3、ES10 的数组扩展方法 ———— flat 和 flatMap</h2><p>flat(深度) 能将多维数组转化为低维数组，深度默认是 1</p>
<pre><code>const arr = [1,2,3,[4,5,6]];  //二维数组
console.log(arr.flat());  //输出[1,2,3,4,5,6]
const arr = [1,2,3,[4,5,6,[7,8,9]]];  //三维数组
console.log(arr.flat()); //输出二维数组[1,2,3,4,5,6,[7,8,9]]
console.log(arr.flat(2)); //输出一维数组[1,2,3,4,5,6,7,8,9]</code></pre>
<p>flatMap 是对 Map 结果作维度降低</p>
<pre><code>const arr1 = [1,2,3,4];
const result = arr1.map(item =&gt; item * 10);
console.log(result); //输出[10,20,30,40]

const result = arr1.map(item =&gt; [item * 10]);
console.log(result); //输出二维数组[[10],[20],[30],[40]]

const result = arr1.flatMap(item =&gt; [item * 10]);
console.log(result); //输出一维数组[10,20,30,40]</code></pre>
<h2 id="4、ES10-的-Symbol-扩展方法-————-Symbol-prototype-description"><a href="#4、ES10-的-Symbol-扩展方法-————-Symbol-prototype-description" class="headerlink" title="4、ES10 的 Symbol 扩展方法 ———— Symbol.prototype.description"></a>4、ES10 的 Symbol 扩展方法 ———— Symbol.prototype.description</h2><pre><code>let s = Symbol(&#39;hello&#39;);
console.log(s.description);  //输出 hello</code></pre>
<h1 id="七、ES11-新特性"><a href="#七、ES11-新特性" class="headerlink" title="七、ES11 新特性"></a>七、ES11 新特性</h1><h2 id="1、私有属性"><a href="#1、私有属性" class="headerlink" title="1、私有属性"></a>1、私有属性</h2><p>私有属性在类的外部无法得到其结果，只能通过类内的方法来访问</p>
<pre><code>class Person&#123;
    //公有属性
    name;
    //私有属性
    #age;
    #weight;
    //构造方法
    constructor(name,age,weight)&#123;
        this.name = name;
        this.#age = age;
        this.#weight = weight;    
    &#125;
    intor()&#123;
        console.log(this.name);
        console.log(this.#age);
        console.log(this.#weight);
    &#125;
&#125;
const girl = new Person(&#39;xxx&#39;,18,&#39;50kg&#39;);
console.log(girl.#age);  //报错 Private field &#39;#age&#39; must be declared in an enclosing class
girl.intro();  //不报错</code></pre>
<h2 id="2、Promise-allSettled"><a href="#2、Promise-allSettled" class="headerlink" title="2、Promise.allSettled"></a>2、Promise.allSettled</h2><p>Promise.allSettled 接收 Promise 数组，总是返回成功的 Promise 对象，成功的值是个数组，数组中每个元素是对象{status,value 或 reason}</p>
<pre><code>const p1 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据1&#39;);
    &#125;,1000)
&#125;);
const p2 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据2&#39;);
    &#125;,1000)
&#125;);
const result = Promise.allSettled([p1,p2]);
console.log(result);</code></pre>
<p>类似的方法有 Promise.all，也是接收 Promise 数组，返回 Promise 对象，但返回的 Promise 对象是否为成功由数组中每个 Promise 对象的状态决定，只要有一个 Promise 对象失败则 all 方法返回的 Promise 对象也是失败</p>
<p>all 方法成功的值为数组，数组中的元素是接收的 Promise 对象成功的值，all 方法失败的值为接收的 Promise 对象中失败的那个的失败的值</p>
<pre><code>const p1 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据1&#39;);
    &#125;,1000)
&#125;);
const p2 = new Promise((resolve,reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        resolve(&#39;商品数据2&#39;);
    &#125;,1000)
&#125;);
const result = Promise.all([p1,p2]);</code></pre>
<h2 id="3、ES11-的字符串扩展方法-————-Sting-prototype-matchAll"><a href="#3、ES11-的字符串扩展方法-————-Sting-prototype-matchAll" class="headerlink" title="3、ES11 的字符串扩展方法 ———— Sting.prototype.matchAll"></a>3、ES11 的字符串扩展方法 ———— Sting.prototype.matchAll</h2><p>Sting.prototype.matchAll 用于得到正则批量匹配的结果</p>
<pre><code>let str = `&lt;ul&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a&gt;xxx&lt;/a&gt;
                    &lt;p&gt;xxx&lt;/p&gt;
                &lt;/li&gt;
            &lt;/ul&gt;`;
const reg = /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;
const result = str.matchAll(reg); //返回的结果是一个可迭代对象
for(let v of result)&#123;  //或者使用扩展运算符 const arr = [...result];
    console.log(v);
&#125;</code></pre>
<h2 id="4、可选链操作符"><a href="#4、可选链操作符" class="headerlink" title="4、可选链操作符"></a>4、可选链操作符</h2><p>可选链操作符 <code>?.</code>，当面对对象类型的参数时，若对象深度较深，则通过可选链操作符后无需作层级判断</p>
<p>例子：获取 db 中的 host</p>
<pre><code>function main(config)&#123;
    //原先的方法
    const dbHost = config &amp;&amp; config.db &amp;&amp; config.db.host; //但是当没有db对象或 db 中没有 host 属性时会报错
    //使用可选链操作符
    const dbHost = config?.db?.host;  //此时若没有db对象或 db 中没有 host 属性时也不会报错会输出 undefined，只有当前的属性存在时才会读后面的属性
&#125;
main(&#123;
    db: &#123;
        host:&#39;192.168.1.100&#39;
        username: &#39;root&#39;
    &#125;,
    cache: &#123;
        host:&#39;192.168.1.200&#39;
        username: &#39;admin&#39;
    &#125;
&#125;)</code></pre>
<h2 id="5、动态-import"><a href="#5、动态-import" class="headerlink" title="5、动态 import"></a>5、动态 import</h2><p>通过动态 import 可实现按需加载，提高加载效率，import 方法返回的是 Promise 对象，语法：<code>import(文件).then(module =&gt; &#123;&#125;)</code></p>
<pre><code>//文件hello.js
export function hello()&#123;
    alert(&#39;hello&#39;);
&#125;
//入口文件app.js
//在 ES11 之前使用 import * as m1 from &#39;./hello.js&#39; 静态导入模块
cosnt btn = document.getElementById(&#39;#btn&#39;);
btn.onclick = function()&#123;
    //ES11 中动态导入模块
    import(&#39;./hello.js&#39;).then(module =&gt; &#123;
        module.hello();
    &#125;)
&#125;</code></pre>
<h2 id="6、ES11-引入的数据类型-————-BigInt"><a href="#6、ES11-引入的数据类型-————-BigInt" class="headerlink" title="6、ES11 引入的数据类型 ———— BigInt"></a>6、ES11 引入的数据类型 ———— BigInt</h2><p>大整型通过 <code>整数n</code> 表示</p>
<p>通过 BigInt() 函数可将整数转为大整型</p>
<pre><code>let n = 123;
console.log(BigInt(n));  //输出 123n</code></pre>
<p>BigInt() 函数可用于大数值运算，注意 BigInt 类型数据不能直接和普通 int 作运算</p>
<pre><code>let max = NUMBER.MAX_SAFE_INTEGER;
console.log(max);  //9007199254740991
console.log(max + 1);  //9007199254740992
console.log(max + 2);  //9007199254740992

console.log(BinInt(max));  //9007199254740991n
console.log(BinInt(max) + BigInt(1));  //9007199254740992n
console.log(BinInt(max) + BigInt(2));  //9007199254740993n</code></pre>
<h2 id="7、绝对全局对象-globalThis"><a href="#7、绝对全局对象-globalThis" class="headerlink" title="7、绝对全局对象 globalThis"></a>7、绝对全局对象 globalThis</h2><p>globalThis 始终指向全局对象，无论执行环境是什么（如浏览器、Nodejs 等）</p>
<pre><code>//在浏览器中
console.log(globalThis);  //window 对象
//在 Nodejs 中
console.log(globalThis);  //输出 Object [global]</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>AngularJS学习笔记</title>
    <url>/2022/01/12/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、AngularJS"><a href="#一、AngularJS" class="headerlink" title="一、AngularJS"></a>一、AngularJS</h1><a id="more"></a>

<p>AngularJS 是谷歌开源的前端 JS 结构化框架，<a href="https://angularjs.org/">官网</a></p>
<p>为了方便开发可安装 chrome 插件 ng-inspector</p>
<p>AngularJS 版本有 1.x、2.x、4.x，其中 1.x 是基于 JavaScript，2.x、4.x 是基于 typescript，4.x 是在 2.x 基础上扩展的</p>
<h2 id="1、AngularJS-的特性和优点"><a href="#1、AngularJS-的特性和优点" class="headerlink" title="1、AngularJS 的特性和优点"></a>1、AngularJS 的特性和优点</h2><p>（1）双向数据绑定</p>
<p>（2）声明式依赖注入</p>
<p>（3）解耦应用逻辑，数据模型和视图</p>
<p>（4）完善的页面指令</p>
<p>（5）定制表单验证</p>
<p>（6）Ajax 封装</p>
<h2 id="2、AngularJS-和-jQuery-的比较"><a href="#2、AngularJS-和-jQuery-的比较" class="headerlink" title="2、AngularJS 和 jQuery 的比较"></a>2、AngularJS 和 jQuery 的比较</h2><p>jQuery 是 JS 函数库，作用是封装简化 DOM 操作</p>
<p>angular 是 JS 结构化框架，主体不再是 DOM ，而是页面中的动态数据</p>
<h2 id="3、AngularJS-应用场景"><a href="#3、AngularJS-应用场景" class="headerlink" title="3、AngularJS 应用场景"></a>3、AngularJS 应用场景</h2><p>AngularJS 用于构建单页面（SPA）Web 应用或 Web App 应用，如<a href="https://www.ele.me/home/">饿了么</a>、<a href="https://wx.qq.com/">微信网页版</a>、<a href="https://zhuanlan.zhihu.com/Weekly">知乎周报</a>、后台管理应用（如阿里云、土豆后台、唯品会等）</p>
<p>单页面应用 SPA（Single Page Application）特点：</p>
<p>— 将所有活动局限于一个页面</p>
<p>— 当页面中有部分数据发生变化时不会刷新整个页面，而是局部刷新</p>
<p>— 利用的是 ajax 技术、路由</p>
<h1 id="二、AngularJS-语法"><a href="#二、AngularJS-语法" class="headerlink" title="二、AngularJS 语法"></a>二、AngularJS 语法</h1><h2 id="1、hello-world"><a href="#1、hello-world" class="headerlink" title="1、hello world"></a>1、hello world</h2><p>例子：输入框中输入的文本在下方实时显示</p>
<pre><code>&lt;body ng-app&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;
    &lt;p&gt;&lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt;&lt;/p&gt;
    &lt;script src=&quot;./angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;    </code></pre>
<p>ng-app 指令：告诉 angular 核心它管理当前标签所包含的整个区域，并会自动创建 $rootScope 根作用域对象</p>
<p>ng-model 指令：ng-model 指向属性名，将当前输入框的值与当前作用域对象关联（属性名：属性值），并作为当前作用域对象（$rootScope）的属性</p>
<p><code>&#123;&#123; &#125;&#125;</code> 表达式：显示数据，从当前作用域对象的指定属性名上获取，只能用于显示不能操作更改</p>
<h2 id="2、双向数据绑定"><a href="#2、双向数据绑定" class="headerlink" title="2、双向数据绑定"></a>2、双向数据绑定</h2><p>数据绑定：数据从一个地方 A 转移（传递）到另一个地方 B，且该操作由框架完成</p>
<p>双向数据绑定：数据可以从 View（视图层）流向 Model（模型），也可以从 Model 流向 View</p>
<p>— 视图（View）：就是页面（主要是 angular 指令和表达式）</p>
<p>— 模型（Model）：作用域对象，它可以包含一些属性或方法</p>
<p>— 当改变 View 中的数据，Model 对象的对于属性也会随之改变：ng-model 指令数据从 View ==&gt; Model</p>
<p>— 当 Model 域对象的属性发生改变时，页面对象数据随之更新：<code>&#123;&#123; &#125;&#125;</code> 表达式数据从 Model ==&gt; View</p>
<p>— ng-model 是双向数据绑定（View &lt;==&gt; Model），而 <code>&#123;&#123; &#125;&#125;</code> 是单向数据绑定（Model ==&gt; View）</p>
<p>ng-init 用来初始化当前作用域变量，是单向数据绑定（View ==&gt; Model）</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>两个输入框，每个输入框下显示输入框中的文本，更改其中一个输入框，另一个输入框以及两个输入框下的文本都改变，初始时输入框和文本为 “xxx”</p>
<pre><code>&lt;body ng-app ng-init=&quot;username=&#39;xxx&#39;&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;
    &lt;p&gt;&#123;&#123;username&#125;&#125;&lt;/p&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;
    &lt;p&gt;&#123;&#123;username&#125;&#125;&lt;/p&gt;
    &lt;script src=&quot;./angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;    </code></pre>
<h2 id="3、依赖注入"><a href="#3、依赖注入" class="headerlink" title="3、依赖注入"></a>3、依赖注入</h2><p>依赖对象：完成某个特定功能需要某个对象才能实现，该对象就是依赖对象</p>
<p>依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是声明式依赖注入</p>
<p>注意：形参必须是特定的名称，否则 angular 无法注入，抛出异常</p>
<p>angular 的 <code>$scope</code> 对象就是依赖对象，并且是依赖注入的形式进行使用</p>
<p>回调函数的 event 就是依赖对象，回调函数有形参就是依赖注入</p>
<h1 id="三、三个重要对象"><a href="#三、三个重要对象" class="headerlink" title="三、三个重要对象"></a>三、三个重要对象</h1><h2 id="1、作用域对象与控制器对象"><a href="#1、作用域对象与控制器对象" class="headerlink" title="1、作用域对象与控制器对象"></a>1、作用域对象与控制器对象</h2><h3 id="作用域对象"><a href="#作用域对象" class="headerlink" title="作用域对象"></a>作用域对象</h3><p>作用域对象是一个 js 实例对象，ng-app 指令默认会创建一个根作用域对象（$rootScope）</p>
<p>它的属性和方法与页面中的指令或表达式是关联的</p>
<h3 id="控制器对象"><a href="#控制器对象" class="headerlink" title="控制器对象"></a>控制器对象</h3><p>控制器对象用来控制 AngularJS 应用数据的实例对象的</p>
<p>ng-controller：指定控制器构造函数，Angular 会自动 new 此函数创建控制器对象</p>
<p>同时 Angular 还有创建一个新的作用域对象 $scope，它是 $rootScope 的子对象</p>
<p>在控制器函数中声明 $scope 形参，Angular 会自动将 $scope 对象传入</p>
<pre><code>&lt;body ng-app ng-init=&quot;age=12&quot;&gt;
    &lt;div ng-controller=&quot;MyController&quot;&gt;
        &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;
        &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;
        &lt;p&gt;&#123;&#123;firstName + '-' + lastName&#125;&#125;&lt;/p&gt;
        &lt;p&gt;&#123;&#123;getName()&#125;&#125;&lt;/p&gt;
        &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //老版本 angular 生成作用域对象的方式
        function MyController($scope)&#123;  //形参必须是$scope
            $scope.firstName = &#39;aa&#39;;
            $scope.lastName = &#39;bb&#39;;
            $scope.getName = function()&#123;
                return this.firstName + &#39; &#39; + this.lastName;  //也可以是 $scope.firstName + &#39; &#39; + $scope.lastName
            &#125;
        &#125;
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h2 id="2、模块与控制器对象"><a href="#2、模块与控制器对象" class="headerlink" title="2、模块与控制器对象"></a>2、模块与控制器对象</h2><p><code>angular.module</code> 可在全局创建、注册、获取 Angular 模块，所有模块（angular 核心或第三方）都必须使用这个机制注册才能在应用中生效</p>
<p>模块对象可链式调用，<code>模块对象.controller</code> 返回值是模块对象</p>
<pre><code>&lt;body ng-app=&quot;MyApp&quot;&gt;
    &lt;div ng-controller=&quot;MyController1&quot;&gt;
        &lt;input type=&quot;text&quot; ng-model=&quot;empName&quot;&gt;
        &lt;p&gt;&#123;&#123;empName&#125;&#125;&lt;/p&gt;
    &lt;/div&gt;
    &lt;div ng-controller=&quot;MyController2&quot;&gt;
        &lt;input type=&quot;text&quot; ng-model=&quot;empName&quot;&gt;
        &lt;p&gt;&#123;&#123;empName&#125;&#125;&lt;/p&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //创建模块对象
        var myModule = angular.module(&#39;MyApp&#39;,[]);
        //生成作用域对象（新版本 angular）
        myModule.controller(&#39;MyController1&#39;,function($scope)&#123;   //隐式声明依赖注入
            $scope.empName = &#39;aaa&#39;
        &#125;)
        myModule.controller(&#39;MyController2&#39;,function($scope)&#123;
            $scope.empName = &#39;bbb&#39;
        &#125;)
        //或使用链式调用
        //angular.module(&#39;MyApp&#39;,[])
        //    .controller(&#39;MyController1&#39;,function($scope)&#123;   //隐式声明依赖注入
        //        $scope.empName = &#39;aaa&#39;
        //    &#125;)
        //    .controller(&#39;MyController2&#39;,function($scope)&#123;
        //        $scope.empName = &#39;bbb&#39;
        //    &#125;)

    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>注意：当代码压缩时，$scope 会被 abcd等字母代替，导致 angular 解析不了，因此需要使用显式声明依赖注入，开发时需要使用该方式</p>
<pre><code>angular.module(&#39;MyApp&#39;,[])
    .controller(&#39;MyController1&#39;,[&#39;$scope&#39;,function($scope)&#123;   //显式声明依赖注入
        $scope.empName = &#39;aaa&#39;
    &#125;])
    .controller(&#39;MyController2&#39;,[&#39;$scope&#39;,function($scope)&#123;
        $scope.empName = &#39;bbb&#39;
    &#125;])</code></pre>
<h1 id="四、表达式"><a href="#四、表达式" class="headerlink" title="四、表达式"></a>四、表达式</h1><p><code>&#123;&#123;表达式&#125;&#125;</code> 用于显示表达式的结果数据</p>
<p>表达式中引用的变量必须是当前作用域对象有的属性（包括其原型属性）</p>
<p>可操作的数据有：</p>
<p>— 基本类型数据：number、string（需加引号）、boolean</p>
<p>— undefined、Infinity、NaN、null解析为空串，不显示任何效果</p>
<p>— 对象的属性或方法</p>
<p>— 数组</p>
<h1 id="五、指令"><a href="#五、指令" class="headerlink" title="五、指令"></a>五、指令</h1><p>Angular 指令是 Angular 为 HTML 页面扩展的自定义标签属性或标签</p>
<p>Angular 指令与 Angular 的作用域对象（scope）交互，扩展页面的动态表现力</p>
<p>常用指令有</p>
<p>ng-app：指定模块名，angular 管理的区域</p>
<p>ng-model：双向数据绑定，输入相关标签</p>
<p>ng-init：初始化数据</p>
<p>ng-click：点击时调用作用域对象的方法</p>
<p>ng-controller：指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）</p>
<p>ng-bind：解决使用 <code>&#123;&#123; &#125;&#125;</code> 显示数据闪屏（在很短时间内显示 <code>&#123;&#123; &#125;&#125;</code>）</p>
<p>ng-repeat：遍历数组显示数据，数组有几个元素就会产生几个新的作用域，自动携带的属性有 $index（下标）、$first（布尔值）、$last（布尔值）、$middle（布尔值）、$odd（布尔值，下标为奇数时为 true）、$even（布尔值）</p>
<p>ng-show：布尔类型，为 true 才显示</p>
<p>ng-hide：布尔类型，为 true 就隐藏</p>
<pre><code>&lt;body ng-app=&quot;MyApp&quot;&gt;
    &lt;div ng-controller=&quot;MyController&quot;&gt;
        &lt;div&gt;
            数量：&lt;input type=&quot;number&quot; ng-model=&quot;count&quot;&gt;
            价格：&lt;input type=&quot;number&quot; ng-model=&quot;price&quot;&gt;
            &lt;button ng-click=&quot;getTotalPrice()&quot;&gt;计算&lt;/button&gt;
            &lt;p&gt;&#123;&#123;totalPrice&#125;&#125;&lt;/p&gt;
        &lt;/div&gt;

        &lt;div&gt;
            &lt;ul&gt;
                &lt;li ng-repeat=&quot;person in persons&quot;&gt;
                    &#123;&#123;$index&#125;&#125;---&#123;&#123;$even&#125;&#125;---&#123;&#123;person.username&#125;&#125;---&#123;&#123;person.age&#125;&#125;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div&gt;
            &lt;p&gt;&#123;&#123;123&#125;&#125;&lt;/p&gt;
            &lt;p ng-bind=&quot;123&quot;&gt;&lt;/p&gt;&lt;!--与上行使用表达式&#123;&#123;&#125;&#125;等价-->
			
	
			<div>
				<button ng-click="switchShow()">显示/隐藏</button>
				<p ng-show="isShow">aaa</p>
				<p ng-hide="isShow">aaa</p>
			</div>
			
		
		<script type="text/javascript" src="./angular-1.5.5/angular.js"></script>
		<script type="text/javascript">
			angular.module('MyApp',[])
				.controller('MyController',['$scope',function($scope)&#123;
					$scope.count = 2;
					$scope.price = 10;
					$scope.totalPrice = 20;
					$scope.getTotalPrice = function()&#123;
						$scope.totalPrice = $scope.count * $scope.price;
					&#125;
					
					$scope.persons = [
						&#123;username:'a',age:12&#125;,
						&#123;username:'b',age:12&#125;,
						&#123;username:'c',age:12&#125;,
					]

					$scope.isShow = true;
					$scope.switchShow = function()&#123;
						$scope.isShow = !$scope.isShow;
					&#125;
				&#125;])
		</script>
	

ng-class：动态引用定义的样式 &#123;aClass:true, bClass:false&#125;

ng-style：动态应用通过 js 指定的样式对象 `ng-style="&#123;color:'red', background:'green'&#125;"` 或 `ng-style="作用域变量"`

ng-click：点击监听，值为函数调用，可以传 $event

ng-mouseenter：鼠标移入监听，值为函数调用，可以传 $event

ng-mouseleave：鼠标移出监听，值为函数调用，可以传 $event

	<style>
		.evenB&#123;
			background-color: red;
		&#125;
		.oddB&#123;
			background-color: green;
		&#125;
	</style>
	<body ng-app="MyApp">
		<div ng-controller="MyController">
			<div style="width:100px;height:100px;" ng-style="myStyle" ng-mouseenter="enter()" ng-mouseleave="leave()"></div>

			<!--奇偶行显示不同颜色-->
			<ul>
				<li ng-class="&#123;oddB:$odd,evenB:$even&#125;" ng-repeat="person in persons">
					&#123;&#123;person.username&#125;&#125;---&#123;&#123;person.age&#125;&#125;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        angular.module(&#39;MyApp&#39;,[])
            .controller(&#39;MyController&#39;,[&#39;$scope&#39;,function($scope)&#123;
                $scope.myStyle = &#123;
                    background: &#39;red&#39;
                &#125;
                $scope.enter = function()&#123;
                    this.myStyle.background = &#39;green&#39;;
                &#125;
                $scope.leave = function()&#123;
                    this.myStyle.background = &#39;red&#39;;
                &#125;
                $scope.persons = [
                    &#123;username:&#39;a&#39;,age:12&#125;,
                    &#123;username:&#39;b&#39;,age:12&#125;,
                    &#123;username:&#39;c&#39;,age:12&#125;,
                ]
            &#125;])
    &lt;/script&gt;
&lt;/body&gt;</li></ul></div></body></code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1、开发的两种方式</p>
<p>（1）命令式</p>
<p>更加注重的是执行的过程</p>
<p>（2）声明式</p>
<p>更加注重的是执行的结果，至于中间是如何执行的并不关心</p>
<p>声明式是对命令式的局部包装</p>
<p>命令式如同考试的解答题，声明式如同选择填空题</p>
<p>例子：对数组中的每个元素加 10</p>
<pre><code>var arr = [1,2,3,4,5]
//命令式
var arr1 = []
for(var i = 0; i &lt; arr.length; i++)&#123;
    var value = arr[i] + 10;
    arr1.push(value);
&#125;
console.log(arr1);
//声明式
var arr2 = arr.map(function(item, index)&#123;
    return item + 10;
&#125;)
console.log(arr2);</code></pre>
<p>2、多选框绑定数据</p>
<p>多选框绑定的数据会是布尔值，表示是否选中</p>
<pre><code>&lt;body ng-app=&quot;MyApp&quot;&gt;
    &lt;div ng-controller=&quot;MyController&quot;&gt;
        &lt;div ng-repeat=&quot;todo in todos&quot;&gt;
            &lt;input type=&quot;checkbox&quot; ng-model=&quot;todo.isChecked&quot;&gt;
            &lt;span&gt;&#123;&#123;todo.name&#125;&#125;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        angular.module(&#39;MyApp&#39;,[])
            .controller(&#39;MyController&#39;,[&#39;$scope&#39;,function($scope)&#123;
                $scope.todos = [
                    &#123;name:&#39;aa&#39;, isChecked: false&#125;,
                    &#123;name:&#39;bb&#39;, isChecked: true&#125;,
                    &#123;name:&#39;cc&#39;, isChecked: false&#125;
                ]
            &#125;])
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Node.js学习笔记</title>
    <url>/2022/01/15/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Node-js-介绍"><a href="#一、Node-js-介绍" class="headerlink" title="一、Node.js 介绍"></a>一、Node.js 介绍</h1><a id="more"></a>

<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>Node.js 是一个<strong>能在服务器端运行 JavaScript **的开放源代码、跨平台的</strong> JavaScript 运行环境**，Node.js 与传统服务器端的多线程不同，Node.js 是单线程（既是优点也是缺点，渲染页面快，但对于用户较多的场景有局限）</p>
<p>Node 采用 Google 开发的V8 引擎运行 js 代码，使用<strong>事件驱动、非阻塞和异步I/O模型</strong>等技术来提高性能，可优化应用程序的传输量和规模</p>
<p>Node 大部分基本模块都用 JavaScript 编写，在 Node 出现之前 JS 通常作为客户端程序设计语言使用，用 JS 写出的程序常在用户的浏览器上运行</p>
<p>目前 Node 已被 IBM、Microsoft、Yahoo!、Walmart、Groupon、SAP、LinkedIn、Rakuten、PayPal、Voxer 和 GoDaddy 等企业采用</p>
<h2 id="2、Node-是对-ES-标准的一个实现"><a href="#2、Node-是对-ES-标准的一个实现" class="headerlink" title="2、Node 是对 ES 标准的一个实现"></a>2、Node 是对 ES 标准的一个实现</h2><p>Node 是对 ES 标准的一个实现，Node 也是一个 JS 引擎，但 Node 仅仅对 ES 标准进行了实现，所以<strong>在 Node 中不包含 DOM 和 BOM</strong></p>
<p>Node 中可使用所有内建对象：String、Number、Boolean、Math、Date、RegExp、Function、Object、Array，而 BOM 和 DOM 不能使用，但可以使用 console 也可以使用定时器（setTimeout()、setInterval()）</p>
<h2 id="3、Node-的服务器是单线程的"><a href="#3、Node-的服务器是单线程的" class="headerlink" title="3、Node 的服务器是单线程的"></a>3、Node 的服务器是单线程的</h2><p>Node 可在后台编写服务器，Node 编写服务器都是单线程的服务器（Node 处理请求时是单线程，但是在后台拥有一个 I/O（对磁盘的读写操作）线程池）</p>
<p>而传统的服务器都是多线程的（即每进来一个请求，就创建一个线程去处理请求）</p>
<h2 id="4、Node-用途"><a href="#4、Node-用途" class="headerlink" title="4、Node 用途"></a>4、Node 用途</h2><p>（1）Web 服务 API，如 REST</p>
<p>（2）实时多人游戏</p>
<p>（3）后端的 Web 服务，如跨域、服务器端的请求</p>
<p>（4）基于 Web 的应用</p>
<p>（5）多客户端的通信，如即时通信</p>
<h1 id="二、CommonJS-规范"><a href="#二、CommonJS-规范" class="headerlink" title="二、CommonJS 规范"></a>二、CommonJS 规范</h1><h2 id="1、ECMAScript-标准的缺陷"><a href="#1、ECMAScript-标准的缺陷" class="headerlink" title="1、ECMAScript 标准的缺陷"></a>1、ECMAScript 标准的缺陷</h2><p>（1）没有模块系统</p>
<p>（2）标准库较少</p>
<p>（3）没有标准接口</p>
<p>（4）缺乏管理系统，如下载各模块需要去相应官网下载不方便</p>
<h2 id="2、模块化"><a href="#2、模块化" class="headerlink" title="2、模块化"></a>2、模块化</h2><p>若程序设计的规模达到一定程度，则必须对其进行模块化</p>
<p>模块化可以有多种形式，但至少应该提供能够将代码分割为多个源文件的机制</p>
<p>CommonJS 的模块功能可帮我们解决该问题</p>
<h2 id="3、CommonJS"><a href="#3、CommonJS" class="headerlink" title="3、CommonJS"></a>3、CommonJS</h2><p>CommonJS 规范的提出主要是为了弥补当前 JavaScript 没有模块标准的缺陷</p>
<p>CommonJS 规范为 JS 指定了一个美好的愿景，希望 JS 能在任何地方运行</p>
<p>CommonJS 对模块的定义：模块引用、模块定义、模块标识（即模块的名字，是传递给 require() 方法的参数，必须是符合驼峰命名法的字符串或相对/绝对路径）</p>
<p>Node 中使用的是 CommonJS 规范</p>
<h1 id="三、Node-js-基础"><a href="#三、Node-js-基础" class="headerlink" title="三、Node.js 基础"></a>三、Node.js 基础</h1><h2 id="1、模块化"><a href="#1、模块化" class="headerlink" title="1、模块化"></a>1、模块化</h2><p>在 Node 中模块分为三类：底层由 C++ 编写的内建模块、Node 提供的核心模块（通过 npm 安装）、用户编写的模块（称为文件模块）</p>
<p>在 Node 中一个 js 文件就是一个模块</p>
<h3 id="模块暴露"><a href="#模块暴露" class="headerlink" title="模块暴露"></a>模块暴露</h3><p>在 Node 中每个 js 文件中的 js 代码都是独立运行在一个函数中，变量和方法是局部变量/方法，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问</p>
<p>可通过 exports 向外部暴露变量和方法，只需将需要暴露给外部的变量或方法设置为 exports 的属性即可</p>
<pre><code>exports.x = &#39;xxx&#39; //或 module.exports.x = &#39;xxx&#39;
exports.fn = function()&#123;&#125;</code></pre>
<h3 id="模块引入"><a href="#模块引入" class="headerlink" title="模块引入"></a>模块引入</h3><p>（1）核心模块</p>
<p>对于由 node 引擎提供的核心模块，标识就是模块的名字，通过 <code>require(&quot;模块名&quot;)</code> 引入</p>
<p>node 在使用模块名字来引入时会首先在当前目录的 node_modules 中寻找是否含有该模块，若有则直接使用，若没有则去上一级目录的 node_modules 中寻找，若有则直接使用，若没有再去上一级目录的 node_modules 中寻找，直到找到为止，若直到找到磁盘的根目录依然没有则报错</p>
<p>（2）文件模块</p>
<p>文件模块是由用户自己创建的模块，通过 require(文件路径) 函数引入外部模块，若使用相对路径必须以 <code>.</code> 或 <code>..</code> 开头</p>
<p>使用 require 引入模块后，该函数会返回一个对象，这个对象代表的是引入的模块</p>
<h3 id="模块中的变量和方法是局部的"><a href="#模块中的变量和方法是局部的" class="headerlink" title="模块中的变量和方法是局部的"></a>模块中的变量和方法是局部的</h3><p>console.log(global.变量) 的结果是 undefined 可证明这一说法</p>
<h3 id="模块中的代码是包装在一个函数中执行"><a href="#模块中的代码是包装在一个函数中执行" class="headerlink" title="模块中的代码是包装在一个函数中执行"></a>模块中的代码是包装在一个函数中执行</h3><p>在模块中执行 console.log(arguments) 输出有结果说明模块是相当于一个函数</p>
<p>或 console.log(arguments.callee) 输出 [Function] 也说明模块是相当于一个函数</p>
<p>注：arguments.callee 这个属性保存的是当前执行的函数对象</p>
<p>node 在执行模块中的代码时，会首先在代码最顶部添加如下代码</p>
<pre><code>function (exports, require, module, __filename__, __dirname__)&#123;&#125;</code></pre>
<p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时同时传递进 5 个实参：</p>
<pre><code>exports 该对象用来将变量或函数暴露到外部
require 是个函数，用来引入外部模块
module 代表的是当前模块本身，exports 就是 module 的属性，既可以使用 exports 导出，也可以使用 module.exports 导出
__filename__ 当前模块的完整路径
__dirname__ 当前模块所在文件夹的完整路径</code></pre>
<h3 id="exports-和-module-exports-对比"><a href="#exports-和-module-exports-对比" class="headerlink" title="exports 和 module.exports 对比"></a>exports 和 module.exports 对比</h3><p>二者的效果基本相同</p>
<p>但通过 exports 只能使用 <code>export.xxx = xxx</code> 的方式来向外暴露内部变量，注意不能使用 exports = {}</p>
<p>而 module.exports 既可通过 <code>module.export.xxx = xxx</code> 的形式，也可以直接赋值 <code>module.exports = &#123;&#125;</code> 来向外暴露内部变量，且可一次性暴露多个变量或方法</p>
<pre><code>//方式一
module.exports.name = &#39;xxx&#39;; //或 exports.name = &#39;xxx&#39;;
module.exports.age = 12;
module.exports.sayName = function()&#123;&#125;
//方式二
module.exports = &#123;
    name: &#39;xxx&#39;,
    age: 12,
    sayNamge:function()&#123;&#125;
&#125;</code></pre>
<h2 id="2、全局对象-global"><a href="#2、全局对象-global" class="headerlink" title="2、全局对象 global"></a>2、全局对象 global</h2><p>在 node 中有一个全局对象 global，它的作用和网页中的 window 类似</p>
<p>在全局中创建的变量都会作为 global 的属性保存</p>
<p>在全局中创建的函数都会作为 global 的方法保存</p>
<h2 id="3、包-package"><a href="#3、包-package" class="headerlink" title="3、包 package"></a>3、包 package</h2><p>CommonJS 的包规范允许将一组相关的模块组合到一起，形成一组完整的工具</p>
<p>CommonJS 的包规范由<strong>包结构</strong>和<strong>包描述文件</strong>两部分组成，包实际上就是一个压缩文件，解压后还原为目录，该目录包含如下文件或子目录</p>
<pre><code>package.json  描述文件，只有该文件在包目录中是必须的
bin  可执行二进制文件，非必须
lib  js 代码，非必须
doc  文档，非必须
test  单元测试，非必须</code></pre>
<p>包结构：用于组织包中的各种文件</p>
<p>包描述文件：描述包的非代码相关信息，以供外部读取分析，它是一个 JSON 格式的文件 package.json，文件中不能写注释，位于包的根目录下，是包的重要组成部分，其中字段包括 name、description、version、keyword、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies</p>
<h2 id="4、npm"><a href="#4、npm" class="headerlink" title="4、npm"></a>4、npm</h2><p>CommonJS 包规范是理论，npm（Node Package Manager）是其中一种实践</p>
<p>对于 Node 而言，npm 帮助其完成了第三方模块的发布、安装和依赖等</p>
<p>借助 npm，Node 与第三方模块之间形成了很好的一个生态系统</p>
<h3 id="npm-相关命令"><a href="#npm-相关命令" class="headerlink" title="npm 相关命令"></a>npm 相关命令</h3><p><code>npm -v</code>  查看版本</p>
<p><code>npm version</code>  查看所有模块的版本</p>
<p><code>npm</code>  帮助说明</p>
<p><code>npm search 包名</code>  搜索模块包</p>
<p><code>npm install 包名</code> 或 <code>npm i 包名</code> 在当前目录安装包</p>
<p><code>npm install 包名 -g</code>  全局模式安装包（全局安装的包一般都是一些工具）</p>
<p><code>npm install 包名 --save</code>  安装包并添加到依赖中</p>
<p><code>npm install</code>  下载当前项目所依赖的包</p>
<p><code>npm remove 包名</code> 或 <code>npm r 包名</code>  删除一个模块</p>
<p><code>npm install 文件路径</code>  从本地安装</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  安装 cnpm</p>
<p><code>npm install 包名 --registry=地址</code>  从镜像源安装</p>
<p><code>npm config set registry 地址</code>  设置镜像源</p>
<h2 id="5、文件系统"><a href="#5、文件系统" class="headerlink" title="5、文件系统"></a>5、文件系统</h2><h3 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h3><p>Buffer 是传输数据时保存数据的缓冲区</p>
<p>Buffer 的结构和数组很像，它的元素为 16 进制的两位数，操作的方法也和数组类似</p>
<p>实际上一个元素就表示内存中的一个字节</p>
<p>Buffer 是 Node.js 中扩充的对象，使用 Buffer 不需要引入模块，直接使用即可</p>
<p>数组中不能存储二进制文件，而 Buffer 就是专门用来存储二进制数据，在 Buffer 中存储的都是二进制数据，但是显示时都是以 16 进制的形式显示，传输的时候都是二进制，buffer 中每个元素的范围是 00 - ff（即 00000000 - 11111111），buffer 中的英文一个元素占用内存的一个字节，一个汉字占用 3 个字节（传输数据的最小单位是字节（8 bit））</p>
<p>Buffer 中的内存不是通过 JavaScript 分配的，而是在底层通过 C++ 申请的，也就是可以直接通过 Buffer 来创建内存中的空间</p>
<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h4><p>Buffer.from(字符串)  将一个字符串转换为 buffer</p>
<p>Buffer.alloc(大小)  创建一个指定大小的 Buffer</p>
<p>Buffer.allocUnsafe(大小)  创建一个指定大小的 Buffer，但可能含有敏感数据</p>
<p>Buffer实例对象.toString()  将缓冲区中的数据转换为字符串</p>
<pre><code>//将一个字符串保存到 buffer 中
var str = &#39;hello&#39;;
var buf = Buffer.from(str);
console.log(buf);  //输出 &lt;Buffer 48 65 6c 6c 6f&gt;（计算机中所有的二进制都会以十六进制显示）
console.log(buf.length); //输出 5，表示占用内存的大小占用 5 个字节
console.log(str.length); //输出 5，表示字符串的长度

var str = &#39;hello 你好&#39;;
var buf = Buffer.from(str);
console.log(buf.length); //输出 12，即 6 + 2 * 3，表示占用 12 个字节
console.log(str.length); //输出 8

//通过构造函数创建一个指定大小的 buffer，不推荐使用
var buf2 = new Buffer(10);  //10 个字节的 buffer

//通过类方法 Buffer.alloc 创建一个指定大小的 buffer，在分配内存时清空之前的数据
var buf3 = Buffer.alloc(10);  //10 个字节的 buffer

//通过类方法 Buffer.allocUnsafe 创建一个指定大小的 buffer，但 buffer 中可能含有敏感数据，在分配内存时不清空之前的数据
var buf4 = Buffer.allocUnsafe(10);  //10 个字节的 buffer</code></pre>
<p>注意 Buffer 的构造函数都不推荐使用</p>
<p>Buffer 的大小一旦确定则不能修改，Buffer 实际上是对底层内存的直接操作，一般会给 Buffer 分配一段连续内存空间，当给 Buffer 中超出范围的索引赋值时该位置内存可能已被其他程序占用，则需要分配其他与前面不连续的内存空间会降低效率，所以为避免这种情况 Buffer 的大小确定后不能修改</p>
<p>可以通过索引操作 Buffer 中的元素</p>
<p>只要数字在控制台或页面中输出一定是十进制，若要输出非十进制只需 <code>.toString(进制)</code></p>
<h3 id="fs（文件系统）"><a href="#fs（文件系统）" class="headerlink" title="fs（文件系统）"></a>fs（文件系统）</h3><p>在 Node 中，与文件系统的交互很重要，服务器的本质是将本地文件发送给远程客户端</p>
<p>Node 通过 fs 模块来和文件系统交互对系统中的文件进行操作，该模块提供了一些标准文件访问 API 来打开、读取、写入文件以及与其交互</p>
<p>fs 模块是 Node 中已经继承好了，不需要再使用 npm 下载，直接引入即可</p>
<p>加载 fs 模块 <code>const fs = require(&quot;fs&quot;);</code></p>
<p>fs 模块中所有的操作都有同步和异步两种形式可供选择</p>
<p>同步文件系统会阻塞程序的执行，即除非操作完毕，否则不会向下执行代码</p>
<p>异步文件系统不会阻塞程序的执行，而是在操作完成时通过回调函数将结果返回</p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>（1）同步文件写入</p>
<p><code>fs.openSync(path, flags[,mode])</code> 打开文件，返回一个文件的描述符作为结果，可通过该描述符来对文件进行各种操作</p>
<pre><code>-path 要打开文件的路径
-flags 打开文件要做的操作类型，如 r（只读）、w（可写）
-mode 设置文件的操作权限，一般不传</code></pre>
<p><code>fs.writeSync(fd, string[,position[,encoding]])</code> 向文件写入内容</p>
<pre><code>-fd 文件的描述符，需要传递要写入的文件的描述符
-string 要写入的内容
-position 写入的起始索引位置
-encoding 写入的编码，默认 utf-8</code></pre>
<p><code>fs.closeSync(fd)</code> 关闭文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
var fd = fs.openSync(&#39;hello.txt&#39;,&#39;w&#39;,2);
fs.writeSync(fd,&#39;xxxx&#39;);
fs.closeSync(fd);</code></pre>
<p>（2）异步文件写入</p>
<p><code>fs.open(path, flags[, mode], callback)</code> 打开文件，没有返回值，异步调用的方法结果都是通过回调函数的参数返回的</p>
<pre><code>回调函数有两个参数：
    err 错误对象，若没有错误则为 null
    fd 文件的描述符</code></pre>
<p><code>fs.write(fd, string[, position[, encoding]], callback)</code> 异步写入一个文件</p>
<p><code>fs.close(fd, callback)</code> 关闭文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
fs.open(&#39;hello.txt&#39;,&#39;w&#39;, function(err, fd)&#123;
    if(!err)&#123;
        console.log(fd);
        fs.write(fd,&quot;异步写入的内容&quot;,function(err)&#123;
            if(!err)&#123;
                console.log(&quot;写入成功&quot;);
            &#125;
            fs.close(fd, function(err)&#123;
                if(!err)&#123;
                    console.log(&quot;文件已关闭&quot;);
                &#125;
            &#125;)
        &#125;)
    &#125;else&#123;
        conosle.log(err);
    &#125;
&#125;);
fs.writeSync(fd,&#39;xxxx&#39;);
fs.closeSync(fd);</code></pre>
<p>相比同步，异步代码较为繁琐但执行效率更高，且同步中没有对错误进行处理，若遇到一个错误则整个程序就结束</p>
<p>（3）简单文件写入</p>
<p>异步：<code>fs.writeFile(file, data[, options], callback)</code></p>
<p>同步：<code>fs.writeFileSync(file, data[, options])</code></p>
<pre><code>-file 要操作的文件的路径
-data 要写入的数据
-options 选项对象，可对写入进行一些设置，包括 encoding（默认是 &#39;utf8&#39;）、mode（权限，默认是 0o666）、flag（默认是 &#39;w&#39;）
-callback 当写入完成后执行的函数

var fs = require(&quot;fs&quot;);
fs.writeFile(&#39;hello.txt&#39;,&#39;写入的内容&#39;, &#123;flag:&#39;w&#39;&#125;, function(err)&#123;
    if(!err)&#123;
        console.log(&#39;写入成功&#39;);
    &#125;
&#125;);</code></pre>
<p>通过上述方式写入文件无需手动打开关闭文件</p>
<p>（4）流式文件写入</p>
<p>上述文件写入方式是要将写入内容在内存准备好一次性全写入，内容较多时内存占用多，且速度慢，因此同步、异步、简单文件写入都不适合大文件的写入，性能较差，容易导致内存溢出</p>
<p><code>fs.createWriteStream(path[, options])</code> 创建一个可写流</p>
<pre><code>-path 文件路径
-options 配置的参数</code></pre>
<p><code>可写流.write(写入的内容)</code> 通过可写流像文件中输出内容，只要流还在可分多次写入</p>
<p><code>可写流.end()</code> 关闭流</p>
<p>可通过监听流的 open 和 close 事件来监听流的打开和关闭</p>
<p><code>可写流.on(事件字符串,function()&#123;&#125;)</code> on 绑定的是长期事件</p>
<p><code>可写流.once(事件字符串,function()&#123;&#125;)</code> once 是绑定一个一次性事件，该事件将会在触发一次后自动失效</p>
<pre><code>var fs = require(&quot;fs&quot;);
var ws = fs.createWriteStream(&#39;hello.txt&#39;);
ws.once(&#39;open&#39;, function()&#123;
    console.log(&#39;流打开了&#39;)
&#125;);
ws.once(&#39;close&#39;, function()&#123;
    console.log(&#39;流关闭了&#39;)
&#125;);
ws.write(&quot;写入的内容1&quot;);
ws.write(&quot;写入的内容2&quot;);
ws.write(&quot;写入的内容3&quot;);

ws.end();
//若使用 ws.close(); 则只会写入“写入的内容1”，因为内容还没写完就把流输出端关闭，而 ws.end(); 可理解为把流的输入端关闭，内容只要进入流中都会写入</code></pre>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>（1）同步文件读取</p>
<p>和同步文件写入差不多</p>
<p>（2）异步文件读取</p>
<p>和异步文件写入差不多</p>
<p>（3）简单文件读取</p>
<p>异步：<code>fs.readFile(path[, options], callback)</code></p>
<p>同步：<code>fs.readFileSync(path[, options])</code></p>
<pre><code>-path 要读取的文件的路径
-options 读取的选项
-callback 异步中回调函数，通过回调函数将读取到的内容返回，回调函数参数有 err 和 data
    err 错误对象
    data 读取到的数据，会返回一个 Buffer，因为文件可能为文本、图片、音频等，返回 Buffer 通用性更高

var fs = require(&quot;fs&quot;);
fs.readFile(&#39;xxx.jpg&#39;, function(err, data)&#123;
    if(!err)&#123;
        //将 data 写入文件中
        fs.writeFile(&#39;xxx1.jpg&#39;, data, function(err)&#123;
            console.log(&quot;文件写入成功&quot;);
        &#125;)
    &#125;
&#125;);</code></pre>
<p>（4）流式文件读取</p>
<p>流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中</p>
<p>使用方式基本和流式文件写入相似</p>
<p>若要读取一个可读流中的数据，必须要为可读流绑定一个 data 事件，data 事件绑定完毕会自动开始读取数据，读完会自动关闭</p>
<p><code>可读流.pipe(可写流)</code> 可将可读流中的内容直接输出到可写流中</p>
<p>例子：读取文件内容写入新文件</p>
<pre><code>var fs = require(&quot;fs&quot;);
var rs = fs.createReadStream(&#39;xxx.mp3&#39;);
var ws = fs.createWriteStream(&#39;xx1.mp3&#39;);
rs.once(&#39;open&#39;, function()&#123;
    console.log(&#39;可读流打开了&#39;)
&#125;);
rs.once(&#39;close&#39;, function()&#123;
    console.log(&#39;可读流关闭了&#39;);
    //数据读取完毕，关闭可写流
    ws.end();
&#125;);
ws.once(&#39;open&#39;, function()&#123;
    console.log(&#39;可写流打开了&#39;)
&#125;);
ws.once(&#39;close&#39;, function()&#123;
    console.log(&#39;可写流关闭了&#39;)
&#125;);
rs.on(&quot;data&quot;, function(data)&#123;
    console.log(data.length);  //每次读取的长度
    //将读取到的数据写入可写流中
    ws.write(data);
&#125;);</code></pre>
<p>更简便的写法，使用 pipe()</p>
<pre><code>var fs = require(&quot;fs&quot;);
var rs = fs.createReadStream(&#39;xxx.mp3&#39;);
var ws = fs.createWriteStream(&#39;xx1.mp3&#39;);
rs.pipe(ws);</code></pre>
<h4 id="fs-模块的其他方法"><a href="#fs-模块的其他方法" class="headerlink" title="fs 模块的其他方法"></a>fs 模块的其他方法</h4><p>（1）验证路径是否存在</p>
<p><code>fs.exists(path, callback)</code>（被废弃，使用 fs.stat() 或 fs.access() 代替）</p>
<p><code>fs.existsSync(path)</code> 返回布尔值</p>
<p>（2）获取文件状态</p>
<p><code>fs.stat(path, callback)</code>，返回一个对象，该对象中保存了当前对象状态的相关信息，回调有两个参数(err, stats)，第一个是错误，第二个是 fs.Stats 对象</p>
<p>fs.Stats 对象中有属性/方法：</p>
<pre><code>size 文件的大小
isFile() 是否是一个文件
isDirectory() 是否是一个文件夹（目录）</code></pre>
<p><code>fs.statSync(path)</code></p>
<pre><code>fs.stat(&#39;xx.mp3&#39;, function(err, stat)&#123;
    console.log(stat);
    console.log(stat.isDirectory());
&#125;)</code></pre>
<p>（3）删除文件</p>
<p><code>fs.unlink(path, callback)</code></p>
<p><code>fs.unlinkSync(path)</code> </p>
<p>（4）读取目录的目录结构</p>
<p><code>fs.readdir(path[, options], callback)</code></p>
<p><code>fs.readdirSync(path[, options])</code> 读取一个目录的目录结构，回调函数参数一个是错误 err，一个是字符串数组 files，files 中每个元素就是一个文件夹或文件的名字</p>
<pre><code>fs.readdir(&#39;.&#39;,function(err, files)&#123;
    if(!err)&#123;
        console.log(files);
    &#125;
&#125;)</code></pre>
<p>（5）截断文件</p>
<p><code>fs.truncate(path, len, callback)</code></p>
<p><code>fs.truncateSync(path, len)</code></p>
<p>将文件修改为指定字节长度大小，其中一个字母占一个字节，一个汉字占 3 个字节</p>
<p>（6）建立目录</p>
<p><code>fs.mkdir(path[, mode], callback)</code></p>
<p><code>fs.mkdirSync(path[, mode])</code></p>
<p>（7）删除目录</p>
<p><code>fs.rmdir(path, callback)</code></p>
<p><code>fs.rmdirSync(path)</code></p>
<p>（8）重命名/剪切文件和目录</p>
<p><code>fs.rename(oldPath, newPath, callback)</code></p>
<p><code>fs.renameSync(oldPath, newPath)</code></p>
<p>（9）监视文件更改写入</p>
<p><code>fs.watchFile(filename[, options], listener)</code></p>
<pre><code>-filename 要监视的文件的名字
-options 配置选项，可传参数 persistent（默认是 true）、interval（监视的间隔时间默认是 5007 ms）
-listener 回调函数，当文件发生变化时，回调函数会执行，回调函数中有两个参数
    curr 当前文件的状态，是 fs.Stats 对象
    prev 修改前文件的状态，是 fs.Stats 对象

fs.watchFile(&#39;hello.txt&#39;, &#123;interval: 1000&#125;, function(curr, prev)&#123;
    console.log(&quot;修改前文件大小：&quot; + prev.size);
    console.log(&quot;修改后文件大小：&quot; + curr.size);
&#125;);</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Zepto.js学习笔记</title>
    <url>/2022/01/18/Zepto-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、zepto-基础"><a href="#一、zepto-基础" class="headerlink" title="一、zepto 基础"></a>一、zepto 基础</h1><p>zepto 是轻量级的 JavaScript 库，专门为<strong>移动端</strong>定制的框架</p>
<a id="more"></a>

<p>zepto 与 jQuery 有类似的 API（“会 jQuery 就会用 zepto”）</p>
<p><a href="http://zeptojs.com/">zepto官网</a>和<a href="https://github.com/madrobby/zepto">GitHub 上下载地址</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>（1）针对移动端</p>
<p>（2）轻量级，压缩版本只有 8kb 左右</p>
<p>（3）响应、执行快</p>
<p>（4）语法、API 大部分同 jQuery 一样，学习难度低，上手快</p>
<p>（5）目前 API 完善的框架中体积最小的一个</p>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><pre><code>&lt;body&gt;
    &lt;div id=&#39;btn&#39;&gt;hello world&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/zepto.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 zepto--&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/touch.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 移动端触屏事件相关函数--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(function()&#123;
            $(&#39;#btn&#39;).on(&#39;touchstart&#39;, function()&#123;
                alert(&#39;hello world&#39;);
            &#125;)
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h1 id="二、zepto-和-jQuery"><a href="#二、zepto-和-jQuery" class="headerlink" title="二、zepto 和 jQuery"></a>二、zepto 和 jQuery</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>（1）都是优秀的 js 函数库</p>
<p>（2）语法、API 大部分都一样（zepto 是按照 jQuery 的思路来设计的）</p>
<p>（3）zepto 相当于 jQuery 的子集</p>
<p>（4）和 jQuery 一样都是以 $ 为核心</p>
<h3 id="和-jQuery-相同的-API"><a href="#和-jQuery-相同的-API" class="headerlink" title="和 jQuery 相同的 API"></a>和 jQuery 相同的 API</h3><p>jQuery 核心： $</p>
<p>— 作为函数调用（一般关注参数），参数可以是</p>
<pre><code>function()&#123;&#125;
选择器字符串
DOM 节点
html 字符串</code></pre>
<p>— 作为对象使用（一般关注方法）</p>
<pre><code>$.isArray()
$.ajax() $.get() $.post()
$.each()
...</code></pre>
<p>jQuery 对象：核心函数 $ 调用返回的就是 jQuery 对象，而且是一个伪数组，方法有</p>
<pre><code>append()
find()
show()
...</code></pre>
<p>以上 jQuery 的概念 zepto 同样适用</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="（1）-attr-和-prop"><a href="#（1）-attr-和-prop" class="headerlink" title="（1） attr 和 prop"></a>（1） attr 和 prop</h3><p>在 zepto 中用 attr 也可以获取布尔值属性，prop 在读取属性时优先级高于 attr，布尔值属性的读取还是建议用 prop</p>
<p>如对于下拉框 <select><option></option></select> 中，选中的选中标签中属性 selected=”selected”</p>
<pre><code>在 jQuery 中
    使用 attr 读取时
    有 selected 属性的返回 selected，没有的返回 undefined
    若用 prop 读取时
    有 selected 属性的返回 true，没有的返回 false，若有多个 selected=&quot;selected&quot; 则只有最下面的选项返回为 true
在 zepto 中
    使用 attr 读取时
    有 selected 属性的返回 selected，没有的返回 false
    若用 prop 读取时
    有 selected 属性的返回 true，没有的返回 false，若有多个 selected=&quot;selected&quot; 则只有最下面的选项返回为 true，和 jQuery 中相同</code></pre>
<p>注意：zepto 中 removeProp() 方法在 1.2+ 版本才支持</p>
<h3 id="（2）DOM-操作"><a href="#（2）DOM-操作" class="headerlink" title="（2）DOM 操作"></a>（2）DOM 操作</h3><p>jQuery 中插入 DOM 元素时添加配置对象（如 id、class 等）不起作用</p>
<p>zepto 中插入 DOM 元素时添加配置对象（如 id、class 等）可以添加进去，并且会直接显示在</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./js/zepto.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        var $p = $(&#39;&lt;p&gt;文本&lt;/p&gt;&#39;, &#123;
            id:&#39;xxx&#39;
        &#125;)
        $(&#39;#box&#39;).append($p);
    &#125;);
&lt;/script&gt;</code></pre>
<h3 id="（3）each-方法"><a href="#（3）each-方法" class="headerlink" title="（3）each 方法"></a>（3）each 方法</h3><p>在 jQuery 中 $each() 可以遍历数组（以 index,item 的形式）、对象（以 key,value 的形式），但不可以遍历字符串，也意味着不能遍历 json 的对象和数组</p>
<p>在 zepto 中 $each() 可以遍历数组（以 index,item 的形式）、对象（以 key,value 的形式），也可以遍历字符串，也可以以字符串形式遍历 json 的对象和数组</p>
<h3 id="（4）offset"><a href="#（4）offset" class="headerlink" title="（4）offset()"></a>（4）offset()</h3><p>在 jQuery 中 offset() 获取匹配元素在当前视口的相对偏移量，返回的对象包含 top 和 left 两个整型属性</p>
<p>在 zepto 中 offset() 返回的对象包含 top、left、width、height 四个整型属性，其中 width 和 height 是元素可见区（宽/高 + padding + border）的宽高</p>
<h3 id="（5）height-和-width"><a href="#（5）height-和-width" class="headerlink" title="（5）height() 和 width()"></a>（5）height() 和 width()</h3><p>在 jQuery 中获取宽高的方法：</p>
<pre><code>width() 和 height() ———— content 内容区的宽高，没有单位 px
.css(&#39;width&#39;)、.css(&#39;height&#39;) ———— 获取 content 内容区宽高 + padding + border，有单位 px
innerHeight()、innerWidth() ———— 获取 content 内容区宽高 + padding，没有单位
outerHeight()、outerWidth() ———— 获取 content 内容区宽高 + padding + border，没有单位</code></pre>
<p>在 zepto 中获取宽高：</p>
<pre><code>width() 和 height() ———— 根据盒模型取值，获取 content 内容区宽高 + padding + border，没有单位 px
.css(&#39;width&#39;)、.css(&#39;height&#39;) ———— 获取 content 内容区宽高，有单位 px
.css(&#39;padding&#39;) ———— 获取 padding 值，有单位 px
.css(&#39;border&#39;)、.css(&#39;border-width&#39;) ———— 获取 border 相关值，有单位 px
没有 innerHeight()、innerWidth()、outerHeight()、outerWidth() 方法</code></pre>
<h3 id="（6）隐藏元素的宽高"><a href="#（6）隐藏元素的宽高" class="headerlink" title="（6）隐藏元素的宽高"></a>（6）隐藏元素的宽高</h3><p>在 jQuery 中对于 display:none 的元素使用 .width() 和 .height() 依然可以得到元素宽高</p>
<p>在 zepto 中对于 display:none 的元素使用 .width() 和 .height() 得到结果为 0</p>
<h3 id="（7）事件委托"><a href="#（7）事件委托" class="headerlink" title="（7）事件委托"></a>（7）事件委托</h3><p>在 jQuery 中设置事件委托：</p>
<p>（1）$(父元素选择器).delegate(子元素选择器,事件名,回调函数)</p>
<p>（2）$(父元素选择器).on(事件名,子元素选择器,回调函数)</p>
<p>（3）在 1.7 及以下还可以使用 live 函数，但在 1.7 以上已被废除</p>
<p>在 zepto 官网表示已经要废除 live、delegate 等</p>
<p>在 zepto 中委托的事件先被依次放入数组队列里，然后由自身开始往后找直到找到最后，期间符合条件的元素委托的事件都会执行，条件有</p>
<pre><code>（1）委托在同一个父元素，或者触发的元素的事件范围小于同类型事件（冒泡能冒到自身范围）
（2）是同一个事件
（3）委托关联，即操作的类要进行关联
（4）绑定顺序————从当前的代码位置往后看</code></pre>
<p>如</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        .a&#123;
            width:100px;
            height:100px;
            background:red;
        &#125;
        .b&#123;
            width:200px;
            height:200px;
            background:green;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&#39;box&#39;&gt;
        &lt;div class=&quot;a&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;b&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/zepto.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 zepto--&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/touch.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 移动端触屏事件相关函数--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(&#39;#box&#39;).on(&#39;touchstart&#39;, &#39;.a&#39;, function()&#123;
            alert(&#39;a触发的事件&#39;);
            $(this).removeClass().addClass(&#39;b&#39;); //和 b 关联
        &#125;)
        $(&#39;#box&#39;).on(&#39;touchstart&#39;, &#39;.b&#39;, function()&#123;
            alert(&#39;b触发的事件&#39;);
            $(this).removeClass().addClass(&#39;a&#39;);
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>上述代码中当点击 a 的 div 时，会弹出 “a触发的事件”、“b触发的事件”，但 div 的样式没有变化，而当点击 b 的 div 时，会弹出 “b触发的事件”，div 的样式变为 a 类的 div</p>
<p>— 若把 a 绑定的事件中 $(‘#box’) 改为 $(‘#body’) 就不会发生这种情况，因为不符合第（1）个条件</p>
<p>— 若把 a 绑定的事件中 touchstart 改为 click 就不会发生这种情况，因为不符合第（2）个条件</p>
<p>— 若把 a 绑定的事件中 <code>$(this).removeClass().addClass(&#39;b&#39;);</code> 删除就不会发生这种情况，因为不符合第（3）个条件</p>
<p>— 若把 a 绑定的事件相关代码移到 b 绑定的事件之后就不会发生这种情况，因为不符合第（4）个条件</p>
<p>而点击 a 样式没有变化（没有按预期变为 b）是因为当 class 变为 b 后会启动一个新线程用于重排，但 js 代码执行比重排快，此时会执行 b 绑定的事件，且 alert 会阻断代码执行，而当关闭 alert 窗口后 class 又变回 a 因此样式没有变化</p>
<h3 id="（8）touch-Event"><a href="#（8）touch-Event" class="headerlink" title="（8）touch Event"></a>（8）touch Event</h3><p>同 jQuery 类似的事件：</p>
<pre><code>on() 绑定事件处理程序
off() 移除用目标元素 on 绑定的事件处理程序
one() 为每一个匹配元素的特定事件（如 click）绑定一个一次性事件处理函数，只执行一次
bind() 为每个匹配元素的特定事件绑定事件处理函数，可同时绑定多个事件，也可自定义事件
trigger() 触发由 bind 定义的事件（通常是自定义事件）
unbind() bind 的反向操作，删除匹配元素绑定的 bind 事件</code></pre>
<p>如自定义事件</p>
<pre><code>$(&#39;#btn&#39;).bind(&#39;myTouch&#39;,function()&#123;
    alert(&#39;xx&#39;);
&#125;)
$(&#39;#btn&#39;).trigger(&#39;myTouch&#39;)</code></pre>
<p>zepto touch 方法</p>
<p>tap() 点击事件，利用在 document 上绑定 touch 事件来模拟 tap 事件的，并且 tap 事件会冒泡到 document 上</p>
<p>singleTap() 单击事件</p>
<p>doubleTap() 双击事件</p>
<p>longTap() 当一个元素被按住超过 750ms 触发</p>
<p>swipe、swipeLeft、swipeRight、swipeUp、swipeDown 当元素被划过（同一个方向大于 30px）时触发（可选择给定的方向在一个方向滑动大于 30px 即为滑动，否则算点击）</p>
<p>注意：在给元素设置滑动事件时需要通过 <code>touch-action:none;</code> 将默认的元素上滑动翻页行为禁掉</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        #btn&#123;
            touch-action: none;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&#39;btn&#39;&gt;xxx&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/zepto.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 zepto--&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./js/touch.js&quot;&gt;&lt;/script&gt;  &lt;!--引入 移动端触屏事件相关函数--&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(&#39;#btn&#39;).swipe(function()&#123;
            alert(&#39;xxx&#39;);
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h1 id="三、zepto-事件机制"><a href="#三、zepto-事件机制" class="headerlink" title="三、zepto 事件机制"></a>三、zepto 事件机制</h1><p>zepto 有自己的一套事件机制，并对不同的浏览器做了兼容的内部封装处理</p>
<p>新版本的 zepto 中已经舍弃了 bind、delegate、die（live 的反向操作），同样 jQuery 中舍弃了 live 等</p>
<p>现在统一使用 on、off 标准事件来绑定事件</p>
<h1 id="四、form-表单"><a href="#四、form-表单" class="headerlink" title="四、form 表单"></a>四、form 表单</h1><h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h2><p>在 Ajax post 请求中将用作提交的表单元素的值编译成 URL-encoded 字符串 ———— name=value</p>
<p>不能使用的表单元素、buttons、未选中的 radio buttons、checkboxs 将会被跳过</p>
<h2 id="serializeArray"><a href="#serializeArray" class="headerlink" title="serializeArray()"></a>serializeArray()</h2><p>将用作提交的表单元素的值编译成拥有 {name,value} 对象组成的数组</p>
<p>不能使用的表单元素、buttons、未选中的 radio buttons、checkboxs 将会被跳过</p>
<h2 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h2><p>为 “submit” 事件绑定一个处理函数，或者触发元素上的 “submit” 事件</p>
<p>当参数 function 没有给出时，触发当前表单 “submit” 事件，并且执行默认的提交表单行为，除非阻止默认行为</p>
<pre><code>&lt;form method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;val&quot; value=&quot;aaa&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;pw&quot; value=&quot;123&quot;&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;item&quot; checked=&quot;checked&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;按钮&quot; name=&quot;btn&quot;&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./js/zepto.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./js/touch.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function()&#123;
        var result = $(&#39;form&#39;).serialize();
        console.log(result);  //输出 val=aaa&amp;pw=123&amp;item=on
        $(&#39;form&#39;).submit(function(event)&#123;
            event.preventDefault();  //取消默认提交
            console.log(&quot;暂时不想提交&quot;)
        &#125;)
    &#125;)
&lt;/script&gt;</code></pre>
<h1 id="五、ajax-细节剖析"><a href="#五、ajax-细节剖析" class="headerlink" title="五、ajax 细节剖析"></a>五、ajax 细节剖析</h1><p>abort() 在 zepto 中取消 ajax 请求</p>
<p>问题：点击获取验证码的按钮，用户十秒后可再次获取，当十秒过后第一次请求没有返回，然后因为网速好或其他原因，两次请求同时返回该如何解决？</p>
<p>用户再次点击时取消之前的请求，注意 disabled 禁止用户点击操作按钮、表单项，但只是针对 click 事件，并没有对 touch 事件做处理</p>
<pre><code>$(function()&#123;
    var isSend = false;  //通过该变量控制间隔相应时间后才能再次点击
    var xmlHttp = null;
    $(&#39;#btn&#39;).on(&#39;touchstart&#39;,function()&#123;
        if(isSend)&#123;  //用户点击失效
            return;
        &#125;
        isSend = true;
        $(this).css(&#39;background&#39;,&#39;gray&#39;);
        setTimeout(function()&#123;
            $(&#39;#btn&#39;).css(&#39;background&#39;,&#39;red&#39;);
            isSend = false;
        &#125;,2000);
        if(!xmlHttp)&#123;  //用户没发过请求
            xmlHttp = sendXml();
        &#125;else&#123;
            xmlHttp.abort();  //取消上一次请求
            xmlHttp = sendXml();
        &#125;
    &#125;)
&#125;);
function sendXml()&#123;
    var xmlHttp = $.ajax(&#123;
        &quot;method&quot;:&#39;GET&#39;,
        &quot;url&quot;:&#39;http://127.0.0.1&#39;
        dataType:&#39;json&#39;;
        success: function(data)&#123;
            console.log(data);
        &#125;,
        error: function(error)&#123;
            console.log(error);
        &#125;
    &#125;)
    return xmlHttp;
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB学习笔记</title>
    <url>/2022/01/19/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h1><a id="more"></a>

<p>数据库是按照数据结构来组织、存储和管理数据的仓库</p>
<p>程序都是在内存中运行的，一旦程序运行结束或计算机断电，程序运行中的数据都会丢失，所以需要将一些程序运行的数据持久化到硬盘中，以确保数据的安全性，而数据库是数据持久化的最佳选择</p>
<p>数据库包含数据库服务器和数据库客户端：</p>
<p>— 数据库服务器用来保存数据</p>
<p>— 数据库客户端用来操作服务器，对数据进行增删改查的操作</p>
<h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p>数据库分为两种：</p>
<p>— 关系型数据库（RDBMS）</p>
<p>关系型数据库中全都是表，如 MySQL、Oracle、DB2、SQL Server…</p>
<p>所有关系型数据库使用 SQL（结构化查询语言）来操作</p>
<p>关系型数据库每操作一次就要连接一次（因为有事务控制）</p>
<p>— 非关系型数据库（No SQL ———— Not Only SQL）</p>
<p>键值对数据库，如 MongoDB（文档数据库）、Redis…</p>
<p>只需连接一次，连接一次后，除非项目停止服务器关闭，否则连接一般不会断开</p>
<h2 id="数据库、集合、文档"><a href="#数据库、集合、文档" class="headerlink" title="数据库、集合、文档"></a>数据库、集合、文档</h2><p><img src="/2022/01/19/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E5%90%88%E6%96%87%E6%A1%A3.png" alt="数据库集合文档"></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库是一个仓库，仓库中可以存放集合</p>
<p>一个数据库服务器中可以有多个数据库</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合类似于数组，集合就是一组文档，集合是用来存放文档的</p>
<p>集合中存储的文档可以是各种各样的，没有格式要求</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是文档数据库中的最小单位，我们存储和操作的内容都是文档</p>
<p>文档类似于 JS 中的对象，在 MongoDB 中每一条数据都是一个文档</p>
<h1 id="二、MongoDB"><a href="#二、MongoDB" class="headerlink" title="二、MongoDB"></a>二、MongoDB</h1><p>MongoDB 是为快速开发互联网 Web 应用而设计的数据库系统</p>
<p>MongoDB 的设计目标是极简、灵活、作为 Web 应用栈的一部分</p>
<p>MongoDB 的数据模型是面向文档的，所谓文档是一种类似于 JSON 的结构，MongoDB 中存的是 JSON 和 二进制数据（BSON）</p>
<p>MongoDB 版本中偶数版为稳定版，奇数版为开发版，MongoDB 对 32 位系统支持不佳，在 3.2 版本后没有再对 32 位系统的支持</p>
<h2 id="1、下载和安装"><a href="#1、下载和安装" class="headerlink" title="1、下载和安装"></a>1、下载和安装</h2><p>（1）在官网下载并安装 –&gt; </p>
<p>（2）配置环境变量（添加安装包的 bin 目录到 path 中） –&gt; </p>
<p>（3）在磁盘创建 data/db 文件夹 –&gt;</p>
<p>（4）在命令行输入 <code>mongod</code> 启动数据库服务器（32 位第一次启动需输入 <code>mongod --storageEngine=mmapvl</code>） –&gt;</p>
<p>（5）在命令行输入 <code>mongo</code> 启动数据库客户端连接 mongodb</p>
<p>也可通过 <code>mongod --dbpath 路径 --port 端口号</code> 指定 data/db 文件夹路径和端口</p>
<h3 id="MongoDB-自启动"><a href="#MongoDB-自启动" class="headerlink" title="MongoDB 自启动"></a>MongoDB 自启动</h3><p>将 MongoDB 设置为系统服务，可以自动在后台启动，无需每次手动启动</p>
<p>（1）创建 data/db 和 data/log 文件夹</p>
<p>（2）在安装路径 xxx\MongoDB\Server\x.x 下新建文件 mongod.cfg，在文件中添加如下内容</p>
<pre><code>systemLog:
    destination: file
    path: xxx\data\log\mongod.log
storage:
    dbPath: xxx\data\db</code></pre>
<p>（3）以管理员身份打开命令行，执行</p>
<pre><code>sc.exe create MongoDB binPath=&quot;\&quot;xxxx\MongoDB\Server\x.x\bin\mongod.exe\&quot; --service --config=\&quot;xxx\MongoDB\Server\x.x\mongod.cfg\&quot;&quot; DisplayName=&quot;MongoDB&quot; start=&quot;auto&quot;</code></pre>
<p>（4）在任务管理启动右键 “MongoDB” 点击 “启动”</p>
<p>注意若启动失败，在命令行输入 <code>sc delete MongoDB</code> 删除之前配置的服务，从第一步再来一遍</p>
<h2 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h2><p>在 MongoDB 中，数据库和集合都不需要手动创建，当创建文档时，若文档所在的集合或数据库不存在会自动创建数据库和集合</p>
<p>所以在 MongoDB 中，即使数据库不存在也能使用 use 指令进入数据库，当向该数据库中插入第一条文档时会自动创建该数据库和集合</p>
<p>MongoDB 的文档的属性值也可以是一个文档，当一个文档的属性值为一个文档时，称属性值的这个文档为内嵌文档</p>
<h2 id="3、基本指令"><a href="#3、基本指令" class="headerlink" title="3、基本指令"></a>3、基本指令</h2><p><code>show dbs</code> 或 <code>show databases</code> 显示所有数据库</p>
<p><code>use 数据库名</code> 进入指定数据库</p>
<p><code>db</code> 显示当前所处的数据库</p>
<p><code>show collections</code> 显示数据库中所有的集合</p>
<h3 id="数据库的增删改查（CRUD）操作"><a href="#数据库的增删改查（CRUD）操作" class="headerlink" title="数据库的增删改查（CRUD）操作"></a>数据库的增删改查（CRUD）操作</h3><h4 id="向数据库中插入文档"><a href="#向数据库中插入文档" class="headerlink" title="向数据库中插入文档"></a>向数据库中插入文档</h4><p><code>db.集合名.insert(doc)</code> 向集合中插入一个或多个文档，db 即可表示当前数据库，当向集合中插入文档时，若没有给文档指定 _id 属性，则数据库会自动为文档添加 _id，该属性是根据时间戳生成，作为文档的唯一标识，若自己指定 _id 也要确保唯一性</p>
<pre><code>向 test 数据库 stus 集合中插入一个新的对象
use test
db.stus.insert(&#123;name:&quot;xxx&quot;,age:18,gende:&quot;female&quot;,hobby:&#123;movies:[&#39;hero&#39;,&#39;xxxxx&#39;]&#125;&#125;);
db.stus.insert([
    &#123;name:&quot;xxx&quot;,age:18,gende:&quot;female&quot;&#125;,
    &#123;name:&quot;xxx1&quot;,age:18,gende:&quot;male&quot;&#125;
]);
db.stus.insert(&#123;_id:&quot;hello&quot;,name:&quot;xxx&quot;,age:18,gende:&quot;female&quot;&#125;);</code></pre>
<p><code>db.集合名.insertOne(doc)</code> 插入一个文档对象</p>
<p><code>db.集合名.insertMany(doc)</code> 插入多个文档对象  </p>
<h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p><code>db.集合名.find(&#123;字段名1:值,字段名2:值&#125;)</code> 查询当前集合中的所有符合条件的文档，也可不传参或对象为空表示查询集合中所有文档，返回数组</p>
<pre><code>db.stus.find(&#123;_id:&quot;hello&quot;&#125;)</code></pre>
<p><code>db.集合名.find(&#123;&#125;).count()</code> 查询所有结果的数量</p>
<p><code>db.集合名.findOne(&#123;字段名1:值,字段名2:值&#125;)</code> 查询当前集合中符合条件的第一个文档，返回的是一个文档对象</p>
<p>MongoDB 支持直接通过内嵌文档的属性进行查询，通过 <code>&quot;xxx.xxx&quot;:&#39;xxx&#39;</code> 查询内嵌文档，但属性名必须使用引号，若要查询的是内嵌文档中数组的某个元素也可直接使用 <code>:&quot;xxx&quot;</code> 查询数组中是否存在该元素</p>
<pre><code>查询喜欢 hero 电影的人
db.stus.find(&#123;&quot;hobby.movies&quot;:&quot;hero&quot;&#125;)</code></pre>
<p>查询的相关操作符：</p>
<pre><code>$eq 等于
$gt 大于
$gte 大于等于
$lt 小于
$lte 小于等于
$or:[&#123;&#125;,&#123;&#125;] 或
.limit(条数)  设置显示数据的上限
.skip(条数)  跳过指定数量的数据
.skip((页码-1)*每页显示的条数).limit(每页显示的条数)  显示指定数据，顺序无要求，MongoDB 会自动调整 skip 和 limit 位置

db.numbers.find(&#123;num:&#123;$gt:500&#125;&#125;)  查询大于500的文档
db.numbers.find(&#123;num:&#123;$gt:500, $lt:600&#125;&#125;)  查询大于500小于600的文档
db.numbers.find(&#123;$or:[&#123;num:&#123;$lt:100&#125;&#125;,&#123;num:&#123;$gt:200&#125;&#125;]&#125;)  查询小于100或大于200的文档
db.numbers.find().limit(10)  查询前10条数据
db.numbers.find().skip(10).limit(10)  查询前11-20条数据</code></pre>
<h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p><code>db.集合名.update(查询条件,新对象)</code> 默认会使用新对象替换旧对象，并且只会修改第一个符合条件的文档，若需要修改指定的属性而不是替换则需要使用修改操作符，如 </p>
<pre><code>$set 来完成修改文档中指定属性
$unset 用来删除文档中指定属性
$push 用于向数组中添加一个新的元素
$addToSet 向数组中添加一个新的元素，若数组中已存在该元素，则不会添加
$inc 在原来的数据上自增</code></pre>
<p><code>db.集合名.update(查询条件,新对象,&#123;multi:true&#125;)</code> 修改多个符合条件的文档</p>
<pre><code>db.stuts.update(
    &#123;_id:&quot;hello&quot;&#125;,
    &#123;
        $set:&#123;
            gender:&quot;女&quot;,
            address:&quot;xxxxx&quot;
        &#125;
    &#125;
);

db.stuts.update(
    &#123;_id:&quot;hello&quot;&#125;,
    &#123;
        $unset:&#123;
            address:1
        &#125;
    &#125;
);
注意要删除的属性值写啥无所谓

db.stuts.update(
    &#123;name:&quot;xxx&quot;&#125;,
    &#123;
        $push:&#123;
            &quot;hobby.movies&quot;:&quot;1111&quot;
        &#125;
    &#125;
);

db.emp.updataMany(&#123;sal:&#123;$lte:1000&#125;&#125;,&#123;$inc:&#123;sal:400&#125;&#125;); 给薪资低于1000的员工增加400元</code></pre>
<p><code>db.集合名.updateOne(查询条件,新对象)</code> 修改一个符合条件的文档</p>
<p><code>db.集合名.updateMany(查询条件,新对象)</code> 修改多个符合条件的文档</p>
<p><code>db.集合名.replaceOne(查询条件,新对象)</code> 替换一个文档</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>注意：删除属性依然使用 update</strong></p>
<p><code>db.集合名.remove(查询条件)</code> 根据条件删除符合条件的所有文档，传递条件的方式和 find 一样，若第二个参数传递一个 true 则只会删除第一个符合条件的文档</p>
<pre><code>db.stuts.remove(&#123;_id:&quot;hello&quot;&#125;,true);</code></pre>
<p><code>db.集合名.deleteOne(查询条件,新对象)</code></p>
<p><code>db.集合名.deleteMany(查询条件,新对象)</code></p>
<p><code>db.集合名.remove(&#123;&#125;)</code> 清空集合，集合还在，但性能略差（因为先匹配然后一个个删） </p>
<p><code>db.集合名.drop()</code> 删除集合，若数据库中只有一个集合，则删除该集合后数据库也会自动删除</p>
<p><code>db.dropDatabase()</code> 删除数据库</p>
<h2 id="3、文档间的关系"><a href="#3、文档间的关系" class="headerlink" title="3、文档间的关系"></a>3、文档间的关系</h2><h3 id="一对一（one-to-one）"><a href="#一对一（one-to-one）" class="headerlink" title="一对一（one to one）"></a>一对一（one to one）</h3><p>MongoDB 中可通过内嵌文档的形式体现一对一的关系</p>
<pre><code>db.wifeAndHusband.insert([
    &#123;
        name:&#39;xx&#39;,
        husband:&#123;
            name;&#39;xxx&#39;
        &#125;
    &#125;
])</code></pre>
<h3 id="一对多（one-to-many）-多对一（many-to-one）"><a href="#一对多（one-to-many）-多对一（many-to-one）" class="headerlink" title="一对多（one to many）/ 多对一（many to one）"></a>一对多（one to many）/ 多对一（many to one）</h3><p>也可通过内嵌文档的形式体现一对多的关系（使用数组）</p>
<pre><code>db.users.insert([
    &#123;
        username:&#39;xx&#39;
    &#125;,&#123;
        username:&#39;xx1&#39;
    &#125;
])
db.order.insert(&#123;
    list:[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;],
    user_id:ObjectId(&quot;xxxxxxxxxxxxxxxxx&quot;)
&#125;)
var user_id = db.users.findOne(&#123;username:&quot;xx&quot;&#125;)._id
db.order.find(&#123;user_id:user_id&#125;);</code></pre>
<h3 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many to many）"></a>多对多（many to many）</h3><pre><code>db.teachers.insert([
    &#123;name:&#39;aaa&#39;&#125;,
    &#123;name:&#39;bbb&#39;&#125;,
    &#123;name:&#39;ccc&#39;&#125;,
])
db.stus.insert([
    &#123;
        name:&#39;ddd&#39;,
        teach_ids:[
            ObjectId(&quot;xxxxxxxxxxxx&quot;),
            ObjectId(&quot;xxxxxxxxxxxx&quot;)
        ]
    &#125;,
    &#123;
        name:&#39;eee&#39;,
        teach_ids:[
            ObjectId(&quot;xxxxxxxxxxxx&quot;),
            ObjectId(&quot;xxxxxxxxxxxx&quot;)
        ]
    &#125;
])</code></pre>
<h2 id="4、sort"><a href="#4、sort" class="headerlink" title="4、sort"></a>4、sort</h2><p>查询文档时默认是按照 _id 的值进行排列（升序）</p>
<p><code>sort(&#123;对象&#125;)</code> 可以用来指定文档的排序规则，需要传递一个对象来指定排序规则，1 表示升序，-1 表示降序</p>
<pre><code>db.emp.find(&#123;&#125;).sort(&#123;sal:1&#125;);  按 sal 字段升序排列
db.emp.find(&#123;&#125;).sort(&#123;sal:1,empno:-1&#125;);  先按 sal 字段升序再按 empno 降序排列</code></pre>
<p>limit、skip、sort 可以以任意顺序进行调用，都会自动先调用 sort</p>
<h2 id="5、投影"><a href="#5、投影" class="headerlink" title="5、投影"></a>5、投影</h2><p>在查询时可以在第二个参数设置查询结果的投影，默认都会显示 _id</p>
<pre><code>db.emp.find(&#123;&#125;,&#123;ename:1&#125;)  会显示 _id 和 ename
db.emp.find(&#123;&#125;,&#123;ename:1, _id:0&#125;)  只显示 ename
db.emp.find(&#123;&#125;,&#123;ename:1, _id:0, sal:1&#125;)  显示 ename 和 sal</code></pre>
<h1 id="三、Mongoose"><a href="#三、Mongoose" class="headerlink" title="三、Mongoose"></a>三、Mongoose</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>之前都是通过 shell 来完成对数据库的操作，在开发中大部分时候都需要通过程序来完成对数据库的操作</p>
<p>Mongoose 是一个 Node 中的模块，让我们可以通过 Node 来操作 MongoDB 数据库</p>
<p>Mongoose 是一个对象文档模型（ODM）库，Node 原生的 MongoDB 模块也可以操作 MongoDB 数据库，Mongoose 对 Node 原生的 MongoDB 模块进行进一步优化封装，并提供了更多的功能</p>
<p>在大多数情况下，它被用来把结构化的模式应用到一个 MongoDB 集合，并提供了验证和类型转换等好处</p>
<h2 id="2、Mongoose-优点"><a href="#2、Mongoose-优点" class="headerlink" title="2、Mongoose 优点"></a>2、Mongoose 优点</h2><p>（1）可以为文档创建一个模式结构（Schema，即约束），如必须要几个字段、字段类型等</p>
<p>（2）可以对模型中的对象/文档进行验证（因为有约束）</p>
<p>（3）数据可通过类型转换转换为对象模型（因为有约束）</p>
<p>（4）可使用中间件来应用业务逻辑挂钩</p>
<p>（5）比 Node 原生的 MongoDB 驱动更容易</p>
<h2 id="3、安装-Mongoose"><a href="#3、安装-Mongoose" class="headerlink" title="3、安装 Mongoose"></a>3、安装 Mongoose</h2><p>（1）下载安装 Mongoose</p>
<pre><code>npm -i mongoose --save</code></pre>
<p>（2）项目中引入 mongoose</p>
<pre><code>const mongoose = require(&quot;mongoose&quot;);</code></pre>
<p>（3）连接 MongoDB 数据库，可在<a href="https://mongoosejs.com/">官网</a>查看方法</p>
<pre><code>mongoose.connect(&#39;mongodb://数据库ip地址:端口号/数据库名&#39;);  端口号默认是 27017</code></pre>
<p>在 mongoose 对象中有个属性 connection，该对象表示的就是数据库连接，通过监该对象的状态可以来</p>
<p>一旦连接了 MongoDB 数据库后，底层的 Connection 对象就可以通过 mongoose 模块的 connection 属性来访问</p>
<p>connection 对象就是数据库连接的抽象，它提供了对象连接、底层的 Db 对象和表示结合的 Model 对象的访问</p>
<p>并可对 connection 对象上的事件进行监听，来获悉数据库连接的开始与断开，如通过 open 和 close 事件来监控连接的打开和关闭</p>
<pre><code>数据库连接成功的事件
mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;);
数据库断开的事件
mongoose.connection.once(&quot;close&quot;,function()&#123;&#125;);</code></pre>
<p>（4）断开连接（一般不需要）</p>
<pre><code>mongoose.disconnect();</code></pre>
<p>MongoDB 数据库一般情况下只需连接一次，连接一次后，除非项目停止服务器关闭，否则连接一般不会断开</p>
<h2 id="4、Mongoose-中新的对象"><a href="#4、Mongoose-中新的对象" class="headerlink" title="4、Mongoose 中新的对象"></a>4、Mongoose 中新的对象</h2><p>（1）Schema（模式对象）</p>
<p>Schema 对象定义约束了数据库中的文档结构，如文档中有几个字段，哪些必须哪些可选等</p>
<p>（2）Model</p>
<p>Model 对象作为集合中的所有文档的表示，相当于 MongoDB 数据库中的集合 collection</p>
<p>通过 Schema 来创建 Model，Model 代表的是数据库中的集合，通过 Model 才能对数据库进行操作</p>
<pre><code>mongoose.model(要映射的集合名, 模式)</code></pre>
<p>注意：mongoose 会自动将集合名变成复数，即“要映射的集合名”中若为单数，在数据库中创建的集合会自动变为复数</p>
<p>（3）Document</p>
<p>Document 表示集合中的具体文档，相当于集合中的一个具体的文档</p>
<pre><code>模型.create(文档对象,function(err)&#123;&#125;)</code></pre>
<p>注意：三者有顺序要求，先有 Schema 再有 Model 再有 Document</p>
<h3 id="Model-的方法"><a href="#Model-的方法" class="headerlink" title="Model 的方法"></a>Model 的方法</h3><p>有了 Model 就可以对数据库进行增删改查操作</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><code>Model.create(doc(s), [callback])</code> 用创建一个或多个文档并添加到数据库中</p>
<pre><code>参数：
    -doc(s) 可以是一个文档对象，也可以是一个文档对象的数组
    -callback 当操作完成后调用的回调函数</code></pre>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><code>Model.find(conditions, [projection], [options], [callback])</code> 查询所有符合条件的文档，返回数组</p>
<p><code>Model.findById(id, [projection], [options], [callback])</code> 根据文档的 id 属性查询文档，返回一个具体的文档对象</p>
<p><code>Model.findOne([conditions], [projection], [options], [callback])</code> 查询符合条件的第一个文档，返回一个具体的文档对象</p>
<pre><code>参数
    -conditions 查询的条件
    -projection 投影（需要获取到的字段）
        -例：显示字段1，不显示字段2
        -方式一：&#123;字段1:1,字段2;0&#125;
        -方式二：&quot;字段1 -字段2&quot;
    -options 查询选项（skip、limit）
    -callback 回调函数，查询结果通过回调函数返回，一般回调函数必须传，若不传就不会查询。回调函数的第一个参数是错误，第二个参数就是查询到的数据</code></pre>
<p>find 查询返回的结果就是 Document 文档对象，<strong>Document 对象就是 Model 的实例</strong></p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p><code>Model.update(conditions, doc, [options], [callback])</code> 修改一个或多个文档</p>
<p><code>Model.updateMany(conditions, doc, [options], [callback])</code></p>
<p><code>Model.updateOne(conditions, doc, [options], [callback])</code></p>
<p><code>Model.replaceOne(conditions, doc, [options], [callback])</code></p>
<pre><code>参数：
    -conditions 查询条件
    -doc 修改后的对象
    -options 配置参数，如 &#123;multi:true&#125; 一次修改多个
    -callback 回调函数</code></pre>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><code>Model.remove(conditions, [callback])</code></p>
<p><code>Model.deleteMany(conditions, [callback])</code></p>
<p><code>Model.deleteOne(conditions, [callback])</code></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>Model.count(conditions, [callback])</code> 统计文档数量</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>//连接数据库
const mongoose = require(&quot;mongoose&quot;);
mongoose.connect(&#39;mongodb://127.0.0.1:27017/test&#39;);

var Schema = mongoose.Schema;
//创建 Schema（模式）对象
var stuSchema = new Schema(&#123;
  name:  Number,
  gender: &#123;
        type:String,
        default:&quot;female&quot;
    &#125;,
  address: String,
&#125;);
//通过 Schema 来创建 Model
var StuModel = mongoose.model(&#39;students&#39;, stuSchema);
//向数据库中插入一个文档
StuModel.create(&#123;
    name:&quot;xxx&quot;,
    age:18,
    gender:&quot;male&quot;,
    address:&quot;ddddd&quot;
&#125;,function(err)&#123;
    if(!err)&#123;
        console.log(&quot;插入成功&quot;)
    &#125;
&#125;);
//查询
StuModel.find(&#123;name:&#39;xxx&#39;&#125;,&quot;name -_id&quot;, &#123;skip:2,limit:!&#125;,function(err,docs)&#123;  
//&quot;name -_id&quot;相当于 &#123;name:1,_id:0&#125; ，表示查询 name，不显示 _id（默认会显示 _id）
    if(!err)&#123;
        console.log(docs);
    &#125;
&#125;);
StuModel.findById(&quot;_id的值&quot;,function(err,doc)&#123;  
    if(!err)&#123;
        console.log(doc);
    &#125;
&#125;);
StuModel.findOne(&#123;&#125;,function(err,doc)&#123;  
    if(!err)&#123;
        console.log(doc);
    &#125;
&#125;);
//修改
StuModel.update(&#123;name:&#39;xxx&#39;&#125;,&#123;$set:&#123;age:20&#125;&#125;,&#123;multi:true&#125;,function()&#123;
    if(!err)&#123;
        console.log(&quot;修改成功&quot;);
    &#125;
&#125;)
//删除
StuModel.remove(&#123;name:&#39;xxx&#39;&#125;,function(err)&#123;
    if(!err)&#123;
        console.log(&quot;删除成功&quot;);
    &#125;
&#125;)
//统计文档数量
StuModel.count(&#123;&#125;,function(err,count)&#123;
    if(!err)&#123;
        console.log(count);
    &#125;
&#125;)</code></pre>
<h3 id="Document-中的方法"><a href="#Document-中的方法" class="headerlink" title="Document 中的方法"></a>Document 中的方法</h3><p>Document 和集合中的文档一一对应，Document 是 Model 的实例，通过 Model 查询到的结果都是 Document</p>
<p>因此可以通过 Model 的构造函数 <code>new Model对象</code> 来创建一个 Document 对象</p>
<p><code>Model#save([options], [options.safe], [options.validateBeforeSave], [fn])</code> 将文档插入数据库中</p>
<p><code>Document对象.update(修改内容,[options],[callback])</code> 修改对象</p>
<p><code>Document对象.remove([callback])</code> 删除对象</p>
<p><code>Document对象.get(属性)</code> 或 <code>Document对象.属性</code> 获取文档中的指定属性值</p>
<p><code>Document对象.set(属性名,新属性值)</code> 设置文档中的指定属性值</p>
<p><code>Document对象.id</code> 获取文档的 _id 属性值</p>
<p><code>Document对象.equal(doc)</code> 比较两个文档是否相同</p>
<p><code>Document对象.isNew</code> 是否为一个新的文档，即是否存入，是布尔值</p>
<p><code>isInit(path)</code> 属性是否初始化</p>
<p><code>toJSON()</code> 转换为一个 JSON 对象</p>
<p><code>toObject()</code> 将 Document 对象转换为一个普通的 JS 对象，转换后所有的 Document 对象的方法或属性都不能使用了</p>
<pre><code>//创建一个 Document，但并没有插入数据库中
var stu = new StuModel(&#123;
    name:&quot;xxx1&quot;,
    age:12,
    gender:&quot;female&quot;,
    address:&quot;ddddd&quot;
&#125;)
//将上面的文档插入数据库中
stu.save(function(err)&#123;
    if(!err)&#123;
        console.log(&quot;保存成功&quot;)
    &#125;
&#125;)
//
StuModel.findOne(&#123;&#125;,function(err,doc)&#123;  
    if(!err)&#123;
        //修改方式一
        doc.update(&#123;$set:&#123;age:28&#125;&#125;,function(err)&#123;
            if(!err)&#123;
                console.log(&quot;修改成功&quot;)
            &#125;
        &#125;)
        //修改方式二
        doc.age = 18;
        doc.save();
        //删除
        doc.remove(function(err)&#123;
            if(!err)&#123;
                console.log(&quot;删除成功&quot;)
            &#125;
        &#125;
        console.log(doc.get(&quot;age&quot;));  //相当于doc.age
        doc.set(&quot;name&quot;,&quot;aaa&quot;);  //相当于doc.name=&quot;aaa&quot;
        doc.save();
        console.log(doc.id);  //相当于doc._id
    &#125;
&#125;);</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>向数据库中添加数据可以使用 <code>Model.create</code> 或 <code>Model#save</code>（# 表示是 Model 实例对象的方法）</p>
<h2 id="5、Mongoose-模块化"><a href="#5、Mongoose-模块化" class="headerlink" title="5、Mongoose 模块化"></a>5、Mongoose 模块化</h2><p>（1）定义一个模块（如 conn_mongo.js），用来连接 MongoDB 数据库</p>
<pre><code>var mongoose = require(&quot;mongoose&quot;);
mongoose.connect(&quot;mongodb://127.0.0.1/test&quot;);
mongoose.connection.once(&quot;open&quot;,function()&#123;
    console.log(&quot;数据库连接成功&quot;);
&#125;);</code></pre>
<p>（2）定义模型对象（如 student.js）</p>
<pre><code>var mongoose = require(&quot;mongoose&quot;);
var Schema = mongoose.Schema;
var stuSchema = new Schema(&#123;
  name:  Number,
  gender: &#123;
        type:String,
        default:&quot;female&quot;
    &#125;,
  address: String,
&#125;);
//定义模型
var StuModel = mongoose.model(&#39;students&#39;, stuSchema);
//暴露方式一
exports.model = StuModel;
//暴露方式二：module.exports = StuModel;</code></pre>
<p>（3）使用</p>
<pre><code>require(&quot;./conn_mongo&quot;);
var Student = require(&quot;./student&quot;).model; //使用方式一暴露时
//使用方式一暴露时：var Student = require(&quot;./student&quot;);
//两种方式引入后，Student 就是表示模型对象</code></pre>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p>1、数据库相关操作速度较慢，应尽量少用数据库操作相关语句，在操作数据库前将数据整理好，如插入 20000 条数据</p>
<p>方式一：</p>
<pre><code>for(var i=1; i&lt;=20000; i++)&#123;
    db.numbers.insert(&#123;num:i&#125;);
&#125;
执行 7.2s</code></pre>
<p>方式二：</p>
<pre><code>var arr = [];
for(var i=1; i&lt;=20000; i++)&#123;
    arr.push(&#123;num:i&#125;);
&#125;
db.numbers.insert(arr);
执行 0.4s</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、版本控制"><a href="#一、版本控制" class="headerlink" title="一、版本控制"></a>一、版本控制</h1><p>Git 是版本控制器，版本控制是一种记录一个或若干文件内容变化以便将来查阅特定版本修订情况的系统</p>
<a id="more"></a>

<p>版本控制系统分为集中式和分布式</p>
<h2 id="为什么要使用版本控制"><a href="#为什么要使用版本控制" class="headerlink" title="为什么要使用版本控制"></a>为什么要使用版本控制</h2><p>（1）软件开发中采用版本控制系统可将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间的的状态，且额外增加的工作量很少</p>
<p>（2）还可比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致问题出现的原因，又是谁在何时报告了某个功能缺陷等</p>
<h3 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h3><p>集中化的版本控制系统，如  CVS，Subversion（svn） 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或提交更新。</p>
<p>svn 因为每次存的都是差异(A1、A2-A1…An-A(n-1))，需要的硬盘空间会相对小一点，可是回退的速度会很慢</p>
<p><strong>优点：</strong>代码存放在单一服务器上便于项目管理</p>
<p>每个人都可以在一定程度上看到项目中的其他人正在做些什么，而管理员也可以轻松掌控每个开发者的权限，并管理一个集中化的版本控制系统，远比在各个客户端上维护本地数据库来的轻松容易</p>
<p><strong>缺点：</strong>服务器宕机：员工写的代码得不到保障，不敢轻易修改代码；服务器炸了：整个项目历史记录都会丢失</p>
<p>中央服务器的单点故障，若服务器宕机一小时，这一小时内谁都无法提交更新也就无法协同工作。若中央服务器磁盘发生故障，且没备份或备份不及时，就会有丢失数据的风险，甚至彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来保存在本地的某些快照数据不能保证所有数据都有人事先完整提取出来过，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险</p>
<h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p>在这类系统中，如 Git、BitKeeper 等客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来（每台电脑都相当于一台服务器）。这样任何一处协同工作用的服务器发生故障事后都可以用任何一个镜像出来的本地仓库恢复，因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p>
<p>许多这类系统都可以指定和若干不同的远端代码仓库进行交互，所以就可以在同一个项目中分别和不同工作小组的人相互协作</p>
<p>git 每次存的是项目完整快照(A1、A1A2…A(n-1)An)，需要的硬盘空间相对大一点，但 Git 团队对代码做了极致的压缩，最终需要的实际空间比 svn 大不了很多，可是 Git 的回滚速度很快</p>
<p>分布式版本控制系统在管理项目时，存放的不是项目版本与版本之间的差异，它存的是索引，因此所需磁盘空间很少，每个客户端都可以放下整个项目的历史记录</p>
<p>优点：分布式版本控制系统解决了集中式版本控制系统的缺陷</p>
<p>— 断网时也可以进行开发（因为版本控制是在本地进行的）</p>
<p>— 使用 github 进行团队协作，哪怕 github 挂了，每个客户端保存的也都是包含历史记录的整个完整项目</p>
<p>缺点：学习起来比 svn 陡峭</p>
<h1 id="二、Git"><a href="#二、Git" class="headerlink" title="二、Git"></a>二、Git</h1><p>Git 是目前世界上最先进的分布式版本控制系统，设计目标是分支切换速度快，容量小（压缩），完全分布式，非线性分支管理（允许上千个并行开发的分支），适合管理大项目（对速度和数据量的高要求，如有能力管理类似 Linux 内核一样的超大规模项目）</p>
<h2 id="1、Git-安装和配置"><a href="#1、Git-安装和配置" class="headerlink" title="1、Git 安装和配置"></a>1、Git 安装和配置</h2><p>在<a href="https://git-scm.com/download/win">官网</a>下载并安装</p>
<p>Git 提供了一个叫 git config 的命令来配置或读取相应的工作环境变量，这些变量可以存放在以下三个不同地方</p>
<pre><code>/etc/gitconfig 文件：系统中所有用户都普遍适用的配置，若使用 git config 时用 --system 选项，读写的就是这个文件
~/.gitconfig 文件：用户都目录下的配置文件只适用于该用户，若使用 git config 时用 --global 选项，读写的就是这个文件
.git/config 文件：当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件），这里的配置仅针对当前项目有效</code></pre>
<p>注意每个级别的配置都会覆盖上层的相同配置（项目目录下的配置文件优先级最高）</p>
<p>安装后需要配置用户信息（用户名称和电子邮箱），每次 Git 提交时都会引用这两条信息，会随更新内容一起被永久写入历史记录</p>
<pre><code>git config --global user.name &quot;xxx&quot;
git config --global user.email xxx@xxx.com</code></pre>
<p>通过 <code>git config --list</code> 查看已有配置信息</p>
<p>注：也可通过 <code>git config --global --unset user.name</code> 或 <code>git config --global --unset user.email</code> 删除配置信息</p>
<h2 id="2、区域"><a href="#2、区域" class="headerlink" title="2、区域"></a>2、区域</h2><p>区域有三个区域：工作区、暂存区（索引区）、版本库</p>
<p>工作区就是本地代码，是个沙箱环境，在将修改提交到暂存区并记录到历史之前可以随意修改</p>
<p>暂存区可通过 <code>git ls-files -s</code> 查看暂存区当前的样子</p>
<p>版本库可通过 <code>find .git/objects -type f</code> 查看版本库中所有文件</p>
<h2 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象</h2><p>对象有 Git 对象、树对象、提交对象</p>
<p>git 对象相当于文件的一个个版本</p>
<p>树对象相当于项目的一个个版本的快照</p>
<p>提交对象只是树对象的封装，提供作者等信息，提交对象是链式的</p>
<p>一个提交对象对应一个树对象，一个树对象可以对应很多个 git 对象，一个 git 对象对应一个文件，则一个提交对象可以对应很多个文件</p>
<h2 id="4、Git-底层概念（底层命令）"><a href="#4、Git-底层概念（底层命令）" class="headerlink" title="4、Git 底层概念（底层命令）"></a>4、Git 底层概念（底层命令）</h2><h3 id="基础-Linux-命令"><a href="#基础-Linux-命令" class="headerlink" title="基础 Linux 命令"></a>基础 Linux 命令</h3><p>clear：清除屏幕</p>
<p>echo ‘xxx’：往控制台输出信息</p>
<p>echo ‘xxx’ &gt; xxx.txt 往控制台输出信息并存到文件中</p>
<p>ll：将当前目录下的子文件和子目录平铺在控制台</p>
<p>find 目录名：将对应目录下的子孙文件和子孙目录平铺在控制台</p>
<p>find 目录名 -type f：将对应目录下的文件平铺在控制台</p>
<p>rm 文件名：删除文件</p>
<p>mv 源文件 重命名文件：重命名</p>
<p>cat 文件的url：查看对应文件内容</p>
<p>vim 文件的url：编辑文件，按 esc 后按 :q!（强制推出不保存）或按 :wq（保存退出）或按 :set nu（设置行号）</p>
<h3 id="git-对象"><a href="#git-对象" class="headerlink" title="git 对象"></a>git 对象</h3><p>git 对象用于存储数据内容</p>
<p>Git 对象核心部分是个简单的键值对数据库，可向数据库插入任意类型内容，返回一个键值，通过键值可在任意时刻再次检索该内容</p>
<p>Git 存储的键值对（即 Git 对象）是 blob 类型</p>
<h4 id="向数据库写入内容并返回对应键值"><a href="#向数据库写入内容并返回对应键值" class="headerlink" title="向数据库写入内容并返回对应键值"></a>向数据库写入内容并返回对应键值</h4><p><strong>将控制台内容存入文件</strong></p>
<pre><code>echo &#39;test content&#39; | git hash-object -w --stdin</code></pre>
<p>-w 选项指示 hash-object 命令存储数据对象，若不指定该选项，则该命令仅返回对应键值，不存储数据</p>
<p>–stdin （standard input）选项指示该命令从标准输入读取内容，若不指定该选项则须在命令尾部给出待存储文件的路径 <code>git hash-object -w 文件路径</code></p>
<p>该命令输出一个长度为 40 个字符的校验和（SHA-1 哈希值）</p>
<p><strong>存文件（往 git 数据库中存对象）</strong></p>
<pre><code>git hash-object -w 文件路径</code></pre>
<p><strong>返回对应文件的键值</strong></p>
<pre><code>git hash-object 文件路径</code></pre>
<h4 id="Git-如何存储数据"><a href="#Git-如何存储数据" class="headerlink" title="Git 如何存储数据"></a>Git 如何存储数据</h4><p>开始时 Git 存储内容的方式是一个文件对应一条内容，校验和的前两个字符用于命名 objects 下子目录，余下的 38 个字符用作文件名</p>
<p>如存储数据后通过命令 <code>find .git/objects -type f</code> 查看保存的文件（假设该文件哈希值为 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc），返回 .git/objects/d6/70460aaaaaaaaaaaaabbbbbbbbbbcccccccccc，该命令用于查看版本库内容</p>
<h4 id="根据键值拉取数据"><a href="#根据键值拉取数据" class="headerlink" title="根据键值拉取数据"></a>根据键值拉取数据</h4><p>下列命令返回文件内容</p>
<pre><code>git cat-file -p 完整哈希值</code></pre>
<p>-p 选项指示该命令自动判断内容的类型，并显示格式友好的内容（即不是压缩后的乱码）</p>
<p>下列命令可显示存储的任何对象的类型</p>
<pre><code>git cat-file -t 完整哈希值</code></pre>
<h4 id="对一个文件进行简单版本控制"><a href="#对一个文件进行简单版本控制" class="headerlink" title="对一个文件进行简单版本控制"></a>对一个文件进行简单版本控制</h4><p>创建一个新文件并将其内容存入数据库</p>
<pre><code>echo &#39;version 1&#39; &gt; test.txt
git hash-object -w test.txt</code></pre>
<p>返回文件哈希值</p>
<p>向文件写入新内容，并再次将其存入数据库</p>
<pre><code>echo &#39;version 2&#39; &gt; test.txt
git hash-object -w test.txt</code></pre>
<p>此时会生成新哈希值就会在 objects 中生成新目录新文件</p>
<p>注意上述所有操作当前都是对本地数据库进行操作，直接存至版本库，不涉及暂存区</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、记住文件的每个版本所对应的 SHA-1 值并不现实</p>
<p>2、在 Git 中，文件名并没有被保存，仅保存了文件内容</p>
<p><strong>解决：</strong>树对象</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object）能解决文件名保存的问题，也允许将多个文件组织到一起。</p>
<p>Git 以一种类似于 UNIX 文件系统的方式存储内容，所有内容均以树对象和数据对象（git 对象）的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象（git 对象）大致上对应文件内容</p>
<p>一个树对象包含一条或多条记录（一条记录即一个 git 对象），也可以包含另一个树对象，每条记录含有一个指向 git 对象或子树对象的 SHA-1 指针，及对应的模式、类型、文件名信息</p>
<h4 id="构建树对象"><a href="#构建树对象" class="headerlink" title="构建树对象"></a>构建树对象</h4><p>可通过 update-index、write-tree、read-tree 等命令构建树对象并塞入暂存区</p>
<p>（1）利用 update-index 命令为 git 数据库中已存在的 test.txt 文件的首个版本创建一个暂存区，让 git 对象对应上文件名，并通过 write-tree 命令生成树对象并存入版本库</p>
<pre><code>git update-index --add --cacheinfo 100644 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc test.txt
git write-tree</code></pre>
<p>其中文件模式<br>    100644 表示这是个普通文件<br>    100755 表示一个可执行文件<br>    120000 表示一个符号链接</p>
<p><code>--add</code> 选项：因为此前该文件并不在暂存区中，首次添加需要 <code>--add</code></p>
<p><code>--cacheinfo</code> 选项：因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下，所以需要 <code>--cacheinfo</code></p>
<p>（2）新增 new.txt 将 new.txt 和 test.txt 文件的第二个版本塞入暂存区，并通过 write-tree 命令生成树对象并存入版本库</p>
<pre><code>echo &#39;new file&#39; &gt; new.txt
git update-index --cacheinfo 10064 d670460aaaaaaaaaaaaabbbbbbbbbbcccccccccc test.txt 此时会覆盖原先暂存区中的test.txt
git update-index --add new.txt 该命令完成两步（1）生成 git 对象存入版本库（2）将 new.txt 文件放入暂存区（执行类似上条命令，但需要加 --add，因为该文件首次加入暂存区）</code></pre>
<p>（3）将第一个树对象加入第二个树对象，使其称为新的树对象</p>
<pre><code>git read-tree --prefix=bak 第一个树对象的哈希值
git write-tree</code></pre>
<p>read-tree 命令可以把树对象读入暂存区</p>
<p>最终树对象结构如下</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%AF%B9%E8%B1%A1.png" alt="树对象"></p>
<h4 id="查看树对象"><a href="#查看树对象" class="headerlink" title="查看树对象"></a>查看树对象</h4><pre><code>git cat-file -p master^&#123;tree&#125;或是树对象的hash</code></pre>
<p>master^{tree} 语法表示 master 分支上最新提交所指向的树对象</p>
<h4 id="解析树对象"><a href="#解析树对象" class="headerlink" title="解析树对象"></a>解析树对象</h4><p>Git 给根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录某个时间段内一系列的树对象</p>
<p>其实树对象是对暂存区内操作的抽象，树对象相当于快照，当工作区有任何更改同步到暂存区时，便会调用 write-tree 命令</p>
<p>通过 write-tree 命令向暂存区内容写入一个树对象，它会根据当前暂存区状态自动创建一个新的树对象，即每一次同步都产生一个树对象，且该命令返回一个 hash 指向树对象</p>
<p>在 Git 中每个文件（数据）都对应一个 hash（blob 类型），每个树对象都对应一个 hash（tree 类型）</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>现有两个树对象分别代表想要跟踪的不同项目快照，若想宠用这些快照必须记住所有 SHA-1 哈希值，可能完全不指定谁在什么时候保存了这些快照</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>可通过调用 <code>commit-tree</code> 创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（若有的话）（第一次将暂存区做快照就没有父对象）</p>
<p>git commit-tree 不但生成提交对象，而且会将对应的快照（树对象）提交到版本库中</p>
<h4 id="创建提交对象"><a href="#创建提交对象" class="headerlink" title="创建提交对象"></a>创建提交对象</h4><pre><code>echo &#39;first commit&#39; | git commit-tree 树对象哈希值</code></pre>
<p>返回提交对象哈希值</p>
<h4 id="查看提交对象"><a href="#查看提交对象" class="headerlink" title="查看提交对象"></a>查看提交对象</h4><pre><code>git cat-file -p 提交对象哈希值</code></pre>
<h4 id="提交对象的格式"><a href="#提交对象的格式" class="headerlink" title="提交对象的格式"></a>提交对象的格式</h4><p>它先指定一个顶层树对象，代表当前项目快照，然后是作者/提交信息（依据 user.name 和 user.email 配置，外加一个时间戳），空一行，最后是提交注释</p>
<p>创建另外两个提交对象，它们分别引用各自的上一个提交作为其父对象</p>
<pre><code>echo &#39;second commit&#39; | git commit-tree 树对象哈希值 -p 第一个提交对象哈希值
echo &#39;third commit&#39; | git commit-tree 树对象哈希值 -p 上一个提交对象哈希值</code></pre>
<h2 id="5、Git-本地操作（高层命令）"><a href="#5、Git-本地操作（高层命令）" class="headerlink" title="5、Git 本地操作（高层命令）"></a>5、Git 本地操作（高层命令）</h2><h3 id="git-操作基本流程"><a href="#git-操作基本流程" class="headerlink" title="git 操作基本流程"></a>git 操作基本流程</h3><p>（1）创建工作目录，对工作目录进行修改</p>
<p>（2）git add 路径</p>
<p>（3）git commit -m “注释内容”</p>
<h3 id="初始化新仓库"><a href="#初始化新仓库" class="headerlink" title="初始化新仓库"></a>初始化新仓库</h3><p>要对现有的某个项目开始用 Git 管理，只需在此项目所在目录下执行 <code>git init</code> 初始化新仓库</p>
<p>作用：初始化后在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中</p>
<pre><code>hooks：目录包含客户端或服务端的钩子脚本
info：包含一个全局性排除的文件
logs：保存日志信息
objects：目录存储所有数据内容
refs：目录存储指向数据的提交对象的指针（即分支）
config：文件包含项目特有的配置选项
description：用来显示对仓库的描述信息
HEAD：文件指示目前所检出的分支
index：文件保存暂存区信息</code></pre>
<p>至此仅是按照既有的结构框架初始化里边所有文件和目录，还没开始跟踪管理项目中的任何一个文件</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下所有文件都不外乎两种状态：已跟踪 或 未跟踪</p>
<p><strong>已跟踪的文件</strong>指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<strong>已提交、已修改或已暂存</strong></p>
<p>所有其他文件都属于<strong>未跟踪文件</strong>，它们既没有上次更新时的快照也不在当前的暂存区域</p>
<p>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为已提交，在编辑过某些文件后，Git 将这些文件标记为已修改，我们逐步把这些修改过的文件放到暂存区，最后一次性提交所有暂存文件</p>
<h3 id="跟踪新文件（将修改添加到暂存区）"><a href="#跟踪新文件（将修改添加到暂存区）" class="headerlink" title="跟踪新文件（将修改添加到暂存区）"></a>跟踪新文件（将修改添加到暂存区）</h3><pre><code>git add ./</code></pre>
<p>git add 命令是先将工作区的文件以 git 对象（几个文件就对应几个 git 对象）存储到版本库中，再存放到暂存区</p>
<p>此时这些文件受到 git 管理</p>
<p>该命令相当于底层命令中的 <code>git hash-object -w 文件名</code>（修改了多少个工作目录中的文件此命令就要被执行多少次）和 <code>git update-index ...</code></p>
<h3 id="提交更新（将暂存区提交到版本库）"><a href="#提交更新（将暂存区提交到版本库）" class="headerlink" title="提交更新（将暂存区提交到版本库）"></a>提交更新（将暂存区提交到版本库）</h3><p>方式一：</p>
<pre><code>git commit</code></pre>
<p>这种方式会启动文本编辑器以便输入提交注释，默认的注释是最后一次 git status 的输出</p>
<p>方式二：</p>
<pre><code>git commit -m &quot;注释&quot;</code></pre>
<p>执行上述两种命令进行提交，不会清空暂存区</p>
<p>该命令相当于底层命令中的 <code>git write-tree</code> 和 <code>git commit-tree</code></p>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><pre><code>git status</code></pre>
<p>查看文件当前处于什么状态</p>
<p>文件状态生命周期如下图所示</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="文件状态生命周期"></p>
<p>注意若对已经 add 但未 commit 的文件进行修改后使用 git status 查看会显示该文件有两种状态，一种是已暂存（这种状态对应最新修改前的版本），一种是已修改未暂存（这种状态对应最新修改后的版本），此时需要重新 add 后 commit 提交的才是最新版本</p>
<h3 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h3><p>git status 只是列出修改过的文件，若要查看具体修改的地方，用 git diff 命令</p>
<p>查看当前做的哪些更新还没有暂存</p>
<pre><code>git diff</code></pre>
<p>有哪些更新已经暂存还没提交</p>
<pre><code>git diff --cached
或
git diff --staged（1.6.1以上版本）</code></pre>
<h3 id="跳过使用暂存区"><a href="#跳过使用暂存区" class="headerlink" title="跳过使用暂存区"></a>跳过使用暂存区</h3><p>给 git commit 加上 -a 选项，Git 会自动把所有<strong>已跟踪的文件</strong>暂存起来一并提交，从而跳过 git add 步骤（注意只有已跟踪的文件才能用这条命令，没有跟踪过的文件还是需要先 add）</p>
<pre><code>git commit -a
或
git commit -a -m &quot;注释&quot;</code></pre>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>方式一：</p>
<p>若在工作目录中删除某文件相当于一次修改操作，依然需要 add 和 commit</p>
<p>方式二：</p>
<p>要从 Git 中移除某文件，必须从已跟踪文件清单中年注册删除（也就是在暂存区注册删除），然后提交</p>
<pre><code>git rm 文件路径和名
git status
git commit -m &quot;注释&quot;</code></pre>
<p><code>git rm</code> 删除工作目录中指定文件，再将修改添加到暂存区，这样以后就不会出现在未跟踪文件清单中</p>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><pre><code>git mv 原文件 新文件路径和名
git status</code></pre>
<p>git mv 将工作目录中的文件进行重命名，再将修改添加到暂存区</p>
<p>运行 <code>git mv</code> 相当于运行了三条命令：（1）<code>git mv 原文件 新文件</code>（2）<code>git rm 原文件</code>（3）<code>git add 新文件</code></p>
<h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><pre><code>git log</code></pre>
<p>默认不加任何参数时 git log 会按提交时间列出所有更新，最近的排在最上面，会列出哈希值、作者名、邮箱、提交时间、提交说明</p>
<pre><code>git log --pretty=oneline</code></pre>
<p>每条记录的信息排列在一行</p>
<pre><code>git log --oneline</code></pre>
<p>每条记录的信息排列在一行，且提交对象哈希值只显示前 7 位</p>
<pre><code>git reflog</code></pre>
<p>只要 HEAD 有变化，git reflog 就会记录下来</p>
<h2 id="6、Git-分支操作（杀手功能）"><a href="#6、Git-分支操作（杀手功能）" class="headerlink" title="6、Git 分支操作（杀手功能）"></a>6、Git 分支操作（杀手功能）</h2><p>几乎所有版本控制系统都以某种形式支持分支。使用分支可以把工作从开发主线上分离开来，以免影响开发主线，相当于创建一个源码目录副本，十分耗时低效，但 Git 的分支模型及其高效轻量，也是这一特性让 Git 脱颖而出</p>
<p>分支的本质是指向提交对象的可变指针，可理解为其实就是一个提交对象（相当于给提交对象取名），那个可变指针是 HEAD</p>
<p>HEAD 是个指针，默认指向 master 分支，切换分支时就是让 HEAD 指向不同分支</p>
<p>每次有新的提交时，HEAD 都会带着当前指向的分支一起往前移动</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code>git branch 分支名</code></pre>
<p>作用：在当前所在提交对象上创建一个可移动的新指针</p>
<p>注意：创建新分支后不会自动切换到新分支上</p>
<pre><code>git checkout -b 分支名</code></pre>
<p>上述命令新建一个分支并切换到该分支上</p>
<pre><code>git branch 分支名 提交对象哈希值</code></pre>
<p>上述命令新建一个分支并使分支指向对应提交对象，通过该命令可实现版本回退，想回哪里回哪里，只需在之前某版本处创建一个分支指向它即可查看该版本内容</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre><code>git branch</code></pre>
<p>得到当前所有分支的列表</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre><code>git branch -d 分支名</code></pre>
<h3 id="查看每个分支的最后一次提交"><a href="#查看每个分支的最后一次提交" class="headerlink" title="查看每个分支的最后一次提交"></a>查看每个分支的最后一次提交</h3><pre><code>git branch -v</code></pre>
<h3 id="查看已合并到当前分支的分支"><a href="#查看已合并到当前分支的分支" class="headerlink" title="查看已合并到当前分支的分支"></a>查看已合并到当前分支的分支</h3><pre><code>git branch -merged</code></pre>
<p>在这个列表中分支名且前没有 * 号的分支通常可以使用</p>
<h3 id="查看所有包含未合并工作的分支"><a href="#查看所有包含未合并工作的分支" class="headerlink" title="查看所有包含未合并工作的分支"></a>查看所有包含未合并工作的分支</h3><pre><code>git branch --no-merged</code></pre>
<p>一旦出现在这个列表中就应该观察一些是否需要合并</p>
<p>使用 git branch -d 删除在这个列表中的分支时会失败，若真要删除分支并丢掉那些工作可使用 -D 选项强制删除它</p>
<h3 id="查看当前分支所指对象"><a href="#查看当前分支所指对象" class="headerlink" title="查看当前分支所指对象"></a>查看当前分支所指对象</h3><pre><code>git log --oneline --decorate</code></pre>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code>git checkout 分支名</code></pre>
<p>即将 HEAD 指针指向切换的分支，HEAD 默认指向 master（有新版本 HEAD 带动着 master 向前移动）</p>
<p>切换分支会动三个地方：HEAD、暂存区、工作目录</p>
<p>最佳方法：每次切换分之前，当前分支一定得是干净的（已提交状态）（可通过 git status 查看是否 clean）</p>
<p>坑：在切换分支时，若当前分支上有未暂存修改或未提交的暂存，此时分支可以切换成功，但可能会污染其他分支（这种情况针对于增加某文件时，若文件已在某分支提交过只是修改，则不会有该坑，git 自己会禁止切换分支操作）</p>
<pre><code>如在分支test中新增文件但未跟踪（没有 add）或 add 了但没有 commit，此时切回 master，该文件依然存在

若在分支test中修改文件但没有 add 或 add 了但没有 commit，此时 Git 就不让切换分支</code></pre>
<p>注意：分支切换回改变工作目录中的文件，在切换分支时，一定要注意工作目录里的文件会被改变，若是切换到一个较旧的分支，工作目录会恢复到该分支最后一次提交时的样子，若 Git 不能干净利落完成这个任务将禁止切换分支</p>
<p><strong>每次在切换分支前，提交一下当前分支</strong></p>
<p>允许切换分支的情况：</p>
<pre><code>（1）分支上所有内容处于已提交状态
（2）分支上内容是初始化创建的，处于未跟踪状态，但这种情况要避免切换分支
（3）分支上内容是初始化创建的且该文件是第一次处于已暂存状态（即第一次 add 该文件，且 add 后没有修改过该文件），但这种情况要避免切换分支</code></pre>
<p>不允许切换分支的情况：</p>
<pre><code>（1）分支上所有内容处于已修改状态
（2）第二次以后的已暂存状态</code></pre>
<h3 id="查看项目分支历史"><a href="#查看项目分支历史" class="headerlink" title="查看项目分支历史"></a>查看项目分支历史</h3><pre><code>git log --oneline --decorate --graph --all</code></pre>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>先切回 master 分支，再合并分支</p>
<pre><code>git merge 分支名</code></pre>
<p>快进合并（fast-forward）：若合并两个分支时，顺着一个分支走下去能到达另一个分支，那么 Git 在合并时只会简单地将指针向前推进。快进合并没有冲突问题</p>
<p>典型合并：此时 master 不是待合并分支的直接祖先（不在一条线路上），可能两个分支上都对某文件内容进行了修改，要解决冲突就是打开有冲突的文件保留下有用代码删除无用代码后 add（该命令即可标记冲突已解决） 和 commit 提交即可</p>
<h3 id="给命令配别名"><a href="#给命令配别名" class="headerlink" title="给命令配别名"></a>给命令配别名</h3><p>Git 不会在输入部分命令时自动推断你想要的命令，若不想每次输入完整 Git 命令，可通过 git config 文件位每个命令设置一个别名，如</p>
<pre><code>git config --global alias.简称 原命令（不包含&#39;git&#39;）
或
git config --global alias.简称 &quot;原命令（不包含&#39;git&#39;）&quot;
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status</code></pre>
<p>当要输入 git commit 时只需输入 git ci</p>
<h3 id="分支实战"><a href="#分支实战" class="headerlink" title="分支实战"></a>分支实战</h3><p>如在开发某网闸时为实现某新需求创建一个分支</p>
<p>原版本中出现一个 bug 需要修复时，要先将当前分支内容 add 和 commit 提交后切换到  master 分支，然后新建一个分支完成 bug 修复</p>
<p>测试通过后切回 master 分支，合并这个修补分支，最后将改动推送到 master 上，此时可以删除修补分支</p>
<p>最后切换回最初工作的分支上继续工作</p>
<h3 id="分支模式"><a href="#分支模式" class="headerlink" title="分支模式"></a>分支模式</h3><p>长期分支（即 master）</p>
<p>特性分支（如 dev、topic功能分支）</p>
<h3 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h3><p>.git/refs 目录中保存了分支及其对应的提交对象</p>
<h4 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h4><p>当运行类似于 <code>git branch 分支名</code> 这样的命令时，Git 会取得当前所在分支最新提交对应的哈希值，并将其加入你想要创建的任何新分支中</p>
<p><strong>当执行 <code>git branch 分支名</code> 时 Git 如何直到最新提交的哈希值呢？</strong></p>
<p>答：通过 HEAD 文件，HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支，所谓符号引用意味着它不像普通引用那样包含一个 SHA-1 值，它是一个指向其他引用的指针</p>
<h2 id="7、Git-存储"><a href="#7、Git-存储" class="headerlink" title="7、Git 存储"></a>7、Git 存储</h2><p>若工作一半需要切换分支，但原工作分支上不想创建一次提交，此时可以使用 <code>git stash</code> 命令</p>
<p><code>git stash</code> 会将未完成的修改保存到一个栈上，可在任何时候通过 <code>git stash apply</code> 重新应用这些改动</p>
<h3 id="git-stash-相关命令"><a href="#git-stash-相关命令" class="headerlink" title="git stash 相关命令"></a>git stash 相关命令</h3><pre><code>git stash list： 查看存储
git stash apply stash@&#123;编号&#125;：若不指定储藏，默认是最近的储藏，注意该命令只会应用栈顶元素不会从栈里删除，应用后可搭配 git ，编号可通过 git stash list 查看
stash drop 删除该元素
git stash drop stash@&#123;编号&#125;：移除某储藏
git stash pop： 应用储藏然后立即从栈上扔掉它（即应用并从栈中删除）</code></pre>
<h2 id="8、数据恢复"><a href="#8、数据恢复" class="headerlink" title="8、数据恢复"></a>8、数据恢复</h2><p>可能因为强制删除正在工作的分支或硬重置一个分支而丢失一次提交</p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><h4 id="撤回工作目录中的修改"><a href="#撤回工作目录中的修改" class="headerlink" title="撤回工作目录中的修改"></a>撤回工作目录中的修改</h4><pre><code>git checkout -- 文件</code></pre>
<h4 id="撤回暂存"><a href="#撤回暂存" class="headerlink" title="撤回暂存"></a>撤回暂存</h4><pre><code>git reset HEAD 文件</code></pre>
<h4 id="撤回提交"><a href="#撤回提交" class="headerlink" title="撤回提交"></a>撤回提交</h4><pre><code>git commit --amend</code></pre>
<p>作用：该命令会将暂存区中的文件提交，若自上次提交以来还未做任何修改，那么快照会保持不变，修改的只是提交信息</p>
<p>若提交时注释写错了，可通过 <code>git commit --amend</code> 重新给用户一次机会改注释</p>
<p>若提交后还有需暂存的文件，或者 add 后又对文件进行修改，可使用以下命令提交新文件</p>
<pre><code>git commit -m &quot;第一次提交&quot;   对于第二种情况这里提交的是之前 add 的文件即修改前的文件
git add 新的暂存文件
git commit --amend</code></pre>
<p>第二次提交将代替第一次提交结果，最终只会有一个提交</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><h4 id="reset-三部曲"><a href="#reset-三部曲" class="headerlink" title="reset 三部曲"></a>reset 三部曲</h4><p>假设文件最初有三个版本，且 HEAD 和 master 都指向最后一次提交，如下图</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset0.png" alt="reset0"></p>
<p><strong>（1）移动 HEAD</strong></p>
<pre><code>git reset --soft HEAD~
或
git reset --soft 上一次提交对象哈希值</code></pre>
<p>上述指令与 checkout 所作的改变 HEAD 自身不同（HEAD 移动，分支不动），reset 是移动 HEAD 指向的分支</p>
<p>该命令只动 HEAD（带着分支一起移动），工作区和暂存区不变</p>
<p>本质上是撤销上一次 git commit 命令。运行 git commit 命令时 Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。当 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，不会改变索引和工作目录，此后可更新索引并再次运行 git commit 命令来完成 git commit –amend 所要做的事</p>
<p>HEAD~ 表示上一次 HEAD</p>
<p><code>git reset --soft HEAD~</code> 相当于 –amend</p>
<p>注意 <code>git reset --soft 提交对象哈希值</code> 可前进到回退之前的版本，这个哈希值可以通过 <code>git reflog</code> 查看</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset1.png" alt="reset1"></p>
<p><strong>（2）更新暂存区（索引）</strong></p>
<pre><code>git reset [--mixed] HEAD~</code></pre>
<p><code>git reset HEAD~</code> 等同于 <code>git reset --mixed HEAD~</code></p>
<p>该命令动了 HEAD（带着分支一起移动）和暂存区</p>
<p>它依然会撤销上一次提交，同时还会取消上一次暂存的所有东西，所以回滚到上一次 add 和 commit 执行之前</p>
<p>注意 <code>git reset --mixed 提交对象哈希值</code> 可前进到回退之前的版本，这个哈希值可以通过 <code>git reflog</code> 查看</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset2.png" alt="reset2"></p>
<p><strong>（3）更新工作目录</strong></p>
<pre><code>git reset --hard HEAD~</code></pre>
<p>撤销了最后的提交、add、commit 以及工作目录中的所有工作</p>
<p>该命令动了 HEAD（带着分支一起移动）、暂存区和工作区</p>
<p>该命令和 chechout 很像，都动了 HEAD、暂存区和工作区，但唯一区别是 checkout 中分支位置没变（即 master 没有跟着 HEAD 移动）</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset3.png" alt="reset3"></p>
<p>注意：–hard 是 reset 命令唯一的危险用法，也是 Git 会真正销毁数据的仅有的几个操作之一，其他任何形式的 reset 都可以轻松撤销，但 –hard 选项不能，因为它强制覆盖了工作目录中的文件</p>
<p>在这种情况下，Git 数据库中的一个提交内还留有该文件的最新版（file.txt v3），可通过 reflog 找回它，但若该文件还未提交，Git 仍会覆盖它从而导致无法恢复</p>
<h5 id="checkout-和-–hard-的区别"><a href="#checkout-和-–hard-的区别" class="headerlink" title="checkout 和 –hard 的区别"></a>checkout 和 –hard 的区别</h5><p><code>git checkout 提交对象哈希值</code> 和 <code>git reset --hard 提交对象哈希值</code> 的区别为</p>
<p>（1）checkout 只动 HEAD，–hard 动 HEAD 且带着分支一起走</p>
<p>（2）checkout 对工作目录是安全的（就算在某分支有没有提交的文件，在切换分支后该文件依然在工作区中），–hard 是强制覆盖工作目录</p>
<h4 id="路径-reset"><a href="#路径-reset" class="headerlink" title="路径 reset"></a>路径 reset</h4><pre><code>git reset [--mixed] HEAD </code></pre>
<p>在 reset 命令中若指定一个路径，reset 将会跳过第 1 步，即该命令只动暂存区，并将它的作用范围限定为指定文件或文件集合。这是因为 HEAD 只是个指针，无法让它同时指向两个提交中各自的一部分，但索引（即暂存区）和工作目录可以部分更新，所以重置会继续进行第 2、3 步</p>
<p>例子</p>
<p>如修改 file.txt 且 add 但没有 commit</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/add%E5%90%8E.png" alt="add后"></p>
<p>然后运行</p>
<pre><code>git reset file.txt
其实是 git reset --mixed HEAD file.txt 的简写</code></pre>
<p>其中 HEAD 指向上一次提交内容，上一次提交内容即为上一次暂存区中的内容，因此相当于用上一次暂存区覆盖当前暂存区，本质上就是一次重置操作</p>
<p>它会移动 HEAD 分支的指向</p>
<p><img src="/2022/02/08/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/reset%E5%90%8E.png" alt="reset后"></p>
<h4 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h4><h5 id="不带路径"><a href="#不带路径" class="headerlink" title="不带路径"></a>不带路径</h5><pre><code>git checkout [分支名]</code></pre>
<p>运行该命令与运行 <code>git reset --hard [分支名]</code> 非常相似，它会更新三者使其看起来像要切换的分支，不过有两点重要区别</p>
<pre><code>区别1：不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢，而 reset --hard 会不做检查就全面替换所有东西
区别2：如何更新 HEAD。reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支

如：在 dev 分支运行 git reset master，则 dev 自身会和 master 指向同一个提交，而若运行 git checkout，dev 不会移动，HEAD 自身会移动，现在 HEAD 会指向 master</code></pre>
<h5 id="带路径"><a href="#带路径" class="headerlink" title="带路径"></a>带路径</h5><p>方式一：</p>
<pre><code>git checkout 提交对象哈希值 文件</code></pre>
<p>若指定一个文件路径，则会像 reset 一样不会移动 HEAD，就像 <code>git reset --hard [分支名] 文件</code> </p>
<p>这样对工作目录不安全，会跳过第 1 步，更新暂存区和工作目录</p>
<p>方式二：</p>
<pre><code>git checkout -- 文件</code></pre>
<p>相比于 <code>git checkout 提交对象哈希值 文件</code>，上述命令第 1、2 步都没做，即 HEAD 和暂存区都没动，只会动工作目录</p>
<h3 id="数据恢复的方式"><a href="#数据恢复的方式" class="headerlink" title="数据恢复的方式"></a>数据恢复的方式</h3><p>方式一：找到对应提交对象的哈希值再使用 reset –hard 硬重置</p>
<p>方式二：    在对应提交对象上创建一个分支</p>
<pre><code>git branch 分支名 提交对象哈希值</code></pre>
<h2 id="9、打-tag"><a href="#9、打-tag" class="headerlink" title="9、打 tag"></a>9、打 tag</h2><p>Git 可以给历史中的某个提交打上标签，一般会用这个功能标记发布结点（v1.0 等）</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><pre><code>git tag
git -l &#39;v1.2.3*&#39; 会列出 v1.2.3 开头的标签</code></pre>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签和附注标签</p>
<p>轻量标签像是一个不会改变的分支，它只是一个特定提交的引用，轻量标签如下</p>
<pre><code>git tag v1.2
git tag v1.2 提交对象哈希值</code></pre>
<p>附注标签是存储在 Git 数据库中的一个完整对象，它可以有哈希值，其中包含打标签者的名字、邮箱、日期时间、标签信息。附注标签如下</p>
<pre><code>git tag -a v1.2
git tag -a v1.2 提交对象哈希值
git tag -a v1.2 提交对象哈希值 -m &quot;注释&quot;</code></pre>
<h3 id="查看特定标签"><a href="#查看特定标签" class="headerlink" title="查看特定标签"></a>查看特定标签</h3><pre><code>git show 标签名</code></pre>
<p>git show 可显示任意类型对象（git 对象、树对象、提交对象、tag 对象）</p>
<h3 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h3><p>默认情况下，git push 命令不会传送标签到远程仓库服务器上，创建完标签后必须显式推送标签到共享服务器上</p>
<pre><code>git push origin [标签名]</code></pre>
<p>若要一次性推送很多标签也可使用 –tags 选项，会把所有不在远程仓库服务器上的标签都推送到那里</p>
<pre><code>git push origin --tags</code></pre>
<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><pre><code>git tag -d 标签名</code></pre>
<p>上述命令可删除本地仓库上的标签，但不会从任何远程库中移除该标签，必须使用如下命令更新远程仓库</p>
<pre><code>git push origin :refs/tags/v1.2</code></pre>
<h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>查看某个标签所指向的文件版本并创建新分支指向它：</p>
<pre><code>git checkout 标签名
git checkout -b 分支名</code></pre>
<p>虽说这会使仓库处于 “分离头指针（detached HEAD）” 状态（即 HEAD 并没有指向哪个分支，而是指向了标签对应的提交版本），在该状态下，若做某些更改并提交，标签不会发生变化，但新提交将不属于任何分支，并将无法访问，除非访问确切的提交对象哈希值，因此若需要进行更改，如修复旧版本的错误，通常要创建一个新分支</p>
<h1 id="三、Git-命令整理"><a href="#三、Git-命令整理" class="headerlink" title="三、Git 命令整理"></a>三、Git 命令整理</h1><h2 id="1、Git-底层命令"><a href="#1、Git-底层命令" class="headerlink" title="1、Git 底层命令"></a>1、Git 底层命令</h2><p><strong>git 对象</strong></p>
<pre><code>git hash-object -w 文件路径
上传一个 key(hash值):val(压缩后的文件内容)存到 .git/objects</code></pre>
<p><strong>tree 对象</strong></p>
<pre><code>git update-index --add --cacheinfo 文件模式 哈希值 文件名
往暂存区添加一条记录（让 git 对象对应上文件名）存到 .git/index
git write-tree
生成树对象</code></pre>
<p><strong>commit 对象</strong></p>
<pre><code>echo &#39;xxxxxx&#39; | git commit-tree 树对象哈希值
生成一个提交对象</code></pre>
<p><strong>对以上对象的查询</strong></p>
<pre><code>git cat-file -p 哈希值
拿到对应对象的内容
git cat-file -t 哈希值
拿到对应对象的类型</code></pre>
<p><strong>查看暂存区</strong></p>
<pre><code>git ls-files -s</code></pre>
<h2 id="2、Git-高层命令"><a href="#2、Git-高层命令" class="headerlink" title="2、Git 高层命令"></a>2、Git 高层命令</h2><p><strong>安装</strong></p>
<pre><code>git --version</code></pre>
<p><strong>初始化配置</strong></p>
<pre><code>git config --global user.name &quot;名字&quot;
git config --gloabal user.email 邮箱
git config --list</code></pre>
<p><strong>初始化仓库</strong></p>
<pre><code>git init</code></pre>
<p><strong>C（新增）</strong></p>
<pre><code>在工作目录新增文件
git status
git add ./
git commit -m &quot;注释&quot;</code></pre>
<p><strong>U（修改）</strong></p>
<pre><code>在工作目录修改文件
git status
git add ./
git commit -m &quot;注释&quot;</code></pre>
<p><strong>D（删除 &amp; 重命名）</strong></p>
<pre><code>git rm 文件路径
git status
git commit -m &quot;注释&quot;

git mv 老文件 新文件
git status
git commit -m &quot;注释&quot;</code></pre>
<p><strong>R（查询）</strong></p>
<pre><code>git status 查看工作目录文件状态
git diff
git diff --cache
git log --oneline
git log --oneline --decorate --graph --all</code></pre>
<p><strong>分支</strong></p>
<pre><code>git log --oneline --decorate --graph --all
查看整个项目的分支图
git branch
查看分支列表
git branch -v
查看分支指向的最新的提交
git branch 分支名
在当前提交对象上创建新分支
git branch 分支名 提交对象哈希值
在指定提交对象上创建新的分支
git checkout 分支名
切换分支
git checkout -b 分支名
创建并切换分支
git branch 分支名 提交对象哈希值
版本穿梭（时光机）
git branch -d 分支名
删除空的分支（即该分支上没有做过任何提交）/删除已经被合并的分支
git branch -D 分支名
强制删除分支
git merge 分支名
合并分支
    快进合并 -- 不会产生冲突
    典型合并 -- 有可能产生冲突
    解决冲突：打开冲突文件进行修改然后 add、commit
git branch --merged
查看合并到当前分支的分支列表，一旦出现在这个列表就应该删除
git branch --no-merged
查看没有合并到当前分支的分支列表，一旦出现在这个列表就应该观察是否需要合并
git stash 将现有做一半的工作存储到栈中
git stash apply 将栈顶工作内容还原，不出栈
git stash drop 删除栈顶
git stash pop 相当于 apply 和 drop 两步操作
git stash list 查看存储</code></pre>
<p><strong>后悔药</strong></p>
<pre><code>git checkout -- 文件名：撤销工作目录的修改
git reset HEAD 文件名：撤销暂存区的修改
git commit --amend： 撤销提交    </code></pre>
<p><strong>reset 三部曲</strong></p>
<pre><code>git reset --soft 提交对象哈希值：用对应提交对象内容重置 HEAD 内容（可对应后悔药中的撤销提交）
git reset [--mixed] 提交对象哈希值：用对应提交对象内容重置 HEAD 内容、重置暂存区（可对应后悔药中的撤销暂存区的修改）
git reset --hard 提交对象哈希值：用对应提交对象内容重置 HEAD 内容、重置暂存区、重置工作目录（可对应后悔药中的撤销工作目录的修改）</code></pre>
<p>三部曲和后悔药其实是一一对应的</p>
<p><strong>路径 reset</strong></p>
<pre><code>所有的路径 reset 都要省略第一步
第一步是重置 HEAD 内容（HEAD 本质指向一个分支，分支的本质是个提交对象，提交对象指向一个树对象，树对象可能指向多个 git 对象，一个 git 对象代表一个文件）
HEAD 可代表一系列文件的状态

git reset [--mixed] 提交对象哈希值 文件
用对应提交对象中的文件的内容重置暂存区</code></pre>
<p><strong>checkout 深入理解</strong></p>
<p>‘git checkout 分支名’ 和 ‘git reset –hard 提交对象哈希值’很像</p>
<p>共同点：</p>
<pre><code>都需要重置 HEAD、暂存区、工作目录</code></pre>
<p>区别：</p>
<pre><code>checkout 对工作目录是安全的，reset --hard 是强制覆盖
checkout 动 HEAD 不会带着分支走，而是切换分支
reset --hard 是带着分支走</code></pre>
<p>checkout + 路径</p>
<pre><code>git checkout 提交对象哈希值 文件
重置暂存区、工作目录
git checkout -- 文件
重置工作目录</code></pre>
<h1 id="四、Git-特点"><a href="#四、Git-特点" class="headerlink" title="四、Git  特点"></a>四、Git  特点</h1><h2 id="（1）直接记录快照，而非差异比较"><a href="#（1）直接记录快照，而非差异比较" class="headerlink" title="（1）直接记录快照，而非差异比较"></a>（1）直接记录快照，而非差异比较</h2><p>Git 和其他版本控制系统的主要差别在于 Git 只关心数据的整体是否发生变化，而大多数其他系统（如 CVS、Subversion、Perforce、Bazaar 等）则只关心文件内容的具体差异，这类系统每次记录哪些文件做了更新以及更新了哪些行什么内容</p>
<h2 id="（2）近乎所有操作都是本地执行"><a href="#（2）近乎所有操作都是本地执行" class="headerlink" title="（2）近乎所有操作都是本地执行"></a>（2）近乎所有操作都是本地执行</h2><p>Git 中绝大多数操作都只需要访问本地文件和资源，不用连网。但若使用 CVCS 的话几乎所有操作都需连网，因为 Git 在本地磁盘上保存着所有当前项目的历史更新，所以处理起来速度飞快</p>
<h2 id="（3）时刻保持数据完整性"><a href="#（3）时刻保持数据完整性" class="headerlink" title="（3）时刻保持数据完整性"></a>（3）时刻保持数据完整性</h2><p>在保存到 Git 之前，所有数据都要进行内容的校验和计算，并将此结果作为数据的唯一标识和索引。索引在文件传输时变得不完整或磁盘损坏导致文件数据缺失，Git 都能立即察觉、</p>
<p>Git 使用 SHA-1 算法计算数据的校验，通过对文件内容或目录结构计算出一个 SHA-1 哈希值作为指纹字符串，由 40 个十六进制字符组成。Git 的工作完全依赖于这类指纹字符串</p>
<h2 id="（4）多数操作仅添加数据"><a href="#（4）多数操作仅添加数据" class="headerlink" title="（4）多数操作仅添加数据"></a>（4）多数操作仅添加数据</h2><p>因为任何一种不可逆的操作，如删除数据，都会使回退或重现历史版本变得困难重重。</p>
<p>在 VCS 中若还未提交更新就有可能丢失或混淆一些修改内容，但在 Git 里一旦提交快照后就完全不用担心丢失数据</p>
<h2 id="（5）文件的三种状态"><a href="#（5）文件的三种状态" class="headerlink" title="（5）文件的三种状态"></a>（5）文件的三种状态</h2><p>对于任何一个文件，在 Git 内部只有三种状态（Git 外的状态就是一个普通文件）：</p>
<p>已提交（committed）：表示该文件已经被安全保存在本地数据库中</p>
<p>已修改（modified）：表示修改了某文件但还没提交保存</p>
<p>已暂存（staged）：表示把已修改的文件放在下次提交时要保存的清单中</p>
<h1 id="五、Git-工作流程"><a href="#五、Git-工作流程" class="headerlink" title="五、Git 工作流程"></a>五、Git 工作流程</h1><p>每个项目都有个 Git 目录（.git），它是 Git 用来保存元数据和对象数据库的地方。每次克隆镜像仓库时，实际拷贝的就是这个目录里的数据</p>
<p>1、在工作目录中修改某些文件</p>
<p>从项目中去除某个版本的所有文件和目录（工作目录），这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的。接下来可在工作目录中编辑文件</p>
<p>2、保存到暂存区，对暂存区做快照</p>
<p>暂存区只不过是个简单的文件，也叫索引文件，一般都放在 Git 目录中</p>
<p>3、提交更新，将保存在暂存区的文件快照永久转储到本地数据库（Git 目录）中</p>
<p>可以从文件所处位置判断状态：</p>
<p>—若是 Git 目录中保存着的特定版本文件，就属于已提交状态</p>
<p>— 若做了修改并已放入暂存区，就属于已暂存状态</p>
<p>— 若自上次取出后，做了修改但还没放到暂存区，就是已修改状态</p>
<h1 id="六、代码风格"><a href="#六、代码风格" class="headerlink" title="六、代码风格"></a>六、代码风格</h1><h2 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h2><p>Eslint 是个开源的 JavaScript 代码检查工具，由 Nicholas C.Zakas 于 2013 年 6 月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或代码，并且不依赖于具体的编码风格，一般编译程序会内置检查工具</p>
<p>JavaScript 是个动态的弱类型语言，在开发中较易出错，因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。ESLin 可让程序员在编码过程中发现问题而不是在执行过程中</p>
<p>ESLint 初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他插件没有什么区别，规则本身和测试可依赖于同样的模式。为了便于使用，ESLint 内置了一些规则，也可在使用过程中自定义规则</p>
<p>ESLint 使用 Node.js 编写，这样既有一个快速的运行环境也便于安装</p>
<p>Lint 是检验代码格式工具的统称，具体的工具由 Jslint、Eslint 等</p>
<h2 id="git-时忽略某些文件"><a href="#git-时忽略某些文件" class="headerlink" title="git 时忽略某些文件"></a>git 时忽略某些文件</h2><p>一些自动生成的文件如日志文件、编译过程中创建的临时文件等无需纳入 Git 管理</p>
<p>可创建一个 .gitignore 文件列出要忽略的文件模式，如</p>
<pre><code>*.[oa] 忽略以 .o 或 .a 结尾的文件
*~ 忽略以 ~ 结尾的文件</code></pre>
<h3 id="gitignore-的格式规范"><a href="#gitignore-的格式规范" class="headerlink" title=".gitignore 的格式规范"></a>.gitignore 的格式规范</h3><p>所有空行或以注释符号 # 开头的行都会被 Git 忽略</p>
<p>可使用标准的 glob 模式匹配</p>
<pre><code>* 代表匹配任意个字符
? 代表匹配任意一个字符
** 代表匹配多级目录
匹配模式前跟反斜杠（/）代表项目根目录
匹配模式最后跟反斜杠（/）说明要忽略的是目录
在模式前加感叹号（!）取反表示忽略指定模式以外的文件或目录</code></pre>
<p>.gitignore 文件一般内容如下：</p>
<pre><code>.DS_Store
node_modules/
/dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
# 编辑器的目录和文件
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln</code></pre>
<p>在 GitHub 有一个针对数十种项目及语言的<a href="https://github.com/github/gitignore">.gitignore 文件列表</a>，可找到对应的 .gitignore 文件进行使用</p>
<h3 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h3><p>glob 模式指 shell 所使用的简化了的正则表达式</p>
<h2 id="使用-Eslint"><a href="#使用-Eslint" class="headerlink" title="使用 Eslint"></a>使用 Eslint</h2><p>（1）安装 node 和 npm 环境</p>
<p>（2）创建项目</p>
<pre><code>npm init</code></pre>
<p>（3）本地安装 eslint</p>
<pre><code>npm i eslint --save-dev</code></pre>
<p>（4）设置 package.json 文件</p>
<pre><code>&quot;scripts&quot;&#123;
    &quot;lint&quot;: &quot;eslint ./src&quot;
    &quot;lint:create&quot;: &quot;eslint --init&quot;
&#125;</code></pre>
<p>（5）生成 .eslintrc.js 文件，提供编码规则</p>
<pre><code>npm run lint:create</code></pre>
<p>（6）校验代码，自动检验 src 目录下所有的 .js 文件</p>
<pre><code>npm run lint</code></pre>
<p>注意（4）（5）（6）也可以换成 <code>npx eslint --init</code> 和 <code>npx eslint 目录名</code></p>
<h2 id="eslint-结合-git"><a href="#eslint-结合-git" class="headerlink" title="eslint 结合 git"></a>eslint 结合 git</h2><p>husky 帮助自动注册很多 git 的钩子，为 git 仓库设置钩子程序</p>
<p>要先有 git 仓库再安装 husky</p>
<pre><code>git init
npm i husky --save-dev</code></pre>
<p>在 package.json 中添加如下配置</p>
<pre><code>&quot;husky&quot;: &#123;
    &quot;hooks&quot;: &#123;
        &quot;pre-commit&quot;: &quot;npm run lint&quot;, //表示在 git commit 之前要通过 npm run lint，不通过不让提交
        &quot;pre-push&quot;: &quot;npm test&quot;,
        &quot;...&quot;: &quot;...&quot;
    &#125;
&#125;</code></pre>
<h1 id="七、团队协作"><a href="#七、团队协作" class="headerlink" title="七、团队协作"></a>七、团队协作</h1><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>为了能在任意Git 项目上团队协作，远程仓库是指托管在因特网或其他网络中的你的项目的版本库。</p>
<p>管理远程仓库包括添加远程仓库、移除无效远程仓库、管理不同的远程分支并定义它们是否被跟踪等</p>
<h2 id="远程协作基本流程"><a href="#远程协作基本流程" class="headerlink" title="远程协作基本流程"></a>远程协作基本流程</h2><p>GitHub 是最大的 Git 版本库托管商，大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其他事情</p>
<p>（1）项目经理创建远程仓库</p>
<p>在 github 中创建一个未初始化的空仓库</p>
<p>（2）项目经理创建本地库</p>
<pre><code>git init</code></pre>
<p>（3）项目经理为远程仓库配置别名与用户信息</p>
<pre><code>git remote add 简称 远程仓库的https路径</code></pre>
<p>添加一个新的远程 Git 仓库，同时指定一个简称</p>
<pre><code>git config user.name &quot;xxx&quot;
git config user.email &quot;xxx@xxx.com&quot;</code></pre>
<p>配置用户信息</p>
<pre><code>git remote -v </code></pre>
<p>显式远程仓库使用的 Git 别名与其对应的 URL</p>
<pre><code>git remote show 远程仓库名</code></pre>
<p>查看某个远程仓库的更多信息</p>
<pre><code>git remote rename pb 新名字</code></pre>
<p>重命名</p>
<pre><code>git remote rm 远程仓库名</code></pre>
<p>移除某个远程仓库</p>
<p>（4）项目经理推送本地项目到远程仓库</p>
<p>初始化一个本地仓库并清理 Windows 凭据，然后</p>
<pre><code>git push 远程仓库名 分支名</code></pre>
<p>推完后会附带生成远程跟踪分支</p>
<p>（5）成员克隆远程仓库到本地</p>
<pre><code>git clone 远程仓库的https路径</code></pre>
<p>克隆后在本地生成 .git 文件，默认克隆时为远程仓库起的别名为 origin，并且默认主分支有对应的远程跟踪分支</p>
<pre><code>git clone -o 别名</code></pre>
<p>默认的远程仓库别名为自定义</p>
<p><strong>注意：只有在克隆时本地分支 master 和远程跟踪分支 别名/master 是有同步关系的，即后续在本地该分支 push 时即使不指定远程分支也能准确 push 到对应远程分支上</strong></p>
<p>（6）项目经理邀请成员加入团队</p>
<p>在 GitHub 项目仓库的 ‘Settings’ –&gt; ‘Collaborators’ 中设置</p>
<p>（7）成员推送提交到远程仓库</p>
<pre><code>git push 远程仓库名 分支名</code></pre>
<p>此处 push 后也会附带生成远程跟踪分支</p>
<p>（8）项目经理更新成员提交的内容</p>
<pre><code>git fetch 远程仓库名</code></pre>
<p>该命令会访问远程仓库，从中拉取所有你还没有的数据，将修改同步到远程跟踪分支上，执行完后，将拥有那个远程仓库中所有分支的引用，可随时合并或查看</p>
<pre><code>git merge 远程跟踪分支</code></pre>
<p>git fetch 会将数据拉取到本地仓库，它不会自动合并或修改当前工作，需手动将其合并入你的工作</p>
<p>上述 fetch + merge 也可以使用 pull 代替（前提是本地分支需要关联远程跟踪分支才能直接使用 git pull）</p>
<h2 id="正常的数据推送和拉取步骤"><a href="#正常的数据推送和拉取步骤" class="headerlink" title="正常的数据推送和拉取步骤"></a>正常的数据推送和拉取步骤</h2><p>（1）确保本地分支已经跟踪了远程跟踪分支（远程跟踪分支和远程分支间的关系在 push 时已自动建立好了）</p>
<p>（2）拉取数据：git pull</p>
<p>（3）上传数据：git push</p>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>删除远程分支</p>
<pre><code>git push origin --delete 分支</code></pre>
<p>列出仍在远程跟踪但远程已被删除的无用分支</p>
<pre><code>git remote prune origin --dry-run</code></pre>
<p>清除上面命令列出来的远程跟踪</p>
<pre><code>git remote prune origin</code></pre>
<h2 id="pull-request-流程"><a href="#pull-request-流程" class="headerlink" title="pull request 流程"></a>pull request 流程</h2><p>派生（Fork）指 GitHub 将在你的空间中创建一个完全属于你的项目副本，且对其有推送权限</p>
<p>当想参与某个项目但没有推送权限时可对该项目进行 “派生”    </p>
<p>派生项目后将修改推送到派生处的项目副本中，并通过创建合并请求（pull request）来让改动进入源版本库</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>（1）从 master 分支中创建一个新分支（自己 fork 的项目）</p>
<p>（2）提交一些修改来改进项目（自己 fork 的项目）</p>
<p>（3）将这个分支推送到 GitHub 上（自己 fork 的项目）</p>
<p>（4）创建一个合并请求</p>
<p>（5）讨论，根据实际情况继续修改</p>
<p>（6）项目的拥有者合并或关闭你的合并请求</p>
<p>注意：每次再发起新的 pull request 时，要去拉取最新的源仓库的代码，而不是自己 fork 的那个仓库</p>
<pre><code>git remote add 源仓库简称 源仓库路径
git fetch 远程仓库名字
git merge 对应的远程跟踪分支</code></pre>
<h2 id="深入理解远程仓库"><a href="#深入理解远程仓库" class="headerlink" title="深入理解远程仓库"></a>深入理解远程仓库</h2><h3 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h3><p>远程跟踪分支是远程分支状态的引用，它们是不能移动的本地分支，当做任何网络通信操作时，它们会自动移动</p>
<p>它们以（remote）/（branch）形式命名，例如若要看最后一次与远程仓库 orgin 通信时 master 分支的状态，可查看 origin/master 分支</p>
<p>在 push 时会产生远程跟踪分支</p>
<p><strong>当克隆一个仓库时，它通常会自动创建一个跟踪 origin/master 的 master 分支（这是个本地分支）</strong></p>
<p>如</p>
<pre><code>从网络 Git 服务器中克隆一个仓库会自动命名为 origin，拉取它的所有数据，并创建一个指向它的 master 分支的指针，
并在本地将其命名为 origin/master。
Git 也会给你一个与 origin/master 分支指向同一个地方的本地的 master 分支，这样就有工作的基础</code></pre>
<h3 id="跟踪分支（这是个本地分支）"><a href="#跟踪分支（这是个本地分支）" class="headerlink" title="跟踪分支（这是个本地分支）"></a>跟踪分支（这是个本地分支）</h3><p>跟踪分支是与远程分支有直接关系的本地分支，若在一个跟踪分支上输入 <code>git pull</code>，Git 能自动识别去哪个服务器上抓取、合并到哪个分支</p>
<p>从一个远程跟踪分支（origin/master）检出一个本地分支会自动创建一个叫作跟踪分支（也称上游分支 master）</p>
<p>只有主分支并且在克隆时才会自动创建跟踪分支</p>
<pre><code>git checkout -b 分支名 远程仓库/远程分支
或
git checkout --track 远程仓库/远程分支</code></pre>
<p>上述命令可设置跟踪分支关联远程跟踪分支，但第二种命令方式创建的本地分支与远程分支同名，若要不同命则使用第一种命令方式</p>
<p>若已有本地分支，想设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或想修改正在跟踪的跟踪分支，可在任意时间使用 -u 选项运行 git branch 来显式地设置，如下</p>
<pre><code>git branch -u 远程仓库/远程分支
-u 相当于 --set-uptream-to</code></pre>
<p>查看设置的所有跟踪分支：</p>
<pre><code>git branch -vv</code></pre>
<h3 id="推送其他分支"><a href="#推送其他分支" class="headerlink" title="推送其他分支"></a>推送其他分支</h3><p>本地分支并不会自动与远程仓库同步，必须显式地推送想要分享的分支</p>
<pre><code>git push origin 本地分支名</code></pre>
<p>这里 Git 自动将本地分支名展开为 refs/heads/本地分支名:refs/heads/远程分支名，也可运行 git push origin 本地分支:远程分支</p>
<pre><code>git fetch origin</code></pre>
<p>抓取数据，注意当抓取到新的远程跟踪分支时，本地不会自动生成一个对应分支，只有一个不可修改的 origin/远程分支 指针</p>
<p>因此需要将抓取到的合并到当前所在本地分支</p>
<pre><code>git merge origin/远程分支</code></pre>
<p>若想要在自己的本地分支上工作，可建立在远程跟踪分支之上</p>
<pre><code>git checkout -b 本地分支 origin/远程分支</code></pre>
<p>注意：上述的 origin 可以换成对应的远程仓库名</p>
<h3 id="本地分支如何跟踪一个远程跟踪分支"><a href="#本地分支如何跟踪一个远程跟踪分支" class="headerlink" title="本地分支如何跟踪一个远程跟踪分支"></a>本地分支如何跟踪一个远程跟踪分支</h3><p>1、当克隆时会自动生成一个 master 本地分支（已经跟踪了对应的远程跟踪分支）</p>
<p>2、在新建其他分支的同时可指定想要跟踪的远程跟踪分支</p>
<pre><code>git checkout -b 本地分支名 远程跟踪分支
或
git checkout --track 远程跟踪分支</code></pre>
<p>3、将一个已经存在的本地分支改成一个跟踪分支来对应远程跟踪分支</p>
<pre><code>git branch -u 远程跟踪分支</code></pre>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>当 push 时有冲突，需要先 git pull，修改冲突文件后 add 和 commit，然后再 git push</p>
<h1 id="八、SSH"><a href="#八、SSH" class="headerlink" title="八、SSH"></a>八、SSH</h1><p>SSH 协议是 GitHub 自己的协议，https 和 SSH 都是用于验证是哪个用户</p>
<p>使用 https 协议时每次访问远程仓库都要去找到 Windows 凭据，凭据里代表了是哪个用户，而 SSH 协议不用填用户名和密码，和 GitHub 账户是无关联的</p>
<p>在 GitHub 账户中配置公私钥方法：</p>
<p>（1）生成公私钥</p>
<pre><code>ssh-keygen -t rsa -C 邮箱</code></pre>
<p>（2）在 C:\Users\Administrator.ssh 会生成公钥 id_rsa.pub 和公钥 id_rsa</p>
<p>（3）在 GitHub 的 ‘Personal settings’ –&gt; ‘SSH and GPG keys’ 中新增一个 SSH key，把公钥 id_rsa 中的内容复制粘贴进去</p>
<p>测试公私钥是否已经配对</p>
<pre><code>ssh -T git@github.com</code></pre>
<p>之后的克隆需要使用 SSH 协议而不是 https 协议</p>
<h1 id="九、使用频率最高的五个命令"><a href="#九、使用频率最高的五个命令" class="headerlink" title="九、使用频率最高的五个命令"></a>九、使用频率最高的五个命令</h1><pre><code>git status
git add
git commit
git push
git pull</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack学习笔记</title>
    <url>/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Webpack"><a href="#一、Webpack" class="headerlink" title="一、Webpack"></a>一、Webpack</h1><p>Webpack 是一种前端资源构建工具，一个静态模块打包器（module bundler）</p>
<a id="more"></a>

<p><img src="/2022/01/24/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85.png" alt="静态模块打包"></p>
<p>在 Webpack 中前端所有资源文件（js/json/css/img/less/…）都会作为模块处理，它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）</p>
<h2 id="1、Webpack-五个核心概念"><a href="#1、Webpack-五个核心概念" class="headerlink" title="1、Webpack 五个核心概念"></a>1、Webpack 五个核心概念</h2><h3 id="（1）Entry"><a href="#（1）Entry" class="headerlink" title="（1）Entry"></a>（1）Entry</h3><p>入口（Entry）指示 Webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</p>
<h3 id="（2）Output"><a href="#（2）Output" class="headerlink" title="（2）Output"></a>（2）Output</h3><p>输出（Output）指示 Webpack 打包后的资源 bundles 输出到哪里，以及如何命名</p>
<h3 id="（3）Loader"><a href="#（3）Loader" class="headerlink" title="（3）Loader"></a>（3）Loader</h3><p>Loader 让 Webpack 能够处理那些非 JavaScript 文件（如样式 css 文件、图片等）（Webpack 自身只能理解 JavaScript）</p>
<p>使用 loader 需要：1）下载 2）使用（配置loader）</p>
<h3 id="（4）Plugins"><a href="#（4）Plugins" class="headerlink" title="（4）Plugins"></a>（4）Plugins</h3><p>插件（Plugins）可以用于执行范围更广的任务，插件的范围包括从打包优化和压缩，到重新定义环境中的变量等</p>
<p>使用 plugins 需要：1）下载 2）引入 3）使用</p>
<h3 id="（5）Mode"><a href="#（5）Mode" class="headerlink" title="（5）Mode"></a>（5）Mode</h3><p>模式（Mode）指示 Webpack 使用相应模式的配置，模式分为 development 开发模式和 production 生产模式</p>
<h4 id="development"><a href="#development" class="headerlink" title="development"></a>development</h4><p>development 会将 process.env.NODE_ENV 的值设置为 development，启用 NamedChunksPlugin 和 NamesModulesPlugin</p>
<p>特点：能让代码本地调试运行的环境</p>
<h4 id="production"><a href="#production" class="headerlink" title="production"></a>production</h4><p>production 会将 process.env.NODE_ENV 的值设置为 production，启用 FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin、OccurenceOrderPlugin、SideEffectsFlagPlugin、UglifyJsPlugin/TerserPlugin（压缩 js 代码）</p>
<p>特点：能让代码优化上线运行的环境</p>
<h4 id="开发环境和生产环境的异同"><a href="#开发环境和生产环境的异同" class="headerlink" title="开发环境和生产环境的异同"></a>开发环境和生产环境的异同</h4><p>生产环境和开发环境能将 ES6 模块化编译成浏览器能识别的模块化</p>
<p>生产环境生成的打包文件压缩了 js 代码，而开发环境没有，因此生产环境打包后生成的文件较小</p>
<h2 id="2、使用-Webpack"><a href="#2、使用-Webpack" class="headerlink" title="2、使用 Webpack"></a>2、使用 Webpack</h2><p>新建项目文件夹，在文件夹下使用命令 <code>npm init</code> 初始化生成 package.json 文件</p>
<p>全局安装 webpack 和 webpack-cli <code>npm i webpack webpack-cli -g</code></p>
<p>本地安装 webpack 和 webpack-cli <code>npm i webpack webpack-cli -D</code></p>
<p>在项目下新建文件夹 src 存放源码，并新建 index.js 文件作为入口文件，在项目下新建文件夹 build 存放打包后的文件</p>
<p>在 index.js 中编写相关代码</p>
<pre><code>function add(x,y)&#123;
    return x+y;
&#125;
console.log(add(1,2))</code></pre>
<p>运行指令</p>
<pre><code>开发环境中
webpack ./src/index.js -o ./build/built.js --mode=development
webpack 会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js，整体打包环境是开发环境

生产环境
webpack ./src/index.js -o ./build/built.js --mode=production
webpack 会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js，整体打包环境是生产环境</code></pre>
<p>打包后会生成 built.js 文件，且命令行输出中有个 Hash 相当于文件的 id，后面可以利用它作为文件命名的方式</p>
<p>在生产环境生成的 built.js 中压缩了 js 代码</p>
<p>使用 <code>node .\build\built.js</code> 运行代码，也可在 html 文件中使用 <code>&lt;script&gt;</code> 标签引入打包后的 built.js 文件</p>
<h2 id="3、使用-webpack-打包样式资源"><a href="#3、使用-webpack-打包样式资源" class="headerlink" title="3、使用 webpack 打包样式资源"></a>3、使用 webpack 打包样式资源</h2><p>要打包样式资源需要用到 loader，而 loader 需要定义配置文件</p>
<p>在和 src 同级目录下新建配置文件 webpack.config.js，运行 webpack 指令时会加载里面的配置指示 webpack 干哪些活，内容如下</p>
<pre><code>//resolve 用来拼接绝对路径的方法
const &#123;resolve&#125; = require(&#39;path&#39;);
module.exports = &#123;
    //webpack 配置
    //入口起点
    entry:&#39;./src/index.js&#39;,
    //输出
    output:&#123;
        //输出文件名
        filename: &#39;built.js&#39;,
        //输出路径，__dirname 是 node.js 的变量，代表当前文件的目录绝对路径
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    //loader 的配置
    module:&#123;
        rules:[
            //详细 loader 配置，不同类型文件必须配置不同 loader 处理
            //处理 css 文件
            &#123;
                //匹配哪些文件
                test:/\.css$/, //匹配以 .css 结尾的文件
                //使用哪些loader进行处理
                use:[
                    //use 数组中 loader 执行顺序：从右到左，从下到上依次执行，下列 loader 先执行 css-loader 再执行 style-loader
                    &#39;style-loader&#39;,  //创建 style 标签，将 js 中的样式资源插入进去，添加到 head 中生效
                    &#39;css-loader&#39;  //将 css 文件变成 CommonJS 模块加载到 js 中，里面内容是样式字符串
                ]
            &#125;,
            //处理 less 文件
            &#123;
                test:/\.less$/, //匹配以 .less 结尾的文件
                use:[
                    &#39;style-loader&#39;,  //创建 style 标签，将 js 中的样式资源插入进去，添加到 head 中生效
                    &#39;css-loader&#39;,  //将 css 文件变成 CommonJS 模块加载到 js 中，里面内容是样式字符串
                    &#39;less-loader&#39;  //将 less 文件编译成 css 文件，注意这里需要下载 less-loader 和 less
                ]
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        //详细 plugins 的配置
    ],
    //模式
    mode: &#39;development&#39;,
    //mode:&#39;production&#39;
&#125;</code></pre>
<p>注意：要使用多个 loader 处理时用 use，若只需一个 loader 时再 rules 的对象中直接使用 <code>loader:</code> 进行配置</p>
<p>注意：所有构建工具都是基于 node.js 平台运行的，模块化默认采用 CommonJS 规范，而 src 文件夹中写的项目相关代码所使用的模块化是 ES6 规范的</p>
<h2 id="4、使用-webpack-打包-html-资源"><a href="#4、使用-webpack-打包-html-资源" class="headerlink" title="4、使用 webpack 打包 html 资源"></a>4、使用 webpack 打包 html 资源</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        //详细 plugins 的配置
        //html-webpack-plugin 默认会创建一个空的 html 文件，自动引入打包输出的所有资源（js/css）
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39; //复制 ./src/index.html 文件并自动引入打包输出的所有资源
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<h2 id="5、使用-webpack-打包图片资源"><a href="#5、使用-webpack-打包图片资源" class="headerlink" title="5、使用 webpack 打包图片资源"></a>5、使用 webpack 打包图片资源</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.less$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;, //需要下载 url-loader 和 file-loader 两个包
                options:&#123;
                    //这里设置图片大小小于 8kb 就会被转换为 base64 编码的一种字符串，以 base64 处理
                    //优点：减少请求数量，减轻服务器压力
                    //缺点：图片体积会更大，文件请求速度更慢（如原先图片 10kb，转为 base64 编码后可能有 14kb）
                    //所以一般不会对大图片进行 base64 处理，会对 8-12kb 图片进行 base64 处理
                    limit:8*1024,
                    esModule: false,
                    //给图片重命名
                    name:&#39;[hash:10].[ext]&#39;//取图片 hash 的前 10 位以及文件原扩展名来命名，这样文件也会小一点
                &#125;
            &#125;,
            //注意：上面的方式默认处理不了 html 中的 img 图片（通过 img 标签的 src 属性引入的图片）
            &#123;
                test:/\.html$/,
                //处理 html 文件的 img 图片（负责引入 img，从而能被 url-loader 进行处理）
                loader:&#39;html-loader&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<p>注意：打包图片资源需要下载 url-loader 和 file-loader 两个包，因为 url-loader 依赖于 file-loader</p>
<p>问题：url-loader 默认处理不了 html 中的 img 图片，因为 url-loader 是使用 ES6 中的 module 去处理模块，而 html-loader 打包后引入的 img 是通过 CommonJS 规范引入，所以通过 url-loader 去解析 html-loader 引入的图片解析不了会报错，即打包后 img 标签中 src 会变成 [object Module]</p>
<p>解决：<code>esModule: false</code> 关闭 url-loader 的 ES6 模块化，使用 CommonJS 解析</p>
<p>注意：当一个文件多次使用时，webpack 只会打包一次，不会重复打包一个文件 </p>
<h2 id="6、使用-webpack-打包其他资源（如字体图标）"><a href="#6、使用-webpack-打包其他资源（如字体图标）" class="headerlink" title="6、使用 webpack 打包其他资源（如字体图标）"></a>6、使用 webpack 打包其他资源（如字体图标）</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //打包其他资源（除了 html/js/css/less 以外的资源）
            &#123;
                //排除 css/js/html 资源
                exclude:/\.(css|js|html|less)$/,
                loader:&#39;file-loader&#39;
            &#125;,
            options:&#123;
                name:&#39;[hash:10].[ext]&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<h2 id="7、devServer"><a href="#7、devServer" class="headerlink" title="7、devServer"></a>7、devServer</h2><p>开发服务器 devServer 用来自动化，可自动编译、自动打开浏览器、自动刷新浏览器</p>
<p>特点：只会在内存中编译打包，不会有任何输出</p>
<p>需下载包 webpack-dev-server，启动 devServer 指令：<code>npx webpack-dev-server</code>（若没有全局安装 webpack-dev-server 需要使用 npx 启动）</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //打包其他资源（除了 html/js/css/less 以外的资源）
            &#123;
                //排除 css/js/html 资源
                exclude:/\.(css|js|html|less)$/,
                loader:&#39;file-loader&#39;
            &#125;,
            options:&#123;
                name:&#39;[hash:10].[ext]&#39;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    //模式
    mode: &#39;development&#39;,
    devServer:&#123;
        contentBase:resolve(__dirname,&#39;build&#39;), //要运行的项目构建后的目录
        compress:true,  //启动 gzip 压缩，使代码更小运行更快
        port:3000,  //端口号
        open:true  //自动打开浏览器
    &#125;
&#125;</code></pre>
<h2 id="8、开发环境基本配置"><a href="#8、开发环境基本配置" class="headerlink" title="8、开发环境基本配置"></a>8、开发环境基本配置</h2><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //处理 css
            &#123;
                test:/\.less$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]
            &#125;,
            //处理 less
            &#123;
                test:/\.css$/,
                use:[&#39;style-loader&#39;,&#39;css-loader&#39;]
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;,
                options:&#123;
                    limit:8*1024,
                    esModule: false,
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                &#125;
            &#125;,
            //处理 html 中 img 资源
            &#123;
                test:/\.html$/,
                loader:&#39;html-loader&#39;
            &#125;,
            //处理其他资源
            &#123;
                exclude:/\.(css|js|html|less|jpg|png|gif)/,
                loader:&#39;file-loader&#39;,
                options:&#123;
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                &#125;
            &#125;
        ]
    &#125;,
    //plugins 的配置
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    devServer:&#123;
        contentBase:resolve(__dirname,&#39;build&#39;), 
        compress:true,
        port:3000,
        open:true
    &#125;,
    //模式
    mode: &#39;development&#39;
&#125;</code></pre>
<p>运行项目指令：</p>
<p>1）<code>webpack</code> 会将打包结果输出出去</p>
<p>2）<code>npx webpack-dev-server</code> 只会在内存中编译打包，没有输出</p>
<h2 id="9、生产环境"><a href="#9、生产环境" class="headerlink" title="9、生产环境"></a>9、生产环境</h2><h3 id="生产环境中需解决的问题"><a href="#生产环境中需解决的问题" class="headerlink" title="生产环境中需解决的问题"></a>生产环境中需解决的问题</h3><p>（1）经过上面的配置，css 文件在打包后都会添加到 js 代码中，使得 js 代码很大，且由于要先加载 js 代码才能解析出其中所需的 css 样式，因此会出现闪屏现象</p>
<p>（2）在生产环境中需要对代码进行压缩</p>
<p>（3）还需要考虑一些样式代码（如一些 css3 的效果）和 js 的兼容性问题</p>
<p>……</p>
<h3 id="提取-css-成单独文件"><a href="#提取-css-成单独文件" class="headerlink" title="提取 css 成单独文件"></a>提取 css 成单独文件</h3><p>使用插件 mini-css-extract-plugin 可将 css 提取成单独文件</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    //&#39;style-loader&#39;, //创建 style 标签，将样式放入
                    MiniCssExtractPlugin.loader, //这个 loader 取代 style-loader，提取 js 中的 css 成单独文件
                    &#39;css-loader&#39; //将 css 文件整合到 js 文件中
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39; //对输出的 css 文件进行重命名，生成的 css 文件会在 build/css/built.css
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>通过上述方式从打包生成的 js 文件中提取 css 样式成单独文件后，生成的 build/index.html 中引入样式的方式就不是通过 style 标签引入，而是通过 <code>&lt;link ref=&quot;css/built.css&quot; rel=&quot;stylesheet&quot;&gt;</code> 引入样式，这样也解决了闪屏现象，并且生成的 js 文件体积也没那么大了</p>
<h3 id="css-兼容性处理"><a href="#css-兼容性处理" class="headerlink" title="css 兼容性处理"></a>css 兼容性处理</h3><p>css 兼容性处理需要使用库 postcss，在 webpack 中通过 postcss-loader 以及插件 postcss-preset-env（帮助 postcss 识别某些环境，从而加载指定的配置，能让兼容性精确到某一个浏览器的版本）使用</p>
<p>其中 postcss-preset-env 帮助 postcss 找到 package.json 中 browserlist 里面的配置，通过配置加载指定的 css 兼容性样式</p>
<p>安装 postcss-loader 和 postcss-preset-env <code>npm i postcss-loader postcss-preset-env -D</code></p>
<p>在 webpack.config.js 中内容如下</p>
<pre><code>//设置 Nodejs 环境变量，决定使用 browserlists 的哪个环境，因为默认是看 package.json 中的生产环境
process.env.NODE_ENV = &#39;development&#39;;
const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    MiniCssExtractPlugin.loader,
                    &#39;css-loader&#39;,
                    //使用 loader 的默认配置
                    //&#39;postcss-loader&#39; //相当于&#123;loader:&#39;postcss-loader&#39;&#125;
                    //修改 loader 的配置
                    &#123;
                        loader:&#39;postcss-loader&#39;,
                        options:&#123;
                            ident: &#39;postcss&#39;,
                            plugins: () =&gt; [
                                //postcss 的插件
                                require(&#39;postcss-preset-env&#39;)()
                            ]
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>在 package.json 文件中添加如下内容，在开发环境中兼容最新版本的各浏览器，在生产环境中兼容 99.8% 的浏览器，不要已经 dead 和 op_mini 浏览器</p>
<pre><code>&quot;browserslist&quot;: &#123;
    &quot;development&quot;: [
        &quot;last 1 chrome version&quot;,
        &quot;last 1 firefox version&quot;,
        &quot;last 1 safari version&quot;
    ]
    &quot;production&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not op_mini all&quot;
    ]
&#125;</code></pre>
<h3 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h3><p>使用插件 optimize-css-assets-webpack-plugin 进行压缩</p>
<p>安装 <code>npm i optimize-css-assets-webpack-plugin -D</code></p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.css$/,
                use:[
                    MiniCssExtractPlugin.loader,
                    &#39;css-loader&#39;,
                    &#123;
                        loader:&#39;postcss-loader&#39;,
                        options:&#123;
                            ident: &#39;postcss&#39;,
                            plugins: () =&gt; [
                                //postcss 的插件
                                require(&#39;postcss-preset-env&#39;)()
                            ]
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;),
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<h3 id="js-语法检查-eslint"><a href="#js-语法检查-eslint" class="headerlink" title="js 语法检查 eslint"></a>js 语法检查 eslint</h3><p>在 webpack 中通过 eslint-loader 进行语法检查，eslint-loader 依赖于 eslint 库，因此需要安装两者，<code>npm i eslint-loader eslint -D</code></p>
<p>注意：语法检查只检查自己写的源代码，第三方的库是不用检查的</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.js$/,
                exclude: /node_modules/, //不检查 node_modules 中的第三方库
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true //自动修复 eslint 的错误
                &#125;
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;
        &#125;)
    ],
    mode: &#39;development&#39;
&#125;</code></pre>
<p>这里使用<a href="https://www.npmjs.com/package/eslint-config-airbnb-base">airbnb 代码规范</a>对 eslint 进行配置，还需要下载库 eslint-config-airbnb-base 和 eslint-plugin-import</p>
<p>在 package.json 中的 eslintConfig 中设置</p>
<pre><code>“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;
&#125;</code></pre>
<p>项目上线时无需 console.log 语句，可在源代码中的 console.log 语句的上一行加上 <code>//eslint-disable-next-line</code> 使得下一行 eslint 所有规则都失效，即不对下一行进行 eslint 检查</p>
<h3 id="js-兼容性处理-eslint"><a href="#js-兼容性处理-eslint" class="headerlink" title="js 兼容性处理 eslint"></a>js 兼容性处理 eslint</h3><p>在 IE 浏览器中不能识别 ES6 语法，因此需要对 js 进行兼容性处理，将 ES6 语法转换为 ES5 及以下的语法</p>
<p>在 webpack 中通过使用 babel-loader，同时还需要下载 @babel/core 和 @babel/preset-env</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            &#123;
                test:/\.js$/,
                exclude: /node_modules/, //不检查 node_modules 中的第三方库
                loader:&#39;babel-loader&#39;,
                options:&#123;
                    presets:[&#39;@babel/preset-env&#39;] //预设：指示 babel 做怎样的兼容性处理
                &#125;
            &#125;
        ],
        plugins:[
            new HtmlWebpackPlugin(&#123;
                template:&#39;./src/index.html&#39;
            &#125;)
        ],
        mode: &#39;development&#39;
    &#125;
&#125;</code></pre>
<p>其中在 babel-loader 的配置 presets 中 </p>
<pre><code>1、@babel/preset-env 
    实现基本 js 兼容性处理
    问题：只能转换基本语法，如 promise 等高级不能转换
2、@babel/polyfill 
    可对全部 js 做兼容性处理，注意它不是作为插件在配置中设置，只需在 js 源代码中使用 import &#39;@babel/polyfill&#39; 引入即可
    问题：往往只需解决部分兼容性问题，但它会将所有兼容性代码全部引入，使得代码文件体积太大了
3、core-js
    按需加载，需要做兼容性处理的就做，同时 presets 设置需改为
    presets:[
        [
            &#39;@babel/preset-env&#39;,
            &#123;
                //按需加载
                useBuiltIns: &#39;usage&#39;,
                //指定 core-js 版本
                corejs: &#123;
                    version: 3
                &#125;,
                //指定兼容性做到哪个版本浏览器
                targets: &#123;
                    chrome: &#39;60&#39;,
                    firefox: &#39;60&#39;,
                    ie: &#39;9&#39;,
                    safari: &#39;10&#39;,
                    edge: &#39;17&#39;
                &#125;
            &#125;
        ]
    ]</code></pre>
<p>通过 1、3 或 1、2（一般不用） 搭配使用</p>
<h3 id="压缩-html-和-js"><a href="#压缩-html-和-js" class="headerlink" title="压缩 html 和 js"></a>压缩 html 和 js</h3><p>要完成 js 的压缩只需将 webpack.config.js 文件中的 mode 设置为 production 即可，因为生产环境下会自动压缩 js 代码</p>
<p>要完成 html 代码的压缩只需在 webpack.config.js 文件中的 plugin 中进行设置</p>
<pre><code>plugins:[
    new HtmlWebpackPlugin(&#123;
        template:&#39;./src/index.html&#39;,
        //压缩 html 代码
        minify: &#123;
            //移除空格
            collapseWhitespace: true,
            //移除注释
            removeComments: true
        &#125;
    &#125;)
]</code></pre>
<p>注意：html 代码无需做兼容性处理，浏览器认识就认识，不认识就不认识</p>
<h3 id="生产环境基本配置"><a href="#生产环境基本配置" class="headerlink" title="生产环境基本配置"></a>生产环境基本配置</h3><pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
//复用 loader
const commonCssLoader = [
    MiniCssExtractPlugin.loader,
    &#39;css-loader&#39;,
    &#123;
        //还需要在 package.json 中定义 browserslist
        loader:&#39;postcss-loader&#39;,
        options:&#123;
            ident: &#39;postcss&#39;,
            plugins: () =&gt; [
                require(&#39;postcss-preset-env&#39;)()
            ]
        &#125;
    &#125;
]
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.js&#39;,
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //处理 css
            &#123;
                test:/\.less$/,
                use:[...commonCssLoader]
            &#125;,
            //处理 less
            &#123;
                test:/\.css$/,
                use:[...commonCssLoader,&#39;less-loader&#39;]
            &#125;,
            //js 语法检查
            &#123;
                //还需在 package.json 中配置 eslintConfig
                test:/\.js$/,
                exclude: /node_modules/,
                enforce: &#39;pre&#39;, //优先执行
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true
                &#125;
            &#125;,
            // js 兼容性处理
            &#123;
                test:/\.js$/,
                exclude: /node_modules/,
                loader:&#39;babel-loader&#39;,
                options:&#123;
                    presets:[
                        [
                            &#39;@babel/preset-env&#39;,
                            &#123;
                                useBuiltIns: &#39;usage&#39;,
                                corejs: &#123;
                                    version: 3
                                &#125;,
                                targets: &#123;
                                    chrome: &#39;60&#39;,
                                    firefox: &#39;60&#39;,
                                    ie: &#39;9&#39;,
                                    safari: &#39;10&#39;,
                                    edge: &#39;17&#39;
                                &#125;
                            &#125;
                        ]
                    ]
                &#125;
            &#125;,
            //处理图片资源
            &#123;
                test:/\.(jpg|png|gif)$/,
                loader:&#39;url-loader&#39;,
                options:&#123;
                    limit:8*1024,
                    esModule: false,
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                &#125;
            &#125;,
            //处理 html 中 img 资源
            &#123;
                test:/\.html$/,
                loader:&#39;html-loader&#39;
            &#125;,
            //处理其他资源
            &#123;
                exclude:/\.(css|js|html|less|jpg|png|gif)$/,
                loader:&#39;file-loader&#39;,
                options:&#123;
                    name:&#39;[hash:10].[ext]&#39;,
                    outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                &#125;
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;,
            minify: &#123;
                collapseWhitespace: true,
                removeComments: true
            &#125;
        &#125;);
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.css&#39;
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    //模式
    mode: &#39;production&#39;
&#125;</code></pre>
<p>还需在 package.json 文件中添加如下内容</p>
<pre><code>&quot;browserslist&quot;: &#123;
    &quot;development&quot;: [
        &quot;last 1 chrome version&quot;,
        &quot;last 1 firefox version&quot;,
        &quot;last 1 safari version&quot;
    ]
    &quot;production&quot;: [
        &quot;&gt;0.2%&quot;,
        &quot;not dead&quot;,
        &quot;not op_mini all&quot;
    ]
&#125;,
“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;
&#125;</code></pre>
<p>注意：正常来讲一个文件只能被一个 loader 处理，当一个文件要被多个 loader 处理时，一定要指定 loader 的执行现后顺序，如 js 的语法检查和兼容性处理需要先执行 eslint 再执行 babel</p>
<p>原因1：先做语法检查，若语法检查出现错误后续工作无意义</p>
<p>原因2：使用 babel 后会把 ES6 语法转为 ES5 及以下语法，若此时再使用 eslint 进行语法检查又会报错，如 var 等不好用</p>
<h2 id="10、性能优化"><a href="#10、性能优化" class="headerlink" title="10、性能优化"></a>10、性能优化</h2><p>webpack 的性能优化包括开发环境性能优化和生产环境性能优化</p>
<h3 id="开发环境性能优化"><a href="#开发环境性能优化" class="headerlink" title="开发环境性能优化"></a>开发环境性能优化</h3><p>开发环境性能优化包括（1）优化打包构建速度（通过 HMR）（2）优化代码调试（通过 source-map）</p>
<h4 id="（1）优化打包构建速度-————-HMR"><a href="#（1）优化打包构建速度-————-HMR" class="headerlink" title="（1）优化打包构建速度 ———— HMR"></a>（1）优化打包构建速度 ———— HMR</h4><p><strong>问题1：</strong>在开发环境中若只修改 css 样式文件或只修改了某个文件，其他文件没有变动，但 webpack 会把 css、js 等文件一起全部重新打包一次</p>
<p><strong>解决：</strong>可通过 webpack 的 HMR（hot module replacement 热模块替换/模块热替换）功能，HMR 是基于 devServer 的</p>
<p><strong>作用：</strong>一个模块发生变化，只会重新打包这个模块，而不是打包所有模块，极大提升了构建速度</p>
<p>只需修改 webpack.config.js 文件中的 devServer 设置，添加语句 <code>hot: true</code> 开启 HMR 功能</p>
<pre><code>devServer:&#123;
    contentBase: resolve(__dirname,&#39;build&#39;), 
    compress: true,
    port: 3000,
    open: true,
    //开启 HMR 功能
    hot: true
&#125;,</code></pre>
<p>启动 webpack 服务：<code>npx webpack-dev-server</code></p>
<p><strong>问题2：</strong></p>
<p>样式文件：可以使用 HMR 功能，因为 style-loader 内部实现了</p>
<p>js 文件：默认不能使用 HMR 功能</p>
<p>html 文件：默认不能使用 HMR 功能，同时会导致 html 文件不能热更新了</p>
<p><strong>解决：</strong>修改 webpack.config.js 文件中的 entry 入口，将 html 文件加入，此时若修改 html 文件能热更新了，整个页面重新刷新，依然不能使用 HMR 功能（但是 html 无需 HMR 功能，因为项目中只会创建一个 html 文件，当该文件发生变化时自然也需要重新加载这个文件）</p>
<pre><code>entry:[&#39;./src/js/index.js&#39;,&#39;./src/index.html&#39;]</code></pre>
<p>在 index.js 文件中添加如下代码让 js 文件的 HMR 功能生效</p>
<pre><code>if(module.hot)&#123;
    //一旦 module.hot 为 true，说明开启了 HMR 功能
    module.hot.accept(./xxx1.js,function()&#123;
        //方法会监听 xxx.js 文件的变化，一旦发生变化，其他模块不会重新打包构建，会执行回调函数
        print();
    &#125;);
    module.hot.accept(./xxx2.js,function()&#123;
        print();
    &#125;)
&#125;</code></pre>
<p>此时若修改 xxx1.js 文件或 xxx2.js 文件只会重新加载相应文件</p>
<p>注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件</p>
<p>注意：当修改了 webpack 配置，新配置要想生效，必须重新启动 webpack 服务</p>
<h4 id="（2）优化代码调试-————-source-map"><a href="#（2）优化代码调试-————-source-map" class="headerlink" title="（2）优化代码调试 ———— source-map"></a>（2）优化代码调试 ———— source-map</h4><p>source-map 是一种提供源代码到构建后代码映射的技术，若构建后代码出错了，会通过映射关系可以追踪源代码错误</p>
<p>在 webpack.config.js 文件中添加</p>
<pre><code>devtool: &#39;source-map&#39;</code></pre>
<p>打包后会在 js 的输出文件夹下生成 built.js.map 文件</p>
<p>devtool 的参数有<code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code>，其中</p>
<pre><code>source-map：外部，能提供错误代码的准确信息和源代码的错误位置（第几行）
inline-source-map：内联，只生成一个 source-map，能提供错误代码的准确信息和源代码的错误位置
hidden-source-map：外部，能提供代码错误的原因，不能追踪源代码错误，只能提示构建后代码的错误位置（可以半隐藏源代码）
eval-source-map：内联，每个文件都生成对应的 source-map，都在 eval 中，能提供错误代码的准确信息和源代码的错误位置（第几行），只是在错误文件名中多了个哈希值
nosources-source-map：外部，能提供错误代码的准确信息，但没有任何源代码信息（可以隐藏源代码）
cheap-source-map：外部，能提供错误代码的准确信息和源代码的错误位置，但只能精确到行，而前面的方式（如 source-map 可精确到行列）
cheap-module-source：外部，能提供错误代码的准确信息和源代码的错误位置，但只能精确到行，module 会将 loader 的 source-map 加入</code></pre>
<p><strong>外部方式和内联方式的区别：</strong>（1）使用外部方式会生成 built.js.map 文件，而使用内联方式不会生成文件，而是嵌入在 built.js 文件中，（2）但内联的构建速度更快</p>
<p>开发环境下：需要速度快，调试更友好</p>
<pre><code>速度快（eval &gt; inline &gt; cheap &gt; ...）
    最快：eval-cheap-source-map
    其次：eval-source-map
调试更友好
    最友好：source-map
    其次：cheap-module-source-map
    再其次：cheap-source-map
综合：可选择 eval-source-map 或 eval-cheap-module-source-map</code></pre>
<p>生产环境下：需要考虑源代码要不要隐藏？调试要不要更友好？</p>
<p>由于内联会让代码体积变大，所以在生产环境不用内联</p>
<pre><code>考虑源代码隐藏
    nosources-source-map（全部隐藏）
    hidden-source-map（只隐藏源代码，会提示构建后代码的错误信息和位置）
调试更友好
    source-map
    同时速度更快点：cheap-module-source-map</code></pre>
<h3 id="生产环境性能优化"><a href="#生产环境性能优化" class="headerlink" title="生产环境性能优化"></a>生产环境性能优化</h3><p>生产环境性能优化包括（1）优化打包构建速度（oneOf、babel缓存、多进程打包、externals、DLL）（2）优化代码运行的性能（文件资源缓存、tree shaking、code split、懒加载/预加载、PWA）</p>
<h4 id="（1）优化打包构建速度"><a href="#（1）优化打包构建速度" class="headerlink" title="（1）优化打包构建速度"></a>（1）优化打包构建速度</h4><p><strong>问题：</strong>一般一个文件只会使用一种 loader 进行处理（除了 js 文件需要 eslint-loader 和 babel-loader 两种进行处理），但是每加载一个文件都会把所有 loader 过一遍，影响速度</p>
<h5 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h5><p><strong>解决1：</strong>通过将 webpack.config.js 中的各种 loader 放在 oneOf 中，并把 eslint-loader 单独放到 oneOf 前面</p>
<pre><code>module:&#123;
    rules:[
        //js 语法检查
        &#123;
            //还需在 package.json 中配置 eslintConfig
            test:/\.js$/,
            exclude: /node_modules/,
            enforce: &#39;pre&#39;, //优先执行
            loader:&#39;eslint-loader&#39;,
            options:&#123;
                fix:true
            &#125;
        &#125;,
        &#123;
            //以下 loader 只会匹配一个，不能有两个配置处理同一种类型文件
            oneOf:[
                //处理 css
                &#123;
                    test:/\.less$/,
                    use:[...commonCssLoader]
                &#125;,
                //处理 less
                &#123;
                    test:/\.css$/,
                    use:[...commonCssLoader,&#39;less-loader&#39;]
                &#125;,
                // js 兼容性处理
                &#123;
                    test:/\.js$/,
                    exclude: /node_modules/,
                    loader:&#39;babel-loader&#39;,
                    options:&#123;
                        presets:[
                            [
                                &#39;@babel/preset-env&#39;,
                                &#123;
                                    useBuiltIns: &#39;usage&#39;,
                                    corejs: &#123;
                                        version: 3
                                    &#125;,
                                    targets: &#123;
                                        chrome: &#39;60&#39;,
                                        firefox: &#39;60&#39;,
                                        ie: &#39;9&#39;,
                                        safari: &#39;10&#39;,
                                        edge: &#39;17&#39;
                                    &#125;
                                &#125;
                            ]
                        ]
                    &#125;
                &#125;,
                //处理图片资源
                &#123;
                    test:/\.(jpg|png|gif)$/,
                    loader:&#39;url-loader&#39;,
                    options:&#123;
                        limit:8*1024,
                        esModule: false,
                        name:&#39;[hash:10].[ext]&#39;,
                        outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                    &#125;
                &#125;,
                //处理 html 中 img 资源
                &#123;
                    test:/\.html$/,
                    loader:&#39;html-loader&#39;
                &#125;,
                //处理其他资源
                &#123;
                    exclude:/\.(css|js|html|less|jpg|png|gif)/,
                    loader:&#39;file-loader&#39;,
                    options:&#123;
                        name:&#39;[hash:10].[ext]&#39;,
                        outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                    &#125;
                &#125;
            ]
        &#125;
    ]
&#125;,</code></pre>
<h5 id="缓存-————-babel-缓存"><a href="#缓存-————-babel-缓存" class="headerlink" title="缓存 ———— babel 缓存"></a>缓存 ———— babel 缓存</h5><p><strong>问题：</strong>修改某个 js 文件后其他未变动的 js 无需重新编译，但 HMR 是基于 devServer 的，所以在生产环境中无法使用</p>
<p><strong>解决：</strong>babel 缓存————让第二次打包构建速度更快</p>
<p>只需在 babel-loader 中进行设置</p>
<pre><code>&#123;
    test:/\.js$/,
    exclude: /node_modules/,
    loader:&#39;babel-loader&#39;,
    options:&#123;
        presets:[
            [
                &#39;@babel/preset-env&#39;,
                &#123;
                    useBuiltIns: &#39;usage&#39;,
                    corejs: &#123;
                        version: 3
                    &#125;,
                    targets: &#123;
                        chrome: &#39;60&#39;,
                        firefox: &#39;60&#39;,
                        ie: &#39;9&#39;,
                        safari: &#39;10&#39;,
                        edge: &#39;17&#39;
                    &#125;
                &#125;
            ]
        ],
        //开启 babel 缓存，第二次构建时会读取之前的缓存
        cacheDirectory: true
    &#125;
&#125;,</code></pre>
<h5 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h5><p>通过 thread-loader 库进行多进程打包，在webpack.config.js 配置文件的 babel-loader 中添加 thread-loader</p>
<p>进程启动大概为 600ms，进程通信也有开销，只有工作消耗事件比较长，才需要多进程打包，若乱用反而会增加打包时间</p>
<p>一般 js 代码较多 babel 干的活久时使用多进程打包的加速效果更明显</p>
<pre><code>&#123;
    test:/\.js$/,
    exclude: /node_modules/,
    use: [
        //开启多进程打包
        &#123;
            loader:&#39;thread-loader&#39;,
            options:&#123;
                workers: 2 //2个进程
            &#125;
        &#125;,
        &#123;
            loader:&#39;babel-loader&#39;,
            options:&#123;
                presets:[
                    [
                        &#39;@babel/preset-env&#39;,
                        &#123;
                            useBuiltIns: &#39;usage&#39;,
                            corejs: &#123;
                                version: 3
                            &#125;,
                            targets: &#123;
                                chrome: &#39;60&#39;,
                                firefox: &#39;60&#39;,
                                ie: &#39;9&#39;,
                                safari: &#39;10&#39;,
                                edge: &#39;17&#39;
                            &#125;
                        &#125;
                    ]
                ],
                //开启 babel 缓存，第二次构建时会读取之前的缓存
                cacheDirectory: true
            &#125;
        &#125;
    ]
&#125;,</code></pre>
<h5 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h5><p>externals 防止将某些包打包到最终输出的 bundle 中，如想要 jQuery 通过 CDN 链接引入，就要禁止将它打包</p>
<p>在 webpack.config.js 文件中添加 externals</p>
<pre><code>externals: &#123;
    //忽略库名（npm 包名）
    jquery: &#39;jQuery&#39; //拒绝 jQuery 被打包进来
&#125; </code></pre>
<p>不打包就要在 html 中通过 <code>&lt;script src=&quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</code> 引入 jQuery 才能使用</p>
<h5 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h5><p>DLL 可以对代码进行单独打包</p>
<p>和 externals 类似，DLL 也是禁止一些库被打包进来，不同的是 DLL<br>会对一些库进行单独打包，在上面的 code split 代码分割中是把 node_modules 所有第三方库打包成一个 chunk，而 DLL 会把不同库分开打包</p>
<p>externals 中还需要通过 CDN 引入第三方库，而 DLL 会自动引入自己打包的第三方库</p>
<p>使用 dll 技术对某些第三方库（如 jQuery、react、vue…）进行单独打包</p>
<p>需要新建文件 webpack.dll.js 写入如下内容</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);
module.exports = &#123;
    entry: &#123;
        //打包生成的名字[name]: [&#39;要打包的库&#39;]
        jquery: [&#39;jquery&#39;]
    &#125;,
    output: &#123;
        filename: &#39;[name].js&#39;,
        path: resolve(__dirname,&#39;dll&#39;),
        library: &#39;[name]_[hash]&#39;, //打包的库里向外暴露出去的内容叫什么名字
    &#125;,
    plugins: [
        //打包生成一个 manifest.json 告诉 webpack 说 jQuery 不需要打包，并且提供和 jQuery 映射
        new webpack.DllPlugin(&#123;
            name: &#39;[name]_[hash]&#39;,  //映射库的暴露的内容名称
            path: resolve(__dirname,&#39;dll/manifest.json&#39;)  //最终这个库输出到哪里去
        &#125;)
    ],
    mode: &#39;production&#39;
&#125;</code></pre>
<p>运行打包 <code>webpack --config webpack.dll.js</code>，因为运行 webpack 时默认查找 webpack.config.js 配置文件，要想运行 webpack.dll.js 配置，需要使用 –config 参数指定</p>
<p>打包后会生成 dll/jquery.js 和 dll/manifest.json，只需打包一次，此后 jQuery 无需再重复打包</p>
<p>下载 add-asset-html-webpack-plugin 包</p>
<pre><code>npm i add-asset-html-webpack-plugin -D</code></pre>
<p>在 webpack.config.js 文件中同样引入 webpack 和 add-asset-html-webpack-plugin</p>
<pre><code>const webpack = require(&#39;webpack&#39;);
const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;);</code></pre>
<p>在 webpack.config.js 文件 的 plugins 中添加</p>
<pre><code>//告诉 webpack 哪些库不参与打包，同时使用时的名称也得变
new webpack.DllReferencePlugin(&#123;
    manifest: resolve(__dirname,&#39;dll/manifest.json&#39;)
&#125;)
//将某个文件打包输出出去，并在 html 中自动引入该资源
new AddAssetHtmlWebpackPlugin(&#123;
    filepath: resolve(__dirname,&#39;dll/jquery.js&#39;)
&#125;)</code></pre>
<p>通过上述配置就会把 jQuery 库单独打包，并在 html 中自动引入自己打包的 jQuery 库，无需再手动通过 script 标签通过 CDN 引入 jQuery</p>
<h4 id="（2）优化代码运行的性能"><a href="#（2）优化代码运行的性能" class="headerlink" title="（2）优化代码运行的性能"></a>（2）优化代码运行的性能</h4><h5 id="缓存-————-文件资源缓存"><a href="#缓存-————-文件资源缓存" class="headerlink" title="缓存 ———— 文件资源缓存"></a>缓存 ———— 文件资源缓存</h5><p>文件资源缓存————让代码上线运行缓存更好使用</p>
<p>可在打包输出的 built.js 文件名以及 css 文件名中添加 webpack 每次构建时生成的唯一 hash 值，当文件改变重新打包后生成的文件名改变则必须重新请求，不会读取缓存中的文件</p>
<p>有三种 hash 值：hash、chunkhash、contenthash</p>
<pre><code>hash：每次 webpack 构建时会生成一个 hash 值
    问题：因为 js 和 css 同时使用一个 hash 值，若重新打包会导致所有缓存失效（可能只改动了一个文件）
chunkhash：根据 chunk 生成的 hash 值，若打包来源于同一个 chunk，则 hash 值就一样
    问题：因为 css 是在 js 中被引入的，所以同属于一个 chunk，打包后都在 built.js 中，所以 js 和 css 文件的 chunkhash 还是一样的
contenthash：根据文件内容生成 hash 值，不同文件的 hash 值一定不一样</code></pre>
<p>更改后配置文件如下</p>
<pre><code>const &#123;resolve&#125; = require(&#39;path&#39;);
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
const OptimizeCssAssetsWebpackPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;);
process.env.NODE_ENV = &#39;production&#39;;
//复用 loader
const commonCssLoader = [
    MiniCssExtractPlugin.loader,
    &#39;css-loader&#39;,
    &#123;
        //还需要在 package.json 中定义 browserslist
        loader:&#39;postcss-loader&#39;,
        options:&#123;
            ident: &#39;postcss&#39;,
            plugins: () =&gt; [
                require(&#39;postcss-preset-env&#39;)()
            ]
        &#125;
    &#125;
]
module.exports = &#123;
    entry:&#39;./src/index.js&#39;,
    output:&#123;
        filename: &#39;js/built.[contenthash:10].js&#39;,  //添加 contenthash
        path: resove(__dirname,&#39;build&#39;)
    &#125;,
    module:&#123;
        rules:[
            //js 语法检查
            &#123;
                //还需在 package.json 中配置 eslintConfig
                test:/\.js$/,
                exclude: /node_modules/,
                enforce: &#39;pre&#39;, //优先执行
                loader:&#39;eslint-loader&#39;,
                options:&#123;
                    fix:true
                &#125;
            &#125;,
            &#123;
                //以下 loader 只会匹配一个，不能有两个配置处理同一种类型文件
                oneOf:[
                    //处理 css
                    &#123;
                        test:/\.less$/,
                        use:[...commonCssLoader]
                    &#125;,
                    //处理 less
                    &#123;
                        test:/\.css$/,
                        use:[...commonCssLoader,&#39;less-loader&#39;]
                    &#125;,
                    // js 兼容性处理
                    &#123;
                        test:/\.js$/,
                        exclude: /node_modules/,
                        loader:&#39;babel-loader&#39;,
                        options:&#123;
                            presets:[
                                [
                                    &#39;@babel/preset-env&#39;,
                                    &#123;
                                        useBuiltIns: &#39;usage&#39;,
                                        corejs: &#123;
                                            version: 3
                                        &#125;,
                                        targets: &#123;
                                            chrome: &#39;60&#39;,
                                            firefox: &#39;60&#39;,
                                            ie: &#39;9&#39;,
                                            safari: &#39;10&#39;,
                                            edge: &#39;17&#39;
                                        &#125;
                                    &#125;
                                ]
                            ],
                            //开启 babel 缓存，第二次构建时会读取之前的缓存
                            cacheDirectory: true
                        &#125;
                    &#125;,
                    //处理图片资源
                    &#123;
                        test:/\.(jpg|png|gif)$/,
                        loader:&#39;url-loader&#39;,
                        options:&#123;
                            limit:8*1024,
                            esModule: false,
                            name:&#39;[hash:10].[ext]&#39;,
                            outputPath:&#39;imgs&#39;  //打包后图片会输出到打包目录下的 imgs 文件夹中
                        &#125;
                    &#125;,
                    //处理 html 中 img 资源
                    &#123;
                        test:/\.html$/,
                        loader:&#39;html-loader&#39;
                    &#125;,
                    //处理其他资源
                    &#123;
                        exclude:/\.(css|js|html|less|jpg|png|gif)/,
                        loader:&#39;file-loader&#39;,
                        options:&#123;
                            name:&#39;[hash:10].[ext]&#39;,
                            outputPath:&#39;media&#39;  //打包后图片会输出到打包目录下的 media 文件夹中
                        &#125;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    plugins:[
        new HtmlWebpackPlugin(&#123;
            template:&#39;./src/index.html&#39;,
            minify: &#123;
                collapseWhitespace: true,
                removeComments: true
            &#125;
        &#125;);
        new MiniCssExtractPlugin(&#123;
            filename: &#39;css/built.[contenthash:10].css&#39;  //添加contenthash
        &#125;),
        //压缩 css
        new OptimizeCssAssetsWebpackPlugin()
    ],
    //模式
    mode: &#39;production&#39;,
    devtool: &#39;source-map&#39;
&#125;</code></pre>
<p>服务器端代码</p>
<pre><code>const express = require(&#39;express&#39;);
//创建应用对象
const app = express();
app.use(express.static(&#39;build&#39;,&#123;maxAge:1000 * 3600&#125;));
//监听端口启动服务
app.listen(8000)</code></pre>
<h5 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h5><p>tree shaking 用于去除无用代码</p>
<p>tree shaking 前提：（1）必须使用 ES6 模块化（2）mode 使用 production 环境即可自动开启 tree shaking</p>
<p>tree shaking 作用：减少代码体积，从而使得请求和加载速度更快</p>
<p>注意：在旧版本 webpack 中或设置 <code>&quot;sideEffects&quot;: false</code> 表示所有代码都没有副作用，即都可以进行 tree shaking，这可能把 css 或 @babel/polyfill 等副作用文件都消除掉，因此需在 package.json 中配置 <code>&quot;sideEffects&quot;: [&quot;*.css&quot;,&quot;*.less&quot;]</code></p>
<h5 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h5><p>通过 code split 代码分割把打包后的文件分成多个，这样在加载时可并行加载速度更快，且可按需加载</p>
<p>代码分割主要是关注 js 文件</p>
<p><strong>方式一：多入口</strong></p>
<p>通过在 entry 中设置多入口来拆分文件（之前的单入口方式一般用在单页面应用，多入口用于多页面应用）</p>
<pre><code>entry:&#123;
    //多入口：每个入口最终都输出一个 bundle
    index: &#39;./src/js/index.js&#39;,
    test: &#39;./src/js/test.js&#39;
&#125;,
output:&#123;
    filename: &#39;js/[name].[contenthash:10].js&#39;
    path: resolve(__dirname,&#39;build&#39;)
&#125;</code></pre>
<p><strong>方式二：splitChunks</strong></p>
<p>若使用单入口 + splitChunks 可以将 node_modules 中代码（第三方代码）单独打包一个 chunk 输出</p>
<p>若使用多入口 + splitChunks 还会自动分析多入口 chunk 中有没有公共的文件，若有则只会把该公共文件打包成一个单独的 chunk 不会重复打包多次</p>
<pre><code>entry:&#123;
    index: &#39;./src/js/index.js&#39;,
    test: &#39;./src/js/test.js&#39;
&#125;,
output:&#123;
    filename: &#39;js/[name].[contenthash:10].js&#39;
    path: resolve(__dirname,&#39;build&#39;)
&#125;,
optimization: &#123;
    splitChunks: &#123;
        chunks: &#39;all&#39;
    &#125;
&#125;,</code></pre>
<p>上述配置中若 index.js 和 test.js 都引入了 jQuery，则打包后会生成三个 bundle 分别对应 index.js、test.js 和 jQuery</p>
<p><strong>方式三：import 动态导入语法</strong></p>
<p>修改 js 代码，使用 impor 动态导入语法，让某个文件被单独打包成一个 chunk</p>
<p>在某 js 文件（如 index.js）中引入另一 js 文件时不使用 <code>import &#123;mul,red&#125; from &#39;./xxx.js&#39;</code>，而使用如下方式</p>
<pre><code>import(/* webpackChunkName: &#39;打包后的文件名&#39; */&#39;./xxx.js)
    .then((&#123;mul,red&#125;) =&gt; &#123;
        //eslint-disable-next-line
        console.log(mul(1,2));
    &#125;)
    .cache(() =&gt; &#123;
        //eslint-disable-next-line
        console.log(&#39;文件加载失败&#39;);
    &#125;);</code></pre>
<p>其中 xxx.js 中定义了 mul 和 red 两个方法</p>
<pre><code>export function mul(x, y) &#123;
    return x * y;
&#125;
export function red(x, y) &#123;
    return x - y;
&#125;</code></pre>
<p>打包后会生成两个 bundle 分别对应 index.js 和 xxx.js</p>
<p>注意：一般多入口使用较少，会使用单入口 + splitChunks，并把其他要单独打包的 js 文件使用 import 动态导入语法来完成</p>
<h5 id="js-的懒加载和预加载"><a href="#js-的懒加载和预加载" class="headerlink" title="js 的懒加载和预加载"></a>js 的懒加载和预加载</h5><p>懒加载：当文件需要使用时才加载，是通过把代码分割的 import 动态导入语法放在一个异步函数中来实现</p>
<p>预加载：在使用之前提前加载 js 文件，但兼容性较差</p>
<p>正常加载是并行加载，即同一时间加载多个文件，而预加载是等其他资源加载完毕，浏览器空闲了再偷偷加载资源</p>
<p>如在 index.js 中编写点击按钮触发 xxx.js 中定义的方法</p>
<pre><code>document.getElementById(&#39;btn&#39;).onclick = function()&#123;
    //懒加载和预加载（webpackPrefetch）
    import(/* webpackChunkName: &#39;xxx&#39;, webpackPrefetch: true */&#39;./xxx.js)
    .then((&#123;mul&#125;) =&gt; &#123;
        //eslint-disable-next-line
        console.log(mul(1,2));
    &#125;)
&#125;</code></pre>
<h5 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h5><p>PWA（渐进式网络应用开发程序）让网页向 app 一样可以离线访问，性能也会更好</p>
<p>PWA 通过 workbox 实现，在 webpack 中通过使用 workbox-webpack-plugin 插件</p>
<p>下载后，在 webpack.config.js 文件中引入 workbox-webpack-plugin</p>
<pre><code>const WorkboxWebpackPlugin = require(&#39;workbox-webpack-plugin&#39;)</code></pre>
<p>在 webpack.config.js 文件中的 plugins 里添加</p>
<pre><code>new WorkboxWebpackPlugin.GenerateSW(&#123;
    clientsClaim: true, //删除旧的 serviceworker
    skipWaiting: true //帮助 serviceworker 快速启动
&#125;)//会生成一个 serviceworker 配置文件</code></pre>
<p>在 index.js 中添加如下代码</p>
<pre><code>if(&#39;serviceWorker&#39; in navigator)&#123;
    window.addEventListener(&#39;load&#39;,() =&gt; &#123;
        navigator.serviceWorker
            .register(&#39;/service-worker.js&#39;) //注册 serviceworker
            .then(() =&gt; &#123;
                console.log(&#39;sw注册成功&#39;);
            &#125;)
            .catch(() =&gt; &#123;
                console.log(&#39;sw注册失败&#39;);
            &#125;);
    &#125;);
&#125;</code></pre>
<p>eslint 不认识 window、navigator 全局变量，因此需要在 package.json 中 eslintConfig 修改为</p>
<pre><code>“eslintConfig”:&#123;
    &quot;extends&quot;:&quot;airbnb-base&quot;,
    &quot;env&quot;: &#123;
        &quot;browser&quot;: true
    &#125;
&#125;</code></pre>
<p>serviceworker 代码必须运行在服务器上，这里通过 serve 包快速构建一个服务器进行测试，下载 serve 包 <code>npm -i serve -g</code>，再启动服务器 <code>serve -s build</code> 其中 build 表示打包后的目录，将 build 目录下所有资源作为静态资源暴露出去</p>
<h1 id="二、webpack-配置详解"><a href="#二、webpack-配置详解" class="headerlink" title="二、webpack 配置详解"></a>二、webpack 配置详解</h1><h2 id="1、entry"><a href="#1、entry" class="headerlink" title="1、entry"></a>1、entry</h2><p>entry 的值可以是 string、array、object，一般用 string 和 object 较多</p>
<p><strong>string：单入口 ———— ‘./src/index.js’</strong></p>
<p>打包形成一个 chunk，输出一个 bundle 文件，此时 chunk 名称默认是 main</p>
<p><strong>array：多入口 ———— [‘./src/index.js’,’./src/xxx.js’]</strong></p>
<p>所有入口文件最终只会形成一个 chunk，输出只有一个 bundle 文件 默认是 main.js（当 output 中 filename 是 [name].js 时）</p>
<p>一般用在 HMR 功能中让 html 热更新生效</p>
<p><strong>object：多入口 ———— {index: ‘./src/index.js’, xxx: ‘./src/xxx.js’}</strong></p>
<p>有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 名称是 key</p>
<p><strong>特殊用法：</strong></p>
<pre><code>entry: &#123;
    index:[&#39;./src/index.js&#39;,&#39;./src/mul.js&#39;], //mul 和 index 形成一个 chunk 打包输出在一个 bundle 文件中
    add: &#39;./src/add.js&#39;  //形成一个 chunk，输出一个 bundle
&#125;</code></pre>
<h2 id="2、output"><a href="#2、output" class="headerlink" title="2、output"></a>2、output</h2><p>output 中可以设置</p>
<p>filename ———— 文件名称（指定该名称 + 目录）</p>
<pre><code>filename: &#39;js/[name].js&#39;</code></pre>
<p>path ———— 输出文件目录（将来所有资源输出的公共目录）</p>
<pre><code>path: resolve(__dirname,&#39;build&#39;)</code></pre>
<p>publicPath ———— 所有资源引入时的公共路径前缀，一般用于生产环境</p>
<pre><code>publicPath: &#39;/&#39; //当引入 imgs/a.jpg 时路径为 /imgs/a.jpg</code></pre>
<p>chunkFilename ———— 非入口 chunk 的名称（entry 中指定的就是入口文件）</p>
<p>如使用 import 动态导入语法进行代码单独打包时，打包输出的文件按 chunkFilename 指定的规则命名，若不修改名称默认使用 filename，这会与入口文件的输出文件名称冲突，webpack 会自动修改导入文件的打包后文件名称，命名方式可能不方便使用</p>
<pre><code>chunkFilename: &#39;js/[name]_chunk.js&#39;</code></pre>
<p>library ———— 整个库向外暴露的变量名，一般配合 dll 使用</p>
<pre><code>library: &#39;[name]&#39;</code></pre>
<p>libraryTarget ———— 变量名添加到哪里</p>
<pre><code>libraryTarget: &#39;window&#39; //将库添加到浏览器的 window 上
libraryTarget: &#39;global&#39; //添加到 node 上
libraryTarget: &#39;commonjs&#39;
libraryTarget: &#39;amd&#39;</code></pre>
<h2 id="3、module"><a href="#3、module" class="headerlink" title="3、module"></a>3、module</h2><pre><code>module: &#123;
    rules: [
        //loader 配置
        &#123;
            test: /\.css$/
            //多个 loader 用 use
            use: [&#39;style-loader&#39;,&#39;&#39;css-loader]
        &#125;,
        &#123;
            test: /\.js$/
            //排除 node_modules 下的 js 文件
            exclude: /node_modules/,
            //只检查 src 目录下的 js 文件
            include: resolve(__dirname, &#39;src&#39;),
            //优先执行
            enforce: &#39;pre&#39;,
            //延后执行 enforce: &#39;post&#39;,
            //单个 loader 用 loader
            loader: &#39;eslint-loader&#39;,
            options: &#123;&#125;
        &#125;,
        &#123;
            //以下配置只会生效一个
            oneOf: []
        &#125;
    ]
&#125;</code></pre>
<h2 id="4、resolve"><a href="#4、resolve" class="headerlink" title="4、resolve"></a>4、resolve</h2><p>resolve 用于解析模块的规则</p>
<p>参数 alias ———— 配置解析模块路径别名：优点简写路径，缺点路径没有提示</p>
<p>参数 extensions ———— 配置省略文件路径的后缀名，默认值是 .js 和 .json</p>
<p>参数 modules ———— 告诉 webpack 解析模块是去哪个目录找加快解析速度</p>
<p>在 webpack.config.js 中添加</p>
<pre><code>resolve:&#123;
    alias: &#123;
        $css: resolve(__dirname, &#39;src/css&#39;)
    &#125;,
    extensions: [&#39;.js&#39;,&#39;.json&#39;, &#39;.jsx&#39;, &#39;.css&#39;]
    modules: [resolve(__dirname, &#39;../../node_modules&#39;), &#39;node_modules&#39;]
&#125;</code></pre>
<h2 id="5、devServer"><a href="#5、devServer" class="headerlink" title="5、devServer"></a>5、devServer</h2><p>devServer 用于开发环境</p>
<pre><code>devServer:&#123;
    contentBase:resolve(__dirname,&#39;build&#39;), //要运行的项目构建后的目录
    watchContentBase: true, //监视 contentBase 目录下的所有文件，一旦文件变化就会 reload
    watchOptions: &#123;
        //忽略文件
        ignored: /node_modules/
    &#125;
    compress:true,  //启动 gzip 压缩，使代码更小运行更快
    port:5000,  //端口号
    open:true,  //自动打开浏览器
    hot: true,  //开启 HMR 功能
    clientLogLevel: &#39;none&#39;, //不显示启动服务器日志信息
    quiet: true, //除了一些基本启动信息外，其他内容都不要显示
    overlay: false, //如果出错不要全屏提示，在日志中打印出来就好
    proxy: &#123; //服务器代理，解决开发环境跨域问题（浏览器和服务器间有跨域问题，服务器和服务器间没有跨域问题）
        &#39;/api&#39;: &#123;
            target: &#39;http://localhost:3000&#39;, //一旦 devServer（5000）服务器接收到 /api/xxx 的请求，就会把请求转发到另一个服务器（3000）
            pathRewrite: &#123; //发送请求时，请求路径重写
                &#39;^/api&#39;:&#39;&#39; //将 /api/xxx 重写为 /xxx（去掉 /api）
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="6、optimization"><a href="#6、optimization" class="headerlink" title="6、optimization"></a>6、optimization</h2><p>optimization 在生产环境中才有意义</p>
<p>参数 splitChunks 用于提取公共代码成单独 chunk 打包</p>
<p>参数 runtimeChunk 将当前模块中记录其他模块 hash 的部分单独打包为一个文件，当 a 模块发生变化时 a 文件以及对应的 runtime 文件重新打包，而其他引用 a 的模块不重新打包 ———— 解决修改 a 文件导致 b 文件的 contenthash 变化产生的缓存失效需要重新打包 b 的问题</p>
<p>因此写代码分割时一定要加上 runtimeChunk，否则会导致缓存失效</p>
<p>参数 minimizer 配置生产环境的压缩方案（针对 js 和 css）</p>
<p>在 webpack 4.26 之前是使用 UglifyJsPlugin 插件进行 js 压缩，之后的版本是使用 terser-webpack-plugin 插件进行压缩</p>
<pre><code>const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);
optimization: &#123;
    splitChunks: &#123;
        chunks: &#39;all&#39;,
        //下面设置的这些都是用的默认值
        minSize: 30 * 1024, //分割的 chunk 最小为 30kb（即文件大于 30kb 才会分割）
        minChunks: 1, //要提取的 chunk 最少被引用 1 次
        maxAsyncRequests: 5, //按需加载时并行加载在的文件最大数量（所以最多也只会打包成相应数量 chunk）
        maxInitialRequests: 3, //入口 js 文件最大并行请求数量
        automaticNameDelimiter: &#39;~&#39;, //名称连接符
        name: true, //可以使用命名规则
        cacheGroups: &#123; //分割 chunk 的组
            vendors: &#123;
                test: /[\\/]node_modules[\\/]/, //node_modules 文件（也需满足上面规则如大小超过 30kb，至少被引用一次）会被打包到 vendors 组的 chunk 中，即会输出 vendors~xxx.js
                priority: -10  //打包的优先级
            &#125;,
            default:&#123;
                minChunks: 2, //要提取的 chunk 最少被引用 2 次
                priority: -20, //打包优先级
                reuseExistingChunk: true //若当前要打包的模块和之前已经被提取的模块是同一个就会复用，而不是重新打包模块
            &#125;
        &#125;
    &#125;,
    runtimeChunk: &#123;
        name: entrypoint =&gt; `runtime-$&#123;entrypoint.name&#125;`
    &#125;,
    minimizer: [
        new TerserWebpackPlugin(&#123;
            cache: true, //开启缓存
            parallel: true, //开启多进程打包，速度更快
            sourceMap: true //启动 source-map
        &#125;)
    ]
&#125;,</code></pre>
<h1 id="三、webpack-5"><a href="#三、webpack-5" class="headerlink" title="三、webpack 5"></a>三、webpack 5</h1><h2 id="1、使用-webpack-5"><a href="#1、使用-webpack-5" class="headerlink" title="1、使用 webpack 5"></a>1、使用 webpack 5</h2><p>首先初始化 npm <code>npm init</code></p>
<p>下载 webpack 5 <code>npm i webpack@next webpack-cli -D</code></p>
<p>在 webpack 5 中 webpack.config.js 配置文件中只有 mode 是需要设置的其他可使用默认值，这不同于 webpack 4，在 webpack 4 中需要设置 entry、output、mode</p>
<p>同样使用命令 <code>webpack</code> 打包</p>
<p>webpack 5 中默认输出的目录是 dist</p>
<p>其中 webpack 5 中使用的默认值如下</p>
<pre><code>entry: &quot;./src/index.js&quot;
output.path: path.resolve(__dirname, &quot;dist&quot;)
output.filename: &quot;[name].js&quot;</code></pre>
<h2 id="2、webpack-5-重点关注的内容"><a href="#2、webpack-5-重点关注的内容" class="headerlink" title="2、webpack 5 重点关注的内容"></a>2、webpack 5 重点关注的内容</h2><p><strong>（1）</strong>通过持久缓存提高构建性能</p>
<p><strong>（2）</strong>使用更好的算法和默认值来改善长期缓存（如 hash 值的相关算法）</p>
<p><strong>（3）</strong>通过更好的 tree shaking 和代码生产来改善 bundle 大小</p>
<p>（4）清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改</p>
<p>（5）通过引入重大更改来为将来的功能做准备，使我们能尽可能长时间使用 v5</p>
<h2 id="3、一些特点"><a href="#3、一些特点" class="headerlink" title="3、一些特点"></a>3、一些特点</h2><h3 id="自动删除-Node-js-Polyfills"><a href="#自动删除-Node-js-Polyfills" class="headerlink" title="自动删除 Node.js Polyfills"></a>自动删除 Node.js Polyfills</h3><p>早期 webpack 的目标是允许在浏览器中允许大多数 node.js 模块，但模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的，webpack &lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用，尽管这使使用 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中，许多情况下，这些 polyfill 是不必要的，webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块</p>
<p>在 webpack 5 中尽可能尝试使用与前端兼容的模块。可为 node.js 核心模块手动添加一个 polyfill，错误消息会提示如何实现</p>
<h3 id="chunk-和-模块-ID"><a href="#chunk-和-模块-ID" class="headerlink" title="chunk 和 模块 ID"></a>chunk 和 模块 ID</h3><p>添加了用于长期缓存的新算法（更优化的 hash 值算法），在生产模式下默认启用这些功能</p>
<pre><code>chunkIds:&quot;deterministic&quot;, moduleIds:&quot;deterministic&quot;</code></pre>
<h3 id="chunk-ID"><a href="#chunk-ID" class="headerlink" title="chunk ID"></a>chunk ID</h3><p>可以不使用 <code>import(/* webpackChunkName:&quot;name&quot; */ &quot;module&quot;)</code> 在开发环境来为 chunk 命名，生产环境还是有必要的</p>
<p>webpack 内部有 chunk 命名规则，不再是以 id(0,1,2) 命名了</p>
<h3 id="tree-shaking-功能更加强大"><a href="#tree-shaking-功能更加强大" class="headerlink" title="tree shaking 功能更加强大"></a>tree shaking 功能更加强大</h3><p><strong>（1） webpack 5 能处理嵌套模块的 tree shaking</strong></p>
<pre><code>//a.js
export const aa = 1;
export const bb = 2;

//b.js
import * as  a from &#39;./a&#39;;
export &#123; a &#125;;

//c.js
import * as b from &#39;./b&#39;;
console.log(b.a.aa);</code></pre>
<p>在生产环境中，a 模块暴露的 bb 会被删除（因为没有被用到）</p>
<p><strong>（2） webpack 5 能处理多个模块间的关系</strong></p>
<pre><code>import &#123; something &#125; from &#39;./something&#39;;
function usingSomething()&#123;
    return something;
&#125;
export function test()&#123;
    return usingSomething();
&#125;</code></pre>
<p>当设置了 “sideEffects”: false 时，一旦发现 test 方法没有使用，不但删除 test，还会删除 ./something</p>
<p><strong>（3） webpack 5 能处理 Commonjs 模块化的 tree shaking（之前 webpack 4 中都是以 ES6 模块化和生产环境为例）</strong></p>
<h3 id="ouput"><a href="#ouput" class="headerlink" title="ouput"></a>ouput</h3><p>webpack 4 默认只能输出 ES5 代码，webpack 5 开始新增属性 output.ecmaVersion 可以生成 ES5 和 ES6/ES2015 代码</p>
<pre><code>output.ecmaVersion: 2015</code></pre>
<h3 id="optimization-中-splitChunk"><a href="#optimization-中-splitChunk" class="headerlink" title="optimization 中 splitChunk"></a>optimization 中 splitChunk</h3><p>webpack 4 中</p>
<pre><code>minSize: 30000;</code></pre>
<p>webpack 5 中，可进行更精确的划分</p>
<pre><code>minSize: &#123;
    javascript: 30000,
    style: 50000
&#125;</code></pre>
<h3 id="caching-缓存"><a href="#caching-缓存" class="headerlink" title="caching 缓存"></a>caching 缓存</h3><p>webpack 4 中设置了 babel 缓存等</p>
<p>webpack 5 在 cache 中设置缓存</p>
<pre><code>//配置缓存
cache: &#123;
    //磁盘存储
    type:&#39;filesystem&#39;,
    buildDependencies: &#123;
        //当配置修改时，缓存失效
        config: [__filename]
    &#125;
&#125;</code></pre>
<p>缓存将存储到 node_modules/.cache/webpack</p>
<h3 id="监视输出文件"><a href="#监视输出文件" class="headerlink" title="监视输出文件"></a>监视输出文件</h3><p>之前 webpack 总是在第一次构建时输出全部文件，重新构建时会只更新修改的文件</p>
<p>webpack 5 在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>webpack 可以处理 js、json 资源，不能处理 css、img 等其他资源</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript学习笔记</title>
    <url>/2022/02/13/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、TypeScript-是什么"><a href="#一、TypeScript-是什么" class="headerlink" title="一、TypeScript 是什么"></a>一、TypeScript 是什么</h1><p>TypeScript 以 JavaScript 为基础构建的语言，是一个 JavaScript 的超集</p>
<a id="more"></a>

<p>TypeScript 完全支持 JavaScript，并进行扩展，添加了类型</p>
<p>TypeScript 可在任何支持 JavaScript 的平台中执行</p>
<p>但 TypeScript 不能被 JavaScript 解析器直接执行，需要将 TypeScript 编译为 JavaScript</p>
<p>一般大型项目使用 TypeScript，相比 JavaScript，更易于维护（因为变量有类型了）</p>
<h1 id="二、TypeScript-增加了什么"><a href="#二、TypeScript-增加了什么" class="headerlink" title="二、TypeScript 增加了什么"></a>二、TypeScript 增加了什么</h1><p>（1）类型</p>
<p>（2）支持 ES 的新特性</p>
<p>（3）添加 ES 不具备的新特性，如抽象类、接口等</p>
<p>（4）丰富的配置选项（可被编译成任意版本的 JS）</p>
<p>（5）强大的开发工具</p>
<h1 id="三、TypeScript-开发环境搭建"><a href="#三、TypeScript-开发环境搭建" class="headerlink" title="三、TypeScript 开发环境搭建"></a>三、TypeScript 开发环境搭建</h1><p>（1）下载并安装 Node.js</p>
<p>（2）使用 npm 全局安装 TypeScript 解析器</p>
<pre><code>npm i -g typescript</code></pre>
<p>（3）编写 ts 文件</p>
<p>（4）进入 ts 文件所在目录，使用 tsc 对 ts 文件进行编译</p>
<pre><code>tsc xxx.ts</code></pre>
<h1 id="四、TypeScript-类型"><a href="#四、TypeScript-类型" class="headerlink" title="四、TypeScript 类型"></a>四、TypeScript 类型</h1><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><p>类型声明是 TS 非常重要的一个特点</p>
<p>通过类型声明可指定 TS 中变量（参数/形参）的类型</p>
<p>指定类型后，当为变量复制时，TS 编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
<p>语法：</p>
<pre><code>let 变量: 类型;
let 变量: 类型 = 值;
(形参: 类型, 形参: 类型, ...) =&gt; 返回值类型
function fn(参数: 类型, 参数: 类型): 返回值类型&#123;...&#125;
fn(参数: 赋值, 参数: 赋值)</code></pre>
<h2 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h2><p>TS 拥有自动类型判断机制</p>
<p>当对变量的声明和赋值是同时进行的，TS 编译器会自动判断变量的类型，所以若变量的声明和赋值同时进行的，可省略类型声明</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>number：任意数字</p>
<p>string：任意字符串</p>
<p>boolean：布尔值</p>
<p>字面量：限制变量的值就是该字面量的值，如 <code>let a: 10;</code>，<code>let b: &quot;mail&quot; | &quot;female&quot;</code>，<code>let c: boolean | string</code></p>
<p>any：任意类型，一个变量设置类型为 any 后相当于对改变了关闭了 TS 的类型检测，</p>
<pre><code>若声明变量不指定类型，则 TS 解析器会自动判断变量类型为 any（隐式的 any）
let d: any; //或 let d;
d = 10;
d = &#39;a&#39;;
d = true

any 类型可赋值给任意变量
let s: string;
s = d; //不报错</code></pre>
<p>unknown：类型安全的 any，unknown 类型不能直接赋值给其他类型变量</p>
<pre><code>let e: unknown;
e = 10;
e = &#39;a&#39;;
e = true

unknown 类型不能赋值给其他类型变量
let s: string;
s = e; //报错
if(typeof e === &quot;string&quot;)&#123;
    s = e;  //不报错
&#125;
s = e as string;  //不报错，通过类型断言（用来告诉解析器变量的实际类型）后可赋值
//或
s = &lt;string&gt;e;  //类型断言的另一种写法</code></pre>
<p>void：没有值（或 undefined、null），以函数为例，表示没有返回值的函数</p>
<p>never：不能是任何值，表示永远不会返回结果（连空都不是），可用于函数报错</p>
<pre><code>function fn():never&#123;
    throw new Error(&#39;报错&#39;);
&#125;</code></pre>
<p>object：任意的 JS 对象，<code>&#123;&#125;</code> 用来指定对象中可以包含哪些属性，在属性后加上？，<code>属性？</code>表示属性是可选的；</p>
<pre><code>let a: object;
let b: &#123;name: string&#125;;  //只能有个 name 属性
let c: &#123;name: string, age?: number&#125;; //必须有 name 属性，age 属性可有可无
let d: &#123;name: string, [propName: string]: any&#125;;  //对象中需要有 name 属性，其他属性不一定，[propName: string]: any 表示任意类型的属性
let k: &#123;name: string&#125; &amp; &#123;age: number&#125;; //对象需要同时有 name 和 age 属性</code></pre>
<p>array：任意 JS 数组，方式一 <code>类型[]</code>，方式二 <code>Array&lt;类型&gt;</code></p>
<pre><code>let e: string[]; //字符串数组
let g: Array&lt;number&gt;; //数字数组，相当于 let g: number[];</code></pre>
<p>tuple：元组，即固定长度数组，TS 新增类型</p>
<pre><code>let h: [string, string]; //长度为2
h = [&#39;a&#39;,&#39;b&#39;];
let i: [string, number]; //长度为2，第一个元素为字符串，第二个元素为数字</code></pre>
<p>enum：枚举，TS 中新增类型，如 enum(A,B)</p>
<pre><code>enum Gender&#123;
    Male = 0,
    Female = 1
&#125;
let j:&#123;name: string, gender: Gender&#125;
j = &#123;
    name:&#39;xx&#39;,
    gender: Gender.Male
&#125;
console.log(j.gender === Gender.Male)</code></pre>
<p>联合类型：可使用 <code>|</code> 连接多个类型</p>
<p>函数结构的类型声明：(形参: 类型, 形参: 类型…) =&gt; 返回值类型</p>
<pre><code>let d: (a:number, b:number) =&gt; number;
d = function(n1:string, n2:string):number&#123;
    return 10;
&#125;</code></pre>
<p>类型别名：<code>type 别名 = 类型</code></p>
<pre><code>let myType = string;
let myType = 1 | 2 | 3 | 4 | 5;
let m: myType;  //相当于 let m: 1 | 2 | 3 | 4 | 5;</code></pre>
<p>html 标签：HTMLElement、HTMLCollection</p>
<h1 id="五、TypeScript-编译选项"><a href="#五、TypeScript-编译选项" class="headerlink" title="五、TypeScript 编译选项"></a>五、TypeScript 编译选项</h1><h2 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h2><p>编译文件时，使用 -w 指令后，TS 编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译</p>
<pre><code>tsc xxx.ts -w</code></pre>
<h2 id="自动编译整个项目"><a href="#自动编译整个项目" class="headerlink" title="自动编译整个项目"></a>自动编译整个项目</h2><p>直接使用 <code>tsc</code> 或 <code>tsc -w</code> 指令，可自动将当前项目下的所有 ts 文件编译为 js 文件</p>
<p>但能直接使用 <code>tsc</code> 命令的前提是在项目根目录下创建 ts 编译器的配置文件 tsconfig.json</p>
<p>tsconfig.json 是一个 JSON 文件，添加配置文件后，只需 tsc 命令即可对整个项目编译</p>
<p>在 tsconfig.json 中配置选项如下：</p>
<pre><code> //定义希望被编译文件所在的目录，默认值是 [&quot;**/*&quot;]，** 表示任意目录，* 表示任意文件
&quot;include&quot;: [
    &quot;src/**/*&quot;, 
    &quot;tests/**/*&quot;
],
 //定义需要排除在外的目录，默认值 [&quot;node_modules&quot;,&quot;bower_components&quot;,&quot;jspm_packages&quot;]
&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;],
//定义被继承的配置文件
&quot;extends&quot;: &quot;./configs/base&quot;,
//指定被编译文件的列表，只有需要编译文件少时才会用到
&quot;files&quot;: [
    &quot;core.ts&quot;,
    &quot;sys.ts&quot;,
    &quot;types.ts&quot;,
    &quot;scanner.ts&quot;,
    &quot;parser.ts&quot;,
    &quot;utilities.ts&quot;,
    &quot;binder.ts&quot;,
    &quot;checker.ts&quot;,
    &quot;tsc.ts&quot;
],
//编译器选项 compilerOptions 包含多个子选项，用来完成编译的配置
&quot;compilerOptions&quot;:&#123;
    //设置 ts 代码编译为的 ES 版本，可选值有 ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext（表示最新版本 js）
    &quot;target&quot;: &quot;ES6&quot;,

    //设置编译后代码使用的模块化规范，可选值：CommonJS、UMD、AMD、System、ES2020、ESNext、None
    &quot;module&quot;: &quot;ES2015&quot;,

    //指定代码运行时所包含的库（宿主环境），默认值是浏览器中运行所需库，一般不需要改，可选值有 ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost...
    //&quot;lib&quot;: [&quot;ES6&quot;,&quot;DOM&quot;],

    //编译后文件的所在目录，默认编译后的 js 文件会和 ts 文件位于相同的目录
    &quot;outDir&quot;: &quot;./dist&quot;,

    //将代码合并为一个文件，所有的全局作用域中的代码合并到同一个文件中
    &quot;outFile&quot;: &quot;./dist/xxx.js&quot;,

    //是否对 js 文件进行编译，默认为 false
    &quot;allowJs&quot;: true,

    //是否检查 js 代码是否符合语法规范，默认是 false
    &quot;checkJS&quot;: true,

    //是否移除注释
    &quot;removeComments&quot;: true,

    //不生成编译后的文件，默认为 false
    &quot;noEmit&quot;: false,

    //当有错误时不生成编译后的文件
    &quot;noEmitOnError&quot;: true,

    //所有严格检查的总开关，设置为 true 或 false 后下面的各选项都会跟着它的值
    &quot;strict&quot;: true,

    //设置编译后的文件是否使用严格模式，默认是 false，为true 时会在编译后 js 中第一行添加 &#39;use strict&#39;，使用严格模式语法更严格，性能也更好
    &quot;alwaysStrict&quot;: true,

    //不允许隐式 any 类型（如函数形参中忘记写类型了）
    &quot;noImplicitAny&quot;: true,

    //不允许不明确类型的 this，如需要指定 this:Window
    &quot;noImplicitThis&quot;: true,

    //严格的检查空值，如有时使用 getElementById 可能会获取到空值是否需要关注
    &quot;strictNullChecks&quot;:true,
&#125;</code></pre>
<h1 id="六、使用-Webpack-打包-ts-代码"><a href="#六、使用-Webpack-打包-ts-代码" class="headerlink" title="六、使用 Webpack 打包 ts 代码"></a>六、使用 Webpack 打包 ts 代码</h1><p>（1）首先初始化项目</p>
<pre><code>npm init -y</code></pre>
<p>（2）安装依赖</p>
<pre><code>npm i -D webpack webpack-cli typescript ts-loader</code></pre>
<p>帮助自动生成 html 文件</p>
<pre><code>npm i -D html-webpack-plugin</code></pre>
<p>webpack 开发服务器</p>
<pre><code>npm i -D webpack-dev-server</code></pre>
<p>打包时先清除 dist 目录的插件</p>
<pre><code>npm i -D clean-webpack-plugin</code></pre>
<p>处理浏览器兼容性问题</p>
<pre><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></pre>
<p>（3）设置 webpack.config.js 配置文件</p>
<pre><code>const path = require(&#39;path&#39;);
const HTMLWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
const &#123; CleanWebpackPlugin &#125; = require(&#39;clean-webpack-plugin&#39;);
module.exports = &#123;
    //入口文件
    entry: &quot;./src/index.ts&quot;,

    //打包文件所在目录
    output: &#123;
        //打包文件的目录
        path: path.resolve(__dirname, &#39;dist&#39;),
        //打包后文件的名字
        filename: &quot;bundle.js&quot;,
        //配置打包环境，告诉 webpack 不使用箭头函数，不使用 const
        environment: &#123;
            arrowFunction:false,
            const: false
        &#125;
    &#125;,

    //打包时要使用的模块
    module: &#123;
        rules: [
            &#123;
                test: /\.ts$/,
                use: [
                    &#123;
                        loader: &#39;babel-loader&#39;,
                        options: &#123;
                            presets:[
                                [
                                    &quot;@babel/preset-env&quot;,
                                    &#123;
                                        //要兼容的目标浏览器
                                        targets:&#123;
                                            &quot;chrome&quot;:&quot;58&quot;, //兼容到 chrome 58
                                            &quot;ie&quot;:&quot;11&quot;
                                        &#125;,
                                        &quot;corejs&quot;:&quot;3&quot;, //core-js 的版本开头，使得 IE 可以使用 promise
                                        &quot;useBuiltIns&quot;:&quot;usage&quot; //按需加载
                                    &#125;
                                ]
                            ]
                        &#125;
                    &#125;,
                    &#39;ts-loader&#39;
                ],
                exclude: /node_modules/
            &#125;
        ]
    &#125;,
    plugins: [
        new CleanWebpackPlugin(),
        new HTMLWebpackPlugin(options: &#123;
            template: &quot;./src/index.html&quot;
        &#125;);
    ],

    //用来设置引用模块，即哪些文件可作为模块
    resolve: &#123;
        extensions: [&#39;.ts&#39;,&#39;.js&#39;]
    &#125;
&#125;;</code></pre>
<p>（4）设置 ts 编译规范，在 tsconfig.json 文件中写入如下内容</p>
<pre><code>&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    &#125;
&#125;</code></pre>
<p>（5）在 package.json 的 “script” 选项中添加命令</p>
<pre><code>&quot;build&quot;: &quot;webpack&quot;,
&quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</code></pre>
<p>build 命令用于打包，start 命令在开发时使用 webpack-dev-serve</p>
<p>（6）执行打包</p>
<pre><code>npm run build</code></pre>
<p>或在开发时运行 webpack 服务器</p>
<pre><code>npm start</code></pre>
<h1 id="七、面向对象"><a href="#七、面向对象" class="headerlink" title="七、面向对象"></a>七、面向对象</h1><p>在程序中所有对象都被分成数据和功能两部分</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>要创建对象必须先定义类，类可以理解为对象的模型</p>
<pre><code>class 类名&#123;
    //定义实例属性
    属性名: 类型;
    属性名: 类型 = 值;
    readonly: 属性名: 类型 = 值; //只读属性
    //定义类属性/静态属性，在属性前使用 static
    static 属性名: 类型 = 值;
    static readonly 属性名: 类型 = 值; //只读静态属性

    //定义实例方法
    方法名()&#123;...&#125;
    //定义类方法
    static 方法名()&#123;...&#125;
&#125;</code></pre>
<p>直接定义的属性是实例实现，需要通过对象的实例去访问</p>
<pre><code>const per = new Person();
per.name</code></pre>
<p>类属性/静态属性（或方法）是通过类直接访问，无需创建对象就可以使用的属性，在属性前使用 static</p>
<pre><code>Person.age</code></pre>
<p>readonly 开头的属性表示一个只读属性，无法修改</p>
<h2 id="构造函数和-this"><a href="#构造函数和-this" class="headerlink" title="构造函数和 this"></a>构造函数和 this</h2><p>构造函数 constructor 会在对象创建时（即 new 时）调用</p>
<pre><code>class 类名&#123;
    属性名: 类型;
    constructor(参数: 类型)&#123;
        this.属性名 = 参数;
    &#125;
    方法名()&#123;...&#125;
&#125;</code></pre>
<p>在实例方法中，this 表示当前实例</p>
<p>在构造函数中当前对象就是当前新建的实例对象，可通过 this 向新建的对象中添加属性</p>
<p>属性在类中定义，在构造函数中赋值</p>
<pre><code>class Dog&#123;
    name: string; //定义属性
    age: number; //定义属性
    constructor(name:string,age:number)&#123;
        this.name = name; //给属性赋值
        this.age = age; //给属性赋值
    &#125;
    bark()&#123;
        alert(&#39;xx&#39;);
    &#125;
&#125;
const dog = new Dog(name:&#39;xx&#39;,age:2);</code></pre>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>使用继承后，子类将会拥有父类所有的方法和属性</p>
<p>通过继承可以将多个类中共有的代码写在一个类中，只需写一次即可让所有子类同时拥有父类中的属性和方法</p>
<p>若要在子类中添加父类中没有的属性或方法直接加就可以</p>
<p>若在子类中添加了和父类相同的方法，则子类方法会覆盖掉父类的方法，这种子类覆盖父类方法的形式称为方法重写</p>
<p>在类的方法中 super 就表示当前类的父类</p>
<p>若在子类中写了构造函数，相当于把父类构造函数覆盖掉，因此<strong>在子类构造函数中必须对父类构造函数进行调用</strong></p>
<pre><code>class Animal&#123; //父类
    name: string;
    constructor(name:string)&#123;
        this.name = name;
    &#125;
    sayHello()&#123;
        console.log(&#39;xx&#39;);
    &#125;
&#125;
class Dog extends Animal&#123; //Dog 类继承 Animal 类
    age: number;
    constructor(name:string,age:number)&#123;
        super(name); //调用父类构造函数
        this.age = age;
    &#125;
    run()&#123;
        console.log($&#123;this.name&#125;)
    &#125;
    sayHello()&#123;
        super.sayHello();
        console.log(&#39;www&#39;)
    &#125;
&#125;
class Cat extends Animal&#123;
    sayHello()&#123;
        console.log(&#39;mmm&#39;)
    &#125;
&#125;
const dog = new Dog(name:&#39;xx&#39;,age:2);
dog.sayHello();
dog.run();
const cat = new Cat(name:&#39;xxx&#39;);
cat.sayHello();</code></pre>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>以 abstract 开头的类是抽象类，抽象类和其他类区别不大，只是不能用来继承</p>
<p>抽象类就是专门用来被继承的类</p>
<p>抽象类中可以添加抽象方法，抽象方法以 abstract 开头，没有方法体，抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</p>
<pre><code>abstract class Animal&#123; //父类
    name: string;
    constructor(name:string)&#123;
        this.name = name;
    &#125;
    abstract sayHello():void;  //抽象方法
&#125;
class Dog extends Animal&#123; //Dog 类继承 Animal 类
    sayHello()&#123;
        console.log(&#39;www&#39;);
    &#125;
&#125;
const dog = new Dog(name:&#39;xx&#39;);</code></pre>
<p>上述代码中不能使用 <code>new Animal</code> 创建 Animal 实例</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口用来定义一个类结构，用来定义一个类中应该包含哪些属性和方法</p>
<p>接口只定义对象的结构，而不考虑实际值，接口中的所有属性都不能有实际值</p>
<p>接口中所有方法都是抽象方法</p>
<p>定义类时，可使类去实现一个接口，实现接口就是使类满足接口的要求</p>
<p>接口其实就是定义一个规范，对类做一些限制</p>
<pre><code>interface myInter&#123;
    name: string;
    sayHello():void;
&#125;
class MyClass implements myInter&#123;
    name: string;
    constructor(name: string)&#123;
        this.name = name;
    &#125;
    sayHello()&#123;
        console.log(&#39;xxx&#39;);
    &#125;
&#125; </code></pre>
<p>同时接口也可以当成类型声明去使用</p>
<p>注意：接口可定义多个同名的接口，使用时是把多个同名接口的内容都加一块看，而 type 类型声明的类型名不能重复</p>
<pre><code>interface myInterface&#123;
    name: string,
    age: number
&#125;
interface myInterface&#123;
    gender: string
&#125;
const obj: myInterface = &#123;
    name:&#39;xx&#39;,
    age:111,
    gender:&#39;male&#39;
&#125;</code></pre>
<p>上述代码相当于</p>
<pre><code>type myType = &#123;
    name: string,
    age: number,
    gender: string
&#125;
const obj: myType = &#123;
    name:&#39;xx&#39;,
    age:111,
    gender:&#39;male&#39;
&#125;</code></pre>
<p>接口和抽象类的区别：</p>
<p>（1）抽象类中可以有普通方法或抽象方法，而接口中都是抽象方法</p>
<p>（2）抽象类通过 extends 继承，接口通过 implements 实现</p>
<h2 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h2><p>之前是属性在对象中设置，属性可任意被修改，这会导致对象中的数据变得非常不安全</p>
<p>TS 可在属性前添加属性的修饰符</p>
<p>public 这是默认值，修饰的属性可在任意位置访问（修改），包括子类</p>
<p>private 私有属性只能在类内部访问（修改），通过在类中添加方法使得私有属性可以被外部访问</p>
<p>protected 受保护的属性，只能在当前类和当前类的子类中访问（修改），不能在实例对象中访问</p>
<p>getter 方法用来读取属性，setter 方法用来设置属性，它们被称为属性的存取器</p>
<pre><code>class Person&#123;
    private _name:string;
    private _age:number;
    constructor(name:string,age:number)&#123;
        this._name = name;
        this._age = age;
    &#125;
    //设置 getter 方法
    get name()&#123;
        return this._name;
    &#125;
    //getName()&#123;  //也可以设置一个方法来获取属性
    //    return this._name;
    //&#125;
    //设置 setter 方法
    set name(value: string)&#123;
        this._name = name;
    &#125;
    //setName(value: string)&#123;     //也可以设置一个方法来设置属性值
    //    this._name = value;
    //&#125;

&#125;
const per = new Person(name:&#39;xxx&#39;,age:1)
console.log(per.name); //此处会调用 get name
per.name = &#39;xxxx&#39;; //此时不是直接去访问 name 属性（因为 name 是私有属性），而是去调用 set name 方法</code></pre>
<p>属性定义也可写在 constructor 中</p>
<pre><code>class A&#123;
    constructor(public name:string,public age:number)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;

相当于

class A&#123;
    name:string;
    public age:number;
    constructor(name:string,age:number)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;</code></pre>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型就是不确定的类型，在定义函数或类时，若遇到类型不明确的情况就可以使用泛型</p>
<p>泛型可以同时指定多个</p>
<pre><code>function fn&lt;T&gt;(a:T):T&#123;
    return a;
&#125;

function fn2&lt;T,K&gt;(a:T,b:K):T&#123;
    return a;
&#125;

interface Inter&#123;
    length: number;
&#125;
function fn3&lt;T extends Inter&gt;(a:T):number&#123; //这里泛型要实现接口 Inter，是 Inter 实现类（或子类）
    return a.length;
&#125;

class MyClass&lt;T&gt;&#123;
    name: T;
    constructor(name: T)&#123;
        this.name = name;
    &#125;
&#125;</code></pre>
<p>可直接调用具有泛型的函数</p>
<pre><code>let result = fn(a:10);  //不指定泛型，TS 可自动对类型进行推断
let result1 = fn&lt;string&gt;(a:&#39;hello&#39;); //指定泛型
fn2(a:123,b:&#39;hello&#39;)
fn2&lt;number,string&gt;(a:123,b:&#39;hello&#39;)
fn3(a:&#39;123&#39;);
fn3(a: &#123;length:10&#125;);
const mc = new MyClass&lt;string&gt;(name:&#39;xx&#39;);</code></pre>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="向一个-DOM-元素里的末尾添加一个-div"><a href="#向一个-DOM-元素里的末尾添加一个-div" class="headerlink" title="向一个 DOM 元素里的末尾添加一个 div"></a>向一个 DOM 元素里的末尾添加一个 div</h2><pre><code>DOM元素.insertAdjacentHTML(where:&quot;beforend&quot;, html:&quot;&lt;div&gt;&lt;/div&gt;&quot;)</code></pre>
<h2 id="键盘事件处理函数"><a href="#键盘事件处理函数" class="headerlink" title="键盘事件处理函数"></a>键盘事件处理函数</h2><pre><code>函数(event: KeyboardEvent)&#123;...&#125;</code></pre>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 作用是创建一个新的函数，把调用 bind 的函数的 this 变为参数中的 this</p>
<pre><code>document.addEventListener(type: &#39;keydown&#39;, 回调函数.bind(this));
则回调函数中的 this 就不是正常情况下的发生事件的 DOM 元素，而是创建函数的当前对象（如外面的类或 window（视情况而定））</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>React学习笔记</title>
    <url>/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、React-简介"><a href="#一、React-简介" class="headerlink" title="一、React 简介"></a>一、React 简介</h1><p>React 是用于构建用户界面的 JavaScript 库，是一个将数据渲染为 HTML 视图的开源 JavaScript 库，只关注操作 DOM 和呈现页面</p>
<a id="more"></a>

<p>React 由 Facebook 开发且开源</p>
<h2 id="1、原生-JS-的痛点"><a href="#1、原生-JS-的痛点" class="headerlink" title="1、原生 JS 的痛点"></a>1、原生 JS 的痛点</h2><p>（1）原生 JavaScript 操作 DOM 繁琐、效率低（DOM-API 操作 UI），</p>
<p>（2）使用 JavaScript 直接操作 DOM，浏览器会进行大量的重绘重排</p>
<p>（3）原生 JavaScript 没有组件化编码方案，代码复用率低</p>
<h2 id="2、React-的特点"><a href="#2、React-的特点" class="headerlink" title="2、React 的特点"></a>2、React 的特点</h2><p>（1）采用<strong>组件化</strong>模式，<strong>声明式编码</strong>，关注结果，过程能自动完成（而非命令式编码，需要关注中间过程），提高开发效率及组件复用率</p>
<p>（2）在 React Native 中可以使用 React 语法进行移动端原生应用开发（利用 js 完成安卓和 ios 移动端开发）</p>
<p>（3）使用虚拟 DOM + 优秀的 Diffing 算法，尽量减少与真实 DOM 的交互</p>
<h2 id="3、React-高效的原因"><a href="#3、React-高效的原因" class="headerlink" title="3、React 高效的原因"></a>3、React 高效的原因</h2><p>（1）使用虚拟 DOM，不总是直接操作页面真实 DOM</p>
<p>（2）DOM Diffing 算法，最小化页面重绘</p>
<h2 id="4、相关-js-库"><a href="#4、相关-js-库" class="headerlink" title="4、相关 js 库"></a>4、相关 js 库</h2><p>babel.min.js：解析 JSX 代码语法转为 JS 代码的库</p>
<p>react.development.js：React 核心库</p>
<p>react-dom.development.js：提供操作 DOM 的 react 扩展库</p>
<p>要先引入 react-dom.development.js，后引入 react.development.js</p>
<h2 id="5、虚拟-DOM-和-真实-DOM"><a href="#5、虚拟-DOM-和-真实-DOM" class="headerlink" title="5、虚拟 DOM 和 真实 DOM"></a>5、虚拟 DOM 和 真实 DOM</h2><p>虚拟 DOM 本质是 Object 类型的对象（一般对象）</p>
<p>虚拟 DOM 比较 “轻”，属性较少，而真实 DOM 较 “重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性（如 style 等）</p>
<p>虚拟 DOM 最终会被 React 转化为真实 DOM 呈现在页面上</p>
<h2 id="6、创建虚拟-DOM"><a href="#6、创建虚拟-DOM" class="headerlink" title="6、创建虚拟 DOM"></a>6、创建虚拟 DOM</h2><h3 id="方式一：纯-js（一般不用）"><a href="#方式一：纯-js（一般不用）" class="headerlink" title="方式一：纯 js（一般不用）"></a>方式一：纯 js（一般不用）</h3><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/JavaScript&quot;&gt; /* 此处写 JavaScript */
        //1.使用 js 创建虚拟 DOM
        const VDOM = React.createElementt(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,&#39;Hello&#39;)
        //2.渲染虚拟 DOM 到页面
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="方式二：JSX"><a href="#方式二：JSX" class="headerlink" title="方式二：JSX"></a>方式二：JSX</h3><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt; /* 此处一定要写 babel */
        //1.使用 jsx 创建虚拟 DOM
        const VDOM = &lt;h1&gt;Hello&lt;/h1&gt; /* 此处一定不要写引号 */
        //2.渲染虚拟 DOM 到页面
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>当要创建嵌套标签的虚拟 DOM 时，使用 js 很繁琐，而使用 jsx 就像写 html 一样很方便，babel 编译后依然是使用 js 创建虚拟 DOM 时的语法，因此 JSX 创建虚拟 DOM 就是 js 创建虚拟 DOM 写法的语法糖</p>
<h2 id="7、JSX"><a href="#7、JSX" class="headerlink" title="7、JSX"></a>7、JSX</h2><p>JSX（JavaScript XML）是 react 定义的一种类似于 XML 的 JS 扩展语法（JS + XML）</p>
<p>（XML 早期用于存储和传输数据，后来用 JSON 用的更多更方便简单）</p>
<p>JSX 本质是 <code>React.createElementt(标签名,&#123;属性名:属性值&#125;,&#39;标签体内容&#39;)</code> 方法的语法糖</p>
<p>作用：用来简化创建虚拟 DOM，<code>var ele = &lt;h1&gt;Hello&lt;/h1&gt;</code>，注意它不是字符串也不是 HTML/XML 标签，它最终产生的就是一个 JS 对象</p>
<p>JSX 中标签名任意，可以是 HTML 标签或其他标签</p>
<h3 id="jsx-语法规则"><a href="#jsx-语法规则" class="headerlink" title="jsx 语法规则"></a>jsx 语法规则</h3><p>（1）定义虚拟 DOM 时不要写引号</p>
<p>（2）标签中混入 JS 表达式时要用 <code>&#123;&#125;</code></p>
<p>（3）样式的类名指定不要用 class，要用 className</p>
<p>（4）内联样式要用 <code>style=&#123;&#123;key:value&#125;&#125;</code> 的形式写</p>
<p>（5）虚拟 DOM 必须只有一个根标签</p>
<p>（6）标签必须闭合，如 <code>&lt;input /&gt;</code> 或 <code>&lt;input&gt;&lt;/input&gt;</code></p>
<p>（7）标签首字母</p>
<pre><code>1）若是小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该编起对应的同名元素，则报错
2）若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错</code></pre>
<p>（8）给一个{数组} react 会自动遍历，但给一个对象不会</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        .title&#123;
            background-color:red;
            width: 100px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        const myId = &#39;xXx&#39;;
        const myData = &#39;123aBc&#39;;
        const VDOM = (
            &lt;h1 className=&quot;title&quot; id=&#123;myId.toLowerCase()&#125;&gt;
                &lt;span style=&#123;&#123;color:'white',fontSize:'20px'&#125;&#125;&gt;&#123;&#123;myData.toLowerCase()&#125;&#125;&lt;/span&gt;
            &lt;/h1&gt;
        )
        ReactDOM.render(VDOM, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<h3 id="区分-js-语句（代码）与-js-表达式"><a href="#区分-js-语句（代码）与-js-表达式" class="headerlink" title="区分 js 语句（代码）与 js 表达式"></a>区分 js 语句（代码）与 js 表达式</h3><p>表达式：一个表达式会产生一个值（即通过 <code>const x =</code> 来接能接到值就是表达式，否则不是），可放在任何一个需要值的地方，如</p>
<pre><code>a
a+b
demo(1) //函数调用表达式
arr.map()
function test()&#123;&#125;
console.log()</code></pre>
<p>而语句（代码）如</p>
<pre><code>if()&#123;&#125;
for()&#123;&#125;
switch()&#123;case:xxx&#125;</code></pre>
<h1 id="二、模块与组件、模块化与组件化"><a href="#二、模块与组件、模块化与组件化" class="headerlink" title="二、模块与组件、模块化与组件化"></a>二、模块与组件、模块化与组件化</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是向外提供特定功能的 js 程序，一般就是一个 js 文件</p>
<p>为什么要拆成模块？：随着业务逻辑增加，代码越来越多且复杂</p>
<p>作用：复用 js，简化 js 的编写（每个 js 文件不那么庞大），提高 js 运行效率</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件用来实现局部功能效果的代码和资源的集合（html/css/js/image等）</p>
<p>为什么用组件？：一个界面的功能更复杂</p>
<p>作用：复用编码，简化项目编码，提高运行效率</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>当应用的 js 都以模块来编写的，这个应用就是一个模块化的应用</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p>
<h1 id="三、React-面向组件编程"><a href="#三、React-面向组件编程" class="headerlink" title="三、React 面向组件编程"></a>三、React 面向组件编程</h1><p>可现在 Chrome 浏览器中安装插件 React Developer Tools</p>
<h2 id="简单组件与复杂组件"><a href="#简单组件与复杂组件" class="headerlink" title="简单组件与复杂组件"></a>简单组件与复杂组件</h2><p>若组件中有状态 state 就是复杂组件</p>
<p>组件的数据存在 state 里，组件的状态 state 驱动页面</p>
<h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><h3 id="方式一：函数式组件"><a href="#方式一：函数式组件" class="headerlink" title="方式一：函数式组件"></a>方式一：函数式组件</h3><p>用函数定义的组件适用于简单组件</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        //1.创建函数式组件
        function Demo()&#123; //组件首字母要大写
            console.log(this); //此处的 this 是 undefined，因为 babel 编译后开启了严格模式（禁止自定义函数中 this 指向 window）
            return &lt;h1&gt;xxx&lt;/h1&gt;
        &#125;
        //2.渲染组件到页面
        ReactDOM.render(&lt;Demo/&gt;, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>执行了 <code>ReactDOM.render(&lt;demo/&gt;...)</code> 后发生了什么？</p>
<p>— 1.React 解析组件标签，找到了 Demo 组件</p>
<p>— 2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中</p>
<h3 id="方式二：类式组件"><a href="#方式二：类式组件" class="headerlink" title="方式二：类式组件"></a>方式二：类式组件</h3><p>用类定义的组件适用于复杂组件</p>
<p>构造器　constructor　调用　１　次</p>
<p>render　调用　１＋n　次（其中　１　是初始化的那次，n　是状态　state　更新的次数）</p>
<p>事件函数触发几次（如点击）调用几次</p>
<h4 id="复习类相关知识"><a href="#复习类相关知识" class="headerlink" title="复习类相关知识"></a>复习类相关知识</h4><p>类中的构造器不是必须写的，要对实例进行初始化操作时（如添加指定属性）才写</p>
<p>类中的构造器方法中的 this 是类的实例对象</p>
<p>类中的一般方法是放在了类型的原型对象上（__proto__），供实例使用，通过实例对象调用类中的方法式，方法中的 this 就是实例对象</p>
<p>若 A 类继承了 B 类，且 A 类中写了构造器，则 A 类构造器中的 super 是必须调用的</p>
<p>类中的方法默认开启了局部的严格模式，所以方法中的　this　为　undefined</p>
<p>且在外部通过　const x = 实例对象.方法，然后　x()　进行调用此时依然不是通过实例对象调用，而是直接调用，因此调用的方法中的　this　不是实例对象</p>
<p>类中可以直接写赋值语句　｀a：１｀，相当于给实例对象自身上添加一个属性　a　值为　１</p>
<p>类中箭头函数中没有this，但若使用this不报错，而是去外部找this</p>
<h4 id="创建类式组件"><a href="#创建类式组件" class="headerlink" title="创建类式组件"></a>创建类式组件</h4><pre><code>&lt;body&gt;
    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
        //1.创建类式组件
        class MyComponent extends React.Component&#123; //必须继承React.Component
            render()&#123;  //必须有 render 函数，render 是放在 MyComponent 类的原型对象上，供实例使用，render 中的 this 是 MyComponent 实例对象（也叫 MyComponent 实例对象）
                return &lt;h1&gt;xxx&lt;/h1&gt;
            &#125;
        &#125;
        //2.渲染组件到页面
        ReactDOM.render(&lt;MyComponent/&gt;, document.getElementById(&#39;test&#39;))
    &lt;/script&gt;
&lt;/body&gt;</code></pre>
<p>执行了 <code>ReactDOM.render(&lt;MyComponent/&gt;...)</code> 后发生了什么？</p>
<p>— 1.React 解析组件标签，找到了 MyComponent 组件</p>
<p>— 2.发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用到原型上的 render 方法</p>
<p>— 3.将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中</p>
<h2 id="组件实例（用类定义的组件）的三大核心属性"><a href="#组件实例（用类定义的组件）的三大核心属性" class="headerlink" title="组件实例（用类定义的组件）的三大核心属性"></a>组件实例（用类定义的组件）的三大核心属性</h2><h3 id="1、state"><a href="#1、state" class="headerlink" title="1、state"></a>1、state</h3><p>state 是组件实例对象最重要的属性，值是对象，可包含多个 key-value 的组合</p>
<p>组件被称为“状态机”，通过更新组件的 state 来更新对应的页面显示（重新渲染组件）</p>
<p>注意：（1）组件中 render 方法中的 this　为组件实例对象</p>
<p>（2）组件自定义的方法中　this　为　undefined　如何解决？</p>
<pre><code>a）强制绑定 this：通过函数对象的 bind（）
b）赋值语句＋箭头函数</code></pre>
<p>（3）状态数据不能直接修改或更新，需要使用　this.setState({state中属性:值})，且更新是一种合并（重名的覆盖掉），不是替换</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            //初始化状态
            this.state=&#123;isHot:true&#125;
        &#125;
        render()&#123;
            return &lt;h1&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>state　的简写方式</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        //constructor(props)&#123;
            //super(props)
            //this.state=&#123;isHot:true&#125;
        //&#125;
        state=&#123;isHot:true&#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
        //自定义方法：用赋值语句的形式＋箭头函数，因为类中箭头函数中没有this，但若使用this不报错，而是去外部找this（这里即实例对象），这样在定义事件方法时就不要再this.demo=this.demo.bind(this)
        demo=()=＞&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="1、props"><a href="#1、props" class="headerlink" title="1、props"></a>1、props</h3><p>每个组件对象都会有　props（properties的简写）属性</p>
<p>组件标签的所有属性都保存在　props　中</p>
<p><strong>作用：</strong></p>
<p>—（1）通过标签属性从组件外向组件内传递变化的数据</p>
<p>—（2）注意：组件内部不要修改 props 数据</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39;/&gt;, document.getElementById(&#39;test&#39;))
    ReactDOM.render(&lt;Person　name=&#39;xxxxx&#39; sex=&#39;女&#39;/&gt;, document.getElementById(&#39;test1&#39;))
&lt;/script&gt; </code></pre>
<p>注意：props 是只读的</p>
<h4 id="props-的批量传递"><a href="#props-的批量传递" class="headerlink" title="props 的批量传递"></a>props 的批量传递</h4><p>在标签属性中使用 <code>&#123;...对象&#125;</code>，react + babel 允许使用展开运算符展开对象，<code>...对象</code> 这也仅适用于标签属性的传递，如在 <code>console.log(...对象)</code> 就无效，啥也不输出，注意这里的花括号表示里面表达式，和 js 中拷贝对象的含义不同</p>
<pre><code>const p =&#123;name:&#39;xxx&#39;,sex:&#39;男&#39;&#125;
ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;, document.getElementById(&#39;test&#39;))</code></pre>
<h4 id="对-props-进行限制"><a href="#对-props-进行限制" class="headerlink" title="对 props 进行限制"></a>对 props 进行限制</h4><p>需要引入 prop-types，用于对组件标签属性进行类型、必要性、默认值限制，引入后全局多了个对象 PropTypes</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./prop-types.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;

    Person.propTypes = &#123;
        name:PropTypes.string.isRequired, //使得 name 必传且为字符串。在 React v15.5 之前使用 name:React.PropTypes.string.isRequired，且不需要引入 prop-types，v15.5 之后单独封装成 prop-types，减轻 React 重量
        sex:PropTypes.string,
        age:PropTypes.number,
        speak:PropTypes.func
    &#125;
    Person.defaultProps = &#123; //设置不传某属性时使用的默认值
        sex:&#39;男&#39;,
        age:18
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39; speak=&#123;speak&#125;/&gt;, document.getElementById(&#39;test&#39;))

    function speak()&#123;
        console.log(&#39;xxx&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<h4 id="props-的简写方式"><a href="#props-的简写方式" class="headerlink" title="props 的简写方式"></a>props 的简写方式</h4><p>把 <code>组件对象.propTypes</code> 和 <code>组件对象.defaultProps</code> 放到类内部，前面加上 static 关键字</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./react.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./react-dom.development.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./prop-types.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Person extends React.Component&#123;
        static propTypes = &#123;
            name:PropTypes.string.isRequired, //使得 name 必传且为字符串
            sex:PropTypes.string,
            age:PropTypes.number,
            speak:PropTypes.func
        &#125;
        static defaultProps = &#123; //设置不传某属性时使用的默认值
            sex:&#39;男&#39;,
            age:18
        &#125;
        render()&#123;
            return (
                &lt;ul&gt;
                    &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                    &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
                &lt;/ul&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&#39;xxx&#39;　sex=&#39;男&#39; speak=&#123;speak&#125;/&gt;, document.getElementById(&#39;test&#39;))

    function speak()&#123;
        console.log(&#39;xxx&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<h4 id="类式组件中的构造器与-props"><a href="#类式组件中的构造器与-props" class="headerlink" title="类式组件中的构造器与 props"></a>类式组件中的构造器与 props</h4><p>在 React 中构造函数仅用于以下两种情况：</p>
<p>—（1）通过 <code>this.state = &#123;...&#125;</code> 来初始化 state（但这种初始化方式可在构造器外直接使用 <code>state = &#123;&#125;</code> 来赋值）</p>
<p>—（2）为事件处理函数绑定实例 <code>this.demo=this.demo.bind(this)</code>（但这种绑定可直接在定义函数时使用箭头函数来省略这步）</p>
<p>因此构造器不是必须的</p>
<p>但是有时需要接收和访问实例对象的 props 值，需要在构造器中接收 props 并传递给 super(props)，若要访问 <code>this.props</code> 则必须将 props 传给 super</p>
<p>即构造器是否接收 props，是否传递给 super 取决于是否希望在构造器中通过 this 访问 props</p>
<pre><code>constructor(props)&#123;
    super(props)
    console.log(this.props)
&#125;</code></pre>
<h4 id="函数式组件使用-props"><a href="#函数式组件使用-props" class="headerlink" title="函数式组件使用 props"></a>函数式组件使用 props</h4><p>若不是通过类创建组件，而是通过函数定义的组件，则无法使用 state 和 refs（除非使用最新版 React 中的 hooks），因为没有类就没有实例就没有 this，但可以使用 props</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建函数式组件
    function Person(props)&#123;
        const &#123;name,age,sex&#125; = props
        return (
            &lt;ul&gt;
                &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt;
                &lt;li&gt;性别：&#123;this.props.ex&lt;/li&gt;
            &lt;/ul&gt;
        )
    &#125;
    Person.propTypes = &#123;
        name:PropTypes.string.isRequired, //使得 name 必传且为字符串
        sex:PropTypes.string,
        age:PropTypes.number,
        speak:PropTypes.func
    &#125;
    Person.defaultProps = &#123; //设置不传某属性时使用的默认值
        sex:&#39;男&#39;,
        age:18
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Person name=&quot;x&quot;/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt;</code></pre>
<h3 id="3、refs"><a href="#3、refs" class="headerlink" title="3、refs"></a>3、refs</h3><p>组件内的标签可以定义 ref 属性来标识自己，这样就可以不使用 id 和 getElementById，而是使用 this.refs.ref名 来替代（注意这样拿到的是真实 DOM 节点，而不是虚拟 DOM 节点）</p>
<p>定义形式：</p>
<p>—（1）字符串形式的 ref <code>&lt;input ref=&quot;input1&quot;/&gt;</code>（因为存在效率问题，这种方式以不被官方推荐使用，可能在未来 React 版本中移除）</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this.refs
            console.log(input1.value)
        &#125;
        showData2=()=＞&#123;
            const &#123;input2&#125; = this.refs
            console.log(input2.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&quot;input1&quot; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&quot;input2&quot; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>—（2）回调形式的 ref <code>&lt;input ref=&#123;(c)=&gt;&#123;this.input1=c&#125;&#125;/&gt;</code> 执行 render 函数时就会执行该回调函数，其中参数 c 表示当前所处 DOM 节点，把当前 DOM 节点挂在实例自身（this）上，并取名为 input1</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this
            console.log(input1.value)
        &#125;
        showData2=()=＞&#123;
            const &#123;input2&#125; = this
            console.log(input2.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&#123;(c)=&gt;&#123;this.input2 = c&#125;&#125; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意：若 ref 回调函数是以内联函数的方式定义，在更新过程中（第二次触发 render() 开始）它会被执行两次，第一次传入参数 null，第二次才传入 DOM 元素，因为每次渲染时会创建一个新的函数实例，所以 React 会传入 null 清空旧的 ref 再设置新的</p>
<p>通过 ref 回调函数定义或 class 的绑定函数的方式可避免上述问题，但大多数情况下它是无关紧要的，可以使用内联方式</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        showData=()=＞&#123;
            const &#123;input1&#125; = this
            console.log(input1.value)
        &#125;
        saveInput=(c)=＞&#123;
            this.input1 = c
            console.log(c)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;this.saveInput&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input ref=&#123;(c)=&gt;&#123;this.input2 = c&#125;&#125; onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>—（3）createRef 创建 ref 容器 <code>myRef = React.createRef()</code>，调用后会返回一个容器，该容器可存储被 ref 标识的节点，把当前 ref 所在 DOM 节点直接存储到容器中（官方推荐使用）</p>
<p>注意：该容器是 “专人专用” 的，如果两个 DOM 节点都放在同一个容器中，后放入的会覆盖前面的</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Demo extends React.Component&#123;
        myRef = React.createRef() //把这个容器挂在组件实例自身上
        myRef2 = React.createRef()
        showData=()=＞&#123;
            console.log(this.myRef.current.value)
        &#125;
        showData2=()=＞&#123;
            console.log(this.myRef2.current.value)
        &#125;
        render()&#123;
            return(
                &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot;/&gt;
                &lt;button onClick=&#123;this.showData&#125;&gt;点击&lt;/button&gt;
                &lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot;/&gt;
            )
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意：不要过度使用 ref，如当发生事件的元素和当前操作的元素是同一个就可以不使用 ref，而是 event.target 来获取，如 <code>&lt;input onBlur=&#123;this.showData2&#125; ref=&#123;this.myRef2&#125; type=&quot;text&quot;/&gt;</code> 可换成 <code>&lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot;/&gt;</code> 在 showData2 中定义如下</p>
<pre><code>showData2=(event)=＞&#123;
    console.log(event.target.value)
&#125;</code></pre>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>在　React　中使用<code>onClick</code>、<code>onBlur</code> 等绑定事件，注意在原生 js 中是 <code>onclick</code>、<code>onblur</code>　</p>
<p>方式一：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            this.state=&#123;isHot:true&#125;
        &#125;
        render()&#123;
            return &lt;h1 onClick=&#123;demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))

    function demo()&#123;
        console.log(&#39;哈哈哈&#39;)
    &#125;
&lt;/script&gt; </code></pre>
<p>方式二：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        constructor(props)&#123;
            super(props)
            this.state=&#123;isHot:true&#125;
            this.demo1=this.demo.bind(this)//生成一个新函数，这个新函数的this为实例对象，并把这个新函数取名为demo1挂在实例上，解决　demo　中　this　指向问题
        &#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo1&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;　//这里　demo　在　Weather　原型对象上，供实例使用，由于　demo　是作为　onClick　的回调，所以不是通过实例调用的，是直接调用，且类中的方法默认开启局部的严格模式，因此　demo　中的　this　为　undefined，所以需要　this.demo=this.demo.bind(this)
        &#125;
        demo()&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>方式三：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Weather extends React.Component&#123;
        //constructor(props)&#123;
            //super(props)
            //this.state=&#123;isHot:true&#125;
        //&#125;
        state=&#123;isHot:true&#125;
        render()&#123;
            return &lt;h1 onClick=&#123;this.demo&#125;&gt;今天天气&#123;this.state.isHot？&#39;炎热&#39;:&#39;凉爽&#39;&#125;&lt;/h1&gt;
        &#125;
        //自定义方法：用赋值语句的形式＋箭头函数，因为类中箭头函数中没有this，但若使用this不报错，而是去外部找this（这里即实例对象），这样在定义事件方法时就不要再this.demo=this.demo.bind(this)
        demo=()=＞&#123;
            console.log(&#39;哈哈哈&#39;)
            this.setState(&#123;isHot:！isHot&#125;)
        &#125;

    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Weather/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>（1）通过 onXxx 属性指定事件处理函数（注意大小写）</p>
<p>— React 使用的是自定义（合成）事件（如 onClick），而不是使用原生 DOM 事件（如 onclick），这是为了更好的兼容性</p>
<p>— React 中的事件是通过事件委托（冒泡）方式处理的（委托给组件最外层的元素），这是为了更高效</p>
<p>（2）通过 event.target 得到发生事件的 DOM 元素对象，这可以解决过度使用 ref 的情况</p>
<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>页面中所有输入类的 DOM 节点（如 checkbox、radio 等）现用现取就是非受控组件</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this
            alert($&#123;username.value&#125;,$&#123;password.value&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input ref=&#123;c=&gt;this.username=c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input ref=&#123;c=&gt;this.password=c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>页面中所有输入类的 DOM 节点，随着输入的变化存入维护到状态 state 中，需要时从 state 中取，这种就属于受控组件</p>
<p>受控组件的优势在于可以省略掉 ref</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveUsername=(event)=&gt;&#123;
            this.setState(&#123;username:event.target.value&#125;)
        &#125;
        savePassword=(event)=&gt;&#123;
            this.setState(&#123;password:event.target.value&#125;)
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;this.saveUsername&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;this.savePassword&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意上述代码中是把 this.saveUsername 函数传给 onChange 作为事件回调</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数：若一个函数符合下面两个规范中的任何一个，那么该函数就是高阶函数</p>
<p>（1）若 A 函数接收的参数是个函数，那么 A 就可称之为高阶函数</p>
<p>（2）若 A 函数调用的返回值依然是个函数，那么 A 就可称之为高阶函数</p>
<p>常见的高阶函数有：Promise、setTimeout、setInterval、arr.map() 等</p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式，如</p>
<pre><code>function sum(a)&#123;
    return (b)=&gt;&#123;
        return (c)=&gt;&#123;
            return a+b+c
        &#125;
    &#125;
&#125;</code></pre>
<p>例子：</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveFormData=(dataType)=&gt;&#123;
            return (event)=&gt;&#123;
                this.setState(&#123;[dataType]:event.target.value&#125;)
            &#125;
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;this.saveFormData(&#39;username&#39;)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;this.saveFormData(&#39;password&#39;)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p>注意上述代码中 <code>onChange=&#123;this.saveFormData(&#39;username&#39;)</code> 的 saveFormData 后加了括号，所以表示把 saveFormData 的返回值传给 onChange，而不是把 saveFormData 函数传给 onChange</p>
<p>上述代码也可不用函数柯里化实现</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Login extends React.Component&#123;
        state=&#123;
            username:&#39;&#39;.
            password:&#39;&#39;
        &#125;
        saveFormData=(dataType,event)=&gt;&#123;
            this.setState(&#123;[dataType]:event.target.value&#125;)
        &#125;
        handleSubmit=(event)=＞&#123;
            event.preventDefault() //阻止表单提交这一默认事件
            const &#123;username,password&#125;=this.state
            alert($&#123;username&#125;,$&#123;password&#125;)
        &#125;
        render()&#123;
            return(
                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
                    用户名：&lt;input  onChange=&#123;event =&gt; this.saveFormData(&#39;username&#39;,event)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;
                    密码：&lt;input  onChange=&#123;event =&gt; this.saveFormData(&#39;password&#39;,event)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;
                    &lt;button&gt;登录&lt;/button&gt;
                &lt;/form&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Login/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>组件对象从创建到死亡会经历特定阶段</p>
<p>React 组件对象包含一系列勾子函数（生命周期回调函数），在特定的时刻调用</p>
<p>在定义组件时，在特定的生命周期回调函数中做特定工作</p>
<p>生命周期钩子中的 this 都是组件实例对象</p>
<p><strong>render：</strong>初始化渲染、状态更新之后调用</p>
<p><strong>componentDidMount：</strong>组件挂在页面之后调用</p>
<p><strong>componentWillReceiveProps(props)：</strong>子组件将要接收新的 props 的钩子，也可以不传参，但是父子组件第一次 render 时不会调用该函数，当父组件第二次 render 时给子组件传 props 才会调用该函数</p>
<p><strong>shouldComponentUpdate：</strong>控制组件更新的 “阀门” 表示组件是否应该被更新，调用 setState 后会调用 shouldComponentUpdate，返回布尔值，默认返回 true，若写了 shouldComponentUpdate 函数就要写返回值</p>
<p><strong>componentWillUpdate：</strong>组件将要更新的钩子</p>
<p><strong>componentDidUpdate：</strong>组件更新完毕的钩子</p>
<p><strong>componentWillUnmount：</strong>组件将要卸载时调用</p>
<h3 id="旧版的-React-生命周期"><a href="#旧版的-React-生命周期" class="headerlink" title="旧版的 React 生命周期"></a>旧版的 React 生命周期</h3><p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="旧版生命周期"></p>
<p><strong>生命周期的三个阶段（旧版）：</strong></p>
<p>（1）初始化阶段：由 ReactDOM.render() 触发—初次渲染</p>
<pre><code>1. constructor()
2. componentWillMount()
3. render()
4. componentDidMount() ==&gt; 常用，一般在这个钩子中做一些初始化的事，如开启定时器、发送网络请求、订阅消息</code></pre>
<p>（2）更新阶段：由组件内部 this.setState() 或父组件重新 render 触发</p>
<pre><code>1. shouldComponentUpdate()
2. componentWillUpdate()
3. render()  ==&gt; 必须使用的一个
4. componentDidUpdate()</code></pre>
<p>（3）卸载组件：由 ReactDOM.unmountComponentAtNode() 触发</p>
<pre><code>1. componentWillUnmount() ==&gt; 常用，一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</code></pre>
<p><strong>例子：</strong></p>
<p>h2 标签中的文字2s逐渐变淡直到完全透明后又变黑再逐渐变淡，而当点击按钮时删除 h2</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Life extends React.Component&#123;
        state=&#123;opacity:1&#125;
        death=()=&gt;&#123;
            //卸载组件
            ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))
        &#125;
        //组件挂载完毕
        componentDidMount()&#123;
            this.timer = setInterval(()=&gt;&#123;
                let &#123;opacity&#125; = this.state
                opacity -= 0.1
                if(opacity &lt;= 0) opacity = 1
                this.setState(&#123;opacity&#125;) //这里相当于 this.setState(&#123;opacity:opacity&#125;)，因为俩 opacity 同名所以可以简写
            &#125;,200)
        &#125;
        //组件将要卸载
        componentWillUnmount()&#123;
            clearInterval(this.timer)
        &#125;
        render()&#123;

            return(
                &lt;div&gt;
                    &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;xxx&lt;/h2&gt;
                    &lt;button onClick=&#123;this.death&#125;&gt;xx&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Life/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<p><strong>例子：</strong></p>
<p>每点击一次按钮就 + 1</p>
<pre><code>&lt;script type=&quot;text/babel&quot;&gt;
    //1.创建类式组件
    class Count extends React.Component&#123;
        constructor(props)&#123;
            console.log(&#39;constructor&#39;)
            super(props)
            this.state=&#123;count:0&#125;
        &#125;

        add=()=&gt;&#123;
            const &#123;count&#125; = this.state
            this.setState(&#123;count:count+1&#125;)
        &#125;
        force=()=&gt;&#123;
            this.forceUpdate() //强制更新
        &#125;
        //组件将要挂载
        componentWillMount()&#123;
            console.log(&#39;componentWillMount&#39;)
        &#125;
        //组件挂载完毕
        componentDidMount()&#123;
            console.log(&#39;componentDidMount&#39;)
        &#125;
        //组件将要卸载
        componentWillUnmount()&#123;

        &#125;
        render()&#123;
            console.log(&#39;render&#39;)
            return(
                &lt;div&gt;
                    &lt;h2&gt;当前求和为：&#123;count&#125;&lt;/h2&gt;
                    &lt;button onClick=&#123;this.add&#125;&gt;点击+1&lt;/button&gt;
                    &lt;button onClick=&#123;this.force&#125;&gt;强制更新&lt;/button&gt;
                &lt;/div&gt;
            )
        &#125;    
    &#125;
    //2.渲染组件到页面
    ReactDOM.render(&lt;Count/&gt;, document.getElementById(&#39;test&#39;))
&lt;/script&gt; </code></pre>
<h3 id="新版的-React-生命周期（v17-0-1之后）"><a href="#新版的-React-生命周期（v17-0-1之后）" class="headerlink" title="新版的 React 生命周期（v17.0.1之后）"></a>新版的 React 生命周期（v17.0.1之后）</h3><p>与旧版本不同的是 componentWillReceiveProps、componentWillMount、componentWillUpdate 重命名为 UNSAFE_componentWillReceiveProps、UNSAFE_componentWillMount、UNSAFE_componentWillUpdate，且 v18.x 版本开始必须加 UNSAFE_ 才行</p>
<p>注意：UNSAFE_ 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染后</p>
<p><strong>新旧版本对比：</strong>新版本废弃了三个钩子 componentWillReceiveProps、componentWillMount、componentWillUpdate，新引入了两个钩子 getDerivedStateFromProps 和 getSnapshotBeforeUpdate</p>
<p><strong>getDerivedStateFromProps(props,state)：</strong>返回一个对象来更新 state，或返回 null 则不更新任何内容，并且这个更新的 state 无法修改，值只能是 props 的值</p>
<pre><code>static getDerivedStateFromProps(props)&#123;
    return props
&#125;</code></pre>
<p>注意：getDerivedStateFromProps 适用于 state 的值在任何时候都取决于 props 值的情况</p>
<p>getDerivedStateFromProps 会导致代码冗余，并使组件难以维护</p>
<p><strong>getSnapshotBeforeUpdate：</strong>在最近一次渲染输出（提交到 DOM 节点）之前调用，它使得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置），此生命周期的任何返回值将作为参数传给 componentDidUpdate，返回 snapshot 或 null</p>
<pre><code>getSnapshotBeforeUpdate()&#123;
    return &#39;xx&#39; //或 return null
&#125;</code></pre>
<p>此用法不常见，可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等</p>
<p>如随着时间 list 的顶部一直增加一定高度的内容，但下拉至某位置后滚动条位置不动且不影响上面继续添加</p>
<pre><code>getSnapshotBeforeUpdate()&#123;
    return this.refs.list.scrollHeight
&#125;
componentDidUpdate(preProps,preState,height)&#123;
    this.refs.list.scrollTop += this.refs.list.scrollHeight - height
&#125;</code></pre>
<p><strong>componentDidUpdate(preProps,preState)：</strong></p>
<pre><code>componentDidUpdate(preProps,preState,snapshotValue)&#123;
    console.log(&#39;上一个props&#39;+preProps+&#39;上一个state&#39;+preState+&#39;getSnapshotBeforeUpdate return来的&#39;+snapshotValue)
&#125;</code></pre>
<p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%B0%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="新版生命周期"></p>
<p><strong>生命周期的三个阶段（新版）：</strong></p>
<p>（1）初始化阶段：由 ReactDOM.render() 触发—初次渲染</p>
<pre><code>1. constructor()
2. getDerivedStateFromProps()
3. render()
4. componentDidMount() ==&gt; 常用，一般在这个钩子中做一些初始化的事，如开启定时器、发送网络请求、订阅消息</code></pre>
<p>（2）更新阶段：由组件内部 this.setState() 或父组件重新 render 触发</p>
<pre><code>1. getDerivedStateFromProps
2. shouldComponentUpdate()
3. render()
4. getSnapshotBeforeUpdate()
5. componentDidUpdate()</code></pre>
<p>（3）卸载组件：由 ReactDOM.unmountComponentAtNode() 触发</p>
<pre><code>1. componentWillUnmount() ==&gt; 常用，一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</code></pre>
<h2 id="DOM-的-Diffing-算法"><a href="#DOM-的-Diffing-算法" class="headerlink" title="DOM 的 Diffing 算法"></a>DOM 的 Diffing 算法</h2><h3 id="验证-Diffing-算法"><a href="#验证-Diffing-算法" class="headerlink" title="验证 Diffing 算法"></a>验证 Diffing 算法</h3><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p><strong>问题1：</strong> react/vue 中 key 有什么作用？（key 的内部原理是什么？）</p>
<p>虚拟 DOM 中 key 的作用：</p>
<pre><code>1）简单的说：key 是虚拟 DOM 对象的标识，在更新显式时 key 起着极其重要的作用
2）详细的说：当状态中数据发生变化时，react 会根据【新数据】生成【新的虚拟 DOM】，随后 react 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 对比，比较规则如下：
    a.旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key
        若虚拟 DOM 中内容没变，直接使用之前的真实 DOM
        若虚拟 DOM 中的内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM
    b.旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，则根据数据创建新的真实 DOM，随后渲染到页面</code></pre>
<p><strong>问题2：</strong>为什么遍历列表时 key 最好不要用 index？</p>
<p>用 index 作为 key 可能会引发的问题：</p>
<pre><code>1）若对数据进行逆序添加、逆序删除等破坏顺序操作时会产生没有必要的真实 DOM 更新 =&gt; 界面效果没问题，但效率低
2）若结构中还包含输入类的 DOM，会产生错误 DOM 更新 =&gt; 界面会出问题
3）注意若不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的</code></pre>
<p><strong>问题3：</strong>开发中如何选择 key？</p>
<p>1）最好使用每条数据的唯一标识作为 key，如 id、手机号、身份证号、学号等唯一值</p>
<p>2）若确定只是简单的展示数据，用 index 也是可以的</p>
<p><strong>例子：</strong>点击按钮后在数组头部增加一条数据并显示</p>
<pre><code>add=()=&gt;&#123;
    const &#123;personArr&#125; = this.state
    const p = &#123;id:personArr.length+1,name:&#39;c&#39;,age:20&#125;
    this.setState(&#123;personArr:[p,...personArr]&#125;)
&#125;

render()&#123;
    return(
        &lt;ul&gt;
            &#123;
                this.state.personArr.map((personObj,index)=&gt;&#123;  //这里用 index 做 key
                    return &lt;li key=&#123;index&#125;&gt;&#123;personObj.name&#125;---&#123;personObj.age&#125;&lt;/li&gt;
                &#125;)
            &#125;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<p>当使用 index 作为 key 时</p>
<pre><code>初始数据：
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=0&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
更新后的数据：
    &#123;id:3,name:&#39;c&#39;,age:20&#125;
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
更新后的虚拟 DOM
    &lt;li key=0&gt;c---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</code></pre>
<p>这种情况下增加数据后，头两条数据的 input 框中内容和之前一样，这是已导致了混乱</p>
<p>当使用 id 作为 key 时</p>
<pre><code>初始数据：
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
初始的虚拟 DOM
    &lt;li key=1&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
更新后的数据：
    &#123;id:3,name:&#39;c&#39;,age:20&#125;
    &#123;id:1,name:&#39;a&#39;,age:18&#125;
    &#123;id:2,name:&#39;b&#39;,age:18&#125;
更新后的虚拟 DOM
    &lt;li key=30&gt;c---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=1&gt;b---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;
    &lt;li key=2&gt;a---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</code></pre>
<p>这种情况下增加数据后，第一条数据后的 input 框中为空白，后两条数据的 input 框中内容和之前一样</p>
<h1 id="四、React-应用"><a href="#四、React-应用" class="headerlink" title="四、React 应用"></a>四、React 应用</h1><h2 id="1、react-脚手架"><a href="#1、react-脚手架" class="headerlink" title="1、react 脚手架"></a>1、react 脚手架</h2><p>xxx 脚手架是用来帮助程序员快速创建一个基于 xxx 库的模板项目</p>
<p>脚手架中包含了所有需要的配置（语法检查、jsx 编译、devServer…）、下载好了所有相关依赖、可以直接运行一个简单的效果</p>
<p>react 提供了一个用于创建 react 项目的脚手架库：create-react-app</p>
<p>项目的整体技术架构为 react + webpack + es6 + eslint</p>
<p>使用脚手架开发的项目的特点：模块化、组件化、工程化（工程化就是写好代码后会自动进行语法检查、代码压缩、编译、兼容性处理等一系列操作）</p>
<h2 id="2、使用脚手架创建-react-项目并启动"><a href="#2、使用脚手架创建-react-项目并启动" class="headerlink" title="2、使用脚手架创建 react 项目并启动"></a>2、使用脚手架创建 react 项目并启动</h2><p>（1）全局安装 create-react-app 库</p>
<pre><code>npm install -g create-react-app</code></pre>
<p>（2）切换到想创建项目的目录，并创建项目 <code>create-react-app 项目名</code></p>
<p>（3）进入项目文件夹，并启动项目 <code>npm start</code></p>
<h2 id="3、react-脚手架项目结构"><a href="#3、react-脚手架项目结构" class="headerlink" title="3、react 脚手架项目结构"></a>3、react 脚手架项目结构</h2><p>public — 静态资源文件夹</p>
<pre><code>facion.icon --- 网站页签图标
index.html --- 主页面
logo192.png --- logo 图
logo512.png --- logo 图
manifest.json --- 应用加壳（将网络加壳成安卓或 ios 应用）的配置文件
robots.txt --- 爬虫协议文件</code></pre>
<p>src — 源码文件夹</p>
<pre><code>App.css --- App 组件的样式
App.js --- App 组件
App.test.js --- 用于给 App 做测试
index.css --- 样式
index.js --- 入口文件
logo.svg ---logo 图
reportWebVitals.js --- 页面性能分析文件（需要 web-vitals 库的支持）
setupTests.js --- 用于做应用的整体测试或组件单元测试（需要 jest-dom 库支持）</code></pre>
<h2 id="4、样式模块化"><a href="#4、样式模块化" class="headerlink" title="4、样式模块化"></a>4、样式模块化</h2><p>若组件内都直接使用 import ‘./组件.css’ 引入样式，不同组件间可能定义了 className 相同的标签而设置的样式不同就会产生冲突</p>
<p>要解决这种冲突的一种方式是使用 less</p>
<p>另一种方式是组件的 css 文件都命名为 xxx.module.css，在 组件.js 文件中引入样式时使用 <code>import xxx from &#39;./xxx.module.css&#39;</code>，使用样式时如 <code>&lt;h1 className=&#123;xxx.类名&#125;&gt;&lt;/h1&gt;</code></p>
<h2 id="5、vscode-中-react-插件"><a href="#5、vscode-中-react-插件" class="headerlink" title="5、vscode 中 react 插件"></a>5、vscode 中 react 插件</h2><p>ES7 React/Redux/GraphQL/React-Native snippets 插件便于生成代码模板，如 <code>rcc + 回车</code> 即可生成类式组件代码模板，<code>rfc + 回车</code> 即可生成函数式组件代码模板</p>
<h2 id="6、功能界面的组件化编码流程"><a href="#6、功能界面的组件化编码流程" class="headerlink" title="6、功能界面的组件化编码流程"></a>6、功能界面的组件化编码流程</h2><p>（1）拆分组件：拆分界面，抽取组件</p>
<p>（2）实现静态组件：使用组件实现静态页面效果</p>
<p>（3）实现动态组件：</p>
<p>— 1）动态显示初始化数据：数据类型、数据名称、保存在哪个组件</p>
<p>— 2）交互（从绑定事件监听开始）</p>
<h2 id="7、如何确定将数据放在哪个组件的-state-中？"><a href="#7、如何确定将数据放在哪个组件的-state-中？" class="headerlink" title="7、如何确定将数据放在哪个组件的 state 中？"></a>7、如何确定将数据放在哪个组件的 state 中？</h2><p>若某个组件使用，则放在其自身的 state 中</p>
<p>若某些组件使用，则放在他们共同的父组件 state 中（也称为状态提升）</p>
<p>状态在哪，操作状态的方法就在哪</p>
<h2 id="8、父子组件间数据传递"><a href="#8、父子组件间数据传递" class="headerlink" title="8、父子组件间数据传递"></a>8、父子组件间数据传递</h2><p>【父组件】给【子组件】传数据可在子组件传属性，在子组件中通过 props 获取数据</p>
<p>【子组件】给【父组件】传数据，在父组件定义函数并传给子组件，在子组件中调用该函数 this.props.函数()</p>
<h1 id="五、react-ajax"><a href="#五、react-ajax" class="headerlink" title="五、react ajax"></a>五、react ajax</h1><p>React 本身只关注于界面，并不包含发送 ajax 请求的代码</p>
<p>前端应用需要通过 ajax 请求与后台进行交互（json 数据）</p>
<p>react 应用中需要集成第三方 ajax 库（或自己封装）</p>
<h2 id="1、常用的-ajax-请求库"><a href="#1、常用的-ajax-请求库" class="headerlink" title="1、常用的 ajax 请求库"></a>1、常用的 ajax 请求库</h2><p>（1）jQuery：比较重，若需要另外引入不建议使用</p>
<p>（2）axios：轻量级，建议使用</p>
<p>—a）封装 XmlHttpRequest 对象的 ajax</p>
<p>—b）promise 风格</p>
<p>—c）可以用在浏览器端和 node 服务器端</p>
<h2 id="2、跨域问题"><a href="#2、跨域问题" class="headerlink" title="2、跨域问题"></a>2、跨域问题</h2><p>ajax 引擎会拦截不同源返回的数据，所以需要一个中间代理服务器，该服务器的和前端 ajax 引擎是同源的，前端给服务器发请求时是给代理服务器发送请求，代理服务器再转发至服务器，然后服务器将数据返回给代理服务器，最后再返回给前端</p>
<p><strong>解决方式一：</strong>在脚手架中配置代理解决跨域</p>
<p>在 package.json 文件中添加</p>
<pre><code>&quot;proxy&quot;:&quot;服务器端地址:服务器端口&quot;
但这种方式会把服务器端口写死，只能向这个地址这个端口发请求</code></pre>
<p>在代码中发送请求时地址写前端运行的端口</p>
<pre><code>axios.get(&#39;http://localhost:前端端口/获取后端数据的api&#39;)</code></pre>
<p>因为在前端找不到相应 api，所以代理服务器会转发至后端</p>
<p>优点：配置简单，前端请求资源时可以不加任何前缀</p>
<p>缺点：不能配置多个代理</p>
<p>工作方式：当请求了前端如 3000 端口不存在的资源时，该请求会转发给配置的服务器如 5000 端口（优先匹配前端资源）</p>
<p><strong>解决方式二：</strong>也是在脚手架中配置代理解决跨域</p>
<p>新加文件 src/setupProxy.js 文件，并添加如下内容，React 脚手架会自动找到这个文件进行代理服务器配置</p>
<pre><code>const proxy = require(&#39;http-proxy-middleware&#39;)
module.exports = function(app)&#123;
    app.use(
        proxy(&#39;/api1&#39;,&#123;  //遇见 /api1 前缀的请求，就会触发该代理配置
            target:&#39;http://localhost:5000&#39;, //请求转发给哪个服务器
            changeOrigin: true, //控制服务器收到的请求头中 Host 字段的值，设为 true 后服务器端输出请求头的 Host 值时就不是真正前端地址，而是服务器自身地址，这样服务器设置一些限制时不会有问题
            pathRewrite:&#123;&#39;^/api1&#39;:&#39;&#39;&#125; //重写请求路径，删掉前面的 /api1
        &#125;),
        /*changeOrigin 为 true 时，服务器收到的请求头中 host 为如 localhost:5000（服务器自身地址）
        changeOrigin 为 false 时，服务器收到的请求头中 host 为如 localhost:3000（前端地址）
        changeOrigin 默认为 false，一般将其设为 true
        */
        proxy(&#39;/api2&#39;,&#123;
            target:&#39;http://localhost:5001&#39;,
            changeOrigin: true,
            pathRewrite:&#123;&#39;^/api2&#39;:&#39;&#39;&#125;
        &#125;)
    )
&#125;</code></pre>
<p>在代码中发送请求时写的地址要加上 <code>/api1</code> 或 <code>/api2</code> 这样会去相应服务器中获取数据</p>
<p>优点：可以配置多个代理，可灵活的控制请求是否走代理</p>
<p>缺点：配置繁琐，前端请求资源时必须加前缀，若不写前缀就不走代理</p>
<h2 id="3、fetch-发送请求"><a href="#3、fetch-发送请求" class="headerlink" title="3、fetch 发送请求"></a>3、fetch 发送请求</h2><p>关于 fetch 可查看 <a href="https://github.github.io/fetch/">github</a> 和 <a href="https://segmentfault.com/a/1190000003810652">思否</a> 的相关文档</p>
<p>之前发送请求都是通过 XMLHttpRequest，即使是使用 jQuery、axios、zepto 等，这些其实是对 XMLHttpRequest 的封装</p>
<p>此外有另一种发送请求的方式 fetch（因为兼容性问题所以不常用）</p>
<p>fetch 是原生函数，不再使用 XMLHttpRequest 对象提交 ajax 请求，注意老版本浏览器可能不支持</p>
<p>fetch 体现了 “关注分离” 的原则（即不是一步到位，而是分步走）</p>
<pre><code>fetch(url, options).then(
    response =&gt; &#123;
        console.log(&#39;联系服务器成功了&#39;,response.json()) //response.json() 返回 Promise 实例对象，若联系服务器成功且获取数据成功则里面存着获取到数据，若联系服务器成功但获取数据失败则里面存着失败的原因
        return response.json()  //返回 Promise 实例对象,因此才能有下面的 .then 链式调用
    &#125;,
    error =&gt; &#123;
        console.log(&#39;联系服务器失败了&#39;)
        return new Promise(()=&gt;&#123;&#125;) //返回初始化状态的 Promise 来阻断往下走执行下面的 then，若没有这个 return 则会返回 undefined，且当前这个 then 对应的 Promise 返回是成功状态，值为 undefined
    &#125;
).then(
    response =&gt; &#123;console.log(&#39;获取数据成功了&#39;,response);&#125;,
    error =&gt; &#123;console.log(&#39;获取数据失败了&#39;,error)&#125;
)</code></pre>
<p>对上面的代码进行优化</p>
<pre><code>fetch(url, options).then(
    response =&gt; &#123;
        console.log(&#39;联系服务器成功了&#39;,response.json())
        return response.json()
    &#125;,
).then(
    response =&gt; &#123;console.log(&#39;获取数据成功了&#39;,response);&#125;,
).catch(
    error =&gt; &#123;console.log(&#39;请求出错&#39;,error)&#125;
)</code></pre>
<p>对上面代码继续优化</p>
<pre><code>事件响应函数 = async() =&gt; &#123;
    try&#123;
        const response = await fetch(url) //此时等到的就是上面未优化代码中 Promise 成功时返回的 response.json()
        const data = await response.json()
        console.log(data)
    &#125;catch(error)&#123;
        console.log(&#39;请求出错&#39;,error)
    &#125;
&#125;</code></pre>
<h1 id="六、任意组件间的通信：消息订阅——发布机制"><a href="#六、任意组件间的通信：消息订阅——发布机制" class="headerlink" title="六、任意组件间的通信：消息订阅——发布机制"></a>六、任意组件间的通信：消息订阅——发布机制</h1><p>需要借助工具库 PubSubJS</p>
<p>下载 <code>npm install pubsub-js --save</code></p>
<p>使用</p>
<pre><code>import PubSub from &#39;pubsub-js&#39; //引入
let token = PubSub.subscribe(&#39;订阅的消息&#39;,回调函数(消息名,收到的数据)=&gt;&#123;...&#125;)  //在需要获取消息的组件中订阅
PubSub.unsubscribe(token) //取消订阅
PubSub.publish(&#39;消息名&#39;,携带的数据)  //发布消息</code></pre>
<p>如在订阅消息的组件中</p>
<pre><code>componentDidMount()&#123;
    this.token = PubSub.subscribe(&#39;xx&#39;,(_,data)&#123;
        conosle.log(data)
    &#125;)
&#125;
//取消订阅
componentWillUnmount()&#123;
    PubSub.unsubscribe(this.token)
&#125;</code></pre>
<p>在发布消息的组件中</p>
<pre><code>PubSub.publish(&#39;xx&#39;,&#123;name:&#39;tom&#39;,age:18&#125;)</code></pre>
<h1 id="七、React-路由"><a href="#七、React-路由" class="headerlink" title="七、React 路由"></a>七、React 路由</h1><h2 id="1、SPA-的理解"><a href="#1、SPA-的理解" class="headerlink" title="1、SPA 的理解"></a>1、SPA 的理解</h2><p>单页 Web 应用（single page web application, SPA）中整个应用只有一个完整的页面，react、vue 等写的都是单页面多组件应用</p>
<p>点击页面中的链接不会刷新页面，只会做页面的局部更新</p>
<p>数据都需要通过 ajax 请求获取，并在前端异步展现</p>
<h2 id="2、路由的理解"><a href="#2、路由的理解" class="headerlink" title="2、路由的理解"></a>2、路由的理解</h2><p>一个路由就是一个映射关系（key:value），key 为路径，value 可能是 function 或 component</p>
<h3 id="路由的分类"><a href="#路由的分类" class="headerlink" title="路由的分类"></a>路由的分类</h3><p>（1）后端路由：</p>
<p>后端路由的 value 是 function，用来处理客户端提交的请求</p>
<p>注册路由：<code>router.get(path,function(req,res))</code></p>
<p>工作过程：当 node 接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应数据</p>
<p>（2）前端路由：</p>
<p>浏览器路由 value 是 component，用于展示页面的内容</p>
<p>原生 html 中，靠 <code>&lt;a&gt;</code> 跳转不同的页面，在 React 中靠路由链接实现切换组件 </p>
<p>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></p>
<p>工作过程：点击某组件引起路由跳转，路径改变，当浏览器的 path 变为 /test 时，被前端路由器监测到进行匹配组件，当前路由组件就会变为 Test 组件</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>在 BOM 对象（window 也在 BOM 上）上有个属性 history 专门管理浏览器的路径、历史记录等，这是前端路由的基石</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/history/4.7.2/history.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    //方法一
    let history = History.createBrowserHistory() //这种方式是直接使用 H5 推出的 BOM 上 history 身上的 API，这行代码里定义的 history 最终操作的就是 BOM 上的 history
    //方法二
    //let history = History.createHashHistory() //这种方式是使用 hash 值（锚点），路由为 http://xx.xxx.xx.x/xx#/xxx，其中 path 放在 # 后面，# 后的资源都不会发给服务器，且锚点跳转不会引起页面刷新，但会留下历史记录，且这种方式对浏览器兼容性极佳
    function push(path)&#123;
        history.push(path)
    &#125;
    function replace(path)&#123;
        history.replace(path)
    &#125;
    function back()&#123;
        history.goBack()
    &#125;
    function forward()&#123;
        history.goForward()
    &#125;
    history.listen((location)=&gt;&#123;
        conosle.log(&#39;请求路由变化了&#39;,location)
    &#125;)
&lt;/script&gt;</code></pre>
<h2 id="3、react-中路由的基本使用"><a href="#3、react-中路由的基本使用" class="headerlink" title="3、react 中路由的基本使用"></a>3、react 中路由的基本使用</h2><h3 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h3><p>react-router 库有三种实现，分别给三种平台使用，一种是 react-router-dom 给网页开发应用人员，一种是 native 给 React Native 用 React 做原生应用开发，还有一种是 any 在哪都能用，虽然通用性更强但学习它的相关 API 没有前两种方便</p>
<p>react-router-dom 是 react 的一个插件库，专门用来实现一个 SPA 应用</p>
<p>基于 react 的项目基本都会用到此库</p>
<h3 id="react-router-相关-API"><a href="#react-router-相关-API" class="headerlink" title="react-router 相关 API"></a>react-router 相关 API</h3><p>内置组件</p>
<pre><code>&lt;BrowserRouter&gt;
&lt;HashRouter&gt;
&lt;Route&gt;
&lt;Redirect&gt;
&lt;Link&gt;
&lt;NavLink&gt;
&lt;Switch&gt;</code></pre>
<p>其它</p>
<pre><code>history 对象
match 对象
withRouter 函数</code></pre>
<h3 id="react-router-dom-基本使用"><a href="#react-router-dom-基本使用" class="headerlink" title="react-router-dom 基本使用"></a>react-router-dom 基本使用</h3><p>需要下载 <code>npm install react-router-dom</code> 这样下载的是最新版本（目前是版本6），也可指定版本下载 <code>npm install react-router-dom@5</code></p>
<p>在项目的入口文件 index.js 中引入路由器（BrowserRouter 或 HashRouter），该文件内容如下</p>
<pre><code>//引入 react 核心库
import React from &#39;react&#39;    
//引入 ReactDOM
import ReactDOM from &#39;react-dom&#39;
//引入路由器    
import &#123;BrowserRouter&#125; from &#39;react-router-dom&#39;
//引入 App 组件
import App from &#39;./App&#39;

ReactDOM.render(
    &lt;BrowserRouter&gt;
        &lt;App/&gt;
    &lt;/BrowserRouter&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<p>在组件中引入 Link 和 Route</p>
<pre><code>import &#123;Link,Route&#125; from &#39;react-router-dom&#39;</code></pre>
<p>在组件中使用，导航区的 a 标签改为 Link 标签，展示区写 Route 标签进行路径的匹配</p>
<pre><code>&#123;/*编写路由链接*/&#125;
&lt;Link to=&quot;/xxx&quot;&gt;xxx&lt;/Link&gt;
&#123;/*注册路由*/&#125;
&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p>（1）写法不同</p>
<p>一般组件是直接通过 <code>&lt;xxx/&gt;</code> 使用</p>
<p>而路由组件是通过 <code>&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code> 进行路由匹配</p>
<p>（2）存放位置不同</p>
<p>一般组件放在 components 文件夹下</p>
<p>路由组件放在 pages 文件夹下</p>
<p>（3）接收到的 props 不同</p>
<p>一般组件写组件标签时传递了什么就能收到什么，若没传属性，this.props 中就为空</p>
<p>而路由组件会收到三个固定的属性，是路由器发送的三个 props，分别是 history、location、match</p>
<pre><code>history:
    action:
    block:
    createHref:
    go:
    goBack:
    goForward:
    length:
    listen:
    location:
    push:
    replace:

location:
    hash:&quot;&quot;
    key:&quot;随机生成&quot;
    pathname:&quot;/xx&quot;
    search:
    state:

match:
    isExact:
    params:&#123;&#125;
    path:&quot;/xx&quot;
    url:&quot;/xx&quot;</code></pre>
<p>其中 history.location 和 直接获取 location 相同</p>
<h3 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h3><p>若要给 Link 标签对应的导航栏中当前所在路由对应的按钮添加高亮显示，可把 Link 标签替换为 NavLink，在 NavLink 中可添加属性 activeClassName 表示给要高亮显示的标签追加有个样式类（不写该属性的话默认是给 className 中添加 active），然后自己定义这个类对应的高亮样式即可</p>
<h4 id="使用-NavLink"><a href="#使用-NavLink" class="headerlink" title="使用 NavLink"></a>使用 NavLink</h4><p>需要现引入</p>
<pre><code>import &#123;NavLink,Route&#125; from &#39;react-router-dom&#39;</code></pre>
<p>再使用</p>
<pre><code>&#123;/*编写路由链接*/&#125;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&#123;/*注册路由*/&#125;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;</code></pre>
<h4 id="封装-NavLink"><a href="#封装-NavLink" class="headerlink" title="封装 NavLink"></a>封装 NavLink</h4><p>可定义一个组件如 MyNavLink</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;
import &#123;NavLink&#125; from &#39;react-router-dom&#39;
export default class MyNavLink extends Component&#123;
    render()&#123;
        return(
            &lt;NavLink activeClassName=&quot;xxx&quot; &#123;...this.props&#125;/&gt;
        ) //这里显式写标签体是因为标签体是特殊的标签属性，它其实是标签的 children 属性，外面传来的所有属性都在 this.props 中
    &#125;    
&#125;</code></pre>
<p>在其他组件中使用自己定义的 MyNavLink</p>
<pre><code>import MyNavLink from &#39;./components/MyNavLink/MyNavLink&#39;

&lt;MyNavLink to=&quot;/xxx&quot;&gt;标签体&lt;/MyNavLink&gt;
&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<h3 id="Switch-的使用"><a href="#Switch-的使用" class="headerlink" title="Switch 的使用"></a>Switch 的使用</h3><p>使用 <code>&lt;Route path=&quot;/xxx&quot; component=&#123;组件名&#125;/&gt;</code> 进行路由匹配，若有多个组件匹配同一个路由地址，默认情况下路由地址匹配到一个组件后会继续往下匹配，会都展示，但是若这两行代码中间有很多个其他路由匹配代码，那么效率就很低</p>
<p>因此可利用 Switch 提高路由匹配效率（单一匹配）</p>
<p>在 Route 外包裹 <code>&lt;Switch&gt;</code>，那么匹配到当前路由的组件后就不会继续往下匹配了</p>
<pre><code>&lt;Switch&gt;
    &lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
    &lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;/Switch&gt;</code></pre>
<h3 id="解决样式丢失问题"><a href="#解决样式丢失问题" class="headerlink" title="解决样式丢失问题"></a>解决样式丢失问题</h3><p>对于有多级路由的地址（如 /xx1/xx2），若点击浏览器的刷新按钮后会出现 index.html 中引入的 css 文件（如 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/bootstrap.css&quot;&gt;</code>）失效的问题</p>
<p>假设 bootstrap.css 文件存放在 public 文件夹（该文件夹其实就是对应 <a href="http://localhost:3000/">http://localhost:3000</a> 这个地址）下，正常情况下要获取样式访问的是 <a href="http://localhost:3000/css/bootstrap.css%EF%BC%8C%E8%80%8C%E5%88%B7%E6%96%B0%E5%90%8E%E6%A0%B7%E5%BC%8F%E5%A4%B1%E6%95%88%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%AD%A4%E6%97%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF">http://localhost:3000/css/bootstrap.css，而刷新后样式失效是因为此时访问的是</a> <a href="http://localhost:3000/xx1/css/bootstrap.css">http://localhost:3000/xx1/css/bootstrap.css</a></p>
<p><strong>解决方式一：</strong>修改 public/index.html 中引入样式的地址，去掉前面的 <code>.</code>，使用根目录（在浏览器中根目录就是 public 文件夹，且对应 <a href="http://localhost:3000）">http://localhost:3000）</a></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot;&gt;</code></pre>
<p><strong>解决方式二：</strong>在 public/index.html 中引入样式的地址使用绝对路径，<code>%PUBLIC_URL%</code> 表示的就是 public 文件夹所在路径</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot;&gt;</code></pre>
<p><strong>解决方式三</strong>：修改路由模式，使用 HashRouter（这种解决方式比较少见），在入口文件 index.js 中将 BrowserRouter 换成 HashRouter，这样会在根路径后添加 #，如 <a href="http://localhost:3000/#/xx1/xx2%EF%BC%8C#">http://localhost:3000/#/xx1/xx2，#</a> 后表示都是前端资源</p>
<pre><code>//引入 react 核心库
import React from &#39;react&#39;    
//引入 ReactDOM
import ReactDOM from &#39;react-dom&#39;
//引入路由器    
import &#123;HashRouter&#125; from &#39;react-router-dom&#39;
//引入 App 组件
import App from &#39;./App&#39;

ReactDOM.render(
    &lt;HashRouter&gt;
        &lt;App/&gt;
    &lt;/HashRouter&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<h3 id="路由的模糊匹配与严格匹配"><a href="#路由的模糊匹配与严格匹配" class="headerlink" title="路由的模糊匹配与严格匹配"></a>路由的模糊匹配与严格匹配</h3><p>默认是模糊匹配，即输入的路径必须包含要匹配的路径，且顺序要一致</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1/a/b&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 不能显示

&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1/a/b&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 可正常显示

&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/a/xxx1/b&quot;&gt;组件1&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
此时访问 /xx1 也不能显示</code></pre>
<p>在注册路由时添加属性 <code>exact=&#123;true&#125;</code> 或 <code>exact</code> 就可以开启精准匹配</p>
<pre><code>&lt;Route exact path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
或
&lt;Route exact=&#123;true&#125; path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;</code></pre>
<p>注意：若模糊匹配时页面可正常显示就不要开启严格匹配，有时开启严格匹配会导致无法继续匹配二级路由</p>
<h3 id="Redirect-的使用"><a href="#Redirect-的使用" class="headerlink" title="Redirect 的使用"></a>Redirect 的使用</h3><p>Redirect 是 react-router-dom 的内置组件</p>
<p>一般把 Redirect 写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 Redirect 指定的路由</p>
<p>引入</p>
<pre><code>import &#123;NavLink,Route,Redirect&#125; from &#39;react-router-dom&#39;</code></pre>
<p>使用</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1&quot;/&gt;</code></pre>
<p>当路由谁都匹配不上时就去 Redirect 设置的地址</p>
<h2 id="4、嵌套路由（二级路由）的使用"><a href="#4、嵌套路由（二级路由）的使用" class="headerlink" title="4、嵌套路由（二级路由）的使用"></a>4、嵌套路由（二级路由）的使用</h2><p>注册子路由时要写上父路由的 path 值</p>
<p>路由的匹配是按照注册路由的顺序进行的，每次路由匹配都是从最开始注册的路由开始过一遍</p>
<p>如一级路由下组件先注册</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx1&quot;&gt;组件1&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx2&quot;&gt;组件2&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1&quot; component=&#123;组件1名&#125;/&gt;
&lt;Route path=&quot;/xxx2&quot; component=&#123;组件2名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1&quot;/&gt;</code></pre>
<p>二级路由下组件后注册</p>
<pre><code>&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx11&quot;&gt;组件11&lt;/NavLink&gt;
&lt;NavLink activeClassName=&quot;xxx&quot; to=&quot;/xxx12&quot;&gt;组件12&lt;/NavLink&gt;
&lt;Route path=&quot;/xxx1/xx11&quot; component=&#123;组件11名&#125;/&gt;
&lt;Route path=&quot;/xxx1/xx12&quot; component=&#123;组件12名&#125;/&gt;
&lt;Redirect to=&quot;/xxx1/xx11&quot;/&gt;</code></pre>
<p>当点击【组件1】时路由会自动跳转到 /xxx1/xx11，因为 /xxx1 匹配后，相同一级路由下的【组件11】和【组件12】就会挂载，此时这两个组件都未点击，所以 redirect 到 /xxx1/xx11</p>
<p>当访问 /xxx1/xx11 时，先匹配先注册的 /xxx1，再匹配到 /xxx1/xx11，所以【组件1】和【组件11】的内容都会渲染</p>
<h2 id="5、向路由组件传递参数数据"><a href="#5、向路由组件传递参数数据" class="headerlink" title="5、向路由组件传递参数数据"></a>5、向路由组件传递参数数据</h2><h3 id="方式一：向路由组件传递-params-参数"><a href="#方式一：向路由组件传递-params-参数" class="headerlink" title="方式一：向路由组件传递 params 参数"></a>方式一：向路由组件传递 params 参数</h3><pre><code>&#123;/*向路由组件传递 params 参数*/&#125;
&lt;Link to=&#123;`/xxx1/xx11/x111/$&#123;变量1&#125;/$&#123;变量2&#125;`&#125;&gt;xxx&lt;/Link&gt;
&#123;/*声明接收 params 参数*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x111/:id/:title&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.match.params 获取这些传来的变量</p>
<pre><code>const &#123;id,title&#125; = this.props.match.params</code></pre>
<h3 id="方式二：向路由组件传递-search-参数"><a href="#方式二：向路由组件传递-search-参数" class="headerlink" title="方式二：向路由组件传递 search 参数"></a>方式二：向路由组件传递 search 参数</h3><pre><code>&#123;/*向路由组件传递 search 参数*/&#125;
&lt;Link to=&#123;`/xxx1/xx11/x111/?id=$&#123;变量1&#125;&amp;title=$&#123;变量2&#125;`&#125;&gt;xxx&lt;/Link&gt;
&#123;/*search 参数无需声明接收，正常注册路由即可*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x11&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.location.search 获取这些传来的search 参数，但收到的是 <code>&quot;?id=xxx&amp;title=xxx&quot;</code> （key=value&amp;key=value 这种形式称为 urlencoded 编码）的字符串</p>
<pre><code>const &#123;search&#125; = this.props.location</code></pre>
<p>可借助 querystring 库解析，对 urlencoded 编码和对象进行互相转换</p>
<pre><code>import qs from &#39;querystring&#39;
const &#123;search&#125; = this.props.location
cosnt &#123;id,title&#125; = qs.parse(search.slice(1)) //urlencoded =&gt; 对象形式
qs.stringfy(对象) //对象形式 =&gt; urlencoded</code></pre>
<h3 id="方式三：向路由组件传递-state-参数"><a href="#方式三：向路由组件传递-state-参数" class="headerlink" title="方式三：向路由组件传递 state 参数"></a>方式三：向路由组件传递 state 参数</h3><p>注意这里的 state 是路由组件上独有的 state</p>
<pre><code>&#123;/*向路由组件传递 state 参数*/&#125;
&lt;Link to=&#123;&#123;pathname:'/xxx1/xx11/x111',state:&#123;id:变量1,title:变量2&#125;&#125;&#125;&gt;xxx&lt;/Link&gt;
&#123;/*state 参数无需声明接收，正常注册路由即可*/&#125;
&lt;Route path=&quot;/xxx1/xx11/x11&quot; component=&#123;组件名&#125;/&gt;</code></pre>
<p>这些变量在组件中通过 this.props.location.state 接收 state 参数</p>
<pre><code>const &#123;id,title&#125; = this.props.location.state || &#123;&#125; // || &#123;&#125; 是为了若第一次直接访问 /xxx1/xx11/x111 时没有传参时不报错</code></pre>
<p>这种方式在地址栏中没有体现，地址栏中都是 /xxx1/xx11/x111，但刷新也可以保留住参数，因为都在 history 中维护</p>
<h2 id="6、路由跳转的两种模式-push-和-replace"><a href="#6、路由跳转的两种模式-push-和-replace" class="headerlink" title="6、路由跳转的两种模式 push 和 replace"></a>6、路由跳转的两种模式 push 和 replace</h2><p>默认是使用 push 模式</p>
<p>可给 Link 标签添加 <code>replace=&#123;true&#125;</code> <code>replace</code> 开启 replace 模式，使用 replace 不会留下痕迹</p>
<pre><code>&lt;Link replace=&#123;true&#125; to=&#123;`/xxx1/xx11/x111`&#125;&gt;xxx&lt;/Link&gt;
或
&lt;Link replace to=&#123;`/xxx1/xx11/x111`&#125;&gt;xxx&lt;/Link&gt;</code></pre>
<h2 id="7、编程式路由导航"><a href="#7、编程式路由导航" class="headerlink" title="7、编程式路由导航"></a>7、编程式路由导航</h2><p>在按钮上绑定 onClick，并定义响应函数如下</p>
<pre><code>replaceShow = (id,title)&#123;
    //replace 跳转 + 携带 params 参数
    //this.props.history.replace(`/xxx1/xx11/x111/$&#123;id&#125;/$&#123;title&#125;`)
    //replace 跳转 + 携带 search 参数
    //this.props.history.replace(`/xxx1/xx11/x111/?ID=$&#123;id&#125;&amp;title=$&#123;title&#125;`)
    //replace 跳转 + 携带 state 参数
    //this.props.history.replace(`/xxx1/xx11/x111`,&#123;id,title&#125;)
&#125;
pushShow = (id,title)&#123;
    //push 跳转 + 携带 params 参数
    //this.props.history.push(`/xxx1/xx11/x111/$&#123;id&#125;/$&#123;title&#125;`)
    //push 跳转 + 携带 search 参数
    //this.props.history.push(`/xxx1/xx11/x111/?ID=$&#123;id&#125;&amp;title=$&#123;title&#125;`)
    //push 跳转 + 携带 state 参数
    //this.props.history.push(`/xxx1/xx11/x111`,&#123;id,title&#125;)
&#125;
back = () =&gt; &#123;
    this.props.history.goBack()
&#125;
forward = () =&gt; &#123;
    this.props.history.goForward()
&#125;
go = () =&gt; &#123;
    this.props.history.go(整数) //正整数表示前进 n 步，负整数表示后退 n 步
&#125;</code></pre>
<p>注意使用 push 或 replace 中携带不同参数则对应的传参方式和接收参数的方式也要改</p>
<h2 id="8、withRouter-的使用"><a href="#8、withRouter-的使用" class="headerlink" title="8、withRouter 的使用"></a>8、withRouter 的使用</h2><p>withRouter 可以加工一般组件，让一般组件上也有路由组件中特有的 API（history、location、match）</p>
<p>withRouter 的返回值是一个新组件</p>
<p>在一般组件中</p>
<pre><code>import React, &#123;Component&#125; from &#39;react&#39;
import &#123;withRouter&#125; form &#39;react-router-dom&#39;
class 组件名 extends Component &#123;...&#125;
export default withRouter(组件名)</code></pre>
<h2 id="9、BrowserRouter-与-HashRouter-的区别"><a href="#9、BrowserRouter-与-HashRouter-的区别" class="headerlink" title="9、BrowserRouter 与 HashRouter 的区别"></a>9、BrowserRouter 与 HashRouter 的区别</h2><p>（1）底层原理不一样</p>
<p>BrowserRouter 使用的是 H5 的 history（this.props.histyor 是 react 对 H5 的 history 的二次封装） API，不兼容 IE9 及以下版本</p>
<p>HashRouter 使用的是 URL 的哈希值</p>
<p>（2）path 表现形式不一样</p>
<p>BrowserRouter 的路径中没有 #，例如 localhost:3000/xxx/xx</p>
<p>HashRouter 的路径包含 #，例如 localhost:3000/#/xxx/xx</p>
<p>（3）刷新后对路由 state 参数的影响</p>
<p>a. BrowserRouter 没有任何影响，因为 state 保存在 history 对象中</p>
<p>b. HashRouter 刷新后会导致路由 state 参数丢失</p>
<p>（4）HashRouter 可用于解决一些路径错误相关的问题（如样式丢失问题）</p>
<h1 id="八、React-UI-组件库"><a href="#八、React-UI-组件库" class="headerlink" title="八、React UI 组件库"></a>八、React UI 组件库</h1><p>（1）国外的 material-ui，可访问<a href="http://www.material-ui.com/#/">官网</a>或<a href="https://github.com/callemall/material-ui">GitHub</a></p>
<p>（3）国内蚂蚁金服 ant-design，可访问<a href="https://ant.design/index-cn">官网</a>或<a href="https://github.com/ant-design/ant-design/">GitHub</a></p>
<p>（3）饿了么团队出的 Element UI for react，Element UI 原先是基于 vue 的</p>
<p>（4）有道团队推出的 vantUI，主要针对移动端（基于 vue）</p>
<h2 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h2><h3 id="antd-的基本使用"><a href="#antd-的基本使用" class="headerlink" title="antd 的基本使用"></a>antd 的基本使用</h3><p>下载 ant-design</p>
<pre><code>npm install antd --save-dev</code></pre>
<p>如要使用 antd 中封装好的按钮：</p>
<p>要先引入该组件</p>
<pre><code>import &#123;Button&#125; from &#39;antd&#39; //引入 Button 组件</code></pre>
<p>粘贴官方文档中的使用代码，若要修改属性可查看文档中的 API</p>
<pre><code>&lt;Button type=&quot;primary&quot;&gt;Primary Button&lt;/Button&gt;</code></pre>
<p>引入样式</p>
<pre><code>import &#39;antd/dist/antd.css&#39;</code></pre>
<p>优化：按需引入样式</p>
<h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p>可参考<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE">官方文档</a></p>
<p>先下载 react-app-rewired（靠这个库启动）和 customize-cra（靠这个库执行规则的修改）</p>
<pre><code>npm install react-app-rewired customize-cra -D</code></pre>
<p>修改 package.json 文件中的 “scripts”</p>
<pre><code>&quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;react-app-rewired start&quot;,
    &quot;build&quot;: &quot;react-app-rewired build&quot;,
    &quot;test&quot;: &quot;react-app-rewired test&quot;,
&#125;</code></pre>
<p>然后在项目根目录创建一个 config-overrides.js 文件用于修改默认配置</p>
<pre><code>module.exports = function override(config, env) &#123;
  //修改或做一些 webpack 配置...
  return config;
&#125;;</code></pre>
<h4 id="按需引入样式"><a href="#按需引入样式" class="headerlink" title="按需引入样式"></a>按需引入样式</h4><p>babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件</p>
<p>下载</p>
<pre><code>npm install babel-plugin-import -D</code></pre>
<p>将 config-overrides.js 文件改为</p>
<pre><code>const &#123; override, fixBabelImports &#125; = require(&#39;customize-cra&#39;);

module.exports = override(
    fixBabelImports(&#39;import&#39;, &#123;
        libraryName: &#39;antd&#39;,
        libraryDirectory: &#39;es&#39;,
        style: &#39;css&#39;,
    &#125;),
);</code></pre>
<p>此时不要在组件文件中 <code>import &#39;antd/dist/antd.css&#39;</code> 引入样式</p>
<h4 id="antd-自定义主题"><a href="#antd-自定义主题" class="headerlink" title="antd 自定义主题"></a>antd 自定义主题</h4><p>antd 中的样式最初是使用 less 写的然后编译成 css，自定义主题需要用到 less 变量覆盖功能</p>
<p>首先需要下载 less 和 less-loader</p>
<pre><code>npm install less less-loader -D</code></pre>
<p>将 config-overrides.js 文件改为</p>
<pre><code>const &#123; override, fixBabelImports, addLessLoader &#125; = require(&#39;customize-cra&#39;);

module.exports = override(
    fixBabelImports(&#39;import&#39;, &#123;
        libraryName: &#39;antd&#39;,
        libraryDirectory: &#39;es&#39;,
        style: true,
    &#125;),
    addLessLoader(&#123;
        lessOptions:&#123;
            javascriptEnabled: true,
            modifyVars: &#123; &#39;@primary-color&#39;: &#39;#1DA57A&#39; &#125;,
        &#125;
    &#125;),
);</code></pre>
<p>在 addLessLoader 的 lessOptions 中的 modifyVars 里设置主题颜色</p>
<h1 id="九、redux"><a href="#九、redux" class="headerlink" title="九、redux"></a>九、redux</h1><p>redux 可参考相关<a href="https://redux.js.org/">英文文档</a>、<a href="http://www.redux.org.cn/">中文文档</a>、<a href="https://github.com/reactjs/redux">GitHub</a></p>
<h2 id="redux-介绍"><a href="#redux-介绍" class="headerlink" title="redux 介绍"></a>redux 介绍</h2><p>redux 是一个专门用于做状态管理的 JS 库（不是 react 插件库）</p>
<p>它可以用在 react、angular、vue 等项目中，但基本与 react 配合使用</p>
<p><strong>作用：</strong>集中式管理 react 应用中多个组件共享的状态</p>
<h2 id="什么情况下需要使用-redux"><a href="#什么情况下需要使用-redux" class="headerlink" title="什么情况下需要使用 redux"></a>什么情况下需要使用 redux</h2><p>（1）某个组件的状态需要让其他组件可以随时拿到（共享）</p>
<p>（2）一个组件需要改变另一个组件的状态（通信）</p>
<p>（3）总体原则：能不用就不用，若不用比较吃力才考虑使用</p>
<h2 id="redux-工作流程图"><a href="#redux-工作流程图" class="headerlink" title="redux 工作流程图"></a>redux 工作流程图</h2><p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="redux工作流程"></p>
<p>Action Creators 负责把动作包装成一个对象</p>
<p>Reducers 负责初始化状态和加工状态</p>
<h2 id="redux-三个核心概念"><a href="#redux-三个核心概念" class="headerlink" title="redux 三个核心概念"></a>redux 三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action 是动作的对象，包含两个属性</p>
<pre><code>type：标识属性，值为字符串，唯一，必要属性
data：数据属性，值类型任意，可选属性</code></pre>
<p>如 <code>&#123;type:&#39;ADD_STUDENT&#39;,data:&#123;name:&#39;xx&#39;,age:18&#125;&#125;</code></p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>reducer 用于初始化状态、加工状态</p>
<p>加工时，根据旧的 state 和 action，产生新的 state 的纯函数</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store 是将 state、action、reducer 联系在一起的对象</p>
<p>如何得到 store 对象</p>
<pre><code>（1）import &#123;createStore&#125; from &#39;redux&#39;
（2）import reducer from &#39;./reducers&#39;
（3）const store = createStore(reducer)</code></pre>
<p>store 对象的功能</p>
<pre><code>（1）getState()：得到 state
（2）dispatch(action)：分发 action，触发 reducer 调用，产生新的 state
（3）subscribe(listener)：注册监听，当产生了新的 state 时，自动调用</code></pre>
<h2 id="redux-的简单使用"><a href="#redux-的简单使用" class="headerlink" title="redux 的简单使用"></a>redux 的简单使用</h2><p>下载 <code>npm install redux -D</code></p>
<p>例子：下拉框中选择数字，按钮有加、减、奇数时加、异步加</p>
<p>（1）创建 src/redux 文件夹</p>
<p>（2）创建 reducers/reducer.js（可以不为此名） 文件，用于创建一个为某组件服务的 reducer</p>
<pre><code>const initState = 0 //初始化状态
export default function countReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action //从 action 对象中获取 type、data
    switch(type)&#123;
        case &#39;increment&#39;:
            return preState + data
        case &#39;decrement&#39;:
            return preState - data
        default:
            return preState
    &#125;
&#125;</code></pre>
<p>reducer 的本质是一个函数，reducer 函数会接收到两个参数：之前的状态（preState）和动作对象（action）</p>
<p>reducer 第一次被调用是 store 自动触发的，传递的 preState 为 undefined，action 为 {type:@@REDUX/INIT.x.x.x.x}</p>
<p>（3）创建 store.js 文件，该文件专门用于暴露一个 store 对象，整个应用只有一个 store 对象</p>
<pre><code>import &#123;createStore&#125; from &#39;redux&#39; //引入 createStore 专门用于创建 redux 中最核心的 store 对象
import countReducer from &#39;./reducer.js&#39; //引入为 Count 组件服务的 reducer
export default createStore(countReducer) //暴露 store</code></pre>
<p>（4）在要使用 store 的组件中</p>
<p>引入 store</p>
<pre><code>import store form &#39;../../redux/store.js&#39;</code></pre>
<p>在要使用 store 调用 reducer 的地方</p>
<pre><code>store.dispatch(&#123;type:&#39;increment&#39;,data:1&#125;)</code></pre>
<p>在要读取 store 中状态值的地方</p>
<pre><code>store.getState()</code></pre>
<p>监测 redux 中状态的变化，只要变化，就调用 render</p>
<pre><code>componentDidMount()&#123;
    store.subscribe(()=&gt;&#123;
        this.setState(&#123;&#125;) //只要调用 setState 就会自动触发 render
    &#125;)
&#125;</code></pre>
<p>（5）优化：上面最后一步监测 redux 中状态变化调用 render 可不写在组件中，直接写在入口文件 index.js 中，这样写一次就行不用每个组件都写，在 index.js 中添加如下代码</p>
<pre><code>import store from &#39;./redux/store&#39;
store.subscribe(()=&gt;&#123;
    ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;))
&#125;)</code></pre>
<p>只要 store 中状态有一个发生改变就调用 render，因为 react 渲染时使用 diff 算法所以这样效率也不会低</p>
<p>注意：redux 只负责状态管理，状态发生变化时不会自动调用 render 重新渲染，需要自己监测并手动调用 render</p>
<h2 id="redux-的完整写法"><a href="#redux-的完整写法" class="headerlink" title="redux 的完整写法"></a>redux 的完整写法</h2><p>相比于上述 redux 的简单使用，增加如下部分</p>
<p>（1）在 src/redux 文件夹下创建 constant.js 文件用于定义 action 对象中 type 类型的常量值，便于管理的同时防止程序员单词写错</p>
<pre><code>export const INCREMENT = &#39;increment&#39;
export const DECREMENT = &#39;decrement&#39;</code></pre>
<p>（2）在 src/redux 文件夹下创建 actions/count_action.js（也可以不为此名），该文件专门为 Count 组件生成 action 对象</p>
<pre><code>import &#123;INCREMENT,DECREMENT&#125; from &#39;./constant&#39;
export const createIncrementAction = data =&gt; &#123;
    return &#123;type:INCREMENT,data&#125;
&#125;
export const createDecrementAction = data =&gt; (&#123;type:DECREMENT,data&#125;) //这种写法相当于上面的写法，返回的是个对象</code></pre>
<p>（3）在 reducer.js 中同样使用 constant.js 中定义的常量</p>
<pre><code>import &#123;INCREMENT,DECREMENT&#125; from &#39;../constant&#39;
const initState = 0 //初始化状态
export default function countReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action //从 action 对象中获取 type、data
    switch(type)&#123;
        case INCREMENT:
            return preState + data
        case DECREMENT:
            return preState - data
        default:
            return preState
    &#125;
&#125;</code></pre>
<p>（4）在组件中</p>
<p>引入 actionCreator（专门用于创建 action 对象）</p>
<pre><code>import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;</code></pre>
<p>在要使用 store 调用 reducer 的地方</p>
<pre><code>store.dispatch(createIncrementAction(1))</code></pre>
<h2 id="异步-action"><a href="#异步-action" class="headerlink" title="异步 action"></a>异步 action</h2><p>若 action 的值为 Object 类型的一般对象就是同步 action</p>
<p>若 action 的值是个函数（因为只有函数才能开启异步任务，而数字、数组等不行）就是异步 action，该函数由 store 调用</p>
<p>异步 action 中一般都会调用同步 action</p>
<p>何时需要异步 action？</p>
<pre><code>当延迟的动作不想交给组件自身，想交给 action
想要对状态进行操作，但具体的数据靠异步任务返回时</code></pre>
<p>异步 action 不是必须的，也可以自己在组件中等待异步任务的结果再去分发同步 action</p>
<h3 id="使用异步-action"><a href="#使用异步-action" class="headerlink" title="使用异步 action"></a>使用异步 action</h3><p>要使用异步 action 需要安装中间件 </p>
<pre><code>npm install redux-thunk</code></pre>
<p>修改 store.js 文件</p>
<pre><code>import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39; //引入 createStore 专门用于创建 redux 中最核心的 store 对象
import countReducer from &#39;./reducer.js&#39; //引入为 Count 组件服务的 reducer
import thunk from &#39;redux-thunk&#39; //引入 redux-thunk 用于支持异步 action
export default createStore(countReducer,applyMiddleware(thunk)) //执行中间件 thunk 并暴露 store</code></pre>
<p>在 action 文件中</p>
<pre><code>import store from &#39;./store&#39;
//异步 action
export const createIncrementAsyncAction = (data,time) =&gt; &#123;
    return () =&gt; &#123;
        setTimeout(() =&gt; &#123;
            store.dispatch(createIncrementAction(data))
        &#125;,time)
    &#125;
&#125;
或
因为异步 action 返回的函数由 store 调用，所以，可不手动引入 store
//异步 action
export const createIncrementAsyncAction = (data,time) =&gt; &#123;
    return (dispatch) =&gt; &#123;
        setTimeout(() =&gt; &#123;
            dispatch(createIncrementAction(data))
        &#125;,time)
    &#125;
&#125;</code></pre>
<p>在组件中使用异步 action</p>
<pre><code>store.createIncrementAsyncAction(1,1000)</code></pre>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 是 Facebook 出的插件库</p>
<p>react-redux 的模型图如下</p>
<p><img src="/2022/02/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react-redux%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="react-redux模型图"></p>
<p>所有的 UI 组件都应该包裹一个容器组件，他们是父子关系</p>
<p>容器组件是真正和 redux 打交道的，里面可以随意使用 redux 的 api</p>
<p>UI 组件中不能使用任何 redux 的 api</p>
<p>容器组件会通过 props 传给 UI 组件（1）redux 中保存的状态（2）用于操作状态的方法</p>
<h3 id="利用-react-redux-后一个组件要和-redux-打交道要经过哪几步？"><a href="#利用-react-redux-后一个组件要和-redux-打交道要经过哪几步？" class="headerlink" title="利用 react-redux 后一个组件要和 redux 打交道要经过哪几步？"></a>利用 react-redux 后一个组件要和 redux 打交道要经过哪几步？</h3><pre><code>（1）定义 UI 组件 --- 不暴露
（2）引入 connect 生成一个容器组件，并暴露，写法如下
    connect(
        state =&gt; (&#123;key:value&#125;), //映射状态
        &#123;key:xxxAction&#125;  //映射操作状态的方法
    )(UI组件)
（3）在 UI 组件中通过 this.props.xxx 读取和操状态</code></pre>
<h3 id="连接容器组件与-UI-组件"><a href="#连接容器组件与-UI-组件" class="headerlink" title="连接容器组件与 UI 组件"></a>连接容器组件与 UI 组件</h3><p>下载 <code>npm install react-redux -D</code></p>
<p>新建 src/containers 用于存放容器组件，UI 组件依然存放在 src/components 里</p>
<p>在 containers 文件夹中新建一个容器组件的文件夹（如 Count），Count 文件夹下新建 index.js</p>
<pre><code>//引入 Count 的 UI 组件
import CountUI from &#39;../../components/Count&#39;
//引入 action
import &#123;createIncrementAction,createDecrementAction,createIncrementAsyncAction&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;
//mapStateToProps 函数返回的是个对象，返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为传递给 UI 组件 props 的 value，mapStateToProps 用于传递状态
function mapStateToProps(state)&#123; //react-redux 调用的 a 函数，调用时已经 store.getState() 获取到状态，并作为参数传给 a 函数
    return &#123;count:state&#125; //这样相当于 &lt;CountUI count=xxx/&gt;
&#125;
//mapDispatchToProps 函数返回的是个对象，返回的对象中的 key 就作为传递给 UI 组件 props 的 key，value 就作为传递给 UI 组件 props 的 value，mapDispatchToProps 用于传递操作状态的方法
function mapDispatchToProps(dispatch)&#123;
    return &#123;
        inc:number =&gt; dispatch(createIncrementAction(number)),
        dec:number =&gt; dispatch(createDecrementAction(number)),
        incAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time))
    &#125;
&#125;
//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(mapStateToProps,mapDispatchToProps)(CountUI)</code></pre>
<p>最后应渲染容器组件，在使用 Count 组件的组件（如 App.js）中</p>
<pre><code>import React,&#123; Component &#125; from &#39;react&#39;
import store from &#39;./redux/store&#39;
import Count from &#39;./containers/Count&#39;
export default class App extends Component&#123;
    render(
        return(
            &lt;div&gt;
                &lt;Count store=&#123;store&#125;/&gt;
            &lt;/div&gt;
        )
    )
&#125;</code></pre>
<p>注意：容器组件中的 store 是靠 props 传进去的，不是在容器组件中直接 import 引入的</p>
<h3 id="优化程序编写"><a href="#优化程序编写" class="headerlink" title="优化程序编写"></a>优化程序编写</h3><h4 id="优化-mapDispatchToProps"><a href="#优化-mapDispatchToProps" class="headerlink" title="优化 mapDispatchToProps"></a>优化 mapDispatchToProps</h4><p>mapDispatchToProps 可以是个函数也可以是个对象</p>
<pre><code>import CountUI from &#39;../../components/Count&#39;
import &#123;createIncrementAction,createDecrementAction,createIncrementAsyncAction&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;
//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(
    state =&gt; (&#123;count:state&#125;),
    //mapDispatchToProps 的一般写法
    /*dispatch =&gt; (
        &#123;
            inc:number =&gt; dispatch(createIncrementAction(number)),
            dec:number =&gt; dispatch(createDecrementAction(number)),
            incAsync:(number,time) =&gt; dispatch(createIncrementAsyncAction(number,time))
        &#125;
    )*/
    //mapDispatchToProps 的简写
    &#123;
        inc:createIncrementAction, //这是因为 react-redux 收到传来的 action 对象能自动掉 dispatch
        dec:createDecrementAction,
        incAsync:createIncrementAsyncAction
    &#125;
)(CountUI)</code></pre>
<h4 id="无需对-store-中状态进行监测重新-render"><a href="#无需对-store-中状态进行监测重新-render" class="headerlink" title="无需对 store 中状态进行监测重新 render"></a>无需对 store 中状态进行监测重新 render</h4><p>使用 react-redux 后可删除之前在入口文件 index.js 文件中写的</p>
<pre><code>import store from &#39;./redux/store&#39;
store.subscribe(()=&gt;&#123;
    ReactDOM.render(&lt;App/&gt;,document.getElementById(&#39;root&#39;))
&#125;)</code></pre>
<p>因为 react-redux 中使用 connect()() 创建容器组件就会自动监测 store 中的状态变化</p>
<h4 id="Provider-组件的使用"><a href="#Provider-组件的使用" class="headerlink" title="Provider 组件的使用"></a>Provider 组件的使用</h4><p>之前需要给容器组件传递 store，有几个容器组件就要传几次 store</p>
<pre><code>&lt;Count store=&#123;store&#125;/&gt;</code></pre>
<p>利用 Provider 只需写一次即可给所有容器组件传 store，在入口文件 index.js 中</p>
<pre><code>import React from &#39;react&#39;    
import ReactDOM from &#39;react-dom&#39;
import &#123;HashRouter&#125; from &#39;react-router-dom&#39;
import App from &#39;./App&#39;
import store from &#39;./redux/store&#39;
import &#123;Provider&#125; from &#39;react-redux&#39;

ReactDOM.render(
    &lt;Provider store=&#123;store&#125;&gt; /*Provider 让该组件的所有后代容器组件都能接收到 store*/
        &lt;App/&gt;
    &lt;/Provider&gt;,
    document.getElementById(&#39;root&#39;)
)</code></pre>
<h4 id="整合-UI-组件与容器组件"><a href="#整合-UI-组件与容器组件" class="headerlink" title="整合 UI 组件与容器组件"></a>整合 UI 组件与容器组件</h4><p>有多少需要和 redux 关联的 UI 组件就需要写多少容器组件，目前文件太多，从文件层面进行优化，可以把 UI 组件和容器组件写在一个文件中</p>
<pre><code>import React, &#123;Component&#125; from &#39;react&#39;    
import &#123;
    createIncrementAction,
    createDecrementAction,
    createIncrementAsyncAction
&#125; from &#39;../../redux/count_action&#39;
//引入 connect 用于连接 UI 组件与 redux
import &#123;connect&#125; from &#39;react-redux&#39;

//定义 UI 组件
class CountUI extends Component&#123;...&#125; //UI 组件中通过 this.props.xxx 来使用容器组件中从 redux 获取的状态和操作状态的方法

//使用 connect()() 创建并暴露一个 Count 的容器组件
export defualt connect(...)(CountUI)</code></pre>
<h3 id="react-redux-使用的最终版"><a href="#react-redux-使用的最终版" class="headerlink" title="react-redux 使用的最终版"></a>react-redux 使用的最终版</h3><p>（1）新建 src/containers/组件名/index.js，</p>
<pre><code>import React,&#123; Component &#125; from &#39;react&#39;
import &#123; createIncrementAction &#125; from &#39;../../redux/count_action&#39;
import &#123;connect&#125; from &#39;react-redux&#39;
class Count extends Component&#123;
    add = () =&gt; &#123;
        this.props.inc(1)
    &#125;
    render(
        return(
            &lt;div&gt;
                &lt;h1&gt;&#123;this.props.num&#125;&lt;/h1&gt;
                &lt;button onClick=&#123;this.add&#125;&gt;加一&lt;/button&gt;
            &lt;/div&gt;
        )
    )
&#125;
export defualt connect(
    state =&gt; (&#123;num:state&#125;), //映射状态
    &#123;inc:createIncrementAction&#125;//映射状态的方法
)(Count)</code></pre>
<h3 id="多个组件间的数据共享"><a href="#多个组件间的数据共享" class="headerlink" title="多个组件间的数据共享"></a>多个组件间的数据共享</h3><p>假设有两个组件 Count 和 Person，且已写好两个组件相关的 action 和 reducer，Count 组件中可点击+1，Person 组件可添加一个人的信息</p>
<p>新建 src/reducers/index.js 文件用于汇总所有的 reducer 为一个总的 reducer</p>
<pre><code>import &#123;combineReducers&#125; from &#39;redux&#39;
//引入为 Count、Person 组件服务的 reducer
import count from &#39;./reducers/count&#39;
import person from &#39;./reducers/person&#39;

//汇总所有 reducer 变为一个总的 reducer
export default combineReducers(&#123; //这里传入的对象就是 store 中存的对象
    num:count,
    person:person
&#125;)</code></pre>
<p>修改 store.js 文件</p>
<pre><code>import &#123;createStore,applyMiddleware&#125; from &#39;redux&#39;
import reducer from &#39;./reducers/index.js&#39;
import thunk from &#39;redux-thunk&#39;

export default createStore(reducer,applyMiddleware(thunk)) //执行中间件 thunk 并暴露 store</code></pre>
<p>两个 reducer 进行状态传递时应进行修改，如 Count 中</p>
<pre><code>export default connect(
    state =&gt; (&#123;count:state.num,person:state.person&#125;)//注意这里不是之前的 state =&gt; (&#123;count:state&#125;)，因为之前 state 中存只是个数字，现在 state 中存的是个对象，用来存放很多组件的状态
)(Count)</code></pre>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数：只要同样的输入（实参），必定得到同样的输出（返回）</p>
<p>纯函数必须遵守以下一些约束：</p>
<pre><code>（1）不得改写参数数据，如 function func(a)&#123;a=1&#125;
（2）不会产生任何副作用，例如网络请求（可能会断网等），输入和输出设备
（3）不能调用 Date.now() 或 Math.random() 等不纯的方法</code></pre>
<p>redux 的 reducer 函数必须是一个纯函数，如</p>
<pre><code>export default function personReducer(preState=initState,action)&#123;
    const &#123;type,data&#125; = action
    switch(type)&#123;
        case ADD_PERSON:
            return [data,...preState] //注意这里不能使用 preState.unshift(data)，因为这样导致 preState 被改写了，personReducer 就不是纯函数了
        default:
            return preState
    &#125;
&#125;</code></pre>
<h2 id="redux-开发者工具"><a href="#redux-开发者工具" class="headerlink" title="redux 开发者工具"></a>redux 开发者工具</h2><p>在 Chrome 浏览器中安装插件 Redux DevTools</p>
<p>在项目中下载 redux-devtools-extension</p>
<pre><code>npm install redux-devtools-extension -D</code></pre>
<p>在 src/redux/store.js 文件中添加</p>
<pre><code>//引入
import &#123;composeWithDevTools&#125; from &#39;redux-devtools-extension&#39;
//修改原先的 export default...
export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk)))</code></pre>
<h1 id="十、项目打包运行"><a href="#十、项目打包运行" class="headerlink" title="十、项目打包运行"></a>十、项目打包运行</h1><p>执行 <code>npm run build</code> 生成文件夹 build</p>
<p>全局安装 serve 来查看打包项目的运行效果</p>
<pre><code>npm i serve -g
serve build</code></pre>
<h1 id="十一、扩展"><a href="#十一、扩展" class="headerlink" title="十一、扩展"></a>十一、扩展</h1><h2 id="setState-更新状态的两种写法"><a href="#setState-更新状态的两种写法" class="headerlink" title="setState 更新状态的两种写法"></a>setState 更新状态的两种写法</h2><p>setState 是同步的，setState 引起 React 后续更新状态的动作是异步的</p>
<p>若更改完 state 状态后要马上输出查看新的 state 要在回调函数中查看，若在外部查看输出依然是旧值</p>
<p>（1）setState(stateChange, [callback])————对象式的 setState</p>
<pre><code>stateChange 为状态改变对象（该对象可体现出状态的更改）
callback 是可选的回调函数，它在状态更新完毕、界面也更新后（render 调用后）才被调用

如 this.setState(&#123;count:count+1&#125;)</code></pre>
<p>（2）setState(updater, [callback])————函数式的 setState</p>
<pre><code>updater 为返回 stateChange 对象的函数，可接收 state 和 props
callback 是可选的回调函数，它在状态更新完毕、界面也更新后（render 调用后）才被调用

如 this.setState((state,props) =&gt; &#123;
    console.log(state,props)
    return &#123;count:state.count+1&#125;
&#125;)</code></pre>
<p>总结：对象式的 setState 是函数式的 setState 的简写方式（语法糖）</p>
<p>使用原则：</p>
<pre><code>（1）若新状态不依赖原状态————使用对象方式
（2）若新状态依赖于原状态————使用函数/对象方式
（3）若需要在 setState() 执行后获取最新状态数据，要在第二个 callback 函数中读取</code></pre>
<h2 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h2><p>做懒加载最多的是路由组件 lazyLoad</p>
<pre><code>import React, &#123; Component,lazy &#125; from &#39;react&#39;
//通过 React 的 lazy 函数配合 import() 函数动态加载路由组件 ==&gt; 路由组件代码会被分开打包
const Login = lazy(()=&gt;import(&#39;@/pages/Login&#39;))
//通过 &lt;Suspense&gt; 指定在加载得到路由打包文件前显示一个自定义 loading 界面，当网速慢时会先显示 fallback 中的东西
&lt;Suspense fallback=&#123;&lt;h1&gt;Loading...&lt;/h1&gt;&#125;&gt;
    &lt;Switch&gt;
        &lt;Route path=&quot;/xx&quot; component=&#123;Xxx&#125;&gt;
        &lt;Redirect to=&quot;/login/&quot;&gt;
    &lt;/Switch&gt;
&lt;/Suspense&gt;</code></pre>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Hook 是 React 16.8.0 版本增加的新特性/新语法，使得在函数组件中也可以使用 state 以及其他 React 特性</p>
<h3 id="三个常用的-Hook"><a href="#三个常用的-Hook" class="headerlink" title="三个常用的 Hook"></a>三个常用的 Hook</h3><h4 id="State-Hook：React-useState"><a href="#State-Hook：React-useState" class="headerlink" title="State Hook：React.useState()"></a>State Hook：React.useState()</h4><p>State Hook 让函数组件也可以有 state 状态，并进行状态数据的读写操作</p>
<p>语法：<code>const [xxx,setXxx] = React.useState(initValue)</code></p>
<p>useState() 中</p>
<pre><code>参数：第一次初始化指定的值在内部作缓存
返回值：包含 2 个元素的数组，第 1 个为内部当前状态值，第 2 个为更新状态值的函数</code></pre>
<p>setXxx() 两种写法</p>
<pre><code>setXxx(newValue)：参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值
setXxx(value =&gt; newValue)：参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</code></pre>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    function add()&#123;
        setCount(count+1)//或 setCount(count =&gt; count+1)
    &#125;
    return(
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;add&#125;&gt;加一&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h4 id="Effect-Hook：React-useEffect"><a href="#Effect-Hook：React-useEffect" class="headerlink" title="Effect Hook：React.useEffect()"></a>Effect Hook：React.useEffect()</h4><p>Effect Hook 让函数组件也可以执行副作用操作（副作用操作用于模拟类组件中的生命周期钩子）</p>
<p>React 中的副作用操作：</p>
<pre><code>发 ajax 请求数据获取
设置订阅、启动定时器
手动更改真实 DOM</code></pre>
<p>语法：</p>
<pre><code>React.useEffect(()=&gt;&#123;
    //在此可以执行任何带副作用操作
    return () =&gt; &#123; //组件卸载前执行
        //在此做一些收尾工作，如清除定时器/取消订阅
    &#125;
&#125;,[stateValue]) //第二个参数表示监测的值，若为 []，回调函数只会在第一次 render() 后执行</code></pre>
<p>可以把 useEffect Hook 看作三个函数的组合：componentDidMount、componentDidUpdate、componentWillUnmount</p>
<p>React.useEffect() 该函数相当于 componentDidMount 和 componentDidUpdate，具体是哪个取决于传入的第二个参数，若为空数组[]，则相当于 componentDidMount，若数组中有要监测变化的值[xxx]，则相当于 componentDidUpdate</p>
<p>React.useEffect() 中若返回函数，返回的函数相当于 componentWillUnmount</p>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    React.useEffect(()=&gt;&#123;
        let timer = setInterval(()=&gt;&#123;
            setCount(count =&gt; count + 1)
        &#125;,1000)
        return ()=&gt;&#123;
            clearInterval(timer)
        &#125;
    &#125;,[]) 
    function unmount()&#123;
        ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))
    &#125;
    return(
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;unmount&#125;&gt;卸载组件&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h4 id="Ref-Hook：React-useRef"><a href="#Ref-Hook：React-useRef" class="headerlink" title="Ref Hook：React.useRef()"></a>Ref Hook：React.useRef()</h4><p>Ref Hook 可在函数组件中存储/查找组件内的标签或任意其他数据</p>
<p>语法：<code>const refContainer = useRef()</code></p>
<p>作用：保存标签对象，功能与 React.createRef() 一样</p>
<p>例子</p>
<pre><code>import React from &#39;react&#39;
function Demo()&#123;
    const [count,setCount] = React.useState(0)
    const myRef = React.useRef()
    function show()&#123;
        alert(myRef.current.value)
    &#125;
    return(
        &lt;input type=&quot;text&quot; ref=&#123;myRef&#125;&gt;
        &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;
        &lt;button onClick=&#123;show&#125;&gt;点击提示input中输入的数据&lt;/button&gt;
    )
&#125;
export default Demo</code></pre>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>在组件中 jsx 语法一定要求只能有一个根标签，这样使得在组件嵌套后会有很多没用的根标签，而使用 Fragment 作为根标签在实际渲染时会忽略</p>
<pre><code>import React, &#123; Component,Fragment &#125; from &#39;react&#39;
export deffault clss Demo extends Component&#123;
    render(
        return(
            &lt;Fragment&gt;
                &lt;input type=&quot;text&quot;/&gt;
                &lt;input type=&quot;text&quot;/&gt;
            &lt;/Fragment&gt;
        )
    )
&#125;
&lt;Fragment&gt;&lt;/Fragment&gt;
或
&lt;&gt;&lt;/&gt;</code></pre>
<p><code>&lt;Fragment&gt;</code> 可以添加 key 属性，用于遍历</p>
<p>可以不用必须有一个真实的 DOM 根标签了，而 <code>&lt;&gt;</code> 空标签里不能添加任何属性</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 是一种组件间通信方式，常用于【祖组件】与【后代组件】间的通信</p>
<p>使用：</p>
<p>（1）在祖孙组件都能访问到的地方创建 Context 容器对象</p>
<pre><code>const xxxContext = React.createContext()  //xxxContext 首字母需要大写，因为后面它还会作为组件标签使用</code></pre>
<p>（2）在祖组件渲染子组件时外面包裹 xxxContext.Provider，通过 value 属性给后代组件传递数据</p>
<pre><code>&lt;xxxContext.Provider value=&#123;数据&#125;&gt;
    子组件
&lt;/xxxContext.Provider&gt;</code></pre>
<p>（3）后代组件读取数据</p>
<pre><code>//方式一：仅适用于类组件
static contextType = xxxContext //声明接收 context
this.context  //读取 context 中的value 数据

//方式二：函数组件与类组件都可以
&lt;xxxContext.Consumer&gt;
    &#123;
        value =&gt; &#123;  //value 就是 context 中的 value 数据
            //要显示的内容
        &#125;
    &#125;
&lt;/xxxContext.Consumer&gt;</code></pre>
<p>注意：在应用开发中一般不用 context，一般都用它的封装 react 插件（react-redux 中的 Provider）</p>
<p>例子：A 组件是 B 组件的父组件，B 是 C 的父组件，要让 C 不通过 B，直接拿到 A 的数据</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;

//创建 Context 对象
const MyContext = React.createContext()
const &#123;Provider,Consumer&#125; = MyContext

export default class A extends Component&#123;
    state = &#123;username:&#39;xx&#39;,age:18&#125;
    render(
        const &#123;username&#125; = this.state
        return(
            &lt;div&gt;
                &lt;Provider value=&#123;&#123;username:username,age:age&#125;&#125;&gt;
                    &lt;B/&gt;
                &lt;/Provider&gt;
            &lt;/div&gt;
        )
    )
&#125;
class B extends Component&#123;
    render(
        return(
            &lt;div&gt;
                &lt;C/&gt;
            &lt;/div&gt;
        )
    )
&#125;
class C extends Component&#123;
    render(
        static contextType = MyContext
        return(
            &lt;div&gt;
                &lt;h1&gt;&#123;this.context.username&#125;&lt;/h1&gt;
            &lt;/div&gt;
        )
    )
&#125;

//若 C 是函数式组件
function C()&#123;
    return (
        &lt;div&gt;
            &lt;Consumer&gt;
                &#123;
                    value =&gt; &#123;
                        return `$&#123;value.username&#125;,$&#123;value.age&#125;`
                    &#125;
                &#125;
            &lt;/Consumer&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><p>Component 的 2 个问题：</p>
<pre><code>（1）只要执行 setState() 即使不改变状态数据，组件也会重新 render()
（2）只当前组件重新 render()，就会自动重新 render 子组件，就算子组件没有用到父组件的任何数据也会触发子组件重新 render，这会导致效率低</code></pre>
<p>效率高的做法：只有当组件的 state 或 props 数据发生改变时才重新 render()</p>
<p>原因：Component 的 shouldComponentUpdate() 总是返回 true</p>
<p>解决：</p>
<pre><code>办法1：重写 shouldComponentUpdate() 方法
比较新旧 state 或 props 数据，若有变化才返回 true，若没有返回 false
在父子组件中重写：
shouldComponentUpdate(nextProps,nextState)&#123;
    console.log(this.props,this.state)  //目前的 props 和 state
    console.log(nextProps,nextState)  //接下来要变化的新 props 和 state、
    return !this.state.xx === nextState.xxx
&#125;

办法2：使用 PureComponent
PureComponent 重写了 shouldComponentUpdate()，只有 state 或 props 数据有变化才返回 true
注意：只是进行 state 和 props 数据的浅比较，只有对象地址改变时返回 true，若只是数据对象内部数据变了，返回 false，所以不要直接修改 state 数据，而是要产生新数据
用法如下：
import React, &#123; PureComponent &#125; from &#39;react&#39;
class 组件 extends PureComponent&#123;...&#125;</code></pre>
<p>项目中一般使用 PureComponent 来优化</p>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>html 标签里的标签体内容能直接展示，而自定义组件中的标签体（如 <code>&lt;自定义组件&gt;xxx&lt;/自定义组件&gt;</code>）不能直接展示，而是作为 this.props.children 属性的值</p>
<p>如何想组件内部动态传入带内容的结构（标签）？</p>
<pre><code>在 Vue 中，使用 slot 技术，即通过组件标签体传入结构 &lt;A&gt;&lt;B/&gt;&lt;/A&gt;

在 React 中
    使用 children props：通过父组件标签体传入结构（子组件）
    使用 render props：通过组件标签属性传入结构，来形成父子关系，，且可携带数据，一般用 render 的函数属性</code></pre>
<p>（1）childer props</p>
<pre><code>在 A 的父组件中形成 AB 的父子关系
&lt;A&gt;
    &lt;B&gt;xxx&lt;/B&gt;
&lt;/A&gt;
在 A 组件中通过如下代码展示 B 组件
&#123;this.props.children&#125;</code></pre>
<p>但是若 B 组件需要 A 组件内的数据则做不到</p>
<p>（2）render props</p>
<pre><code>在 A 的父组件中形成 AC 的父子关系
&lt;A render=&#123;(data)=&gt;&lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;
A 组件中渲染 C 组件并给 C 传数据
&#123;this.props.render(要给 C 传的数据)&#125;
C 组件中读取 A 组件传入的数据显示 
&#123;this.props.data&#125;</code></pre>
<h2 id="ErrorBoundary-错误边界"><a href="#ErrorBoundary-错误边界" class="headerlink" title="ErrorBoundary 错误边界"></a>ErrorBoundary 错误边界</h2><p>错误边界（ErrorBoundary）用来捕获后代组件错误，渲染出备用页面</p>
<p>错误边界就是让错误控制在一定范围内不要往外扩散，子组件出错父组件依然能正常渲染</p>
<p>错误边界只适用于生产环境</p>
<p>特点：只能捕获后代组件生命周期函数中产生的错误，普通函数中不行，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<p>使用方式：getDerivedStateFromError 配合 componentDidCatch</p>
<pre><code>state = &#123;
    hasError:&#39;&#39;  //用于标识子组件是否产生错误
&#125;
//声明周期函数，一旦后代组件报错，就会触发，并携带错误信息
static getDerivedStateFromError(error)&#123;
    console.log(error)
    //在 render 之前触发
    //返回新的 state
    return &#123;hasError: true&#125;
&#125;
render()&#123;
    return(
        &lt;div&gt;
            &#123;this.state.hasError?&lt;h2&gt;当前网络不稳定，稍后再试&lt;/h2&gt;:&lt;子组件/&gt;&#125;
        &lt;/div&gt;
    )
&#125;
componentDidCatch(error,info)&#123;  //当页面中子组件出现问题时该钩子会被调用
    //统计页面的错误，发送请求发送到后台去，用于通知编码人员解决 bug
    console.log(error,info)
&#125;</code></pre>
<h1 id="十二、组件通信方式总结"><a href="#十二、组件通信方式总结" class="headerlink" title="十二、组件通信方式总结"></a>十二、组件通信方式总结</h1><p>组件间的关系：</p>
<pre><code>父子组件
兄弟组件（非嵌套组件）
祖孙组件（跨级组件）</code></pre>
<p>通信方式：</p>
<pre><code>（1）props
    children props
    render props
（2）消息订阅-发布
    pubs-sub、event（C#中用的多） 等
（3）集中式管理
    redux、dva 等
（4）conText
    生产者-消费者模式</code></pre>
<p>比较好的搭配方式：</p>
<pre><code>父子组件：props
兄弟组件：消息订阅-发布、集中式管理
祖孙组件（跨级组件）：消息订阅-发布、集中式管理、conText（开发用的少，封装插件用的多）</code></pre>
<h1 id="十三、ReactRouter-6"><a href="#十三、ReactRouter-6" class="headerlink" title="十三、ReactRouter 6"></a>十三、ReactRouter 6</h1><p>React Router 以三个不同的包发布到 npm 上，分别为：</p>
<pre><code>（1）react-router：路由的核心库，提供很多组件、钩子
（2）react-router-dom：包含 react-router 所有内容，并添加到一些专门用于 DOM 的组件，如 &lt;BrowserRouter&gt; 等
（3）react-router-native：包括 react-router 所有内容，并添加一些专门用于 ReactNative 的 API，如 &lt;NativeRouter&gt; 等</code></pre>
<h2 id="相比-ReactRouter-5-x-的变化"><a href="#相比-ReactRouter-5-x-的变化" class="headerlink" title="相比 ReactRouter 5.x 的变化"></a>相比 ReactRouter 5.x 的变化</h2><p>（1）内置组件的变化：移除 <code>&lt;Switch/&gt;</code>，新增 <code>&lt;Routes/&gt;</code> 等</p>
<p>（2）语法的变化：<code>component=&#123;组件&#125;</code> 变为 <code>element=&#123;&lt;组件名/&gt;&#125;</code> 等</p>
<p>（3）新增多个 hook：useParams、useNavigate、useMatch 等</p>
<p>（4）官方明确推荐函数式组件了</p>
<h2 id="lt-Routes-gt-与-lt-Route-gt"><a href="#lt-Routes-gt-与-lt-Route-gt" class="headerlink" title="&lt;Routes/&gt; 与 &lt;Route/&gt;"></a><code>&lt;Routes/&gt;</code> 与 <code>&lt;Route/&gt;</code></h2><p>（1）v6 版本中移除了 <code>&lt;Switch&gt;</code>，引入了替代者 <code>&lt;Routes/&gt;</code></p>
<p>（2）<code>&lt;Routes/&gt;</code> 和 <code>&lt;Route/&gt;</code> 要配合使用，且必须要用 <code>&lt;Routes/&gt;</code> 包裹 <code>&lt;Route/&gt;</code></p>
<p>（3）<code>&lt;Route/&gt;</code> 相当于一个 if 语句，若其路径与当前 URL 匹配，则程序对应组件</p>
<p>（4）<code>&lt;Route caseSensitive/&gt;</code> 属性用于指定匹配时是否区分大小写（默认为 false）</p>
<p>（5）当 URL 发生变化时，<code>&lt;Routes/&gt;</code> 都会查看其所有子 <code>&lt;Route/&gt;</code> 元素以找到最佳匹配并呈现组件</p>
<p>（6）<code>&lt;Route/&gt;</code> 也可以嵌套使用，且可配合 useRoutes() 配置“路由表”，但需要通过 <code>&lt;Outlet/&gt;</code> 组件来渲染其子路由</p>
<pre><code>import &#123;NavLink,Routes,Route,Navigate&#125; from &#39;react-router-dom&#39;

&lt;Routes&gt; &#123;/*功能和 Switch 一样（路由一旦匹配到就不继续往下匹配），但必须包裹 Routes*/&#125;
    &lt;Route path=&#39;/about&#39; element=&#123;&lt;About/&gt;&#125;&gt;
        &lt;Route path=&#39;/xx&#39; element=&#123;&lt;Xxx/&gt;&#125;&gt;  &#123;/*嵌套路由，/about/xx*/&#125;
    &lt;/Route&gt;
    &lt;Route path=&#39;/&#39; element=&#123;&lt;Navigate to=&quot;/about&quot;/&gt;&#125;/&gt; &#123;/*没有 Redirect 了，而是换成 Navigate，且 Navigate 组件一旦被渲染一定会触发视图切换*/&#125;
&lt;/Routes&gt;</code></pre>
<h2 id="lt-Navigate-gt-重定向"><a href="#lt-Navigate-gt-重定向" class="headerlink" title="&lt;Navigate/&gt; 重定向"></a><code>&lt;Navigate/&gt;</code> 重定向</h2><p>作用：只要 <code>&lt;Navigate/&gt;</code> 组件被渲染，就会修改路径，切换视图</p>
<p>replace 属性用于控制跳转模式（push 或 replace，默认是 false）</p>
<pre><code>import React,&#123;useState&#125; from &#39;react&#39;
import &#123;NavLink,Routes,Route,Navigate&#125; from &#39;react-router-dom&#39;

export default function About()&#123;
    const [sum,setSum] = useState(1)
    return(
        &lt;div&gt;
            &#123;sum === 1 ? &lt;h2&gt;xxx&lt;/h2&gt; : &lt;Navigate to=&quot;about&quot; replace=&#123;true&#125;/&gt;&#125;
            &lt;button onClick=&#123;()=&gt;setSum(2)&#125;&gt;点击后sum变为2&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="lt-NavLink-gt-高亮"><a href="#lt-NavLink-gt-高亮" class="headerlink" title="&lt;NavLink/&gt; 高亮"></a><code>&lt;NavLink/&gt;</code> 高亮</h2><p>在 v5 中高亮是使用 <code>&lt;NavLink activeClassName=&quot;xxx&quot;/&gt;</code> 来控制标签高亮</p>
<p>在 v6 中废弃了 activeClassName 属性，将要高亮的类也添加在 className 中，值为一个函数</p>
<pre><code>&lt;NavLink className=&#123;(&#123;isActive&#125;)=&gt;isActive?&#39;定义的高亮样式类&#39;:&#39;&#39;&#125; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></pre>
<p>上述方式在每个有可能高亮的组件中都要使用较多重复代码，所以可以单独定义成一个函数</p>
<pre><code>function computedClassName(&#123;isActive&#125;)&#123;
    return isActive?&#39;定义的高亮样式类&#39;:&#39;&#39;
&#125;

在 NavLink 标签中使用
&lt;NavLink className=&#123;computedClassName&#125; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</code></pre>
<h2 id="useRoutes-路由表"><a href="#useRoutes-路由表" class="headerlink" title="useRoutes 路由表"></a>useRoutes 路由表</h2><p>新建 src/routes/index.js</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在组件中</p>
<pre><code>import React from &#39;react&#39;
import &#123;NavLink,useRoutes&#125; from &#39;react-router-dom&#39;
import routes from &#39;./routes&#39;
export default function App()&#123;
    //根据路由表生产对应的路由规则
    const element = useRoutes(routes)
    return (
        &lt;div&gt;
            &#123;element&#125;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>当 <code>&lt;Route&gt;</code> 产生嵌套时，渲染其对于的后续子路由使用 <code>&lt;Outlet /&gt;</code></p>
<p>假设 <code>&lt;News/&gt;</code> 和 <code>&lt;Message/&gt;</code> 是 <code>&lt;Home/&gt;</code> 的子组件，他们在 <code>&lt;Home/&gt;</code> 所在路由的二级路由下</p>
<p>修改 src/routes/index.js 文件</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
import News from &#39;../pages/News&#39;
import Message from &#39;../pages/Message&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;,
        children:[
            &#123;
                path:&#39;news&#39;,
                element:&lt;News/&gt;
            &#125;,
            &#123;
                path:&#39;message&#39;,
                element:&lt;Message/&gt;
            &#125;
        ]
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在 <code>&lt;Home/&gt;</code> 组件中</p>
<pre><code>import &#123;NavLink,Outlet&#125; from &#39;react-router-dom&#39;

&#123;/* 路由链接，end 属性表示若子级路由匹配上则父级路由不高亮 */&#125;
&lt;NavLink to=&quot;news&quot;&gt;News&lt;/NavLink&gt;&#123;/* News 组件对应的是 /home/news 路径，这里要么两级路由写完整，要么只写第二级且不加 /，若加 / 表示从根目录开始，或使用 ./news 表示从当前路径开始加 */&#125;
&lt;NavLink end to=&quot;message&quot;&gt;Message&lt;/NavLink&gt;
&#123;/* 指定路由组件呈现位置 */&#125;
&lt;Outlet /&gt;</code></pre>
<h2 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h2><p>在 src/routes/index.js 文件中</p>
<pre><code>import &#123;Navigate&#125; from &#39;react-router-dom&#39;
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;
import News from &#39;../pages/News&#39;
import Message from &#39;../pages/Message&#39;
export default[
    &#123;
        path:&#39;/about&#39;,
        element:&lt;About/&gt;
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        element:&lt;Home/&gt;,
        children:[
            &#123;
                path:&#39;news&#39;,
                element:&lt;News/&gt;
            &#125;,
            &#123;
                path:&#39;message&#39;,
                element:&lt;Message/&gt;
                children:[
                    &#123;
                        path:&#39;detail/:id/:title&#39;,  //携带params 参数形式
                        element:&lt;Detail/&gt;
                    &#125;,
                    &#123;
                        path:&#39;message&#39;,
                        element:&lt;Message/&gt;
                    &#125;
                ]
            &#125;
        ]
    &#125;,
    &#123;
        path:&#39;/&#39;,
        element:&lt;Navigate to=&quot;/about&quot;/&gt;
    &#125;
]</code></pre>
<p>在组件中</p>
<pre><code>&lt;NavLink to=&#123;`detail/$&#123;变量1&#125;/$&#123;变量2&#125;`&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 params 路由参数的组件中（使用函数式定义的情况下）可使用 useParams 或 useMatch</p>
<pre><code>import &#123;useParams,useMatch&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    //方式一：
    const &#123;id,title&#125; = useParams()
    //方式二：
    const x = useMatch(&#39;/home/message/detail/:id/:title&#39;)
    console.log(x)
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="路由的-search-参数"><a href="#路由的-search-参数" class="headerlink" title="路由的 search 参数"></a>路由的 search 参数</h2><p>在组件中</p>
<pre><code>&lt;NavLink to=&#123;`detail?id=$&#123;变量1&#125;&amp;title=$&#123;变量2&#125;`&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 search 路由参数的组件中（使用函数式定义的情况下），可使用 useSearchParams（返回包含两个值的数组[search参数,更新search的函数]） 或 useLocation</p>
<pre><code>import &#123;useSearchParams,useLocation&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    //方式一：
    const [search,setSearch] = useSearchParams()
    const id =search.get(&#39;id&#39;)
    const title = search.get(&#39;title&#39;)
    //方式二：
    const x = useLocation()
    console.log(x)
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
            &lt;li&gt;&lt;button onClick=&#123;()=&gt;setSearch(&#39;id=111&amp;title=xxx&#39;)&#125;&gt;点击更新收到的 search 参数&lt;/button&gt;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="路由的-state-参数"><a href="#路由的-state-参数" class="headerlink" title="路由的 state 参数"></a>路由的 state 参数</h2><p>在组件中</p>
<pre><code>&lt;NavLink to=&quot;detail&quot; state=&#123;&#123;id:变量1,title:变量2&#125;&#125;&gt;xxx&lt;/NavLink&gt;
&lt;Outlet /&gt;</code></pre>
<p>在接收 state 路由参数的组件中（使用函数式定义的情况下）</p>
<pre><code>import &#123;useLocation&#125; from &#39;react-router-dom&#39;

export default function Detail()&#123;
    const &#123;state:&#123;id,title&#125;&#125; = useLocation()
    return (
        &lt;ul&gt;
            &lt;li&gt;&#123;id&#125;&lt;/li&gt;
            &lt;li&gt;&#123;title&#125;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>使用 useNavigate 实现路由跳转</p>
<pre><code>import React from &#39;react&#39;
import &#123;Link,Outlet,useNavigate&#125; from &#39;react-router-dom&#39;

export default function Message()&#123;
    const navigate = useNavigate()
    function showDetail(m)&#123;
        navigate(&#39;detail&#39;,&#123;
            replace:false,
            state:&#123;
                id:m.id, //假设 m 传来是个对象
                title:m.title
            &#125;
        &#125;) //触发showDetail函数就会发生路由跳转
    &#125;
    return (
        &lt;ul&gt;
            &lt;li&gt;&lt;button onClick=&#123;()=&gt;showDetail(数据)&#125;&gt;查看详情&lt;/button&gt;&lt;/li&gt;
        &lt;/ul&gt;
    )
&#125;</code></pre>
<p>对于一般组件</p>
<pre><code>import React from &#39;react&#39;
import &#123;useNavigate&#125; from &#39;react-router-dom&#39;

export default function Header()&#123;
    const navigate = useNavigate()
    function back(m)&#123;
        navigate(-1)
    &#125;
    function forward(m)&#123;
        navigate(1)
    &#125;
    return (
        &lt;div&gt;
            &lt;button onClick=&#123;()=&gt;back(数据)&#125;&gt;后退&lt;/button&gt;
            &lt;button onClick=&#123;()=&gt;forward(数据)&#125;&gt;前进&lt;/button&gt;
        &lt;/div&gt;
    )
&#125;</code></pre>
<h2 id="一些其他较不常用的-Hooks"><a href="#一些其他较不常用的-Hooks" class="headerlink" title="一些其他较不常用的 Hooks"></a>一些其他较不常用的 Hooks</h2><p>（1）useInRouterContext()</p>
<p>作用：若组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 useInRouterContext 钩子返回 true，否则返回 false</p>
<p>（2）useNavigationType()</p>
<p>作用：返回当前的导航类型（用户是如何来到当前页面的）</p>
<p>返回值：POP、PUSH、REPLACE</p>
<p>备注：POP 是指在浏览器中直接打开了这个路由组件（是刷新当前页面）</p>
<p>（3）useOutlet()</p>
<p>作用：用来呈现当前组件中要渲染的嵌套路由组件</p>
<pre><code>const result = useOutlet()
console.log(result)
//若嵌套路由没有挂载，则 result 为 null
//若嵌套路由已经挂载，则显示嵌套的路由对象</code></pre>
<p>（4）useResolvedPath()</p>
<p>作用：给定一个 URL 值，解析其中的 path、search、hash 值</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="defaultChecked-和-checked"><a href="#defaultChecked-和-checked" class="headerlink" title="defaultChecked 和 checked"></a>defaultChecked 和 checked</h2><p>勾选框 checkbox 初始时是否勾选可使用 defaultChecked（只能在显示初始值时起作用），这样设置后可修改值</p>
<pre><code>&lt;input type=&quot;checkbox&quot; defaultChecked=xxx?true:false&gt;
第一次显示时有效，但当 xxx 变量值发生改变时，checkbox 的勾选情况不会随着改变</code></pre>
<p>或者使用 checked + onChange 来初始和监听是否勾选，这样可实时修改勾选情况</p>
<h2 id="React-中定义的一些事件"><a href="#React-中定义的一些事件" class="headerlink" title="React 中定义的一些事件"></a>React 中定义的一些事件</h2><pre><code>onClick：点击
onBlur：失去焦点
onKeyUp：键盘按下松开
event.KeyCode：按下键盘按键的编码（回车的 KeyCode 是 13）
onMouseLeave：鼠标移入
onMouseEnter：鼠标移出</code></pre>
<h2 id="id-生成"><a href="#id-生成" class="headerlink" title="id 生成"></a>id 生成</h2><p>生成数据 id，可通过 uuid 库（比较大）或 nanoid 库（较小，推荐）</p>
<pre><code>npm i nanoid
import &#123;nanoid&#125; from &#39;nanoid&#39; //暴露的 nanoid 是个函数，可生成全世界唯一的字符串
const Obj = &#123;id:nanoid(),name:&#39;xx&#39;&#125;</code></pre>
<h2 id="确认对话框"><a href="#确认对话框" class="headerlink" title="确认对话框"></a>确认对话框</h2><p>若点击按钮需要弹出确认对话框当用户点击“确定”后方可执行按钮事件可利用 window 下的 confirm 函数</p>
<pre><code>if(window.confirm(&#39;提示语句&#39;))&#123;执行相应代码&#125;</code></pre>
<h2 id="Chrome-中插件"><a href="#Chrome-中插件" class="headerlink" title="Chrome 中插件"></a>Chrome 中插件</h2><p>FeHelper 可帮助整理 json 数据缩进显示</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值</p>
<pre><code>let &#123;对象中的属性&#125; = 对象</code></pre>
<p>连续解构赋值</p>
<pre><code>let &#123;对象中的属性对象:&#123;属性对象中的属性&#125;&#125; = 对象

let obj = &#123;a:&#123;b:&#123;c:1&#125;&#125;&#125;
const &#123;a:&#123;b:&#123;c&#125;&#125;&#125; = obj
console.log(c) //输出 1</code></pre>
<p>连续解构赋值并重命名</p>
<pre><code>let &#123;对象中的属性:新名字&#125; = 对象

let obj = &#123;a:&#123;b:1&#125;&#125;
const &#123;a:&#123;b:data&#125;&#125; = obj
console.log(data)  //也能输出 1</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Vue"><a href="#一、Vue" class="headerlink" title="一、Vue"></a>一、Vue</h1><p>Vue 是一套用于构建用户界面的<strong>渐进式</strong> JavaScript 框架</p>
<p>渐进式指 Vue 是可以自底向上逐层递进的应用，即在简单应用中只需一个轻量小巧的核心库，若要构建复杂应用只需在这基础上引入各式各样 Vue 插件</p>
<a id="more"></a>

<h2 id="Vue-特点"><a href="#Vue-特点" class="headerlink" title="Vue 特点"></a>Vue 特点</h2><p>（1）采用<strong>组件化</strong>模式，提高代码复用率、且让代码更好维护（.vue 文件中包含 html、css、js）</p>
<p>（2）<strong>声明式编码</strong>，让编码人员无需直接操作 DOM 提高开发效率（如原生js中命令式编码需要 forEach 遍历、document.getElementById 获取 DOM 元素，而声明式编码中只需 <code>&lt;li v-for&gt;</code> 即可）</p>
<p>（3）使用<strong>虚拟 DOM</strong> + 优秀的 <strong>Diff 算法</strong>，尽量复用 DOM 节点</p>
<p>（4）遵循 MVVM 模式</p>
<p>（5）编码简化，体积小，运行效率高，适合移动/PC端开发</p>
<p>（6）它本身只关注 UI，也可以引入其他第三方库开发项目</p>
<h2 id="创建-Vue-的基础"><a href="#创建-Vue-的基础" class="headerlink" title="创建 Vue 的基础"></a>创建 Vue 的基础</h2><p>（1）想让 Vue 工作，就必须创建一个 Vue 实例，且要传入一个配置对象</p>
<p>（2）root 容器里的代码依然符合 html 规范，只不过混入了一些特殊的 Vue 语法，如 <code>&#123;&#123;表达式或vue的data中的数据&#125;&#125;</code></p>
<p>（3）root 容器里的代码被称为【Vue 模板】</p>
<p>（4）Vue 实例和容器是一一对应的，一个 Vue 实例只能对应一个容器，一个容器只能对应一个 Vue 实例</p>
<p>（5）真实开发中只有一个 Vue 实例，并会配合组件一起使用</p>
<p>（6）一旦 data 中的数据发生改变，页面中用到该数据的地方也会自动更新</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>引入 Vue</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>html 部分</p>
<pre><code>&lt;!--准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const x = new Vue(&#123;
        el:&#39;#root&#39;, //el 用于指定当前 Vue 实例为哪个容器入伍，值通常为 css 选择器字符串，这里 &#39;#root&#39; 也可用 document.getElementById(&#39;root&#39;)
        data:&#123;  //data 中用于存储数据，数据供 el 指定的容器去使用，值这里暂时写成一个对象
            name:&#39;xxx&#39;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<h1 id="二、Vue-核心"><a href="#二、Vue-核心" class="headerlink" title="二、Vue 核心"></a>二、Vue 核心</h1><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>模板语法即 html 中包含了一些 js 语法代码，Vue 模板语法分为两类</p>
<p>（1）插值语法 <code>&#123;&#123;表达式&#125;&#125;</code></p>
<p>功能：用于解析标签体内容</p>
<p>（2）指令（以 v- 开头）</p>
<p>功能：用于解析标签（包括标签属性、标签体内容、绑定事件…）</p>
<p>如：v-bind:href=”表达式” 或 :href=”表达式”</p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="单向数据绑定"><a href="#单向数据绑定" class="headerlink" title="单向数据绑定"></a>单向数据绑定</h3><p>单项绑定（v-bind）：数据只能从 data 流向页面</p>
<p>当 data 中数据发生变化时，页面上使用该数据的地方也会发生相应变化</p>
<pre><code>&lt;input type=&quot;text&quot; v-bind:value=&quot;xxx&quot;&gt;</code></pre>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>双向绑定（v-model）：数据不仅能从 data 流向页面，还可以从页面流向 data</p>
<p>当 data 中数据发生变化时，页面上使用该数据的地方也会发生相应变化；同时，当页面上用户改变了该数据，则 data 中对应存储的该数据的值也会变</p>
<p>注意：v-model 只能应用在表单类元素（或输入元素）上，如 input、单选框、多选框、select、多行输入</p>
<pre><code>&lt;input type=&quot;text&quot; v-model:value=&quot;xxx&quot;&gt;</code></pre>
<p>注意：v-model:value 可简写为 v-model，因为 v-model 默认收集的就是 value 值</p>
<h2 id="el-和-data-的两种写法"><a href="#el-和-data-的两种写法" class="headerlink" title="el 和 data 的两种写法"></a>el 和 data 的两种写法</h2><p><strong>el 的两种写法：</strong></p>
<p>（1）new Vue 时配置 el 属性</p>
<p>（2）先创建 Vue 实例，再通过 vm.$mount(‘#root’) 指定 el 的值</p>
<pre><code>const vm = new Vue(&#123;
    //el:&#39;#root&#39;, //第一种写法
    data:&#123;
        name:&#39;xxx&#39;
    &#125;
&#125;)
vm.$mount(&#39;#root&#39;) //第二种写法</code></pre>
<p><strong>data 的两种写法：</strong></p>
<p>（1）对象式</p>
<p>（2）函数式</p>
<p>在组件中 data 必须使用函数式，否则会报错</p>
<pre><code>//对象式写法
const vm = new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        name:&#39;xxx&#39;
    &#125;
&#125;)
//函数式写法，必须返回一个对象，组件中必须使用函数式写法
const vm = new Vue(&#123;
    el:&#39;#root&#39;,
    data:function()&#123; //注意这里可简写成 data()&#123;...&#125;，但不能写成箭头函数
        console.log(this) //此处的 this 是 Vue 实例对象
        return&#123;
            name:&#39;xxx&#39;
        &#125;
    &#125;
&#125;)</code></pre>
<p>注意：由 Vue 管理的函数，一定不要写箭头函数，一旦写了箭头函数，this 就不再是 Vue 实例了，而会去外部找</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M：模型（Model），对应 data 中的数据</p>
<p>V：视图（View），模板</p>
<p>VM：视图模型（ViewModel），Vue 实例对象</p>
<p>data 中所有的属性，最后都出现在 vm 身上</p>
<p>vm 身上所有的属性及 Vue 原型上所有属性在 Vue 模板中都可以直接使用</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MVVM.png" alt="MVVM"></p>
<h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><h3 id="数据代理的基础知识"><a href="#数据代理的基础知识" class="headerlink" title="数据代理的基础知识"></a>数据代理的基础知识</h3><p>Object.defineProperty(对象,’属性名’,{配置项}) 方法给一个对象添加/定义一个属性名（ES 6 的语法）</p>
<p>通过该方法添加的属性默认是不能被枚举的（即不能被遍历，如 Object.keys(对象) 不能获取到那个属性），且添加的属性不可被修改、删除</p>
<p>通过添加配置 enumerable:true 后可被枚举</p>
<p>通过添加配置 writable:true 后可被修改</p>
<p>通过添加配置 configurable:true  后可被删除</p>
<pre><code>let person = &#123;
    name:&#39;xx&#39;,
    sex:&#39;男&#39;
&#125;
Object.defineProperty(person,&#39;age&#39;,&#123;
    value:18,
    enumerable:true,  //控制属性是否可被枚举，默认是 false
    writable:true, //控制属性是否可被修改，默认是 false
    configurable:true //控制属性是否可被删除，默认是 false
&#125;)</code></pre>
<p>通过 getter 使得属性和变量绑定，变量值改变则属性值也改变</p>
<p>通过 setter 改变属性的值</p>
<pre><code>let number = 18
let person = &#123;
    name:&#39;xx&#39;,
    sex:&#39;男&#39;
&#125;
Object.defineProperty(person,&#39;age&#39;,&#123;
    get:function()&#123;  //当读取 person 的 age 属性时（person.age），get 函数（getter）就会被调用，且返回值就是 age 的值
        return number
    &#125;,
    set(value)&#123;  //当修改 person 的 age 属性时（如 person.age = 19），set 函数（setter）就会被调用，且会收到修改的具体值
        number = value  //因为 getter 中 age 属性和 number 关联所以这里要修改 number 的值才行
    &#125;
&#125;)</code></pre>
<h3 id="数据代理-1"><a href="#数据代理-1" class="headerlink" title="数据代理"></a>数据代理</h3><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p>
<pre><code>let obj = &#123;x:100&#125;
let obj2 = &#123;y:100&#125;
//通过 obj2 操作 obj 中的 x
Object.defineProperty(obj2,&#39;x&#39;,&#123;
    get:function()&#123;
        return obj.x
    &#125;,
    set(value)&#123;
        obj.x = value
    &#125;
&#125;)</code></pre>
<h3 id="Vue-中的数据代理"><a href="#Vue-中的数据代理" class="headerlink" title="Vue 中的数据代理"></a>Vue 中的数据代理</h3><h4 id="Vue-中的数据代理-1"><a href="#Vue-中的数据代理-1" class="headerlink" title="Vue 中的数据代理"></a>Vue 中的数据代理</h4><p>Vue 中通过 vm 对象来代理 data 对象中属性的操作（读/写）</p>
<p>读取 vm 中属性时：ViewModel 中属性 —getter —&gt; data 中的属性</p>
<p>修改 vm 中属性时：ViewModel 中属性 —setter —&gt; data 中的属性</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.png" alt="数据代理"></p>
<p>上图中后边的橙色和紫色线就是 Vue 做的数据代理</p>
<p>Vue 把 data 中数据放到 vm 的 _data 属性中，即 vm._data = data（所以直接 vm.data 是 undefined），但这时要在模板（即视图 View ）中显示数据需要 <code>&#123;&#123;_data.name&#125;&#125;</code>，通过数据代理把数据放到 vm 上，这里还会做数据代理，就可以通过 <code>&#123;&#123;name&#125;&#125;</code> 来获取使用数据</p>
<h4 id="Vue-中数据代理的好处"><a href="#Vue-中数据代理的好处" class="headerlink" title="Vue 中数据代理的好处"></a>Vue 中数据代理的好处</h4><p>更加方便地操作 data 中数据</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>通过 Object.defineProperty 把 data 对象中所有属性添加到 vm 上</p>
<p>为每个添加到 vm 上的属性都指定一个 getter/setter</p>
<p>在 getter/setter 内部去操作（读/写）data 中对应的属性</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="事件的基本使用"><a href="#事件的基本使用" class="headerlink" title="事件的基本使用"></a>事件的基本使用</h3><p>（1）使用 <code>v-on:事件名</code> 或 <code>@事件名</code> 绑定事件</p>
<pre><code>@click：鼠标点击事件
@scroll：滚动条滚动事件
@wheel：鼠标滚轮滚动事件
@keydown：键盘按下
@keyup：键盘松开</code></pre>
<p>（2）事件的回调需要配置在 methods 对象中，最终会在 vm 上</p>
<p>（3）methods 中配置的函数不要用箭头函数，否则 this 就不是 vm 了</p>
<p>（4）methods 中配置的函数都是被 Vue 所管理的函数，this 的指向是 vm 或组件实例对象</p>
<p>（5）@click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参，$event 是 event 的占位符</p>
<p>（6）@事件名=”xxx” 其中 xxx 可以是简单的语句，但注意只能是对 vm 上有的东西进行操作，vm 上没有的不能进行操作，如 alert 语句就不行，因为 alert 在 window 上，vm 上没有 window，所以 vm 上没有 alert 方法，</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;button v-on:click=&quot;show&quot;&gt;不传参&lt;/button&gt;
        &lt;button @click=&quot;show2($event,123)&quot;&gt;传参&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;xxx&#39;
        &#125;,
        methods:&#123;
            show(event)&#123;
                console.log(event.target.innerText)
                console.log(this)  //此处的 this 是 vm（Vue 实例对象）
            &#125;
            show1:(event)=&gt;&#123;
                console.log(this)  //此处的 this 是 window
            &#125;
            show2(event,number)=&gt;&#123;
                console.log(event,number)
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;</code></pre>
<p>注意：受 Vue 管理的函数最好都写成普通函数，不要写箭头函数，因为 this 的问题</p>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>prevent：阻止默认事件，如 <code>&lt;a href=&quot;http://www.xxx.com&quot; @click.prevent=&quot;xxx&quot;&gt;</code> 这样点击后不会跳转，相当于在事件回调函数中写 event.preventDefault()</p>
<p>stop：给子元素添加，阻止事件冒泡，相当于在事件回调函数中写 event.stopPropagation()</p>
<p>once：事件只触发一次</p>
<p>capture：给父元素添加，使用事件的捕获模式，事件触发时是先捕获后冒泡所以子元素事件先响应后响应父元素事件，而给父元素添加 .capture 使得事件在捕获阶段就开始处理，即先响应父元素事件后响应子元素事件</p>
<p>self：只有 event.target 是当前操作的元素时才触发事件</p>
<p>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</p>
<p>注意：修饰符可以连续写</p>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>Vue 中常用的按键别名，使用方式 <code>@键盘事件.别名=&quot;回调函数&quot;</code>，如 <code>@keyup.enter=&quot;xxx&quot;</code> 表示按下回车时触发回调函数</p>
<pre><code>回车：enter
删除：delete（捕获“删除”和“退格”键）
退出：esc
空格：space
换行：tab（必须配合 keydown 使用）
上：up
下：down
左：left
右：right</code></pre>
<p>Vue 未提供别名的按键，可以使用按键原始的 key 值去绑定，但注意要转为 kebab-case（短横线命名，如 caps-lock）</p>
<p>系统修饰键（ctrl、alt、shift、meta（win键））用法特殊</p>
<pre><code>（1）配合 keyup 使用：先按下修饰键的同时再按下其他键，随后释放其他键，事件才被触发
（2）配合 keydown 使用：正常触发事件</code></pre>
<p>注意：系统修饰符可以连续写，如 <code>@keyup.ctrl.=&quot;xxx&quot;</code> 表示按下 ctrl + y</p>
<p>不推荐使用 keyCode（event.keyCode）去指定具体的按键，如 <code>@keyup.13=&quot;xxx&quot;</code></p>
<p>定制按键别名：<code>Vue.config.keyCodes.自定义键名 = 键码</code></p>
<h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>当模板中要显示的数据需要进行一些处理时若使用 <code>&#123;&#123;函数()&#125;&#125;</code>，则数据一改变，Vue 会重新解析模板，而插值中的函数会被重新调用，这导致效率低 </p>
<p>Vue 认为 data 中的数据就是属性，计算属性就是对属性进行处理，计算属性存放在 <code>computed:&#123;&#125;</code> 中</p>
<p><strong>计算属性：</strong>要显示的数据不存在，要通过计算已有<strong>属性</strong>（注意不是变量）计算得来</p>
<p><strong>原理：</strong>底层借助了 Object.defineproperty 方法提供的 getter 和 setter</p>
<p><strong>用法：</strong>（1）在 computed 对象中定义计算属性，计算属性必须写 get()（2）在页面中使用 <code>&#123;&#123;计算属性&#125;&#125;</code> 来显示计算的结果</p>
<p><strong>计算属性的优势：</strong>与 methods 来实现相比，计算属性内部有缓存机制（复用），当数据没有改变时直接读缓存，效率更高，调式方便</p>
<p>注意：计算属性最终会出现在 vm 上，直接读取使用即可，不用显式调用 .get()</p>
<p>若计算属性要被修改，则必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变</p>
<pre><code>data:&#123;
    firstName:&#39;xx&#39;,
    lastName:&#39;xxx&#39;
&#125;,
computed:&#123;
    fullName:&#123;
        get()&#123; //读取 fullName 时，get 就会被调用，且返回值作为 fullName 的值
        //get 被调用的时机：（1）初次读取 fullName 时（2）所依赖的数据发生变化时
            console.log(this) //此处 this 是 vm
            return this.firstName + &#39;-&#39; + this.lastName
        &#125;
        set(value)&#123; //修改 fullName 时，set 就会被调用
            ...
            this.firstName = xxx
            this.lastName = xxx
        &#125;
    &#125;
&#125;</code></pre>
<p>当计算属性<strong>只读不改时</strong>可简写如下</p>
<pre><code>data:&#123;
    firstName:&#39;xx&#39;,
    lastName:&#39;xxx&#39;
&#125;,
computed:&#123;
    fullName()&#123;  //这个函数可当计算属性的 getter 用
        return this.firstName + &#39;-&#39; + this.lastName
    &#125;
&#125;</code></pre>
<h2 id="监视-侦听属性-watch"><a href="#监视-侦听属性-watch" class="headerlink" title="监视/侦听属性 watch"></a>监视/侦听属性 watch</h2><p>监视属性可通过 vm 对象的 $watch() 或 watch 配置来监视指定的属性，当属性变化时，回调函数自动调用，在函数内部进行计算</p>
<p>监视属性必须存在才能进行监视</p>
<h3 id="监视的两种写法"><a href="#监视的两种写法" class="headerlink" title="监视的两种写法"></a>监视的两种写法</h3><p>方式一：在 new Vue 时传入 watch 配置，即在 vm 对象中使用 watch</p>
<pre><code>watch:&#123;
    isHot:&#123;
        immedeiate:true, //为 true 时使得初始化时让 handler 调用以下，默认时 false
        handler(newValue,oldValue)&#123; //当 isHot 发生改变时 handler 函数被调用
            console.log(newValue,oldValue)
        &#125;
    &#125;
&#125;</code></pre>
<p>方式二：通过 vm.$watch 监视</p>
<pre><code>vm.$watch(&#39;isHot&#39;,&#123;
    immedeiate:true, //为 true 时使得初始化时让 handler 调用以下，默认时 false
    handler(newValue,oldValue)&#123; //当 isHot 发生改变时 handler 函数被调用
        console.log(newValue,oldValue)
    &#125;
&#125;)</code></pre>
<h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h3><p>Vue 中 watch 默认不会监视对象内部值的改变（只监视一层）</p>
<p>配置 deep:true 可监视对象内部值的改变（监视多层）</p>
<p>注意：Vue 自身是可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以</p>
<p>考虑到性能效率问题，使用 watch 时根据数据的具体结构决定是否采用深度监视</p>
<pre><code>data:&#123;
    numbers:&#123;
        a:1,
        b:1
    &#125;
&#125;
watch:&#123;
    &#39;number.a&#39;:&#123; //监视多级结构中某个属性的变化，需要加上引号
        handler()&#123;
            console.log(&#39;a变了&#39;)
        &#125;
    &#125;
    numbers:&#123;
        deep:true, //监视多级结构中所有属性的变化，若不开启这个，则监视的是 numbers，不会监视 numbers 中的属性，而 numbers 是个对象，其中属性变化但该对象地址值不变所以 numbers 也被认为没变
        handler()&#123;
            console.log(&#39;numbers变了&#39;)
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="监视的简写"><a href="#监视的简写" class="headerlink" title="监视的简写"></a>监视的简写</h3><p>当 watch 配置项中只有 handler 时才能简写，使用简写就不能配置 immedeiate 和 deep 了</p>
<pre><code>watch:&#123;
    isHot(newValue,oldValue)&#123;
        console.log(newValue,oldValue,this) //这里 this 是 vm 对象，这里不能写箭头函数，若写箭头函数则 this 是 window
    &#125;
&#125;

vm.$watch(&#39;isHot&#39;,function(newValue,oldValue)&#123;
        console.log(newValue,oldValue,this) //这里 this 是 vm 对象，这里不能写箭头函数，若写箭头函数则 this 是 window
    &#125;
&#125;)</code></pre>
<h2 id="对比-computed-和-watch"><a href="#对比-computed-和-watch" class="headerlink" title="对比 computed 和 watch"></a>对比 computed 和 watch</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）computed 能完成的功能 watch 都可以完成</p>
<p>（2）watch 能完成的功能 computed 不一定能完成，如 watch 可以进行异步操作（如定时器等）</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>（1）所有被 Vue 管理的函数最好都写成普通函数，这样 this 才是指向 vm 或组件实例对象</p>
<p>（2）所有不被 Vue 管理的函数（如定时器的回调函数、ajax 的回调函数、Promise 的回调函数等）最好写成箭头函数，这样在这些回调函数中 this 的指向才是 vm 或组件实例对象</p>
<pre><code>watch:&#123;
    firstName(val)&#123;
        setTimeout(()=&gt;&#123;
            console.log(this) //写成箭头函数后就没有 this 了，会去外部找，这样 this 才是 vm 实例对象，若写普通函数，回调函数由 JS 引擎调用，this 就是 window
        &#125;,1000)
    &#125;
&#125;</code></pre>
<h2 id="绑定样式-class-和-style"><a href="#绑定样式-class-和-style" class="headerlink" title="绑定样式 class 和 style"></a>绑定样式 class 和 style</h2><p>当样式是动态变化时，class/style 绑定就是专门用来实现动态样式效果的技术</p>
<h3 id="class-绑定"><a href="#class-绑定" class="headerlink" title="class 绑定"></a>class 绑定</h3><p>class 样式写法：<code>class=&quot;xxx&quot;</code>，xxx 可以是字符串、对象、数组</p>
<p>（1）字符串写法<code>:class=&#39;data中定义的样式类字符串&#39;</code>适用于样式的类名不确定，需要动态指定的情况</p>
<p>（2）表达式是对象：<code>&#123;classA:isA,classB:isB&#125;</code>，适用于要绑定的样式个数、名字确定，但要动态决定用不用</p>
<pre><code>&lt;div :class=&quot;classObj&quot; @click=&quot;changeMood&quot;&gt;&lt;/div&gt;
//在 vm 中
data:&#123;
    classObj:&#123;
        classA:true,
        classB:false
    &#125;
&#125;
methods:&#123;
    changeMood()&#123;
        //修改 this.classArr
    &#125;
&#125;</code></pre>
<p>（3）表达式是数组：<code>[&#39;classA&#39;,&#39;classB&#39;]</code>，适用于要绑定的样式个数、名字不确定</p>
<pre><code>&lt;div :class=&quot;classArr&quot; @click=&quot;changeMood&quot;&gt;&lt;/div&gt;
//在 vm 中
data:&#123;
    classArr:[&#39;classA&#39;,&#39;classB&#39;]
&#125;
methods:&#123;
    changeMood()&#123;
        //修改 this.classArr
    &#125;
&#125;</code></pre>
<h3 id="style-绑定"><a href="#style-绑定" class="headerlink" title="style 绑定"></a>style 绑定</h3><p>（1）<code>:style=&quot;&#123;color:activeColor,fontSize:fontSize+&#39;px&#39;&#125;&quot;</code></p>
<p>（2）对象写法：<code>:style=&quot;styleObj&quot;</code></p>
<p>在 data 中定义 <code>styleObj:&#123;fontSize:&#39;40px&#39;&#125;</code></p>
<p>（3）数组写法1：<code>:style=&quot;[styleObj1,styleObj2]&quot;</code></p>
<p>在 data 中定义 <code>styleObj1:&#123;fontSize:&#39;40px&#39;&#125;,styleObj2:&#123;color:&#39;red&#39;&#125;</code></p>
<p>（4）数组写法2<code>:style=&quot;styleArr&quot;</code></p>
<p>在 data 中定义 <code>styleArr:[&#123;fontSize:&#39;40px&#39;&#125;,&#123;color:&#39;red&#39;&#125;]</code></p>
<h2 id="条件渲染-v-if-与-v-show"><a href="#条件渲染-v-if-与-v-show" class="headerlink" title="条件渲染 v-if 与 v-show"></a>条件渲染 v-if 与 v-show</h2><p>条件渲染指令</p>
<pre><code>（1）v-if 与 v-else、v-else-if，如&lt;div v-if=&quot;表达式&quot;&gt;x&lt;/div&gt;，而 v-else 后无需写判断
v-if 当不渲染时节点在 html 中不存在
v-if 与 v-else、v-else-if 节点需要连在一起写
（2）v-show，如&lt;div v-show=&quot;n===1&quot;&gt;x&lt;/div&gt;
v-show 实现时其实调整的是 display 属性，当不渲染时节点还在</code></pre>
<h3 id="比较-v-if-与-v-show"><a href="#比较-v-if-与-v-show" class="headerlink" title="比较 v-if 与 v-show"></a>比较 v-if 与 v-show</h3><pre><code>（1）v-if 不展示的 DOM 元素直接被移除，v-show 不展示的 DOM 元素未被移除，仅仅使用 display 样式隐藏掉，所以使用 v-if 的元素可能无法获取，而使用 v-show 一定可以获取到
（2）若要频繁切换 v-show 较好，因为 v-show 无论是否渲染，节点都在，只是通过 display 来控制是否显示，而若使用 v-if 就是不断向 DOM 中添加或删除节点，效率较低
（3）当条件不成立时，v-if 的所有子节点不会解析（在项目中使用）
（4）当 v-if 中成立时，v-else、v-else-if 中就不再判断直接掠过
（5）&lt;template&gt; 只能和 v-if 搭配，不能和 v-show 搭配（&lt;template&gt;在真正渲染时不会出现这一层）
&lt;template v-if=&quot;n===1&quot;&gt;
    &lt;h2&gt;a&lt;/h2&gt;
    &lt;h2&gt;b&lt;/h2&gt;
    &lt;h2&gt;c&lt;/h2&gt;
&lt;/template&gt;</code></pre>
<h2 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染 v-for"></a>列表渲染 v-for</h2><p>可使用 v-for 指令用于展示列表数据</p>
<p>v-for 可遍历数组、对象、字符串、指定次数</p>
<h3 id="v-for-的使用"><a href="#v-for-的使用" class="headerlink" title="v-for 的使用"></a>v-for 的使用</h3><p>遍历数组时 <code>v-for=&quot;(元素,index) in 数组&quot;</code></p>
<p>遍历对象时 <code>v-for=&quot;(value,key) in 对象&quot;</code></p>
<p>遍历字符串时 <code>v-for=&quot;(char,index) in 字符串&quot;</code></p>
<p>遍历对象时 <code>v-for=&quot;(number,index) in 数字&quot;</code></p>
<pre><code>&lt;ul&gt;
    &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;
        &#123;&#123;p.name&#125;&#125;,&#123;&#123;p.age&#125;&#125;
    &lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>注意：key 会在虚拟 DOM 中出现，在真实 DOM 中没有</p>
<h3 id="key-的作用与原理"><a href="#key-的作用与原理" class="headerlink" title="key 的作用与原理"></a>key 的作用与原理</h3><h4 id="react、vue-中的-key-的作用？（key-的内部原理）"><a href="#react、vue-中的-key-的作用？（key-的内部原理）" class="headerlink" title="react、vue 中的 key 的作用？（key 的内部原理）"></a>react、vue 中的 key 的作用？（key 的内部原理）</h4><p>在虚拟 DOM 中 key 的作用：</p>
<pre><code>key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】，
随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较</code></pre>
<p>【新虚拟 DOM】与【旧虚拟 DOM】的差异比较规则：</p>
<pre><code>（1）旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：
    a）若虚拟 DOM 中内容没变，直接使用之前的真实 DOM
    b）若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM
（2）旧虚拟 DOM 未找到与新虚拟 DOM 相同的 key，则创建新的真实 DOM，随后渲染到页面</code></pre>
<p>用 index 作为 key 可能会依法的问题：</p>
<pre><code>（1）若对数据进行逆序添加、逆序删除等破坏顺序操作会产生没必要的真实 DOM 更新，这样界面效果没问题但效率低
（2）若结构中包含输入类的 DOM，则会产生错误 DOM 更新，导致界面有问题</code></pre>
<p>当使用 index 作为 key 时</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index%E4%BD%9C%E4%B8%BAkey.png" alt="index作为key"></p>
<p>当使用 id 作为 key 时</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/id%E4%BD%9C%E4%B8%BAkey.png" alt="id作为key"></p>
<p>开发中如何选择 key：</p>
<pre><code>（1）最好使用每条数据的唯一标识作为 key，如 id、手机号、身份证号、学号等唯一值
（2）若不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表用于展示，那么使用 index 作为 key 是没问题的</code></pre>
<h2 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h2><p>computed 和 watch 都能实现，列表过滤一般用 computed 更省事，因为 watch 还需在 data 中定义一个要显示的数据的数组</p>
<pre><code>data:&#123;
    keyword:&#39;&#39;,
    persons:[&#123;id:&#39;001&#39;,name:&#39;aaa&#39;&#125;,&#123;id:&#39;002&#39;,name:&#39;bbb&#39;&#125;],
    filper:[]  //为使用 watch 定义的数组
&#125;,
computed:&#123;
    filtPersons()&#123;
        return this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(this.keyword)!==-1
        &#125;)
    &#125;
&#125;,
/*watch:&#123;
    keyword(val)&#123;
        this.filper = this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(val)!==-1
        &#125;)
    &#125;
&#125;*/</code></pre>
<h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><pre><code>data:&#123;
    keyword:&#39;&#39;,
    sortType:0, //0 原顺序，1 降序，2 升序
    persons:[&#123;id:&#39;001&#39;,name:&#39;aaa&#39;,age:17&#125;,&#123;id:&#39;002&#39;,name:&#39;bbb&#39;,age:18&#125;],
&#125;,
computed:&#123;
    filtPersons()&#123;
        const arr = this.persons.filter((p)=&gt;&#123;
            return p.name.indexOf(this.keyword)!==-1
        &#125;)
        if(this.sortType)&#123;
            arr.sort((p1,p2)=&gt;&#123; //sort 函数改变原数组
                return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
            &#125;)
        &#125;
        return arr
    &#125;
&#125;,</code></pre>
<h2 id="Vue-监测数据改变的底层原理"><a href="#Vue-监测数据改变的底层原理" class="headerlink" title="Vue 监测数据改变的底层原理"></a>Vue 监测数据改变的底层原理</h2><p>Vue 会监视 data 中所有层次的数据</p>
<h3 id="对象更新检测"><a href="#对象更新检测" class="headerlink" title="对象更新检测"></a>对象更新检测</h3><p>如何监测对象中的数据？</p>
<pre><code>通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据
（1）对象中后追加的属性，Vue 默认不做响应式处理
（2）如需给后添加的属性做响应式，要使用如下 API
    Vue.set(目标对象,要添加的属性名,属性值)
    this.$set(目标对象,要添加的属性名,属性值)</code></pre>
<p>若不是响应式的数据，该数据的添加和修改都不会引起 Vue 的重新解析模板</p>
<p>Vue 监测对象改变的原理类似如下，这里简化成对象只有一层，即对象的属性不为对象，Vue 真正工作时会逐层递归一直找下去找到所有对象</p>
<pre><code>let data = &#123;
    name:&#39;xx&#39;,
    address:&#39;北京&#39;
&#125;
//创建一个监视的实例对象，用于监视 data 中属性的变化
const obs = new Observer(data)
//准备一个 vm 实例对象
let vm = &#123;&#125;
vm._data = data = obs
function Observer(obj)&#123;
    //汇总对象中所有的属性形成一个数组
    const keys = Object.keys(obj)
    keys.forEach((k)=&gt;&#123;
        get()&#123;
            return obj[k]
        &#125;
        set(val)&#123;
            console.log(`$&#123;k&#125;被改了，这里会去解析模板，生成虚拟 DOM 等一些列工作...`)
            obj[k] = val
        &#125;
    &#125;)
&#125;</code></pre>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><p>如何监测对象中的数据？</p>
<pre><code>通过包裹数组更新元素的方法来实现，本质就是做了两件事
（1）调用原生对应的方法（如 push、pop、splice 等）对数组进行更新
（2）重新解析模板，进而更新页面</code></pre>
<p>在 Vue 修改数组中的元素一定要用如下方法</p>
<pre><code>（1）使用 API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()
（2）Vue.set(数组,索引,属性值) 或 this.$set(数组,索引,属性值)</code></pre>
<p>对于 data 中的数组（如 arr），若在代码中使用 arr[0]=xxx 来修改 arr 数组中的元素不奏效，在页面中对应显示的数据不更新，需要通过 <code>arr.splice(0,1,xxx)</code> 或 <code>Vue.set(arr,0,xxx)</code> 或 <code>this.$set(arr,0,xxx)</code> 来更新第一个元素</p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们将会触发视图更新，被包裹的方法包括：</p>
<pre><code>push()
pop()
shift()
unshift()
splice()
sort()
reverse()</code></pre>
<h2 id="Vue-set-或-vm-set"><a href="#Vue-set-或-vm-set" class="headerlink" title="Vue.set() 或 vm.$set()"></a>Vue.set() 或 vm.$set()</h2><p><code>Vue.set(目标对象,要添加的属性名,属性值)</code> 或 <code>vm.$set(目标对象,要添加的属性名,属性值)</code> 向响应式对象（即每个属性有 getter 和 setter）中添加一个属性（向 data 中的对象添加属性），并确保这个新的属性也是响应式的，且触发视图更新</p>
<p><code>Vue.set(数组,索引,属性值)</code> 或 <code>vm.$set(数组,索引,属性值)</code> 可修改数组中的元素</p>
<p><strong>注意：参数中目标对象不能是 Vue 实例或 Vue 实例的根对象（即 data 本身）</strong></p>
<pre><code>data:&#123;
    student:&#123;
        name:&#39;xx&#39;,
        age:18
    &#125;
&#125;
methods:&#123;
    addSex()&#123;
        this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
        //或 Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
    &#125;
&#125;</code></pre>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>数据劫持即给对象加上 getter 和 setter，若修改对象，对象上的 setter 劫持到数据变化后会更新数据然后重新解析 DOM 进行后续一系列操作</p>
<p>数据劫持的原理和数据代理一样也是依赖于 Object.defineProperty</p>
<p>数据劫持是响应式的根基</p>
<h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><p><strong>单行输入 text / 密码 password：</strong>v-model 收集的是 value 值，用户输入的就是 value 值</p>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;account&quot;/&gt;
在 data 中需设置
account:&#39;&#39;</code></pre>
<p><strong>单选 radio：</strong>v-model 收集的是 value 值，所以要给标签配置 value</p>
<pre><code>男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;male&quot;&gt;
女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;female&quot;&gt;
这里要写 value，否则 v-model 默认监听 checked，这样导致一个选中其他也会选中
在 data 中需设置
sex:&#39;female&#39;  //初始默认选女</code></pre>
<p><strong>多选 checkbox：</strong></p>
<p>当没有配置 input 的 value 属性时，收集的是 checked（是否勾选，布尔值），通过 v-model 的值可控制 checked</p>
<p>当配置了 input 的 value 属性时，收集的是 value 组成的数组</p>
<pre><code>学习&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;study&quot;&gt;
吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;eat&quot;&gt;
在 data 中需设置
hobby:[]

若只需知道是否勾选
&lt;input type=&quot;checkbox&quot; v-model=&quot;agree&quot;&gt;
在 data 中需设置
agree:&#39;&#39;</code></pre>
<p><strong>下拉框 select</strong></p>
<pre><code>&lt;select v-model=&quot;city&quot;&gt;
    &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;
    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
&lt;/select&gt;
在 data 中需设置
city:&#39;&#39;</code></pre>
<p><strong>多行输入</strong></p>
<pre><code>&lt;textarea v-model=&quot;other&quot;&gt;&lt;/textarea&gt;
在 data 中需设置
other:&#39;&#39;</code></pre>
<p><strong>表单提交</strong></p>
<pre><code>&lt;form @submit.prevent=&quot;handlerSubmit&quot;&gt;...&lt;/form&gt;

methods:&#123;
    handlerSubmit()&#123; //在表单提交时触发
        console.log(JSON.stringfy(this.useInfo))
    &#125;
&#125;</code></pre>
<p><strong>输入的类型限制</strong></p>
<pre><code>&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt;
其中 type=&quot;number&quot; 是原生的控制，使得用户在输入框中不能输入字母等，v-model.number 使得用户输入后 data 中的 age 为数字不为字符串，否则会默认用户输入的东西都存为字符串</code></pre>
<h3 id="v-model-的修饰符"><a href="#v-model-的修饰符" class="headerlink" title="v-model 的修饰符"></a>v-model 的修饰符</h3><p>v-model.number：输入字符串转为有效的数字</p>
<p>v-model.lazy：当输入框失去焦点时才更新 data 中的数据</p>
<p>v-model.trim：获取到的数据去除前后的空格</p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器可对要显示的数据进行特定格式化后再显示，适用于一些简单逻辑的处理，过滤器的本质是函数</p>
<p>语法：</p>
<pre><code>注册过滤器：Vue.filter(过滤器名,回调函数) 或 new Vue&#123;filters:&#123;...&#125;&#125;
使用过滤器：&#123;&#123;数据名 | 过滤器名&#125;&#125; 或 v-bind:属性 = &quot;数据名 | 过滤器名&quot;</code></pre>
<p>过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>注意：过滤后并没有改变原本的数据，而是产生新的对应的数据</p>
<pre><code>&lt;h2&gt;&#123;&#123;time|timeFormater&#125;&#125;&lt;/h2&gt;
这里会把 time 作为参数传给 timeFormater，得到返回值后替换掉 &#123;&#123;&#125;&#125; 中的内容
	<h2>&#123;&#123;time|timeFormater('YYYY_MM_DD')&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;time|timeFormater('YYYY_MM_DD')|mySlice&#125;&#125;&lt;/h2&gt;
这里会把 time 作为参数传给 timeFormater，得到返回值作为参数传给 mySlice，得到返回值后替换掉 &#123;&#123;&#125;&#125; 中的内容
	局部过滤器：在 vm 实例对象中定义过滤器
	filters:&#123;
		timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss')&#123;
			return dayjs(value).format(str)
		&#125;,
		mySlice(value)&#123;
			return value.slice(0,4)
		&#125;
	&#125;

	全局过滤器：在 new Vue 之前写定义过滤器
	Vue.filter('mySlice1',function(value)&#123;
		return value.slice(0,4)
	&#125;)


## 内置指令

	v-bind：单向绑定解析表达式可用冒号 : 来简写
	v-model：双向数据绑定
	v-for：遍历数字/对象/字符串
	v-on：绑定事件监听，可简写为 @
	v-if：条件渲染（动态控制节点是否存在）
	v-else：条件渲染（动态控制节点是否存在）
	v-show：条件渲染（动态控制节点是否显示）

### v-text

作用：向其所在的节点中渲染文本内容

v-text 不支持结构解析，即内容中的标签不能解析，只是当成字符串

	<div v-text="变量"></div>
	相当于 <div>&#123;&#123;变量&#125;&#125;&lt;/div&gt;</div></h2></code></pre>
<p>与插值语法的区别：v-text 会替换掉节点中的内容，而 <code>&#123;&#123;xx&#125;&#125;</code> 则不会，一般还是用插值语法更灵活</p>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>作用：向指定节点中渲染包含 html 结构的内容</p>
<p>v-html 支持结构解析，即内容中的标签可以解析</p>
<pre><code>&lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;
data:&#123;
    str:&#39;&lt;h2&gt;xxx&lt;/h2&gt;&#39;
&#125;
页面上能识别 h2 标签</code></pre>
<p>与插值语法的区别：</p>
<pre><code>（1）v-html 会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125; 则不会
（2）v-html 可以识别 html 结构</code></pre>
<p>注意：v-html 有安全性问题</p>
<pre><code>（1）在网站上动态渲染任意 html 是非常危险的，容易导致 XSS（冒充用户值守，即盗走用户的 cookie 就可以冒充用户）攻击
（2）一定要在可信的内容上使用 v-html，永远不用用在用户提交的内容上</code></pre>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>v-cloak 指令没有值，本质是一个特殊属性，Vue 实例创建完毕并接管容器后会删掉 v-loak 属性</p>
<p>使用 css 配置 v-cloak 可解决网速慢时页面展示出 <code>&#123;&#123;xxx&#125;&#125;</code> 的问题</p>
<pre><code>&lt;head&gt;
    &lt;style&gt;
        [v-cloak]&#123;
            display:none;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;xxxxx&quot;&gt;&lt;/script&gt; &lt;!--假设网速慢该资源请求很慢--&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue(&#123;...&#125;)
&lt;/script&gt;</code></pre>
<p>上述代码中若没有加 v-cloak，当请求资源的网速慢时，会先渲染没有经过 Vue 解析的 html，页面会显示 <code>&#123;&#123;name&#125;&#125;</code>，当请求的资源返回后才会创建 Vue 实例然后解析模板重新渲染，而加了 v-cloak，当请求的资源还没返回时，根据 css 中的设置，页面不会先渲染 <code>&#123;&#123;name&#125;&#125;</code>，这样用户体验更好</p>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>v-once 所在节点在初次动态渲染后就视为静态内容了，以后数据的改变不会引起 v-once 所在节点的更新，可以用于优化性能</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-once&gt;初始化的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;当前的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;</code></pre>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>v-pre 指令能跳过所在节点的编译过程（即 Vue 不会再去看该节点里有没有插值、指令等），可利用它跳过没有使用指令语法、插值语法的节点，会加快编译</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-pre&gt;这是个字符串&lt;/h2&gt;
    &lt;h2&gt;当前的 n 值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;</code></pre>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>定义语法：</p>
<pre><code>（1）局部指令
    new Vue(&#123;
        directives:&#123;指令名:配置对象&#125;
    &#125;)
    或
    new Vue(&#123;
        directives()&#123;指令名:回调函数&#125;
    &#125;)
（2）全局指令
    Vue.directive(指令名,配置对象)
    或
    Vue.directive(指令名,回调函数)</code></pre>
<p>配置对象中常用的 3 个回调</p>
<pre><code>（1）.bind：指令与元素成功绑定时调用
（2）.inserted：指令所在元素被插入页面时调用
（3）.update：指令所在模板结构被重新解析时调用</code></pre>
<p>注意：指令定义时不加 v-，使用时要加 v-</p>
<p>指令名若是多个单词，使用时用 kebab-case 命名方式（如 v-big-number），不要用 camelCase 命名，定义时可直接拼一起加引号（如 ‘bignumber’）</p>
<p>例子1：定义一个 v-big 指令，和 v-text 功能类似，但会把绑定的数值放大 10 倍</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;当前的 n 值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;h2&gt;放大 10 倍后的 n 值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;

new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        n:1
    &#125;,
    directives:&#123;
        //big 函数被调用的时机：（1）当指令与元素成功绑定时 big 函数会被调用（注意此时元素还没放入页面）（2）指令所在的模板被重新解析时
        big(element,binding)&#123; //第1个参数为 DOM 元素，第2个参数为绑定对象，将元素和指令进行绑定
            console.log(this) //这里的 this 是 window
            element.innerText = binding.value * 10
        &#125;
    &#125;
&#125;)</code></pre>
<p>例子2：定义一个 v-fbind 指令，和 v-bind 功能类似，但会把绑定的 input 元素默认获取焦点</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;
    &lt;button @click=&quot;n++&quot;&gt;点击+1&lt;/button&gt;
&lt;/div&gt;

new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        n:1
    &#125;,
    directives:&#123;
        fbind:&#123;
            //指令与元素成功绑定时（一上来，还没放到页面）
            bind(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update(element,binding)&#123;
                console.log(this) //这里的 this 是 window
                element.value = binding.value
            &#125;
        &#125;
    &#125;
&#125;)</code></pre>
<p>注意：上面两个例子定义的指令是局部指令，只能在当前 Vue 实例中使用</p>
<p>例子3：全局指令</p>
<pre><code>Vue.directive(&#39;big&#39;,function(element,binding)&#123;
    element.innerText = binding.value * 10
&#125;)

Vue.directive(&#39;fbind&#39;,&#123;
    //指令与元素成功绑定时（一上来，还没放到页面）
    bind(element,binding)&#123;
        element.value = binding.value
    &#125;,
    //指令所在元素被插入页面时
    inserted(element,binding)&#123;
        element.focus()
    &#125;,
    //指令所在的模板被重新解析时
    update(element,binding)&#123;
        element.value = binding.value
    &#125;
&#125;)</code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期又称为生命周期回调函数、生命周期函数、生命周期钩子，是 Vue 在关键时刻调用的一些特殊名称的函数</p>
<p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</p>
<p>生命周期函数中的 this 指向是 vm 或 组件实例对象</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" alt="生命周期1"></p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" alt="生命周期2"></p>
<p>beforeCreate()：将要创建，是指数据监测、数据代理创建之前，即还没有 _data</p>
<p>created()：创建完毕</p>
<p>beforeMount()：将要挂载</p>
<p>mounted()：挂载完毕，Vue 完成模板解析并把初始的真实 DOM 元素放入页面后（挂载完毕）调用 mounted，mounted 函数中的 this 为 Vue 实例对象（vm）或 组件实例对象，在 mounted 中完成发生 ajax 请求、启动定时器、绑定自定义事件、订阅消息等初始化操作</p>
<p>beforeUpdate()：将要更新</p>
<p>Updated()：更新完毕</p>
<p>beforeDestroy()：将要销毁，在这完成如清除定时器、解绑自定义事件、取消订阅消息等收尾工作</p>
<p>destroyed()：销毁完毕</p>
<p>vm.$destroy()：用于完全销毁一个实例，清理它与其他实例的连接，解绑它的全部指令及自定义事件的监听器（注意不会解绑原生 DOM 事件，如 click 等），触发 beforeDestroy 和 Destroy 的钩子。一般不用 vm.$destroy 方法，最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期</p>
<p>关于销毁 Vue 实例：</p>
<pre><code>（1）销毁后借助 Vue 开发者工具看不到任何信息
（2）销毁后自定义事件会失效，但原生 DOM 事件依然有效（如 click，继续点击依然会触发，但数据、页面不更新）
（3）一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了</code></pre>
<h1 id="三、Vue-组件化编程"><a href="#三、Vue-组件化编程" class="headerlink" title="三、Vue 组件化编程"></a>三、Vue 组件化编程</h1><h2 id="模块与组件、模块化与组件化"><a href="#模块与组件、模块化与组件化" class="headerlink" title="模块与组件、模块化与组件化"></a>模块与组件、模块化与组件化</h2><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块向外提供特定功能的 js 程序，一般就是一个 js 文件</p>
<p>作用：由于 js 文件很多很复杂所以通过模块化可复用 js，简化 js 的编写，提高 js 运行效率</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是用来实现局部特定功能效果的代码和资源的集合（如 html、css、js、image 等）</p>
<p>作用：由于一个界面的功能很复杂，通过组件可复用编码，简化项目编码，提高运行效率</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>当应用中的 js 都以模块来编写的，这个应用就是一个模块化的应用</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>当应用中的功能都是多组件的方式来编写的，这个应用就是一个组件化的应用</p>
<h2 id="Vue-中使用组件"><a href="#Vue-中使用组件" class="headerlink" title="Vue 中使用组件"></a>Vue 中使用组件</h2><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>一个单词时的两种写法</p>
<pre><code>（1）首字母小写
（2）首字母大写</code></pre>
<p>多个单词时的两种写法</p>
<pre><code>（1）kebab-case 命名，如 my-school
（2）CamelCase 命名，如 MySchool（需要 Vue 脚手架）</code></pre>
<p>组件名尽可能回避 html 中已有的元素名称</p>
<p>可再定义组件时使用 name 配置项指定组件在开发者工具中呈现的名字</p>
<h3 id="组件标签"><a href="#组件标签" class="headerlink" title="组件标签"></a>组件标签</h3><p>两种写法</p>
<pre><code>（1）&lt;school&gt;&lt;/school&gt;
（2）&lt;school/&gt;</code></pre>
<p>不使用脚手架时 <code>&lt;school/&gt;</code> 会导致后续组件不能渲染</p>
<h3 id="三大步骤"><a href="#三大步骤" class="headerlink" title="三大步骤"></a>三大步骤</h3><p>（1）定义组件（创建）</p>
<p>（2）注册组件</p>
<p>（3）使用组件（写组件标签）</p>
<h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4><p>使用 <code>const xxx = Vue.extend(options)</code> 或简写 <code>const xxx = options</code> 创建，其中 options 和 new Vue(options) 时传入的那个 options 几乎一样，但也有区别如下：</p>
<p>（1）el 不要写，因为最终所有的组件都要经过一个 vm 管理，由 vm 中的 el 决定服务哪个容器</p>
<p>（2）data 必须写成函数，因为避免组件被复用时，数据存在引用关系（即一个组件中数据变量另一个也变）</p>
<p>备注：使用 template 可以配置组件结构</p>
<h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><p>（1）局部注册：靠 new Vue 的时候传入 components 选项</p>
<p>（2）全局注册：靠 Vue.component(‘组件名’,组件)</p>
<h4 id="编写组件标签"><a href="#编写组件标签" class="headerlink" title="编写组件标签"></a>编写组件标签</h4><p>如</p>
<pre><code>&lt;school&gt;&lt;/school&gt;</code></pre>
<h2 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h2><p>非单文件组件即一个文件中包含有 n 个组件</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;
    &lt;school&gt;&lt;/school&gt;
&lt;/div&gt;

//创建组件
const school = Vue.extend(&#123;
    //组件定义时，一定不要定义 el 配置项，因为最终所有的组件都要被一个 vm 管理，由 vm 决定服务于哪个容器
    template:`
        &lt;div&gt;&#123;&#123;schoolName&#125;&#125;&lt;/div&gt;
    `,
    data()&#123;  //data 一定要用函数式，避免使用对象式导致当前组件改变数据后复用的组件中数据也被改变
        return &#123;
            schoolName:&#39;xxx&#39;
        &#125;
    &#125;,
    methods:&#123;
        showName()&#123;
            console.log(xxx)
        &#125;
    &#125;
&#125;)
const student = Vue.extend(&#123;...&#125;)
//全局注册组件
Vue.component(&#39;student&#39;,student)
//创建 vm
new Vue(&#123;
    el:&#39;#root&#39;,
    data:&#123;
        msg:&#39;hello&#39;
    &#125;,
    //注册组件（局部注册），这种方式用的多
    components:&#123;
        school:school
    &#125;
&#125;)</code></pre>
<h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>单文件组件即一个文件中只包含有 1 个组件，单文件组件后缀都是 .vue</p>
<pre><code>&lt;template&gt;
    &lt;!--组件的结构--&gt;
    &lt;div class=&quot;xxx&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    //组件交互相关的代码（data、methods 等）
    export default&#123;
        name:&#39;xx&#39;,
        data()&#123;return&#123;...&#125;&#125;
    &#125;
&lt;/script&gt;
&lt;style&gt;
    /*组件的样式*/
    .xxx&#123;...&#125;
&lt;/style&gt;</code></pre>
<p>在 App.vue 中</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;xxx&gt;&lt;/xxx&gt;
        &lt;xxxx&gt;&lt;/xxxx&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import xxx from &#39;./xxx.vue&#39;
    import xxxx from &#39;./xxxx.vue&#39;
    export default&#123;
        name:&#39;xx&#39;,
        components:&#123;xxx,xxxx&#125;
    &#125;
&lt;/script&gt;</code></pre>
<p>在 main.js 文件中</p>
<pre><code>import App from &#39;./App.vue&#39;

new Vue(&#123;
    el:&#39;#root&#39;,
    template:`&lt;App&gt;&lt;/App&gt;`,
    components:&#123;App&#125;
&#125;)</code></pre>
<p>在 html 文件中</p>
<pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; </code></pre>
<h2 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h2><p>在组件定义中可使用 components 配置项添加子组件</p>
<pre><code>const child = Vue.extend(&#123;...&#125;)
const father = Vue.extend(&#123;
    name:&#39;father&#39;,
    template:`&lt;child&gt;&lt;/child&gt;`,
    data()&#123;return &#123;...&#125;&#125;,
    components:&#123;child&#125;
&#125;)</code></pre>
<p>在开发中一般会定义一个 app 组件用于管理所有组件，即作为所有组件的祖先，一人之下（vm 之下）万人之上（其他组件）</p>
<h2 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h2><p>school <strong>组件的本质是</strong>一个名为 VueComponent 的<strong>构造函数</strong>，且不是程序员定义的，是 Vue.extend 生成的</p>
<p>只需要写 <code>&lt;school&gt;&lt;/school&gt;</code> 或 <code>&lt;school/&gt;</code>，Vue  解析时会创建 school 组件的实例对象，即 Vue 会自动执行 <code>new VueComponent(options)</code><br>注意每次调用 Vue.extend 返回的都是一个全新的 VueComponent</p>
<h2 id="关于-this-指向"><a href="#关于-this-指向" class="headerlink" title="关于 this 指向"></a>关于 this 指向</h2><p>组件配置中</p>
<pre><code>data函数、methods中的函数、watch中的函数、computed中的函数，它们的 this 都是【VueComponent 实例对象】</code></pre>
<p>new Vue(options) 配置中</p>
<pre><code>data函数、methods中的函数、watch中的函数、computed中的函数，它们的 this 都是【Vue 实例对象】</code></pre>
<p>VueComponent 的实例对象即为组件实例对象，本文简称vc，Vue 的实例对象，本文简称 vm</p>
<h2 id="Vue-实例与组件实例"><a href="#Vue-实例与组件实例" class="headerlink" title="Vue 实例与组件实例"></a>Vue 实例与组件实例</h2><p>组件是可复用的 Vue 实例，因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，如 data、computed、watch、methods 以及生命周期钩子等</p>
<p>仅有的例外是 el 是 Vue 实例特有的选项，且组件中 data 必须是一个函数，因此每个实例可维护一份被返回对象的独立的拷贝</p>
<h2 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h2><p>一个重要的内置:</p>
<pre><code>VueComponent.prototype.__proto__ === Vue.prototype</code></pre>
<p>为什么要由这个关系：让组件实例对象（vc）可访问到 Vue 原型上的属性、方法</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB.png" alt="重要的内置关系"></p>
<p>上图中 VueComponent.prototype.<strong>proto</strong> 本应指向 Object 的原型对象上，但 Vue 中把它指向了 Vue 的原型对象，这就是 VueComponent.prototype.<strong>proto</strong> === Vue.prototype</p>
<h1 id="四、Vue-脚手架"><a href="#四、Vue-脚手架" class="headerlink" title="四、Vue 脚手架"></a>四、Vue 脚手架</h1><p>Vue 脚手架（Vue CLI，Vue command line interface）是 Vue 官方提供的标准化开发工具（开发平台）</p>
<p>Vue 脚手架隐藏了所有 webpack 相关的配置，若项查看具体的 webpack 配置可执行 <code>vue inspect &gt; output.js</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>全局安装 <code>npm install -g @vue/cli</code></p>
<p>切换到要创建项目的目录后</p>
<p>创建 Vue 项目 <code>vue create xxx</code></p>
<p>启动项目 <code>npm run serve</code></p>
<p>执行 <code>npm run serve</code> 后先去执行项目的入口文件 main.js </p>
<h2 id="main-js-中的-render-函数"><a href="#main-js-中的-render-函数" class="headerlink" title="main.js 中的 render 函数"></a>main.js 中的 render 函数</h2><p>vue.js 与 vue.runtime.xxx.js 的区别：</p>
<pre><code>（1）vue.js 是完整版的 Vue，包含核心功能 + 模板解析器
（2）vue.runtime.xxx.js 是运行版的 Vue，只包含核心功能，没有模板解析器</code></pre>
<p>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容</p>
<p>因此 Vue 2 中的 main.js </p>
<pre><code>new Vue(&#123;
    el:&#39;#app&#39;,
    render: h =&gt; h(App)
&#125;)</code></pre>
<p>在 main.js 中 <code>import Vue form &#39;vue&#39;</code> 引入的 Vue 根据 node_modules/vue/package.json 中 module 配置，引入的是 node_modules/vue/dist/vue.runtime.esm.js，这是个残缺的 vue，完整的 vue 在 vue.js 中，该文件包含 vue 核心和模板解析器</p>
<p>其中 <code>render: h =&gt; h(App)</code> 即</p>
<pre><code>render(createElement)&#123;
    return createElement(&#39;h1&#39;,&#39;hello&#39;)
&#125;</code></pre>
<h2 id="修改脚手架默认配置"><a href="#修改脚手架默认配置" class="headerlink" title="修改脚手架默认配置"></a>修改脚手架默认配置</h2><pre><code>vue inspect &gt; output.js</code></pre>
<p>上述命令可输出 vue 脚手架的默认配置到 output.js 文件，但只是输出给程序查看，修改 output.js 文件无效</p>
<p>可通过 vue.config.js 文件自定义脚手架配置，该文件需要创建在和 package.json 同级的目录下，该文件会被 @vue/cli-service 自动加载，详情可见<a href="https://cli.vuejs.org/zh/config/">官方文档</a></p>
<pre><code>module.exports = &#123;
    pages:&#123;
        index:&#123;
            //入口文件
            entry:&#39;src/main.js&#39;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><p>ref 属性被用来给元素或子组件注册引用信息（id 的替代者）</p>
<p>ref 属性应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</p>
<pre><code>&lt;h1 ref=&quot;xxx&quot;&gt;xxx&lt;/h1&gt;
&lt;组件 ref=&quot;xxxx&quot;&gt;&lt;/组件&gt;

通过 this.$refs.xxx 来获取，相当于原生中 document.getElementById(&#39;xxx&#39;)</code></pre>
<h2 id="props-配置"><a href="#props-配置" class="headerlink" title="props 配置"></a>props 配置</h2><p>props 让组件接收外部传来的数据</p>
<p>props 是只读的，Vue 底层会监测对 props 值的修改，若进行了修改就会发出警告</p>
<p>若确实需要修改，则需赋值 props 的内容到 data 中（Vue 底层实现时先接收到 props 数据后定义 data，若有重名也是 props 优先级高于 data，虽然这不允许控制台会报错），如在 data 中定义 <code>name:this.name</code>，后者的 name 就是 props 接收到的 name，然后去修改 data 中的数据</p>
<p><strong>传递数据：</strong></p>
<p>在父组件中使用子组件</p>
<pre><code>&lt;子组件 name=&quot;xxx&quot; sex=&quot;女&quot; :age=&quot;18&quot;&gt;</code></pre>
<p><strong>接收数据：</strong></p>
<p>在子组件中</p>
<pre><code>&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;sex&#125;&#125;&lt;/h2&gt;
&lt;h2&gt;&#123;&#123;age+1&#125;&#125;&lt;/h2&gt;

//简单声明接收
props:[&#39;name&#39;,sex&#39;,&#39;age&#39;]
//接收的同时对数据进行类型限制
props:&#123;
    name:String,
    sex:String,
    age:Number
&#125;
//接收的同时对数据进行类型限制 + 默认值的指定 + 必要性的限制
props:&#123;
    name:&#123;
        type:String, //name 的类型是字符串
        required:true  //name 是必要的
    &#125;,
    sex:&#123;
        type:String,
        required:true
    &#125;,
    age:&#123;
        type:Number, //name 的类型是字符串
        default:100
    &#125;
&#125;</code></pre>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin 混入"></a>mixin 混入</h2><p>mixin（混入）可以把多个组件共用的配置提取成一个混入对象</p>
<p>使用方式：</p>
<p>（1）定义混合</p>
<pre><code>&#123;
    data()&#123;...&#125;
    methods:&#123;...&#125;
&#125;</code></pre>
<p>（2）使用混入</p>
<pre><code>1）全局混入：在 main.js 中添加 
import &#123;xxx&#125; from &#39;../mixin.js&#39;
Vue.mixin(xxx)
2）局部混入：在组件中添加
import &#123;xxx&#125; from &#39;../mixin.js&#39;
mixins:[&#39;xxx&#39;]</code></pre>
<p>创建 src/mixin.js 文件</p>
<pre><code>export const mixin = &#123;
    methods:&#123;
        showName()&#123;
            console.log(this.name)
        &#125;
    &#125;,
    mounted()&#123;
        console.log(&#39;hello&#39;)
    &#125;
&#125;
export const mixin2 = &#123;
    data()&#123;return&#123;...&#125;&#125;
&#125;</code></pre>
<p>在组件中</p>
<pre><code>import &#123;mixin,mixin2&#125; from &#39;../mixin.js&#39;

export default&#123;
    name:&#39;组件名&#39;,
    data()&#123;return&#123;...&#125;&#125;
    mixins:[mixin,mixin2]
&#125;</code></pre>
<p>组件中和混入中都有定义的东西会合并起来使用（若 data 或 methods 等重名了以组件中定义的为主），而同一生命周期函数两者定义的都会调用，且混合中定义的先调用</p>
<h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件用于增强 Vue</p>
<p>Vue 的插件本质是个对象，并且该对象中必须包含 install，install 的第一个参数是 Vue 构造函数，第二个及之后的参数是插件使用者传递的数据</p>
<p>新建文件 src/plugins.js 定义插件</p>
<pre><code>export default &#123;
    install(Vue,a,b,c)&#123; //第一个参数是 Vue 构造函数
        console.log(a,b,c)
        //全局过滤器
        Vue.filter(&#39;xxx&#39;,function(value)&#123;...&#125;)
        //定义全局指令
        Vue.directive(&#39;xxx&#39;,&#123;...&#125;)
        //定义混入
        Vue.mixin(&#123;...&#125;)
        //给 Vue 原型上添加一个方法（vm 和 vc 就都能用了）
        Vue.prototype.xxx = () =&gt; &#123;...&#125;
        Vue.prototype.$myMethod = function()&#123;...&#125;
        Vue.prototype.$myProperty = xxx
    &#125;
&#125;</code></pre>
<p>在 main.js 文件中使用插件</p>
<pre><code>import plugins from &#39;./plugins.js&#39;
//应用/使用插件
Vue.use(plugins,1,2,3)</code></pre>
<p>在组件中可直接使用插件中定义的东西</p>
<h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><p>scoped 样式让样式在局部生效，即在组件内部生效，防止各组件间样式的冲突</p>
<pre><code>&lt;style scoped&gt;&lt;/style&gt;</code></pre>
<h2 id="组件化编码流程"><a href="#组件化编码流程" class="headerlink" title="组件化编码流程"></a>组件化编码流程</h2><p>（1）拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突</p>
<p>（2）实现动态组件：考虑好数据的存放位置</p>
<pre><code>数据若是一个组件在用：放在组件自身即可
数据若是多个组件再用：放在它们共同的父组件上（状态提升）</code></pre>
<p>（3）实现交互：从绑定事件开始</p>
<h2 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h2><p>组件的自定义事件是一种组件间通信的方式，适用于子组件给父组件传数据</p>
<p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据就要在 A 中给 B 绑定自定义事件（事件的回调在 A 中），在 B 中触发该事件</p>
<h3 id="绑定自定义事件"><a href="#绑定自定义事件" class="headerlink" title="绑定自定义事件"></a>绑定自定义事件</h3><p>通过父组件给子组件传递函数类型的 props 实现子给父传递数据</p>
<pre><code>在父组件中
&lt;子组件 :参数名=&quot;父组件中的函数&quot;/&gt;
父组件中的函数(xxx)&#123;&#125;

在子组件中
props:[&#39;收到的参数名&#39;]
this.收到的参数名(xxx) //调用父组件函数来给父组件传数据</code></pre>
<p>通过父组件给子组件绑定一个自定义事件实现子给父传递数据（第一种写法，使用 @ 或 v-on）</p>
<pre><code>在父组件中绑定自定义事件
&lt;子组件 @自定义事件名=&quot;父组件中的函数&quot;/&gt;
//若想只触发一次:
//&lt;子组件 @自定义事件名.once=&quot;父组件中的函数&quot;/&gt;
父组件中的函数(xxx)&#123;&#125;

在子组件中触发自定义事件
this.$emit(&#39;父组件自定义的事件名&#39;,数据) //作为点击等事件的回调函数使用，就会触发父组件中自定义的事件从而执行父组件中的函数</code></pre>
<p>通过父组件给子组件绑定一个自定义事件实现子给父传递数据（第二种写法，使用 ref）</p>
<pre><code>在父组件中绑定自定义事件
&lt;子组件 ref=&quot;子组件别名&quot;/&gt;
mounted()&#123;
    this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,this.父组件中的函数)
    //若想只触发一次：
    //this.$refs.子组件.$once(&#39;父组件自定义的事件名&#39;,this.父组件中的函数)
    //this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,function(xx)&#123;...//这里的 this 是触发事件的子组件实例对象&#125;)
    //this.$refs.子组件.$on(&#39;父组件自定义的事件名&#39;,(xx)=&gt;&#123;...//这里的 this 是父组件实例对象&#125;)
&#125;</code></pre>
<p>父组件中的函数若要接收多个数据 <code>父组件中的函数(name,...param)&#123;...&#125;</code>，params 中就是第一个参数之后的所有参数都在 params 数组中</p>
<p>组件上也可以绑定原生 DOM 事件，需要使用 native 修饰符</p>
<p>通过 <code>this.$refs.子组件.$on(&#39;xxx&#39;,回调)</code> 绑定自定义事件时，回调要么在 methods 中，要么用箭头函数，否则 this 指向会出问题</p>
<h3 id="解绑自定义事件"><a href="#解绑自定义事件" class="headerlink" title="解绑自定义事件"></a>解绑自定义事件</h3><p>解绑一个自定义事件</p>
<pre><code>在子组件中
this.$off(&#39;父组件自定义的事件名&#39;)</code></pre>
<p>解绑多个自定义事件</p>
<pre><code>在子组件中
this.$off([&#39;父组件自定义的事件名1&#39;,&#39;父组件自定义的事件名2&#39;])</code></pre>
<p>解绑所有自定义事件</p>
<pre><code>在子组件中
this.$off()</code></pre>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、若在组件中 <code>this.$destroy()</code> 销毁当前组件实例，销毁后所有该实例自定义事件全都不奏效</p>
<p>2、若在子组件上绑定 click 事件 <code>&lt;子组件 @click=&quot;xxx&quot;&gt;</code> 不会触发原生 click 事件，而是会把 click 看成自定义事件，需要在子组件中使用 <code>this.$emit(&#39;click&#39;)</code> 才能触发点击事件</p>
<p>3、若要给子组件绑定原生 click 事件可添加 .native，即 <code>&lt;子组件 @click.native=&quot;xxx&quot;&gt;</code> 即可直接触发点击事件无需使用 $emit 触发</p>
<h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>全局事件总线是一种组件间通信的方式，适用于任意组件间通信</p>
<p>（1）安装全局事件总线：在 main.js 中</p>
<pre><code>new Vue(&#123;
    beforeCreate()&#123;
        Vue.prototype.$bus = this //安装全局事件总线
    &#125;
&#125;)</code></pre>
<p>（2）若组件1想接收数据，在组件1中绑定自定义事件到 $bus 组件实例对象上，事件的回调写在组件1自身</p>
<pre><code>mounted()&#123;
    this.$bus.$on(&#39;自定义事件名&#39;,(data)=&gt;&#123;
        console.log(&#39;组件1收到数据&#39;,data)
    &#125;)
&#125;

或
methods()&#123;
    demo(data)&#123;...&#125;
&#125;
mounted()&#123;
    this.$bus.$on(&#39;自定义事件名&#39;,this.demo)
&#125;</code></pre>
<p>（3）在组件2中触发自定义事件给组件1传数据</p>
<pre><code>this.$bus.$emit(&#39;自定义事件名&#39;,数据)</code></pre>
<p>（4）在组件1组件实例销毁之前解绑当前组件用到的自定义事件</p>
<pre><code>beforeDestroy()&#123;
    this.$bus.$off(&#39;自定义事件名&#39;)
&#125;</code></pre>
<h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>消息订阅与发布是一种组件间通信的方式，适用于任意组件间通信</p>
<p>消息订阅与发布借助于 pubsub-js 库</p>
<p>安装 <code>npm install i pubsub-js -D</code></p>
<p>在接收数据的组件中订阅消息</p>
<pre><code>import pubsub from &#39;pubsub-js&#39;

mounted()&#123;
    const pubId = pubsub.subscribe(&#39;消息名&#39;,(msgName,data)=&gt;&#123; //第一个参数是消息名，第二个参数是数据
        consoe.log(this) //这里 this 是组件实例对象
    &#125;)
&#125;

或
methods()&#123;
    demo(msgName,data)&#123;...&#125;
&#125;
mounted()&#123;
    const pubId = pubsub.subscribe(&#39;消息名&#39;,this.demo)
&#125;</code></pre>
<p>在发送数据的组件中发送数据</p>
<pre><code>import pubsub from &#39;pubsub-js&#39;
mounted()&#123;
    pubsub.publish(&#39;消息名&#39;,数据)
&#125;</code></pre>
<p>在接收数据的组件中取消订阅</p>
<pre><code>beforeDestroy()&#123;
    pubsub.unsubscribe(this.pubId)
&#125;</code></pre>
<h2 id="Vue-封装的过度与动画"><a href="#Vue-封装的过度与动画" class="headerlink" title="Vue 封装的过度与动画"></a>Vue 封装的过度与动画</h2><p>过度与动画的作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名</p>
<p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E7%94%BB.png" alt="动画"></p>
<p>写法：</p>
<p>（1）准备好样式</p>
<pre><code>元素进入的样式
v-enter：进入的起点
v-enter-acitve：进入过程中
v-enter-to：进入的终点

元素离开的样式
v-leave：离开的起点
v-leave-acitve：离开过程中
v-leave-to：离开的终点</code></pre>
<p>（2）使用 <code>&lt;transition&gt;</code> 包裹要过度的元素，并配置 name 属性</p>
<p>（3）若有多个元素需要过度，则使用 <code>&lt;transition-group&gt;</code>，且每个元素都要指定 key 值 </p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>例子：实现组件相左滑动离开页面以及从页面外向右滑动进来</p>
<p>方式一：使用 css 实现</p>
<pre><code>@keyframes xxx&#123;
    from&#123;
        transform: translateX(-100%);
    &#125;
    to&#123;
        transform: translateY(0px);
    &#125;
&#125;
.come&#123;
    animation: xxx 1s;
&#125;
.go&#123;
    animation: xxx 1s reverse;
&#125;</code></pre>
<p>方式二：在 Vue 中实现</p>
<pre><code>&lt;transition appear&gt; &lt;!--若添加 appear 属性则页面一渲染就会自动播放动画，真实 DOM 中没有 transition--&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;hello&lt;/h1&gt;
&lt;/transition&gt;

@keyframes xxx&#123;
    from&#123;
        transform: translateX(-100%);
    &#125;
    to&#123;
        transform: translateY(0px);
    &#125;
&#125;
//进入的过程
.v-enter-active&#123; //若在 &lt;transition&gt; 中设置了 name 属性为 xxxx，这里的类需要写成 .xxxx-enter-active
    animation: xxx 1s;
&#125;
//离开的过程
.v-leave-active&#123; //若在 &lt;transition&gt; 中设置了 name 属性为 xxxx，这里的类需要写成 .xxxx-leave-active
    animation: xxx 1s reverse;
&#125;</code></pre>
<h3 id="过度效果"><a href="#过度效果" class="headerlink" title="过度效果"></a>过度效果</h3><pre><code>&lt;transition name=&quot;demo&quot; appear&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;hello&lt;/h1&gt;
&lt;/transition&gt;

h1&#123;
    transition: 1s linear;
&#125;
//进入的起点
.demo-enter&#123;
    transform: translateX(-100%);
&#125;
//进入的终点
.demo-enter-to&#123;
    transform: translateX(0);
&#125;
//离开的起点
.demo-leave&#123;
    transform: translateX(0);
&#125;
//离开的终点
.demo-leave-to&#123;
    transform: translateX(-100%);
&#125;</code></pre>
<p>上述样式可简写为</p>
<pre><code>//进入的起点、离开的终点
.demo-enter,.demo-leave-to&#123;
    transform: translateX(-100%);
&#125;
//进入的终点、离开的起点
.demo-enter-to,.demo-leave&#123;
    transform: translateX(0);
&#125;
.demo-enter-active,.demo-leave-active&#123;
    transition: 1s linear;
&#125;</code></pre>
<p>若多个元素有同样的过度效果</p>
<pre><code>&lt;transition-group name=&quot;demo&quot; appear&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;hello&lt;/h1&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;world&lt;/h1&gt;
&lt;/transition-group&gt;</code></pre>
<h3 id="集成第三方动画"><a href="#集成第三方动画" class="headerlink" title="集成第三方动画"></a>集成第三方动画</h3><p>如第三方动画库 animate.css，<a href="https://animate.style/">官网</a></p>
<p>安装 <code>npm install animate.css -D</code></p>
<p>引入</p>
<pre><code>import &#39;animate.css&#39;</code></pre>
<p>使用</p>
<pre><code>&lt;transition-group 
    appear
    name=&quot;animate__animated animate__bounce&quot;
    enter-active-class=&quot;animate__swing&quot;
    leave-active-class=&quot;animate__backOutRight&quot;
&gt; &lt;!--name 值是固定的，在 enter-active-class 中设置进入动画，在 leave-active-class 中设置离开动画，具体动画效果可在官网查看--&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;1&quot;&gt;hello&lt;/h1&gt;
    &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;world&lt;/h1&gt;
&lt;/transition-group&gt;</code></pre>
<h2 id="利用-Vue-脚手架巧妙解决跨域问题"><a href="#利用-Vue-脚手架巧妙解决跨域问题" class="headerlink" title="利用 Vue 脚手架巧妙解决跨域问题"></a>利用 Vue 脚手架巧妙解决跨域问题</h2><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><pre><code>（1）CORS：后端中在响应头中配置 CORS 来解决跨域问题，但这种方式不安全，使得所有人都能访问服务器
（2）jsonp：利用 script 标签中的 src 在引入资源时不用遵循同源策略，这种方式需要前端后端配合，但这种方法在开发中用的少
（3）代理服务器：借助一台与前端地址同源的代理服务器，前端向代理服务器发送请求，代理服务器转发给服务器，服务器响应数据给代理服务器再转发至前端，因为服务器与服务器之间的通信没有什么同源策略，ajax 只有在前端中才有
    开启代理服务器的方式：（1）nginx（2）借助 vue-cli</code></pre>
<h3 id="利用-Vue-脚手架开启代理服务器解决跨域问题"><a href="#利用-Vue-脚手架开启代理服务器解决跨域问题" class="headerlink" title="利用 Vue 脚手架开启代理服务器解决跨域问题"></a>利用 Vue 脚手架开启代理服务器解决跨域问题</h3><p><strong>方式一</strong></p>
<p>在 vue.config.js 文件中配置如下</p>
<pre><code>devServer:&#123;
    proxy:&#39;http://localhost:3000&#39;, //目标服务器地址
&#125;</code></pre>
<p>在代码中发送请求时写的请求地址和前端同源，path 后缀和服务器接口一致即可，如前端在 <a href="http://localhost:8080，要访问服务器的">http://localhost:8080，要访问服务器的</a> <a href="http://localhost:3000/xxx%EF%BC%8C%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%A6%81%E5%86%99%E6%88%90">http://localhost:3000/xxx，在代码要写成</a> <a href="http://localhost:8080/xxx">http://localhost:8080/xxx</a></p>
<p>注意：代理服务器不是把所有请求都转发给服务器，当请求的资源在代理服务器有的时候就不转发给服务器，代理服务器的根路径就是 public 文件夹所在位置</p>
<p><strong>优点：</strong>配置简单，请求资源时直接发给前端即可</p>
<p><strong>缺点：</strong>上面这种方式中不能配置多个代理，并且不能灵活地控制走不走代理（工作方式：只有当代理服务器中没有所要资源时转发给服务器（优先匹配前端资源））</p>
<p><strong>方式二</strong></p>
<p>在 vue.config.js 文件中配置如下</p>
<pre><code>devServer:&#123;
    proxy:&#123;
        &#39;/api&#39;:&#123;
            target:&#39;http://localhost:3000&#39;, //目标服务器地址
            pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125;,
            ws:true,  //用于支持 websocket
            changeOrigin: true //用于控制请求头中的 host 值，即若为 false，服务器显示收到的请求来自 http://localhost:8080，若为 true 显示的是来自 http://localhost:3000
            //changeOrigin 默认是 true
        &#125;,
        &#39;/demo&#39;:&#123;
            target:&#39;http://localhost:3001&#39;,
            pathRewrite:&#123;&#39;^/demo&#39;:&#39;&#39;&#125;,
        &#125;
    &#125;
&#125;</code></pre>
<p>如前端在 <a href="http://localhost:8080，要访问服务器的">http://localhost:8080，要访问服务器的</a> <a href="http://localhost:3000/xxx%EF%BC%8C%E5%9C%A8%E4%BB%A3%E7%A0%81%E8%A6%81%E5%86%99%E6%88%90">http://localhost:3000/xxx，在代码要写成</a> <a href="http://localhost:8080/api/xxx%EF%BC%8C%E8%8B%A5%E5%90%91%E8%AE%BF%E9%97%AE%E5%89%8D%E7%AB%AF%E7%9A%84">http://localhost:8080/api/xxx，若向访问前端的</a> xxx 资源则是要不加 /api 就可以不走代理服务器</p>
<p><strong>优点：</strong>可以配置多个代理，且可以灵活控制请求是否走代理</p>
<p><strong>缺点：</strong>配置略微繁琐，请求资源时必须加前缀</p>
<h2 id="发送-ajax-请求（vue-resource）"><a href="#发送-ajax-请求（vue-resource）" class="headerlink" title="发送 ajax 请求（vue-resource）"></a>发送 ajax 请求（vue-resource）</h2><p>发送 ajax 请求的方式有 xhr、jQuery、axios、fetch，其中 jQuery 和 axios 都是对 xhr 的二次封装，fetch 是和 xhr 平级的</p>
<p>在 Vue 中还可以借助 vue-resource 插件库发送 ajax 请求，在 Vue 1.0 中用的多，官方已不维护。vue-resource 也是对 xhr 的封装</p>
<p>安装 <code>npm i vue-resource -D</code></p>
<p>在 main.js 文件中</p>
<pre><code>import vueResource from &#39;vue-resource&#39;
Vue.use(vueResource)  //使用 vue-resource 插件库后 vm 和 vc 上都会出现 $http</code></pre>
<p>在组件代码中使用 vue-resource，用法和 axios 相同</p>
<pre><code>this.$http.get(&#39;url地址&#39;).then(
    response=&gt;&#123;...&#125;,
    error=&gt;&#123;...&#125;
)</code></pre>
<h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h2><p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于父组件向子组件传结构</p>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
&lt;div&gt;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;h2&gt;xxx&lt;/h2&gt; &lt;!--这部分内容会替换子组件中 slot 的位置--&gt;
&lt;/子组件&gt;</code></pre>
<p>插槽中的样式可在父组件中定义（解析好父组件后把带样式的结构替换子组件中的 slot）也可在子组件中定义（解析后把结构传入子组件中的 slot 然后再付上样式）</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>当需要在一个组件中定义多个插槽，则需要给每个 slot 加上 name 属性</p>
<p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot name=&quot;aaa&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
    &lt;slot name=&quot;bbb&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值&lt;/slot&gt;
&lt;div&gt;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;h2 slot=&quot;aaa&quot;&gt;xxx&lt;/h2&gt;
    &lt;a slot=&quot;bbb&quot; href=&quot;xxxxx&quot;&gt;xx&lt;/a&gt;
&lt;/子组件&gt;</code></pre>
<p>注意若父组件中要放在 slot 中有多个元素可使用 <code>&lt;template&gt;</code> 把这些元素包裹起来，并且指定插槽时可使用 <code>v-slot:aaa</code> 来代替 <code>slot=&quot;aaa&quot;</code></p>
<pre><code>&lt;子组件&gt;
    &lt;template v-slot:aaa&gt;
        &lt;h2&gt;xxx&lt;/h2&gt;
        &lt;h2&gt;xxx&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;</code></pre>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>当数据在设置了插槽的子组件中，使用该组件的父组件若要用到这些数据就可以使用作用域插槽</p>
<p>即数据在组件自身，但根据数据生成的结构需要组件的使用者来决定</p>
<p>子组件中</p>
<pre><code>&lt;div&gt;
    &lt;h1&gt;xxx&lt;/h1&gt;
    &lt;slot :data1=&quot;data1&quot; msg=&quot;hello&quot;&gt;这里可以设置默认值，当没有传递具体结构时会出现该默认值，这里也可以设置 name，在父组件中相应的使用 slot=&quot;xx&quot;&lt;/slot&gt;
&lt;div&gt;

data()&#123;
    return&#123;
        data1:xxx
    &#125;
&#125;</code></pre>
<p>父组件中</p>
<pre><code>&lt;子组件&gt;
    &lt;template scope=&quot;somedata&quot;&gt;
        &lt;h2&gt;&#123;&#123;somedata.data1&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;&#123;&#123;somedata.msg&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;

&lt;子组件&gt;
    &lt;template scope=&quot;&#123;data1&#125;&quot;&gt;
        &lt;h2&gt;&#123;&#123;data1&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;

&lt;子组件&gt;
    &lt;template slot-scope=&quot;&#123;data1&#125;&quot;&gt;
        &lt;h2&gt;&#123;&#123;data1&#125;&#125;&lt;/h2&gt;
    &lt;/template&gt;
&lt;/子组件&gt;</code></pre>
<h1 id="五、组件间通信"><a href="#五、组件间通信" class="headerlink" title="五、组件间通信"></a>五、组件间通信</h1><p>（1）父子组件：props</p>
<p>父传子数据</p>
<pre><code>父组件中
`&lt;子组件 变量名=&quot;值&quot;&gt;`
子组件中
props:[&#39;变量名&#39;]</code></pre>
<p>子传父</p>
<pre><code>父组件中
`&lt;子组件 变量名=&quot;函数名&quot;&gt;`
子组件中
props:[&#39;变量名&#39;]
调用函数来修改父组件中的数据</code></pre>
<p>（2）绑定自定义事件：$emit（多用于父子间子给父）</p>
<p>（3）全局事件总线（基于自定义事件）（任意组件间通信）这种方式用得比消息订阅发布的方式多</p>
<p>（4）消息订阅与发布（任意组件间通信）</p>
<p>（5）插槽（父给子传 html 结构）、作用域插槽（子中的数据父需要使用）</p>
<p>（6）Vue3 中祖与后代组件间通信的 provide 与 inject</p>
<h1 id="六、Vuex"><a href="#六、Vuex" class="headerlink" title="六、Vuex"></a>六、Vuex</h1><p>vuex 是专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，</p>
<p>vuex 对 vue 应用中多个组件的共享状态进行集中式的管理（读/写）</p>
<p>vuex 也是一种组件间通信的方式，且适用于任意组件间的通信</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>（1）多个组件依赖于同一状态</p>
<p>（2）来自不同组件的行为需要变更同一状态</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vuex.png" alt="vuex"></p>
<h2 id="Vuex-的使用"><a href="#Vuex-的使用" class="headerlink" title="Vuex 的使用"></a>Vuex 的使用</h2><p>（1）安装 <code>npm i vuex@3</code></p>
<p>注意：vue2 只能使用 vuex3，vuex4 只能用在 vue3，这里先以 vue2 + vuex3 为例</p>
<p>（2）引入</p>
<p>在 main.js 中</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import store from &#39;./store/index.js&#39;

new Vue(&#123;
    el:&#39;#app&#39;,
    render: h=&gt;h(App),
    store,
    beforeCreate()&#123;
        Vue.prototype.$bus = this
    &#125;
&#125;)</code></pre>
<p>（3）创建 store</p>
<p>创建 src/store/index.js 文件用于创建 Vuex 中最核心的 store</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
//使用 Vuex 插件
Vue.use(Vuex)

//准备 actions 用于响应组件的动作
const actions = &#123;&#125;
//准备 mutations 用于操作 state 数据
const mutations = &#123;&#125;
//准备 state 用于存储数据
const state = &#123;&#125;
//准备 getters 用于将 state 中的数据进行加工
const getters = &#123;&#125;

//创建并暴露 store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
    getters
&#125;)</code></pre>
<p>当 state 中的数据需要经过加工后再使用时，可使用 getters 加工（优点类似 computed）</p>
<p>（4）组件中读取/修改 vuex 数据</p>
<p>组件中读取 vuex 数据：<code>this.$store.state.sum</code> 和 <code>this.$store.getters.sum</code>，若在模板中读就不加 this</p>
<p>组件中修改 vuex 中的数据：<code>this.$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>this.$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<p>（5）组件中使用 mapState/mapGetters/mapMutations/mapActions</p>
<p>借助 mapState/mapGetters 生成计算属性，从 state/getters 中读取数据</p>
<p>借助 mapMutations/mapGetters 生成对应方法，方法中会调用 commit/dispatch 去联系 mutations/actions</p>
<p>注意：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写 dispatch，直接写 commit</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在 store.js 文件中</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)

const actions = &#123;
    inc(context,value)&#123; //第一个参数是上下文对象，该对象上有 $commit、$dispatch 等方法以及 state，第二个参数是 dispatch 传来的值
        console.log(context.state.sum)
        context.commit(&#39;INC&#39;,value) //会调用 mutations 中的 INC 函数
    &#125;
&#125;
const mutations = &#123;
    INC(state,value)&#123;
        state.sum += value
    &#125;
&#125;
const state = &#123;
    sum:0
&#125;
const getters = &#123;
    bigSum(state)&#123;
        return state.sum * 10
    &#125;
&#125;

export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
    getters
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;h1&gt;&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;
&lt;h1&gt;&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;/h1&gt;

methods:&#123;
    increment()&#123;
        console.log(this.$store.state.sum)
        this.$store.dispatch(&#39;inc&#39;,this.n) //会调用 actions 中的 inc 函数
    &#125;
&#125;</code></pre>
<p>由于在 actions 中没有特别的业务逻辑，所以可以直接跳过 actions（不用 dispatch），由组件直接使用 commit 调用 mutation 里的函数，所以上述代码可简写为</p>
<p>在 store.js 文件中</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)

const actions = &#123;
&#125;
const mutations = &#123;
    INC(state,value)&#123;
        state.sum += value
    &#125;
&#125;
const state = &#123;
    sum:0
&#125;

export default new Vuex.Store(&#123;
    actions,
    mutations,
    state
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;h1&gt;&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;

methods:&#123;
    increment()&#123;
        console.log(this.$store.state.sum)
        this.$store.commit(&#39;INC&#39;,this.n) //会调用 actions 中的 inc 函数
    &#125;
&#125;</code></pre>
<p>在组件里用上 mapState/mapGetters/mapMutations/mapActions</p>
<pre><code>&lt;button @click=&quot;&#123;&#123;increment(n)&#125;&#125;&quot;&gt;&#123;&#123;sum&#125;&#125;&lt;/button&gt;

import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#39;vuex&#39;

computed:&#123;
    ...mapState(&#123;sum:&#39;sum&#39;,xxx:&#39;xx&#39;&#125;) //对象写法，键为本组件中使用的名字，值为 state 中的变量名
    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;)
    //或
    //...mapState([&#39;sum&#39;,&#39;xxx&#39;]) //当组件中使用的名字和 state 中的变量名一致时可使用数组写法
    //...mapGetters([&#39;bigSum&#39;])
    //上述 mapState 写法相当于
    /*sum()&#123;
        return this.$store.state.sum
    &#125;
    xxx()&#123;
        return this.$store.state.xxx
    &#125;*/

    ...mapMutations(&#123;increment:&#39;INC&#39;,decrement:&#39;DEC&#39;&#125;) //对象写法
    //或
    //...mapMutations([&#39;INC&#39;]) //对数组写法，此时在 @click 中应使用 INC 方法
    //上述 mapMutations 写法相当于
    /*increment()&#123;
        return this.$store.commit(&#39;INC&#39;,this.n)
    &#125;*/

    ...mapActions(&#123;increment1:&#39;INC1&#39;,decrement1:&#39;DEC1&#39;&#125;) //对象写法
    //或
    ...mapActions([&#39;INC1&#39;]) //数组写法
    //上述 mapMutations 写法相当于
    /*increment1()&#123;
        return this.$store.dispatch(&#39;INC1&#39;,this.n)
    &#125;*/
&#125;</code></pre>
<h2 id="vuex-模块化"><a href="#vuex-模块化" class="headerlink" title="vuex 模块化"></a>vuex 模块化</h2><p>在 store/index.js 中根据按功能将 actions、mutations、state、getters 包起来，也可以按功能将这些东西放到不同 js 文件中，然后在 store/index.js 中引入</p>
<pre><code>const countOptions = &#123;
    namespace:true,
    actions:&#123;...&#125;,
    mutations&#123;...&#125;,
    state:&#123;...&#125;,
    getters:&#123;...&#125;
&#125;
const persionsOptions = &#123;
    namespace:true,
    actions:&#123;...&#125;,
    mutations&#123;...&#125;,
    state:&#123;...&#125;,
    getters:&#123;...&#125;
&#125;
export default new Vuex.Store(&#123;
    modules:&#123;
        countAbout:countOptions,
        personAbout:persionsOptions
    &#125;
&#125;)</code></pre>
<p>在组件中</p>
<pre><code>&lt;button @click=&quot;&#123;&#123;increment(n)&#125;&#125;&quot;&gt;&#123;&#123;sum&#125;&#125;&lt;/button&gt;
&lt;h1&gt;&#123;&#123;sum&#125;&#125;&lt;/h1&gt;

...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;xxx&#39;])
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
...mapMutations(&#39;countAbout&#39;,[&#39;INC&#39;])

this.$store.getters[&#39;countAbout/bigSum&#39;]
this.$store.dispatch(&#39;countAbout/XXX&#39;,this.n)
this.$store.commit(&#39;countAbout/INC&#39;,this.n)</code></pre>
<h1 id="七、浏览器本地存储-webStorage"><a href="#七、浏览器本地存储-webStorage" class="headerlink" title="七、浏览器本地存储 webStorage"></a>七、浏览器本地存储 webStorage</h1><p>webStorage 存储内容大小一般支持 5MB 左右（不同浏览器可能不一样）</p>
<p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制</p>
<pre><code>xxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)
该方法接收一个键和值作为参数，会把键值对添加到存储中，若键名存在，则更新其对应的值
xxxStorage.getItem(&#39;key&#39;)
该方法接收一个键名作为参数，返回键名对应的值
xxxStorage.removeItem(&#39;key&#39;)
该方法接收一个键名作为参数，并把该键名从存储中删除
xxxStorage.clear()
该方法会清空存储中的所有数据</code></pre>
<p>sessionStorage 存储的内容会随着浏览器窗口关闭而消失</p>
<p>localStorage 存储的内容需要手动清除才会消失</p>
<p>xxxStorage.getItem(‘key’) 若 key 对应的 value 获取不到返回的是 null</p>
<p>Json.parse(null) 的结果依然是 null，不是 undefined</p>
<h1 id="八、路由"><a href="#八、路由" class="headerlink" title="八、路由"></a>八、路由</h1><p>路由就是一组 key（路径）-value（function 或 component） 的对应关系，多个路由需要经过路由器管理</p>
<h2 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h2><p>（1）后端路由</p>
<p>后端路由中 value 是 function，用于处理客户端提交的请求</p>
<p>工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据</p>
<p>（2）前端路由</p>
<p>前端路由中 value 是 component，用于展示页面内容</p>
<p>工作过程：当浏览器的路径改变时，对应的组件就会显示</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>vue-router 是 vue 的一个插件库，专门用来实现 SPA 单页面应用</p>
<p>单页 Web 应用中整个应用只有一个完整的页面，点击页面中的导航链接不会刷新页面，只会做页面的局部更新，数据需要通过 ajax 请求获取</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹</p>
<p>通过切换，“隐藏”了的路由组件默认是被销毁掉的，需要的时候再去挂载</p>
<p>每个组件都有自己的 $route 属性，里面存储着自己的路由信息</p>
<p>整个应用只有一个 router，可通过组件的 $router 属性获取到</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>安装 <code>npm i vue-router@3 -D</code></p>
<p>注意：vue2 只能使用 vue-router3，vue-router 4 只能用在 vue3 中使用，这里先以 vue2 + vuex3 为例，所以安装 vue-router 3</p>
<p>引入，在 main.js 中</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import VueRouter from &#39;vue-router&#39;
import router from &#39;./router/index.js&#39;
import store from &#39;./store/index.js&#39;
Vue.use(VueRouter)
new Vue(&#123;
    el:&#39;#app&#39;,
    render: h=&gt;h(App),
    router
    store,
    beforeCreate()&#123;
        Vue.prototype.$bus = this
    &#125;
&#125;)</code></pre>
<p>创建 src/router/index.js 文件专门用于创建整个应用的路由器</p>
<pre><code>import VueRouter from &#39;vue-router&#39;
import About from &#39;./components/about.vue&#39;
import Home from &#39;./components/home.vue&#39;
//创建并暴露一个路由器
export default new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home
        &#125;
    ]
&#125;)</code></pre>
<p>组件中使用 <code>&lt;router-link&gt;</code> 实现路由的切换（通过 active-class 配置高亮样式），使用 <code>&lt;router-view&gt;</code> 指定不同路由下组件的呈现位置</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;

&lt;router-view&gt;&lt;/router-view&gt;</code></pre>
<h2 id="嵌套（多级）路由"><a href="#嵌套（多级）路由" class="headerlink" title="嵌套（多级）路由"></a>嵌套（多级）路由</h2><p>修改 src/router/index.js 文件</p>
<pre><code>import VueRouter from &#39;vue-router&#39;
import About from &#39;./components/about.vue&#39;
import Home from &#39;./components/home.vue&#39;
import News from &#39;./components/news.vue&#39;
import Message from &#39;./components/message.vue&#39;
//创建并暴露一个路由器
export default new VueRouter(&#123;
    routes:[
        &#123;
            path:&#39;/about&#39;,
            component:About
        &#125;,
        &#123;
            path:&#39;/home&#39;,
            component:Home,
            children:[
                &#123;
                    path:&#39;news&#39;, //子路由不加 /，这里相当于 /home/news
                    component:News
                &#125;,
                &#123;
                    path:&#39;message&#39;,
                    component:Message
                &#125;
            ]
        &#125;
    ]
&#125;)</code></pre>
<p>在 Home 路由组件中</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
&lt;router-link active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;  &lt;!--这里得写完整路径--&gt;

&lt;router-view&gt;&lt;/router-view&gt;</code></pre>
<h2 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h2><p>跳转路由携带 query 参数</p>
<pre><code>&lt;!to 的字符串写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;

&lt;!to 的对象写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    path:&#39;/home/message/detail&#39;,
    query:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>接收参数</p>
<pre><code>this.$route.query.id
this.$route.query.title</code></pre>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail&#39;,
    component:Detail
&#125;</code></pre>
<p>组件中</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    name:&#39;ddd&#39;,
    query:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>在没有 query 参数的组件中使用命名路由</p>
<pre><code>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;name:&#39;xxx&#39;&#125;&quot;&gt;About&lt;/router-link&gt;</code></pre>
<h2 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h2><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail
&#125;</code></pre>
<p>组件中</p>
<pre><code>&lt;!to 的字符串写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;/home/message/detail/$&#123;id&#125;/$&#123;title&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;

&lt;!to 的对象写法--&gt;
&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;
    name:&#39;ddd&#39;, //注意这里只能用 name，不能用 path
    params:&#123;
        id:id,
        title:title
    &#125;
&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/router-link&gt;</code></pre>
<p>接收参数</p>
<pre><code>this.$route.params.id
this.$route.params.title</code></pre>
<p><strong>注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置</strong></p>
<h2 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h2><p>路由的 props 配置让路由组件更方便的收到参数</p>
<h3 id="写法一：路由规则中-props-值为对象"><a href="#写法一：路由规则中-props-值为对象" class="headerlink" title="写法一：路由规则中 props 值为对象"></a>写法一：路由规则中 props 值为对象</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail,
    //写法一：值为 对象，该对象中的所有 key-value 都会以 props 的形式给 Detail 组件（这种写法用的少，因为写的都死数据）
    props:&#123;a:1,b:&#39;xxx&#39;&#125;
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;a&#39;,&#39;b&#39;]</code></pre>
<h3 id="写法二：路由规则中值为布尔值"><a href="#写法二：路由规则中值为布尔值" class="headerlink" title="写法二：路由规则中值为布尔值"></a>写法二：路由规则中值为布尔值</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail/:id/:title&#39;,
    component:Detail,

    //写法二：值为布尔值，若为真就会把该路由组就收到的所有 params 参数以 props 的形式传给 Detail 组件
    props:true
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;id&#39;,&#39;title&#39;]</code></pre>
<h3 id="写法三：路由规则中值为函数"><a href="#写法三：路由规则中值为函数" class="headerlink" title="写法三：路由规则中值为函数"></a>写法三：路由规则中值为函数</h3><p>路由规则中</p>
<pre><code>&#123;
    name:&#39;ddd&#39;
    path:&#39;detail&#39;,
    component:Detail,

    //写法三：值为函数，该函数返回的对象中每一组 key-value 都会通过 props 传给 Detail 组件
    props($route)&#123;
        return &#123;id:$route.query.id,title:$route.query.title&#125;
    &#125;
    //或直接解构赋值
    /*props(&#123;query:&#123;id,title&#125;&#125;)&#123;
        return &#123;id,title&#125;
    &#125;*/
&#125;</code></pre>
<p>在 Detail 组件接收参数</p>
<pre><code>props:[&#39;id&#39;,&#39;title&#39;]</code></pre>
<h2 id="router-link-的-replace-属性"><a href="#router-link-的-replace-属性" class="headerlink" title="router-link 的 replace 属性"></a>router-link 的 replace 属性</h2><p>作用：控制路由跳转时操作浏览器历史记录的模式</p>
<p>浏览器的历史记录有两种写入方式：分别为 push 和 replace，push 是追加历史记录，replace 是替换当前记录，默认是 push</p>
<p>开启 replace 模式的方式：</p>
<pre><code>&lt;router-link replace&gt;xxx&lt;/router-link&gt;</code></pre>
<h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>由于 <code>&lt;router-link&gt;</code> 解析后都是以 a 标签的形式显示在页面中，若想要通过点击按钮来实现跳转则无法使用 <code>&lt;router-link&gt;</code> 来实现，又如要过一段时间后自动跳转路由也无法通过 <code>&lt;router-link&gt;</code> 实现</p>
<p>编程式路由导航作用：不借助 <code>&lt;router-link&gt;</code>  实现路由跳转，让路由跳转更加灵活</p>
<pre><code>this.$router.push(&#123;
    name:&#39;ddd&#39;,
    query:&#123;  //也可以是 params
        id:&#39;xx&#39;,
        title:&#39;xxx&#39;
    &#125;
&#125;)

this.$router.replace(&#123;
    name:&#39;ddd&#39;,
    query:&#123;  //也可以是 params
        id:&#39;xx&#39;,
        title:&#39;xxx&#39;
    &#125;
&#125;)

this.$router.back() //后退

this.$router.forward() //前进

this.$router.go(整整)  //正整数前进 n 步，负整数后退 n 步</code></pre>
<h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><p>当某个组件中有用户输入的数据，当路由跳转后当前组件被销毁，用户输入的数据也消失了</p>
<p>缓存路由组件作用：让不展示的路由组件保持挂载不被销毁，通过在 <code>&lt;router-view&gt;</code> 外包裹 <code>&lt;keep-alive&gt;</code></p>
<p>所有都缓存时</p>
<pre><code>&lt;keep-alive&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<p>缓存一个组件时</p>
<pre><code>&lt;keep-alive include=&quot;要缓存的组件名1&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<p>缓存多个组件时</p>
<pre><code>&lt;keep-alive :include=&quot;[&#39;要缓存的组件名1&#39;,&#39;要缓存的组件名2&#39;]&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre>
<h2 id="路由组件独有的两个新的生命周期钩子"><a href="#路由组件独有的两个新的生命周期钩子" class="headerlink" title="路由组件独有的两个新的生命周期钩子"></a>路由组件独有的两个新的生命周期钩子</h2><p>若在被缓存的组件中开启定时器，当路由跳转时该定时器依然在运行</p>
<p>路由组件独有的两个新的生命周期钩子可用于捕获路由组件的激活状态</p>
<pre><code>activated()&#123; //组件从无到有时被激活触发
    this.timer = setInterval(()=&gt;&#123;
        ...
    &#125;,1000)
&#125;,
deactivated()&#123; //当路由跳转时被失活触发
    clearInterval(this.timer)
&#125;</code></pre>
<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由守卫控制路由的权限</p>
<h3 id="全局前置路由守卫"><a href="#全局前置路由守卫" class="headerlink" title="全局前置路由守卫"></a>全局前置路由守卫</h3><p>在 src/router/index.js 中添加</p>
<pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false&#125; //在 meta 中配置自定义属性
&#125;

//初始化时被调用，每次路由切换之前被调用
router.beforeEach((to,from,next)=&gt;&#123;
    //做一些判断是否允许路由正常跳转
    if(to.meta.isAuth)&#123;
        if(...)&#123;
            next() //正常跳转
        &#125;else&#123;...&#125;
    &#125;else&#123;
        next() //正常跳转
    &#125;
&#125;)</code></pre>
<h3 id="全局后置路由守卫"><a href="#全局后置路由守卫" class="headerlink" title="全局后置路由守卫"></a>全局后置路由守卫</h3><pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false,title:&#39;xxx&#39;&#125; //在 meta 中配置自定义属性
&#125;

//初始化时被调用，每次路由切换之后被调用
router.afterEach((to,from)=&gt;&#123;
    document.title = to.meta.title || &#39;默认&#39;  //修改页签
&#125;)</code></pre>
<h3 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h3><p>独享路由守卫即某个路由独享的路由守卫</p>
<pre><code>&#123;
    name:&#39;hhh&#39;
    path:&#39;/home&#39;,
    component:Home,
    meta:&#123;isAuth:false,title:&#39;xxx&#39;&#125;
    beforeEnter:(to,from,next)=&gt;&#123;
        //这里可以完成如前置路由守卫中的逻辑
    &#125;
&#125;</code></pre>
<p>注意：没有 afterEnter</p>
<h3 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h3><p>在组件中</p>
<pre><code>//通过路由规则进入该组件时被调用（不是在页面中直接展示组件的方式进入组件）
beforeRouteEnter(to,from,next)&#123;
    //这里可以完成如前置路由守卫中的逻辑
    next() //允许进入
&#125;,
//通过路由规则离开该组件时被调用
beforeRouteLeave(to,from,next)&#123;
    next() //允许离开
&#125;</code></pre>
<h2 id="history-模式和-hash-模式"><a href="#history-模式和-hash-模式" class="headerlink" title="history 模式和 hash 模式"></a>history 模式和 hash 模式</h2><p>对于 url 来说 # 及其后面的内容就是 hash 值</p>
<p>hash 值不会包含在 HTTP 请求中，即 hash 值不会带给服务器</p>
<p>hash 模式：</p>
<pre><code>（1）地址中永远带着 # 号，不美观
（2）若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法
（3）兼容性较好</code></pre>
<p>history 模式：</p>
<pre><code>（1）地址干净美观
（2）兼容性和 hash 模式相比略差
（3）应用部署上线时需要后端人员支持，解决刷新页面服务器端 404 的问题</code></pre>
<p>Vue 脚手架应用中默认是用 hash 模式</p>
<p>若要启用 history 模式，在 router/index.js 创建路由器时添加 <code>mode:&#39;history&#39;</code></p>
<h1 id="九、Vue-UI-组件库"><a href="#九、Vue-UI-组件库" class="headerlink" title="九、Vue UI 组件库"></a>九、Vue UI 组件库</h1><p>移动端常用 UI 组件库：<a href="https://youzan.github.io/vant">Vant</a>、<a href="https://didi.github.io/cube-ui">Cube UI</a>、<a href="http://mint-ui.github.io/">Mint UI</a></p>
<p>PC 端常用 UI 组件库：<a href="https://element.eleme.cn/">Element UI</a>、<a href="https://www.iviewui.com/">IView UI</a></p>
<p>注意：使用 Element UI 时按照文档中的按需引入配置会报错，其中安装完 babel-plugin-component 后，修改 babel.config.js 为</p>
<pre><code>&#123;
  &quot;presets&quot;: [[&quot;@babel/preset-env&quot;, &#123; &quot;modules&quot;: false &#125;]],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      &#123;
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      &#125;
    ]
  ]
&#125;</code></pre>
<h1 id="十、Vue-3"><a href="#十、Vue-3" class="headerlink" title="十、Vue 3"></a>十、Vue 3</h1><p>Vue3 在 2020 年 9 月发布正式版，Vue3 支持大多数的 Vue2 特性</p>
<h2 id="Vue-3-带来了什么"><a href="#Vue-3-带来了什么" class="headerlink" title="Vue 3 带来了什么"></a>Vue 3 带来了什么</h2><p>（1）性能的提升</p>
<p>打包大小减少 41%</p>
<p>初次渲染快 55%，更新渲染快 133%</p>
<p>内存减少 54%</p>
<p>……</p>
<p>（2）源码升级</p>
<p><strong>使用 Proxy 配合 Reflect 代替 Vue2 中 defineProperty 实现响应式</strong></p>
<p>重写虚拟 DOM 的实现和 Tree-Shaking</p>
<p>……</p>
<p>（3）拥抱 TypeScript</p>
<p>Vue 3 可以更好的支持 TypeScript</p>
<p>（4）新的特性</p>
<p>— 1） Composition API（组合 API）</p>
<pre><code>setup 配置
ref 与 reactive
watch 与 watchEffect
provide 与 inject
......</code></pre>
<p>—2）新的内置组件</p>
<pre><code>Fragment
Teleport
Suspense</code></pre>
<p>—3）其他改变</p>
<pre><code>新的生命周期钩子
data 选项应始终被声明为一个函数
移除 keyCode 支持作为 v-on 的修饰符
......</code></pre>
<h2 id="使用-vue-cli-创建-Vue3-工程"><a href="#使用-vue-cli-创建-Vue3-工程" class="headerlink" title="使用 vue-cli 创建 Vue3 工程"></a>使用 vue-cli 创建 Vue3 工程</h2><p>要创建 Vue3 项目，则 vue-cli 的版本必须在 4.5.0 以上</p>
<p>安装 <code>npm install -g @vue/cli</code></p>
<p>创建项目 <code>vue create 项目名</code></p>
<p>在项目文件夹下启动 <code>npm run serve</code></p>
<h2 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h2><p>vite 是新一代前端构建工具，当前一般使用 webpack</p>
<p>vite 优势：</p>
<pre><code>开发环境中，无需打包操作，可快速的冷启动
轻量快速的热重载（HMR）
真正的按需编译，不再等待整个应用编译完成</code></pre>
<p>vite 与 webpack 区别：webpack 首先看入口文件，分析路由，然后分析各模块，再将所有东西进行一次打包形成一台准备好的服务器；而 vite 是先准备好空壳服务器，当发起 http 请求时从入口文件进入找到相应路由，然后分析该路由对应的那些模块，这样启动速度更快，东西现用现分析，动态引入和代码分割</p>
<p>创建 Vue3 项目：</p>
<p>创建工程 <code>npm init vite-app 项目名</code></p>
<p>进入工程目录后安装依赖 <code>npm install</code></p>
<p>运行 <code>npm run dev</code></p>
<h2 id="分析工程结构"><a href="#分析工程结构" class="headerlink" title="分析工程结构"></a>分析工程结构</h2><p>在入口文件 main.js 中</p>
<pre><code>//引入的不再是 Vue 构造函数了（构造函数首字母大写，需要通过 new 去调用），而是一个名为 createApp 的工厂函数（工厂函数无需通过 new 去调用）
import &#123;createApp&#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
createApp(App).mount(&#39;#app&#39;)
//上行代码相当于
//const app = createApp(App) //创建应用实例对象 app，类似于 Vue2 中的 vm，但 app 比 vm 更轻，身上没有那么多函数
//app.mount(&#39;#app&#39;) //挂载</code></pre>
<p>Vue3 组件中的结构可以没有根标签</p>
<h2 id="常用的-Composition-API（组合-API）"><a href="#常用的-Composition-API（组合-API）" class="headerlink" title="常用的 Composition API（组合 API）"></a>常用的 Composition API（组合 API）</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup 是 Vue3 中一个新的配置项，值为一个函数</p>
<p>setup 是所有 Composition API 的“表演舞台”</p>
<p>setup 函数的两种返回值</p>
<pre><code>（1）若返回一个对象，则对象中的属性、方法在模板中共均可直接使用
（2）若返回一个渲染函数，则可以自定义渲染内容</code></pre>
<p>注意：尽量不要与 Vue2 配置混用，Vue2 配置（data、methods、computed…）中可以访问到 setup 中的属性、方法，但 setup 中不能访问 Vue2 配置，如有重名，setup 优先</p>
<p>setup 不能是一个 async 函数，因为若加上 async 后返回值不再是 return 的对象，而是 promise，模板看不到 return 对象中的属性（注意：后期也可以返回一个 Promise 实例，但需要 Suspense 和 异步组件的配合）</p>
<p>例子<br>    <template><br>        <h1></h1><br>        <h1></h1><br>        &lt;button @click=”sayHello”&gt;xxx<br>    </template></p>
<pre><code>//import &#123;h&#125; from &#39;vue&#39; //当 setup 要返回渲染函数时需要引入
export default&#123;
    name:&#39;App&#39;,
    //此处暂时不考虑响应式问题
    setup()&#123;
        let name = &#39;xx&#39;
        let age = 18
        function sayHello()&#123;
            console.log(name,age)
        &#125;
        //返回一个对象
        return &#123;
            name,
            age,
            sayHello
        &#125;
        //也可以返回一个渲染函数
        //return ()=&gt;h(&#39;h1&#39;,&#39;hello&#39;)
    &#125;
&#125;</code></pre>
<p>setup 执行的时机：在 beforeCreate 之前执行一次，this 是 undefined</p>
<p>setup 的参数：</p>
<pre><code>props：值为对象，包含组件外部传递过来且组件内部声明接收了的属性
context：上下文对象
    context.attrs：值为对象，包含组件外部传递过来但没有在 props 配置中声明的属性，相当于 Vue2 中 this.$attrs
    context.slots：收到的插槽内容，相当于 this.$slots
    context.emit：分发自定义事件的函数，需要在触发父组件传来自定义事件的子组件中通过 emits:[&#39;事件名&#39;] 来接收，并通过 context.emit(&#39;事件名&#39;,数据) 来触发，相当于 this.$emit</code></pre>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 函数作用：定义一个<strong>（对象类型/基本类型）响应式的数据</strong></p>
<p>语法：<code>const xxx = ref(初始值)</code>，创建一个包含响应式数据的引用对象（即 reference 对象，简称 ref 对象）</p>
<p>操作数据时：<code>xxx.value</code></p>
<p>模板中读取数据时不需要 .value，直接使用 <code>&#123;&#123;xxx&#125;&#125;</code></p>
<p>接收的数据可以是基本类型，也可以是对象类型</p>
<p>基本类型的数据：响应式依然是靠 Object.defineProperty() 的 get 与 set 完成的</p>
<p>对象类型的数据：内部求助了 Vue3 的新函数 reactive 函数</p>
<pre><code>&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;!--自动读取 value 值--&gt;
&lt;h1&gt;&#123;&#123;age&#125;&#125;&lt;/h1&gt;

import &#123;ref&#125; from &#39;vue&#39;
export default&#123;
    name:&#39;App&#39;,
    setup()&#123;
        let name = ref(&#39;xx&#39;) //ref 返回引用实现（implement）的实例对象（RefImpl），变成响应式（通过 getter 和 setter 实现的响应式），name.value 是 Proxy 类型
        let age = ref(18)
        let job = ref(&#123;//对传入的对象加工后变成 Proxy 类型，这封装在了 reactive 函数中
            type:&#39;前端&#39;,
            salary:&#39;100&#39;
        &#125;)
        function changeInfo()&#123;
            name.value = &#39;xxx&#39;,
            age.value = 20,
            job.value.type = &#39;工程师&#39;
            job.value.salary = &#39;200&#39;
        &#125;
        return &#123;
            name,
            age,
            changeInfo
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="reactive-函数"><a href="#reactive-函数" class="headerlink" title="reactive 函数"></a>reactive 函数</h3><p>作用：定义一个<strong>对象类型的响应式数据</strong>（基本类型别用它，用 ref 函数）</p>
<p>语法：<code>const 代理对象 = reactive(Object源对象)</code> 接收一个对象或数组，返回一个代理器对象（Proxy 的实例对象，简称 proxy 对象）</p>
<p>reactive 定义的响应式数据是深层次的（即对象中可有对象）</p>
<p>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据，这种操作都能被 Vue 捕获到（即数据劫持），都是响应式的</p>
<pre><code>import &#123;ref,reactive&#125; from &#39;vue&#39;
export default&#123;
    name:&#39;App&#39;,
    setup()&#123;
        let name = ref(&#39;xx&#39;)
        let age = ref(18)
        let job = reactive(&#123; //reactive 返回 Proxy 类型数据变成响应式
            type:&#39;前端&#39;,
            salary:&#39;100&#39;
        &#125;)
        function changeInfo()&#123;
            name.value = &#39;xxx&#39;,
            age.value = 20,
            job.type = &#39;工程师&#39; //使用 reactive 就不用 job.value.type 了
            job.salary = &#39;200&#39;
        &#125;
        return &#123;
            name,
            age,
            changeInfo
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="Vue2-的响应式"><a href="#Vue2-的响应式" class="headerlink" title="Vue2 的响应式"></a>Vue2 的响应式</h3><p><strong>实现原理：</strong></p>
<p>— 对象类型：通过 <code>Object.defineProperty()</code> 对属性的读取、修改进行拦截（数据劫持）</p>
<p>— 数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹，如 Vue 中对数组 push 先使用原生 js 的 push 修改数组，然后对页面进行更新）</p>
<pre><code>//Vue2 中实现响应式
Object.defineProperty(person,&#39;name&#39;,&#123;
    get()&#123; 
        configurable:true, //配置后就可以 delete parson.name 来删除 name
        return person.name
    &#125;,
    set(value)&#123;
        person.name = value
    &#125;
&#125;)
Object.defineProperty(person,&#39;age&#39;,&#123;
    get()&#123;
        return person.age
    &#125;,
    set(value)&#123;
        person.age = value
    &#125;
&#125;)
但上面只能读取和修改属性，无法捕获删除和添加属性</code></pre>
<p><strong>存在的问题（这些问题在 Vue3 中不存在）：</strong></p>
<p>— 新增属性、删除属性时界面不会更新，如不能用 <code>对象.新属性 = 值</code> 添加属性，也不能用 <code>delete 对象.属性</code></p>
<p>— 直接通过下标修改数组，界面不会自动更新，如不能用 <code>数组[下标] = 值</code> 修改数组中的元素</p>
<p><strong>解决：</strong></p>
<pre><code>增加属性时
this.$set(要添加属性的对象,&#39;新属性名&#39;,属性值)
//或 Vue.set(要添加属性的对象,&#39;新属性名&#39;,属性值)
删除属性时
this.$delete(要删除属性的对象,&#39;属性名&#39;)
//或 Vue.delete(要删除属性的对象,&#39;属性名&#39;)
修改数组时
this.$set(要修改的数组,下标索引,新值)
//或 Vue.set(要修改的数组,下标索引,新值)
//或 要修改的数组.splice(下标索引,1,新值)</code></pre>
<h3 id="Vue3-的响应式"><a href="#Vue3-的响应式" class="headerlink" title="Vue3 的响应式"></a>Vue3 的响应式</h3><p><strong>实现原理：</strong></p>
<p>— 通过 Proxy（代理）：这是 window 上的内置对象，拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等</p>
<p>— 通过 Reflect（反射）：这是 window 上的内置对象，对被代理对象（即源对象）的属性进行操作</p>
<pre><code>let person = &#123;
    name:&#39;xx&#39;,
    age:18
&#125;
const p = new Proxy(person,&#123;  //让 p 映射 person，对 p 进行操作能被捕获到并更新 person
    //拦截读取属性值
    //读取 p 的某个属性时调用
    get(target,propName)&#123; //第一个参数 target 即源对象 person，第二个参数是属性名
        return Reflect.get(target,propName) //相当于target[propName]
    &#125;,
    //拦截设置属性值或添加新属性
    //修改或添加 p 的某个属性时调用
    set(target,propName,value)&#123;
        Reflect.set(target,propName,value) //相当于target[propName] = value
    &#125;,
    //拦截删除属性
    //删除 p 的某个属性时调用
    deleteProperty(target,propName)&#123;
        return Reflect.deleteProperty(target,propName) //相当于delete target[propName]
    &#125;
&#125;)
p.sex = &#39;女&#39; //给 person 添加 sex 属性</code></pre>
<p>MDN 文档中描述的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a></p>
<p><strong>Vue3 中的添加、删除、修改对象或数组元素：</strong></p>
<pre><code>let person = reactive(&#123;
    name:&#39;xxx&#39;,
    hobby:[&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;]
&#125;)

person.sex = &#39;女&#39;
delete person.name
person.hobby[0] = &#39;dd&#39;</code></pre>
<p><strong>对比 reactive 与 ref：</strong></p>
<p>（1）从定义数据角度对比</p>
<pre><code>ref 用来定义基本类型数据
reactive 用来定义对象或数组类型数据
ref 也可以用来定义对象或数组类型数据，它内部会自动通过 reactive 转为代理对象（即 Proxy 实例对象）</code></pre>
<p>（2）从原理角度对比</p>
<pre><code>ref 通过 Object.defineProperty() 的 get 与 set 来实现响应式（数据劫持）
reactive 通过使用 Proxy 来实现响应式（数据劫持），并通过 Reflect 操作源对象内部的数据</code></pre>
<p>（3）从使用角度对比</p>
<pre><code>ref 定义的数据：操作数据需要 .value，读取数据时模板中直接读取不需要 .value
reactive 定义的数据：操作数据与读取数据均不需要 .value</code></pre>
<h2 id="计算属性-computed-1"><a href="#计算属性-computed-1" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>Vue3 与 Vue2 中的 computed 配置功能一致</p>
<pre><code>import &#123;reactive,computed&#125; form &#39;vue&#39;
setup()&#123;
    let person = reactive(&#123;
        firstName: &#39;x&#39;,
        lastName: &#39;xx&#39;
    &#125;)
    //计算属性简写————没有考虑计算属性被修改的情况
    /*person.fullName = computed(()=&gt;&#123;
        return person.firstName + &#39;-&#39; + person.lastName
    &#125;)*/
    //计算属性完整版————考虑读和写
    person.fullName = computed(&#123;
        get()&#123;
            return person.firstName + &#39;-&#39; + person.lastName
        &#125;,
        set(value)&#123;
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        &#125;
    &#125;)
    return &#123;
        person
    &#125;
&#125; </code></pre>
<h2 id="数据监视-watch"><a href="#数据监视-watch" class="headerlink" title="数据监视 watch"></a>数据监视 watch</h2><p>Vue3 与 Vue2 中的 watch 配置功能一致</p>
<p>首先要 <code>import &#123;watch&#125; from &#39;vue&#39;</code>，把 <code>watch(...)</code> 写在 setup 里</p>
<p>情况一：监视 ref 定义的一个响应式数据</p>
<pre><code>watch(sum,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true&#125;)</code></pre>
<p>情况二：监视多个 ref 定义的响应式数据</p>
<pre><code>watch([sum,msg],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum 或 msg，newValue,oldValue 是数组，包含了 sum 和 msg 的值&#39;,newValue,oldValue)
&#125;,&#123;immediate:true&#125;)</code></pre>
<p>情况三：监视 ref 定义的对象类型的响应式数据</p>
<p>对象类型一般通过 reactive 定义，但若使用 ref 定义，则需使用如下两种方式的一种进行监视</p>
<pre><code>watch(person.value,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;)  //通过 person.value 获取到的是 Proxy 类型的对象，而 Proxy 类型对象通过 reactive 生成，所以此时相当于监视一个 reactive 定义的响应式数据 person.value

watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;)</code></pre>
<p>情况三：监视 reactive 定义的响应式数据</p>
<p>若 watch 监视的是 reactive 定义的响应式数据，则无法正确获得 oldValue，并且会强制开启深度监视（即对象中嵌套的对象中属性改变也能监测到）</p>
<pre><code>watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:false&#125;) //此处的 deep 配置不再奏效</code></pre>
<p>情况四：监视 reactive 定义的响应式数据中的某个属性</p>
<pre><code>watch(()=&gt;person.age,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true&#125;) //此处能拿到 oldValue

watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;) //此处由于监视的是 reactive 定义的对象中的属性，所以 deep 配置有效，并且此处无法拿到 oldValue，因为 job 也是 reactive 定义的</code></pre>
<p>情况五：监视 reactive 定义的响应式数据中的某些属性</p>
<pre><code>watch([()=&gt;person.name,()=&gt;person.age,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue)
&#125;)</code></pre>
<p>注意：监视 reactive 定义的响应式数据时，oldValue 无法正确获取，并强制开启了深度监视（deep 配置失效）</p>
<p>监视 reactive 定义的响应式数据中某个属性时 deep 配置有效，但是只有属性依然是 reactive 定义的时配置 deep 才有意义，当监视的是基本数据时无需配置 deep</p>
<h2 id="watchEffect-函数"><a href="#watchEffect-函数" class="headerlink" title="watchEffect 函数"></a>watchEffect 函数</h2><p>watch 的套路是既要指明监视的属性，也要指明监视的回调</p>
<p>watchEffect 的套路是不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性</p>
<p>watchEffect 有点类似于 computed，但 computed 注重的是计算出来的值（回调函数的返回值），所以必须要写返回值；而 watchEffect 更注重过程（回调函数的函数体），所以不再写返回值</p>
<p>首先要 <code>import &#123;watchEffect&#125; from &#39;vue&#39;</code>，把 <code>watchEffect(...)</code> 写在 setup 里</p>
<pre><code>//watchEffect 所指定的回调中用到的数据只要发生变化，则直接重新执行回调
watchEffect(()=&gt;&#123;
    const x1 = sum.value //监视 sum
    const x2 = person.age //监视 person.age
&#125;)</code></pre>
<h2 id="Vue3-生命周期"><a href="#Vue3-生命周期" class="headerlink" title="Vue3 生命周期"></a>Vue3 生命周期</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="Vue3生命周期"></p>
<p>Vue3 中可继续使用 Vue2 中的生命周期钩子，但有两个被更名：<br>    beforeDestory 改名为 beforeUnmount<br>    destroyed 改名为 unmounted</p>
<p>Vue3 也提供了 Composition API 形式的生命周期钩子（注意用之前需要 import 引入），与 Vue2 中钩子的对应关系如下</p>
<pre><code>beforeCreate ===&gt; setup() 若通过配置项写 beforeCreate，则 setup 在 beforeCreate 之前执行，但若要用组合 API 的形式（即放到 setup 中），则 beforeCreate 被 setup 代替，无需写 beforeCreate
created ===&gt; setup() //即 setup 相当于 created
beforeMount ===&gt; onBeforeMount
mounted ===&gt; onMounted
beforeUpdate ===&gt; onBeforeUpdate
updated ===&gt; onUpdated
beforeUnmount ===&gt; onBeforeUnmount
unmounted ===&gt; onUnmounted</code></pre>
<p>这些组合 API 在 setup 中使用，并且需要传入一个回调函数，如</p>
<pre><code>import &#123;onBeforeMount&#125; from &#39;vue&#39;

setup()&#123;
    onBeforeMount(()=&gt;&#123;&#125;)
&#125;</code></pre>
<p>若既写配置项中的生命周期也用组合式 API 的生命周期，则对应同一时期的钩子组合式 API 比配置项中的先执行</p>
<h2 id="自定义-hook"><a href="#自定义-hook" class="headerlink" title="自定义 hook"></a>自定义 hook</h2><p>hook 本质是一个函数，对 setup 函数中使用的 Composition API 进行了封装，类似于 Vue2 中的 mixin</p>
<p>自定义 hook 的优势：复用代码，让 setup 中的逻辑更清除易懂</p>
<p>新建 src/hooks/useXxx.js</p>
<pre><code>import &#123;reactive,onMounted,beforeUnmount&#125;
export default function()&#123;
    let xxx = ref(..)
    let xxxx = reactive(...)
    function xxxxx()&#123;...&#125;
    //生命周期钩子，如
    onMounted(()=&gt;&#123;...&#125;)
    beforeUnmount(()=&gt;&#123;...&#125;)
    return xxx
&#125;</code></pre>
<p>在组件中只需引入就可以复用该功能</p>
<pre><code>import useXxx from &#39;../hooks/useXxx&#39;
然后可直接使用 useXxx</code></pre>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><p>作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性值</p>
<p>语法：</p>
<pre><code>import toRef from &#39;vue&#39;
const name = toRef(person,&#39;name&#39;) //此时若修改 person 中的 name 属性，则变量 name 的值也跟着变；若是直接赋值 const name = persom.name 则当 person.name 修改时变量 name 不变</code></pre>
<p>应用：要将响应式对象中的某个属性单独提供给外部使用时</p>
<p>扩展：toRefs 与 toRef 功能一致，但可以批量创建多个 ref 对象，语法 <code>toRefs(person)</code></p>
<p>当暴露数据时</p>
<pre><code>&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;

setup()&#123;
    retun &#123;
        person,
        name:toRef(person,&#39;name&#39;), //把 person 里常用的一些属性单独暴露出来方便使用
        age:toRef(person,&#39;age&#39;),
        salary:toRef(person.job,&#39;salary&#39;)
        //上述代码也可用 toRefs 替代，批量暴露
        //...toRefs(person)
    &#125;
&#125;</code></pre>
<h2 id="其他-Composition-API"><a href="#其他-Composition-API" class="headerlink" title="其他 Composition API"></a>其他 Composition API</h2><h3 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h3><p>shallowReactive 只处理对象最外层属性的响应式（浅响应式），而 reactive 可处理深层次的对象</p>
<p>shallowRef 只处理基本数据类型的响应式，不进行对象的响应式处理，若传入对象，则 value 是 Object 类型，不是 Proxy 类型，而 Ref 可处理基本数据类型或对象</p>
<p>使用场景：</p>
<pre><code>若有一个对象数据，结构比较深，但变化时只是外层属性变化 ===&gt; shallowReactive
若有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 ===&gt; shallowRef</code></pre>
<h3 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h3><p>readonly 让一个响应式数据变为只读的（深只读）</p>
<p>shallowReadonly 让一个响应式数据变为只读的（浅只读，即只有对象的第一层数据不能改，但对象中的对象的属性可改）</p>
<p>应用场景：不希望数据被修改时</p>
<pre><code>import &#123;ref,reactive,readonly,shallowReadonly&#125; from &#39;vue&#39;
let sum = ref(0)
let person = reactive(&#123;...&#125;)
person = readonly(person)
sum = readonly(sum)
//person = shallowReadonly(person)</code></pre>
<h3 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h3><p><strong>toRaw：</strong></p>
<p>作用：将一个由 reactive 生成的响应式对象转为普通对象，不能转 ref 定义的基本数据类型，否则会返回 undefined</p>
<p>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作不会引起页面更新</p>
<pre><code>import &#123;toRaw&#125; from &#39;vue&#39;

const p = toRaw(person)</code></pre>
<p><strong>markRaw：</strong></p>
<p>作用：标记一个对象，使其永远不会再成为响应式对象</p>
<p>应用场景：</p>
<pre><code>（1）有些值不应该被设置为响应式的，例如复杂的第三方类库等
（2）当渲染具有不可变数据源的大列表时，跳过响应式转换可提高性能</code></pre>
<p>如</p>
<pre><code>import &#123;markRaw&#125; from &#39;vue&#39;
let car = &#123;name:&#39;xx&#39;,price:50&#125;
person.car = markRaw(car) //若直接追加属性 person.car 为 car 对象，则改属性自动为响应式，若无需响应式则加上 markRaw</code></pre>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</p>
<p>customRef 中需传入一个回调函数，且回调函数必须返回一个对象</p>
<p>实现防抖效果：</p>
<pre><code>import &#123;customRef&#125; from &#39;vue&#39;

setup()&#123;
    ler keyWord = myRef(&#39;hello&#39;,1000)
    function myRef(value,delay)&#123;
        let timer,
        return customRef((track,trigger)=&gt;&#123;
            return &#123;
                get()&#123; //当从 myRef 容器中读取数据时调用
                    track() //通知 Vue 追踪 value 的变化
                    return value
                &#125;,
                set(newValue)&#123;  //当修改 myRef 容器中的数据时调用
                    clearTimeout(timer)
                    timer = setTimeout(()=&gt;&#123;
                        value = newValue
                        trigger() //通知 Vue 去重新解析模板，这样会再次 get 获得值
                    &#125;,delay)

                &#125;
            &#125;
        &#125;)
    &#125;
&#125;</code></pre>
<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><p>作用：实现祖与后代组件间通信</p>
<p>套路：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据</p>
<p>祖组件中</p>
<pre><code>import &#123;reactive,toRefs,provide&#125; from &#39;vue&#39;
setup()&#123;
    ...
    let car = reactive(&#123;name:&#39;xx&#39;,price:50&#125;)
    provide(&#39;car&#39;,car)
    ...
    return &#123;...toRefs(car)&#125;
&#125;</code></pre>
<p>后代组件中</p>
<pre><code>import &#123;inject&#125; from &#39;vue&#39;
setup(props,context)&#123;
    ...
    const car = inject(&#39;car&#39;)
    return &#123;car&#125;
&#125;</code></pre>
<h3 id="响应式数据的判断-API"><a href="#响应式数据的判断-API" class="headerlink" title="响应式数据的判断 API"></a>响应式数据的判断 API</h3><p>isRef：检查一个值是否为一个 ref 对象</p>
<p>isReactive：检查一个对象是否是由 reactive 创建的响应式代理</p>
<p>isReadonly：检查一个对象是否是由 readonly 创建的只读代理</p>
<p>isProxy：检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</p>
<h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p><strong>Options API （Vue2 中所使用的方式）存在的问题：</strong></p>
<p>使用传统 Options API 中，新增或者修改一个需求，就需要分别在 data、methods、computed 里修改</p>
<p><strong>Composition API 的优势：</strong></p>
<p>利用组合式 API 可以更加优雅的组织我们的代码、函数，让相关功能的代码更加有序的组织在一起（结合 hooks）</p>
<h2 id="新组件"><a href="#新组件" class="headerlink" title="新组件"></a>新组件</h2><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>在 Vue2 中组件必须有一个根标签</p>
<p>在 Vue3 中组件可以没有根标签，内部会自动将多个标签包含在一个 Fragment 虚拟元素中</p>
<p>好处：减少标签层级，减小内存占用</p>
<h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Teleport 是一种能够将组件 html 结构移动到指定位置的技术</p>
<pre><code>&lt;Teleport to=&quot;内部要显示在的标签如 html、body、#id 等&quot;&gt;
    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
        &lt;div class=&quot;dialog&quot;&gt;
            &lt;h3&gt;一个弹窗&lt;/h3&gt;
            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/Teleport&gt;</code></pre>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
<p>若使用普通 import 静态引入组件则若子孙组件未加载完成则祖组件也都不会渲染，直到内部组件加载完成后一起渲染</p>
<p>而动态/异步引入则当内部组件未加载完成时可先渲染外部组件</p>
<p>使用步骤：</p>
<p>（1）异步引入组件</p>
<pre><code>import &#123;defineAsyncComponent&#125; from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;)) //动态/异步引入组件</code></pre>
<p>（2）使用 Suspense 包裹组件，并配置好 default 与 fallback</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;xxx&lt;/h1&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt; &lt;!--真正要展示的内容--&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt; &lt;!--当真正要展示的内容加载不出来时显示--&gt;
                &lt;h1&gt;加载中...&lt;/h1&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;    
    &lt;/div&gt;
&lt;/template&gt;</code></pre>
<p>注意：当使用了 Suspense 和异步引入后 setup 返回值就可以是一个 Promise 对象</p>
<p>在异步引入的组件中</p>
<pre><code>async setup()&#123;
    let p = new Promise((resolve,reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            resolve(&#123;sum&#125;)
        &#125;,1000)
    &#125;)
    return await p
&#125;</code></pre>
<h2 id="全局-API-的转移"><a href="#全局-API-的转移" class="headerlink" title="全局 API 的转移"></a>全局 API 的转移</h2><p>Vue2 有许多全局 API 和配置，如：注册全局组件、注册全局指令等</p>
<pre><code>//注册全局组件
Vue.component(&#39;xx&#39;,&#123;
    data:()=&gt;(&#123;
        count:0
    &#125;),
    template:&#39;&lt;button @click=&quot;count++&quot;&gt;xx&lt;/button&gt;&#39;
&#125;)
//注册全局指令
Vue.directive(&#39;focus&#39;,&#123;
    inserted:el =&gt; el.focus()
&#125;)</code></pre>
<p>Vue3 中对这些 API 做出了调整，将全局 API，即 Vue.xxx 调整到应用实例（即 createApp 生成的 app）上</p>
<table>
<thead>
<tr>
<th>Vue2 全局 API（在 Vue 上）</th>
<th>Vue3 实例 API（在 app 上）</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxx</td>
<td>app.config.xxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
<p>其他改变：</p>
<p>data 选项应是始终被声明为一个函数</p>
<p>过度类名的更改</p>
<pre><code>Vue2 写法
.v-enter,.v-leave-to&#123;
    opacity:0;
&#125;
.v-leave,.v-enter-to&#123;
    opacity:1;
&#125;

Vue3 写法
.v-enter-from,.v-leave-to&#123;
    opacity:0;
&#125;
.v-leave-from,.v-enter-to&#123;
    opacity:1;
&#125;</code></pre>
<p>移除 keyCode 作为 v-on 的修饰符，同时不再支持 config.keyCodes</p>
<pre><code>Vue2 中
@keyup.13 标识按下回车
Vue.config.keyCodes.huiche = 13 //定义别名按键</code></pre>
<p>移除 v-on.native 修饰符</p>
<pre><code>父组件中绑定事件
&lt;子组件 v-on:close=&quot;函数&quot; v-on:click=&quot;函数&quot;/&gt;

子组件中声明自定义事件
export default&#123;
    emits:[&#39;close&#39;] //此处没声明 click则父组件中给子组件绑定的 click 为原生事件
&#125;</code></pre>
<p>移除过滤器：过滤器需要一个自定义语法，打破大括号内表达式是“只是 JavaScript” 的假设，有学习成本和实现成本，建议用方法调用或计算属性替换过滤器</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="js-表达式和-js-代码-语句"><a href="#js-表达式和-js-代码-语句" class="headerlink" title="js 表达式和 js 代码/语句"></a>js 表达式和 js 代码/语句</h2><p>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如</p>
<pre><code>a
a+b
demo(1)
x === y ? &#39;a&#39; : &#39;b&#39;</code></pre>
<p>代码/语句，如</p>
<pre><code>if(...)&#123;...&#125;
for(...)&#123;...&#125;</code></pre>
<p>表达式是一种特殊的语句</p>
<h2 id="vscode-中-vue-相关插件"><a href="#vscode-中-vue-相关插件" class="headerlink" title="vscode 中 vue 相关插件"></a>vscode 中 vue 相关插件</h2><p>Vue 3 Snippets 会提示代码</p>
<p>Vetur 对符合 Vue 的代码有高亮</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><img src="/2022/02/25/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cookie%E5%9B%BE%E7%A4%BA.png" alt="cookie图示"></p>
<p>在设置 cookie 时重要的 cookie 要设置 HttpOnly，这样就不能通过 document.cookie 获取</p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>注意使用 v-model 绑定的值不能是 props 传来的值，因为 props 是不可以修改的</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props 传来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做，因为 Vue 主要监视的是对象值的地址是否发生变化 </p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>$nextTick 的回调会在 DOM 更新后再执行</p>
<pre><code>this.$nextTick(function()&#123;...&#125;)</code></pre>
<p>作用：$nextTick 在下一次 DOM 更新结束后执行其指定的回调</p>
<p>适用场景：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 $nextTick 所指定的回调函数中执行</p>
<p>如原本 xxx DOM 元素的 v-show 为 false，即不在页面上显示，在某函数中将 v-show 改为 true 并获取该 DOM 元素焦点，但是 Vue 会在函数执行完后才会重新解析模板重新渲染，所以函数中对 DOM 元素获取焦点的操作无效，因为那时页面中并没有相应 DOM 元素，因此可以借助 $nextTick 的回调使得当 v-show 改为 true 页面重新渲染， DOM 元素出现在页面中后再执行对它获取焦点的操作</p>
<p>当然 $nextTick 也可以通过利用不指定时间定时器来代替该函数</p>
<pre><code>setTimeout(()=&gt;&#123;...&#125;)</code></pre>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>插值语法中可以展示 data、props、computed 中的数据</p>
<p>Vue3 + TS 相关笔记可参考<a href="https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html">尚硅谷的课程笔记</a></p>
<p>Vue 中数据代理、数据劫持、计算属性的原理都用到 Object.defineproperty</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Promise学习笔记</title>
    <url>/2022/03/14/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、一些基础知识"><a href="#一、一些基础知识" class="headerlink" title="一、一些基础知识"></a>一、一些基础知识</h1><a id="more"></a>

<h2 id="两种类型的回调函数"><a href="#两种类型的回调函数" class="headerlink" title="两种类型的回调函数"></a>两种类型的回调函数</h2><h3 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h3><p>同步回调立即执行，完全执行完了才结束，不会放入回调队列中</p>
<p>如数组遍历相关的回调函数、Promise 的 excutor 函数</p>
<pre><code>const arr = [1,2,3]
arr.forEach(item=&gt;&#123;
    console.log(item)
&#125;)
console.log(&#39;forEach之后才输出&#39;)
输出：1 2 3 forEach之后才输出</code></pre>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p>异步回调不会立即执行，会放入回调队列中将来执行</p>
<p>如定时器回调、ajax 回调、Promise 的成功/失败回调</p>
<h2 id="js-的-Error-处理"><a href="#js-的-Error-处理" class="headerlink" title="js 的 Error 处理"></a>js 的 Error 处理</h2><h3 id="错误类型-常见的内置错误"><a href="#错误类型-常见的内置错误" class="headerlink" title="错误类型/常见的内置错误"></a>错误类型/常见的内置错误</h3><p>Error：所有错误的父类型</p>
<p>ReferenceError：引用的变量不存在，如 a is not defined</p>
<p>TypeError：数据类型不正确的错误，如 Cannot read property ‘xxx’ of undefined 或 xx.xxx is not a function</p>
<p>RangeError：数据值不在其所允许的范围内，如 递归中没有 return，则 RangeError:Maximun call stack size exceeded</p>
<p>SyntaxError：语法错误</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>捕获错误：try{…}catch(error){…}</p>
<p>抛出错误：throw new Error(‘xxx’)</p>
<pre><code>function func()&#123;
    if(...)&#123;
    &#125;else&#123;
        throw new Error(&#39;出错&#39;) //这里只抛出错误，具体要怎么处理是在控制台输出还是弹窗由下一级处理
    &#125;
&#125;
try&#123;
    func()
&#125;catch(error)&#123;
    console.log(error.message) //这里捕获错误在控制台输出
&#125;</code></pre>
<h2 id="错误对象"><a href="#错误对象" class="headerlink" title="错误对象"></a>错误对象</h2><p>message 属性：错误相关信息</p>
<p>stack 属性：函数调用栈记录信息</p>
<h1 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h1><p>Promise 是 ES6 引入的异步编程的新的解决方案，旧的解决方案是使用回调函数</p>
<p>Promise 是个构造函数，Promise 对象用来封装一个异步操作（如 fs 文件操作、数据库操作、ajax、定时器）并可以获取其成功或失败的结果值</p>
<p>Promise 最大的好处是可以解决回调地狱问题，并在指定回调和错误处理方面更灵活</p>
<h2 id="promise-的状态改变"><a href="#promise-的状态改变" class="headerlink" title="promise 的状态改变"></a>promise 的状态改变</h2><p>（1）pending 变为 resolved</p>
<p>（2）pending 变为 rejected</p>
<p>注意：只有上面这 2 中情况，且一个 promise 对象只能改变一次状态</p>
<p>无论变为成功或失败，都会有一个结果数据（value 或 reason）</p>
<h2 id="promise运行流程"><a href="#promise运行流程" class="headerlink" title="promise运行流程"></a>promise运行流程</h2><p><img src="/2022/03/14/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/promise%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="promise运行流程"></p>
<h2 id="为什么使用-Promise"><a href="#为什么使用-Promise" class="headerlink" title="为什么使用 Promise"></a>为什么使用 Promise</h2><h3 id="（1）指定回调函数的方式更灵活"><a href="#（1）指定回调函数的方式更灵活" class="headerlink" title="（1）指定回调函数的方式更灵活"></a>（1）指定回调函数的方式更灵活</h3><p>旧的使用回调函数必须在启动异步任务前指定</p>
<p>promise：启动异步任务（只要 new 创建了 promise 对象就启动了异步任务） =&gt; 返回 promise 对象 =&gt; 给 promise 对象绑定回调函数（甚至可以在异步任务结束后指定/多个）</p>
<h3 id="（2）支持链式调用，可以解决回调地狱问题"><a href="#（2）支持链式调用，可以解决回调地狱问题" class="headerlink" title="（2）支持链式调用，可以解决回调地狱问题"></a>（2）支持链式调用，可以解决回调地狱问题</h3><p>回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p>
<p>回调地狱不便于阅读，也不便于异常处理</p>
<p>解决方案：promise 链式调用，还可异常传透链式调用出错了会找到最后一个 catch 处理异常</p>
<p>终极解决方案：async / await</p>
<h2 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>（1）Promise 构造函数 <code>Promise(excutor)&#123;&#125;</code></p>
<pre><code>excutor 函数：执行器 (resolve,reject)=&gt;&#123;&#125;
resolve 函数：内部定义成功时调用的函数 value =&gt; &#123;&#125;
reject 函数：内部定义失败时调用的函数 reason =&gt; &#123;&#125;</code></pre>
<p>注意：excutor 会在 Promise 内部立即<strong>同步回调</strong>，异步操作在执行器中执行，then 也是<strong>同步执行</strong>的，但 then 里的回调函数异步执行</p>
<p>（2）<code>Promise.protorype.then</code> 方法 <code>(onResolved,onRejected)=&gt;&#123;&#125;</code></p>
<pre><code>onResolved 函数：成功的回调函数 (value) =&gt; &#123;&#125;
onRejected 函数：失败的回调函数 (reason) =&gt; &#123;&#125;</code></pre>
<p>注意：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调返回一个新的 promise 对象</p>
<p>（3）<code>Promise.protorype.catch</code> 方法 <code>(onRejected)=&gt;&#123;&#125;</code></p>
<pre><code>onRejected 函数：失败的回调函数 (reason) =&gt; &#123;&#125;</code></pre>
<p>注意：是 then() 的语法糖，相当于 then(undefined,onRejected)</p>
<p>（4）<code>Promise.resolve</code> 方法 <code>(value)=&gt;&#123;&#125;</code></p>
<pre><code>value 是成功的数据或 promise 对象

如 const p = Promise.resolve(1) //返回一个成功值为 1 的 promise 对象
p.then(value=&gt;&#123;console.log(value)&#125;)</code></pre>
<p>注意：该方法返回一个成功/失败的 promise 对象，返回一个成功/失败的 promise 对象的简洁语法</p>
<p>（5）<code>Promise.reject</code> 方法 <code>(reason)=&gt;&#123;&#125;</code></p>
<pre><code>如 const p = Promise.reject(1) //返回一个失败值为 1 的 promise 对象
p.catch(reason=&gt;&#123;console.log(reason)&#125;)</code></pre>
<p>注意：该方法返回一个失败的 promise 对象</p>
<p>（6）<code>Promise.all</code> 方法 <code>(promises)=&gt;&#123;&#125;</code></p>
<pre><code>promises 包含 n 个 promise 的数组

如 const pAll = Promise.all([p1,p2,p3])
pAll.then(
    value=&gt;&#123;...&#125;,
    reason=&gt;&#123;...&#125;
)</code></pre>
<p>注意：该方法返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p>
<p>（7）<code>Promise.race</code> 方法 <code>(promises)=&gt;&#123;&#125;</code></p>
<pre><code>promises 包含 n 个 promise 的数组

如 const pAll = Promise.race([p1,p2,p3])
pAll.then(
    value=&gt;&#123;...&#125;,
    reason=&gt;&#123;...&#125;
)</code></pre>
<p>注意：该方法返回一个新的 promise 对象，第一个完成的 promise 的结果状态就是最终的结果状态</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>new Promise((resolve,reject)=&gt;&#123;    //执行器函数，里面执行异步操作任务
    setTimeout(()=&gt;&#123;
        if(...)&#123;
            resolve(&#39;成功&#39;)
        &#125; else&#123;
            reject(&#39;失败&#39;)
        &#125;
    &#125;,1000)
&#125;)
p.then(
    value=&gt;&#123;  //接收成功的 value 数据 onResolved
        console.log(value)
    &#125;,
    reason=&gt;&#123; //接收失败的 reason 数据 onRejected
        console.log(reason)
    &#125;
)</code></pre>
<h2 id="如何改变-promise-状态"><a href="#如何改变-promise-状态" class="headerlink" title="如何改变 promise 状态"></a>如何改变 promise 状态</h2><p>（1）resolve(value)：若当前是 pendding 就变为 resolved</p>
<p>（2）reject(reason)：若当前是 pendding 就变为 rejected</p>
<p>（3）抛出异常：若当前是 pendding 就变为 rejected</p>
<h2 id="一个-promise-指定多个成功-失败回调函数（如多次对一个-Promise-对象调用-then），都会调用吗"><a href="#一个-promise-指定多个成功-失败回调函数（如多次对一个-Promise-对象调用-then），都会调用吗" class="headerlink" title="一个 promise 指定多个成功/失败回调函数（如多次对一个 Promise 对象调用 then），都会调用吗"></a>一个 promise 指定多个成功/失败回调函数（如多次对一个 Promise 对象调用 then），都会调用吗</h2><p>当 promise 改变对应状态时都会调用</p>
<h2 id="改变-promise-状态和指定回调函数谁先谁后？"><a href="#改变-promise-状态和指定回调函数谁先谁后？" class="headerlink" title="改变 promise 状态和指定回调函数谁先谁后？"></a>改变 promise 状态和指定回调函数谁先谁后？</h2><p>（1）都有可能，正常情况下（执行器中是异步任务，resolve()/reject() 在异步任务中）先指定回调再改变状态同时执行回调函数，也可以先改变状态再指定回调</p>
<p>（2）如何先改状态再指定回调</p>
<pre><code>1）再执行器中直接调用 resolve()/reject()
2）延迟更长时间才调用 then()</code></pre>
<p>（3）什么时候才能得到数据？</p>
<pre><code>1）若先指定回调，当状态发生改变时，回调函数就会调用，得到数据
2）若先改变状态，当指定回调时，回调函数就会调用，得到数据</code></pre>
<p>如先指定回调再改变状态</p>
<pre><code>new Promise((resolve,reject)=&gt;&#123;
    setTimeout(()=&gt;&#123;
        resolve(1) //后改变状态同时指定数据，异步执行回调函数
    &#125;,100)
&#125;).then( //先指定回调函数，保存当前指定的回调函数
    value =&gt; &#123;&#125;,
    reason =&gt;&#123;&#125;
)</code></pre>
<p>先改变状态再指定回调1</p>
<pre><code>new Promise((resolve,reject)=&gt;&#123;
    resolve(1)  //先改状态同时指定数据
&#125;).then( //后指定回调函数，异步执行回调函数
    value =&gt; &#123;&#125;,
    reason =&gt;&#123;&#125;
)</code></pre>
<p>先改变状态再指定回调2</p>
<pre><code>const p = new Promise((resolve,reject)=&gt;&#123;
    setTimeout(()=&gt;&#123;
        resolve(1)   //先改状态同时指定数据
    &#125;,100)
&#125;)
setTimeout(()=&gt;&#123;
    p.then(  //后指定回调函数
        value =&gt; &#123;&#125;,
        reason =&gt;&#123;&#125;
    )
&#125;,110)</code></pre>
<h2 id="promise-then-返回的新-promise-的结果状态由什么决定？"><a href="#promise-then-返回的新-promise-的结果状态由什么决定？" class="headerlink" title="promise.then() 返回的新 promise 的结果状态由什么决定？"></a>promise.then() 返回的新 promise 的结果状态由什么决定？</h2><p>简单表达：由 then() 指定的回调函数执行结果决定</p>
<p>详细表达：</p>
<pre><code>（1）若抛出异常，新 promise 变为 rejected，reason 为抛出的异常
（2）若返回非 promise 的任意值，新 promise 变为 resolved，value 为返回的值
（3）若返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果</code></pre>
<p>如</p>
<pre><code>new Promise((resolve,reject)=&gt;&#123;
    resolve(1)
&#125;).then(
    value =&gt; &#123;
        console.log(&#39;onResolved1&#39;,value)
    &#125;,
    reason =&gt;&#123;
        console.log(&#39;onRejected1&#39;,reason)
    &#125;
)
.then(
    value =&gt; &#123;
        console.log(&#39;onResolved2&#39;,value)
    &#125;,
    reason =&gt;&#123;
        console.log(&#39;onRejected2&#39;,reason)
    &#125;
)</code></pre>
<p>上述代码输出：onResolved1 1 onResolved2 undefined</p>
<pre><code>new Promise((resolve,reject)=&gt;&#123;
    reject(1)
&#125;).then(
    value =&gt; &#123;
        console.log(&#39;onResolved1&#39;,value)
    &#125;,
    reason =&gt;&#123;
        console.log(&#39;onRejected1&#39;,reason)
    &#125;
)
.then(
    value =&gt; &#123;
        console.log(&#39;onResolved2&#39;,value)
    &#125;,
    reason =&gt;&#123;
        console.log(&#39;onRejected2&#39;,reason)
    &#125;
)</code></pre>
<p>上述代码输出：onRejected1 1 onResolved2 undefined</p>
<h2 id="promise-如何串联多个操作任务？"><a href="#promise-如何串联多个操作任务？" class="headerlink" title="promise 如何串联多个操作任务？"></a>promise 如何串联多个操作任务？</h2><p>（1）promise 的 then() 返回一个新的 promise，可以看成 then() 的链式调用</p>
<p>（2）通过 then 的链式调用串联多个同步/异步任务，其中异步任务要包在一个 promise 里</p>
<h2 id="promise-异常传-穿透"><a href="#promise-异常传-穿透" class="headerlink" title="promise 异常传/穿透"></a>promise 异常传/穿透</h2><p>（1）当使用 promise 的 then 链式调用时，可在最后指定失败的回调</p>
<p>当 then 中没有对失败时 reason 的处理时相当于默认执行 <code>reason =&gt; &#123;throw reason&#125;</code></p>
<p>（2）前面任何操作出了异常，都会传到最后失败的回调中处理</p>
<h2 id="中断-promise-链"><a href="#中断-promise-链" class="headerlink" title="中断 promise 链"></a>中断 promise 链</h2><p>当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数</p>
<p>办法：在回调函数中返回一个 pendding 状态的 promise 对象</p>
<pre><code>return new Promise(()=&gt;&#123;&#125;)</code></pre>
<h1 id="三、自定义-Promise"><a href="#三、自定义-Promise" class="headerlink" title="三、自定义 Promise"></a>三、自定义 Promise</h1><pre><code>(function(window)&#123;
    function Promise(excutor)&#123;
        const self = this //将当前 promise 保存起来，否则调用 resolve 函数中的 this 为 window
        self.status = &#39;pending&#39;
        self.data = undefined //用于存储结果数据
        self.callbacks = [] //每个元素：&#123;onResolved()&#123;&#125;,onRejected()&#123;&#125;&#125;
        function resolve(value)&#123;
            if(self.status !== &#39;pending&#39;)&#123;return &#125;
            self.status = &#39;resolved&#39;
            self.data = value
            //
            if(self.callbacks.length&gt;0)&#123;
                setTimeout(()=&gt;&#123; //放入队列中执行所有成功的回调
                        self.callbacks.forEach(callbacksObj =&gt; &#123;
                        callbacksObj.onResolved(value)
                    &#125;)
                &#125;)
            &#125;
        &#125;
        function reject(reason)&#123;
            if(self.status !== &#39;pending&#39;)&#123;return &#125;
            self.status = &#39;rejected&#39;
            self.data = reason
            //
            if(self.callbacks.length&gt;0)&#123;
                setTimeout(()=&gt;&#123; //放入队列中执行所有失败的回调
                        self.callbacks.forEach(callbacksObj =&gt; &#123;
                        callbacksObj.onRejected(reason)
                    &#125;)
                &#125;)
            &#125;
        &#125;
        //立即同步执行 excutor
        try&#123;
            excutor(resolve,reject)
        &#125;catch(error)&#123; //若执行器抛出异常，promise 对象变为 rejected 状态
            reject(error)
        &#125;
    &#125;
    //Promise 原型对象的 then，指定成功或失败的回调函数，返回新的 promise 对象
    Promise.prototype.then = function(onResolved,onRejected)&#123;
        onResolved = typeof onResolved === &#39;function&#39; ? onResolved : value =&gt; value //向后传递成功的 value
        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; &#123;throw reason&#125; //指定默认的失败回调（实现错误/异常传透的关键点）
        const self = this
        return new Promise((resolve,reject)=&gt;&#123;
            function handle(callback)&#123; //调用指定的回调函数处理，并根据执行结果改变 return 的 promise 的状态
                try&#123;
                    const result = callback(self.data)
                    if(result instanceof Promise)&#123;
                        result.then( //只有 .then 才能获取到 result 的结果
                            value =&gt;resolve(value),
                            reason =&gt; reject(reason)
                        )
                        //或简写为 result.then(resolve,reject)
                    &#125;else&#123;
                        resolve(result)
                    &#125;
                &#125;catch(error)&#123;
                    reject(error)
                &#125;
            &#125;
            if(self.status === &#39;pending&#39;)&#123;
                //当前为 pending 状态，将回调函数保存起来，保存的函数里会取调用所保存函数来改变 promise 状态
                self.callbacks.push(&#123;
                    onResolved(value)&#123; //这里能接收个 value，但没用
                        handle(onResolved)
                    &#125;,
                    onRejected(reason)&#123;
                        handle(onRejected)
                    &#125;,
                &#125;)
            &#125;else if(self.status === &#39;resolved&#39;)&#123;
                //当前是 resolved 状态，异步执行 onResolve 并改变 return 的 promise 状态
                setTimeout(()=&gt;&#123;
                    handle(onResolved)
                &#125;)
            &#125;else&#123;
                setTimeout(()=&gt;&#123;
                    handle(onRejected)
                &#125;)
            &#125;
        &#125;)

    &#125;
    //Promise 原型对象的 catch，指定失败的回调函数，返回新的 promise 对象
    Promise.prototype.catch = function(onRejected)&#123;
        return this.then(undefined,onRejected)
    &#125;
    //Promise 函数对象的 resolve 方法，返回一个指定结果的 promise
    Promise.resolve = function(value)&#123;
        return new Promise((resolve,reject)=&gt;&#123;
            if(value instanceof Promise)&#123;
                value.then(resolve,reject)
            &#125;else&#123;
                resolve(value)
            &#125;
        &#125;)
    &#125;
    //Promise 函数对象的 reject 方法，返回一个指定 reason 的失败的 promise
    Promise.reject = function(reason)&#123;
        return new Promise((resolve,reject)=&gt;&#123;
            reject(reason)
        &#125;)
    &#125;
    //Promise 函数对象的 all 方法，返回一个 promise，只有当所有 promise 都成功时才成功，否则只要有一个失败就失败
    Promise.all = function(promises)&#123;
        const values = new Array(promises.length) //保存所有成功 value 的数组
        let resolvedCount = 0 //保存成功 promise 的数量
        return new Promise((resolve,reject)=&gt;&#123;
            //遍历获取每个 promise 的结果
            promises.forEach((p,index)=&gt;&#123;
                Promise.resolve(p).then( //Promise.resolve(p)是处理传入的数组中包含的纯数字
                    value=&gt;&#123;
                        resolvedCount++
                        values[index] = value
                        if(resolvedCount === promises.length)&#123;
                            resolve(values)
                        &#125;
                    &#125;,
                    reason =&gt; &#123;
                        reject(reason)
                    &#125;
                )
            &#125;)
        &#125;)
    &#125;
    //Promise 函数对象的 race 方法，返回一个 promise，其结果由第一个完成（注意不是指位置上的第一个）的 promise 决定
    Promise.race = function(promises)&#123;
        return new Promise((resolve,reject)=&gt;&#123;
            promises.forEach((p,index)=&gt;&#123;
                Promise.resolve(p).then(
                    value =&gt; &#123;
                        resolve(value)
                    &#125;,
                    reason =&gt; &#123;
                        reject(reason)
                    &#125;
                )
            &#125;)
        &#125;)
    &#125;
    window.Promise = Promise
&#125;)(window)</code></pre>
<h2 id="自定义-Promise-的其他方法"><a href="#自定义-Promise-的其他方法" class="headerlink" title="自定义 Promise 的其他方法"></a>自定义 Promise 的其他方法</h2><p>Promise 的 resolveDelay 和 rejectDelay，都返回一个 Promise 对象，它们在指定的时间后才确定结果</p>
<pre><code>Promise.resolveDelay = function(value,time)&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            if(value instanceof Promise)&#123;
                value.then(resolve,reject)
            &#125;else&#123;
                resolve(value)
            &#125;
        &#125;,time)
    &#125;)
&#125;

Promise.rejectDelay = function(reason,time)&#123;
    const self = this
    return new Promise((resolve,reject)=&gt;&#123;
        setTimeout(()=&gt;&#123;
            reject(reason)
        &#125;,time)
    &#125;)
&#125;</code></pre>
<h2 id="Promise-的-class-版本"><a href="#Promise-的-class-版本" class="headerlink" title="Promise 的 class 版本"></a>Promise 的 class 版本</h2><pre><code>(function(window)&#123;
    class Promise&#123;
        constructor(excutor)&#123;
            const self = this //将当前 promise 保存起来，否则调用 resolve 函数中的 this 为 window
            self.status = &#39;pending&#39;
            self.data = undefined //用于存储结果数据
            self.callbacks = [] //每个元素：&#123;onResolved()&#123;&#125;,onRejected()&#123;&#125;&#125;
            function resolve(value)&#123;
                if(self.status !== &#39;pending&#39;)&#123;return &#125;
                self.status = &#39;resolved&#39;
                self.data = value
                //
                if(self.callbacks.length&gt;0)&#123;
                    setTimeout(()=&gt;&#123; //放入队列中执行所有成功的回调
                            self.callbacks.forEach(callbacksObj =&gt; &#123;
                            callbacksObj.onResolved(value)
                        &#125;)
                    &#125;)
                &#125;
            &#125;
            function reject(reason)&#123;
                if(self.status !== &#39;pending&#39;)&#123;return &#125;
                self.status = &#39;rejected&#39;
                self.data = reason
                //
                if(self.callbacks.length&gt;0)&#123;
                    setTimeout(()=&gt;&#123; //放入队列中执行所有失败的回调
                            self.callbacks.forEach(callbacksObj =&gt; &#123;
                            callbacksObj.onRejected(reason)
                        &#125;)
                    &#125;)
                &#125;
            &#125;
            //立即同步执行 excutor
            try&#123;
                excutor(resolve,reject)
            &#125;catch(error)&#123; //若执行器抛出异常，promise 对象变为 rejected 状态
                reject(error)
            &#125;
        &#125;
        //Promise 原型对象的 then，指定成功或失败的回调函数，返回新的 promise 对象
        then(onResolved,onRejected)&#123;
            onResolved = typeof onResolved === &#39;function&#39; ? onResolved : value =&gt; value //向后传递成功的 value
            onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; &#123;throw reason&#125; //指定默认的失败回调（实现错误/异常传透的关键点）
            const self = this
            return new Promise((resolve,reject)=&gt;&#123;
                function handle(callback)&#123; //调用指定的回调函数处理，并根据执行结果改变 return 的 promise 的状态
                    try&#123;
                        const result = callback(self.data)
                        if(result instanceof Promise)&#123;
                            result.then( //只有 .then 才能获取到 result 的结果
                                value =&gt;resolve(value),
                                reason =&gt; reject(reason)
                            )
                            //或简写为 result.then(resolve,reject)
                        &#125;else&#123;
                            resolve(result)
                        &#125;
                    &#125;catch(error)&#123;
                        reject(error)
                    &#125;
                &#125;
                if(self.status === &#39;pending&#39;)&#123;
                    //当前为 pending 状态，将回调函数保存起来，保存的函数里会取调用所保存函数来改变 promise 状态
                    self.callbacks.push(&#123;
                        onResolved(value)&#123; //这里能接收个 value，但没用
                            handle(onResolved)
                        &#125;,
                        onRejected(reason)&#123;
                            handle(onRejected)
                        &#125;,
                    &#125;)
                &#125;else if(self.status === &#39;resolved&#39;)&#123;
                    //当前是 resolved 状态，异步执行 onResolve 并改变 return 的 promise 状态
                    setTimeout(()=&gt;&#123;
                        handle(onResolved)
                    &#125;)
                &#125;else&#123;
                    setTimeout(()=&gt;&#123;
                        handle(onRejected)
                    &#125;)
                &#125;
            &#125;)

        &#125;
        //Promise 原型对象的 catch，指定失败的回调函数，返回新的 promise 对象
        catch(onRejected)&#123;
            return this.then(undefined,onRejected)
        &#125;
        //Promise 函数对象的 resolve 方法，返回一个指定结果的 promise
        static resolve = function(value)&#123;
            return new Promise((resolve,reject)=&gt;&#123;
                if(value instanceof Promise)&#123;
                    value.then(resolve,reject)
                &#125;else&#123;
                    resolve(value)
                &#125;
            &#125;)
        &#125;
        //Promise 函数对象的 reject 方法，返回一个指定 reason 的失败的 promise
        static reject = function(reason)&#123;
            return new Promise((resolve,reject)=&gt;&#123;
                reject(reason)
            &#125;)
        &#125;
        //Promise 函数对象的 all 方法，返回一个 promise，只有当所有 promise 都成功时才成功，否则只要有一个失败就失败
        static all = function(promises)&#123;
            const values = new Array(promises.length) //保存所有成功 value 的数组
            let resolvedCount = 0 //保存成功 promise 的数量
            return new Promise((resolve,reject)=&gt;&#123;
                //遍历获取每个 promise 的结果
                promises.forEach((p,index)=&gt;&#123;
                    Promise.resolve(p).then( //Promise.resolve(p)是处理传入的数组中包含的纯数字
                        value=&gt;&#123;
                            resolvedCount++
                            values[index] = value
                            if(resolvedCount === promises.length)&#123;
                                resolve(values)
                            &#125;
                        &#125;,
                        reason =&gt; &#123;
                            reject(reason)
                        &#125;
                    )
                &#125;)
            &#125;)
        &#125;
        //Promise 函数对象的 race 方法，返回一个 promise，其结果由第一个完成（注意不是指位置上的第一个）的 promise 决定
        static race = function(promises)&#123;
            return new Promise((resolve,reject)=&gt;&#123;
                promises.forEach((p,index)=&gt;&#123;
                    Promise.resolve(p).then(
                        value =&gt; &#123;
                            resolve(value)
                        &#125;,
                        reason =&gt; &#123;
                            reject(reason)
                        &#125;
                    )
                &#125;)
            &#125;)
        &#125;
    &#125;
    window.Promise = Promise
&#125;)(window)</code></pre>
<h1 id="四、async-与-await"><a href="#四、async-与-await" class="headerlink" title="四、async 与 await"></a>四、async 与 await</h1><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数返回值为 promise 对象</p>
<p>promise 对象的结果由 async 函数执行的返回值决定</p>
<h2 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h2><p>await 右侧的表达式一般为 promise 对象，但也可以是其他的值，若为其他值则返回该值本身</p>
<p>若表达式为 promise 对象，await 返回的是 promise 成功的值，若返回的 promise 失败，就会抛出异常，要得到失败的结果要用 try…catch</p>
<pre><code>function fun()&#123;
    return new Promise((resolve,reject)=&gt;&#123;
        reject(1)
    &#125;)
&#125;
async function fun1()&#123;
    try&#123;
        const value = await fun()
    &#125;catch(error)&#123;
        console.log(&#39;得到失败的结果&#39;,value)
    &#125;
&#125;</code></pre>
<p>await 必须写在 async 函数中</p>
<h1 id="五、JS-异步之宏队列与微队列"><a href="#五、JS-异步之宏队列与微队列" class="headerlink" title="五、JS 异步之宏队列与微队列"></a>五、JS 异步之宏队列与微队列</h1><p>JS 中用来存储执行回调函数的队列包含 2 个不同特定的列队</p>
<p>宏队列：保存待执行的宏任务（一些回调函数），如定时器回调、DOM 事件回调、ajax 回调</p>
<p>微队列：保存待执行的微任务（一些回调函数），如 promise 的回调（如 then 等）、MutationObserver 的回调</p>
<p>JS 执行时会区别这 2 个队列</p>
<pre><code>（1）JS 引擎首先必须先执行所有的初始化同步任务代码
（2）每次准备取出每个宏任务执行前，都要将所有的微任务一个个取出来执行</code></pre>
<p><img src="/2022/03/14/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%8F%E9%98%9F%E5%88%97%E5%BE%AE%E9%98%9F%E5%88%97.jpg" alt="宏队列微队列"></p>
<p>例子1</p>
<pre><code>const first = () =&gt; (new Promise((resolve,reject)=&gt;&#123;
    console.log(3)
    let p = new Promise((resolve,reject)=&gt;&#123;
        console.log(7)
        setTimeout(()=&gt;&#123;
            console.log(5)
            resolve(6)
        &#125;,0)
        resolve(1)
    &#125;)
    resolve(2)
    p.then((arg)=&gt;&#123;
        console.log(arg)
    &#125;)
&#125;))
first().then((arg)=&gt;&#123;
    console.log(arg)
&#125;)
console.log(4)</code></pre>
<p>上述代码输出：3 7 4 1 2 5</p>
<p>例子2</p>
<pre><code>setTimeout(()=&gt;&#123;
    console.log(0)
&#125;,0)
new Promise((resolve,reject)=&gt;&#123;
    console.log(1)
    resolve()
&#125;).then(()=&gt;&#123;
    console.log(2)
    new Promise((resolve,reject)=&gt;&#123;
        console.log(3)
        resolve()
    &#125;).then(()=&gt;&#123;
        console.log(4)
    &#125;).then(()=&gt;&#123;
        console.log(5)
    &#125;)
&#125;).then(()=&gt;&#123;
    console.log(6)
&#125;)
new Promise((resolve,reject)=&gt;&#123;
    console.log(7)
    resolve()
&#125;).then(()=&gt;&#123;
    console.log(8)
&#125;)</code></pre>
<p>宏队列：【0】</p>
<p>微队列：【2，8，4，6，5】</p>
<p>上述代码输出：1 7 2 3 8 4 6 5 0</p>
<p>注意：<strong>链式调用的 .then 何时放入微队列取决于链的上一个 then 啥时候执行</strong>，如轮到 4 执行后 5 才放入微队列，2 下一长串结束后 6 才放入微队列</p>
<p>注意：<strong>里层的多个链式调用 then 只要有一个放入队列后外层的 then 就可以放入队列</strong></p>
<p>4 放入微队列后后面的 then 就执行了，只是 then 里的 5 等 4 执行了采访如微队列，这样即使 5 还没放入微队列，但 6 上面的 then 都执行完了，所以 6 可以放入微队列</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
</search>
