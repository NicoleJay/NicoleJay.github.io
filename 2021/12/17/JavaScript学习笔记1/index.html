<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nicolejay.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="JavaScript 在1995年由网景公司发明，1996年生成 ECMAScript 标准，不同浏览器对该标准的实现不同，如 FireFox 使用 SpiderMonkey 引擎，Chrome 使用 v8 引擎（Nodejs也是）">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习笔记1">
<meta property="og:url" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/index.html">
<meta property="og:site_name" content="X 的笔记">
<meta property="og:description" content="JavaScript 在1995年由网景公司发明，1996年生成 ECMAScript 标准，不同浏览器对该标准的实现不同，如 FireFox 使用 SpiderMonkey 引擎，Chrome 使用 v8 引擎（Nodejs也是）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png">
<meta property="og:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png">
<meta property="article:published_time" content="2021-12-17T04:23:02.000Z">
<meta property="article:modified_time" content="2022-01-08T07:46:53.181Z">
<meta property="article:author" content="NicoleJay">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97.png">


<link rel="canonical" href="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>JavaScript学习笔记1 | X 的笔记</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <a target="_blank" rel="noopener" href="https://github.com/NicoleJay" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">X 的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81JavaScript%E7%BB%84%E6%88%90"><span class="nav-number">1.</span> <span class="nav-text">一、JavaScript组成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81JS%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.1.</span> <span class="nav-text">1、JS的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81JS%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">2、JS的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E4%BD%BF%E7%94%A8-JS"><span class="nav-number">1.3.</span> <span class="nav-text">3、在网页中使用 JS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%AF%AD%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">二、语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%8E%E8%BE%93%E5%85%A5"><span class="nav-number">2.1.</span> <span class="nav-text">1、输出与输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.</span> <span class="nav-text">2、字面量和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">（1）字面量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">特殊值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="nav-number">2.2.1.3.0.1.</span> <span class="nav-text">1. 转换为字符串 String</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97-Number"><span class="nav-number">2.2.1.3.0.2.</span> <span class="nav-text">2. 转换为数字 Number</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94-Boolean"><span class="nav-number">2.2.1.3.0.3.</span> <span class="nav-text">3. 转换为布尔 Boolean</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">其他进制数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">（2）变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">2.3.</span> <span class="nav-text">3、标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.</span> <span class="nav-text">4、运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.1.</span> <span class="nav-text">（1）二元运算符 + - * &#x2F;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.2.</span> <span class="nav-text">（2）一元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E4%BB%B6%EF%BC%88%E4%B8%89%E5%85%83%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.3.</span> <span class="nav-text">（3）条件（三元）运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.4.</span> <span class="nav-text">（4）逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.5.</span> <span class="nav-text">（5）关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.6.</span> <span class="nav-text">（6）相等运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.4.7.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.5.</span> <span class="nav-text">5、运算符优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">2.6.</span> <span class="nav-text">6、代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.7.</span> <span class="nav-text">7、流程控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.</span> <span class="nav-text">8、对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.8.1.</span> <span class="nav-text">（1）对象的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.2.</span> <span class="nav-text">（2）创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">使用工厂方法创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">创建构造函数来创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">对象操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.9.</span> <span class="nav-text">9、基本数据类型和引用数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">10、函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.</span> <span class="nav-text">三、作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.1.</span> <span class="nav-text">1、全局作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">3.2.</span> <span class="nav-text">2、函数作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81this"><span class="nav-number">4.</span> <span class="nav-text">四、this</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">五、原型对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype"><span class="nav-number">5.1.</span> <span class="nav-text">prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proto"><span class="nav-number">5.2.</span> <span class="nav-text">proto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">原型对象中的属性、方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">修改原型对象中的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">六、垃圾回收（GC）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">7.</span> <span class="nav-text">七、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">7.1.</span> <span class="nav-text">1、数组对象的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">2、数组的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">7.2.1.</span> <span class="nav-text">添加与删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-number">7.2.2.</span> <span class="nav-text">数组遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%89%87%E6%AE%B5%E8%8E%B7%E5%8F%96"><span class="nav-number">7.2.3.</span> <span class="nav-text">数组片段获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">7.2.4.</span> <span class="nav-text">数组连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">7.2.5.</span> <span class="nav-text">数组排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81call-%E5%92%8C-apply"><span class="nav-number">8.</span> <span class="nav-text">八、call 和 apply</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">8.2.</span> <span class="nav-text">不同点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81arguments"><span class="nav-number">9.</span> <span class="nav-text">九、arguments</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81Date-%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.</span> <span class="nav-text">十、Date 对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Math"><span class="nav-number">11.</span> <span class="nav-text">十一、Math</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">12.</span> <span class="nav-text">十二、包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">12.1.</span> <span class="nav-text">String</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.</span> <span class="nav-text">十三、正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">13.1.</span> <span class="nav-text">创建正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.</span> <span class="nav-text">正则表达式的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">13.3.</span> <span class="nav-text">字符串和正则相关方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D"><span class="nav-number">13.4.</span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="nav-number">13.5.</span> <span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">13.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81DOM"><span class="nav-number">14.</span> <span class="nav-text">十四、DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81DOM"><span class="nav-number">14.1.</span> <span class="nav-text">1、DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.</span> <span class="nav-text">2、节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">14.2.1.</span> <span class="nav-text">节点属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.2.</span> <span class="nav-text">获取节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">14.2.3.</span> <span class="nav-text">获取&#x2F;修改元素属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%E5%86%85%E7%9A%84%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.4.</span> <span class="nav-text">获取&#x2F;修改元素内的文本节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.5.</span> <span class="nav-text">获取元素节点的子节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.6.</span> <span class="nav-text">获取元素节点的父节点和兄弟节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9"><span class="nav-number">14.2.7.</span> <span class="nav-text">创建元素节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD"><span class="nav-number">14.3.</span> <span class="nav-text">3、文档加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%88%A9%E7%94%A8-DOM-%E4%BF%AE%E6%94%B9-CSS-%E6%A0%B7%E5%BC%8F"><span class="nav-number">14.4.</span> <span class="nav-text">4、利用 DOM 修改 CSS 样式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="nav-number">14.4.1.</span> <span class="nav-text">操作内联样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F"><span class="nav-number">14.4.2.</span> <span class="nav-text">通过类修改样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F"><span class="nav-number">14.4.3.</span> <span class="nav-text">读取元素样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%A0%B7%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="nav-number">14.4.4.</span> <span class="nav-text">其他样式相关属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="nav-number">15.</span> <span class="nav-text">十五、事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">15.1.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">15.2.</span> <span class="nav-text">事件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%88Bubble%EF%BC%89"><span class="nav-number">15.3.</span> <span class="nav-text">事件冒泡（Bubble）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A7%94%E6%B4%BE"><span class="nav-number">15.4.</span> <span class="nav-text">事件的委派</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="nav-number">15.5.</span> <span class="nav-text">事件绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="nav-number">15.6.</span> <span class="nav-text">事件的传播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="nav-number">15.7.</span> <span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6"><span class="nav-number">15.8.</span> <span class="nav-text">滚轮事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="nav-number">15.9.</span> <span class="nav-text">键盘事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81BOM"><span class="nav-number">16.</span> <span class="nav-text">十六、BOM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">17.</span> <span class="nav-text">十七、定时器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E3%80%81JSON"><span class="nav-number">18.</span> <span class="nav-text">十八、JSON</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">19.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">20.</span> <span class="nav-text">其他</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NicoleJay"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">NicoleJay</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NicoleJay" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NicoleJay" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nicolejay.github.io/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="NicoleJay">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="X 的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript学习笔记1
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-17 12:23:02" itemprop="dateCreated datePublished" datetime="2021-12-17T12:23:02+08:00">2021-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>JavaScript 在1995年由网景公司发明，1996年生成 ECMAScript 标准，不同浏览器对该标准的实现不同，如 FireFox 使用 SpiderMonkey 引擎，Chrome 使用 v8 引擎（Nodejs也是）</p>
<a id="more"></a>

<h1 id="一、JavaScript组成"><a href="#一、JavaScript组成" class="headerlink" title="一、JavaScript组成"></a>一、JavaScript组成</h1><h2 id="1、JS的组成"><a href="#1、JS的组成" class="headerlink" title="1、JS的组成"></a>1、JS的组成</h2><p>JavaScript 包含三部分：ECMAScript（标准）+ DOM（文档对象模型）+BOM（浏览器对象模型）</p>
<h2 id="2、JS的特点"><a href="#2、JS的特点" class="headerlink" title="2、JS的特点"></a>2、JS的特点</h2><p>（1）解释型语言，无需编译</p>
<p>（2）类似 C 和 Java 的语法结构</p>
<p>（3）动态语言</p>
<p>（4）基于原型的面向对象</p>
<p>注意：JS 中严格区分大小写</p>
<h2 id="3、在网页中使用-JS"><a href="#3、在网页中使用-JS" class="headerlink" title="3、在网页中使用 JS"></a>3、在网页中使用 JS</h2><p>（1）可将 JS 代码编写到标签的 <code>onclick</code> 属性中，如 <code>&lt;button onclick=&quot;alert(&quot;xxxx&quot;);&quot;&gt;按钮&lt;/button&gt;</code></p>
<p>（2）可将 JS 代码写在超链接的 <code>href</code> 属性中，点击超链接时会执行 JS 代码，如 <code>&lt;a href=&quot;javascript:alert(&quot;xxxx&quot;);&quot;&gt;超链接&lt;/a&gt;</code></p>
<p>（3）通过 <code>&lt;script&gt;</code> 标签中写 JS 代码， 如<code>&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;xxxx&quot;);&lt;/script&gt;</code></p>
<p>（4）通过 <code>&lt;script&gt;</code> 标签引入外部 JS 文件，<code>&lt;script type=&quot;text/javascript&quot; src=&quot;./xxx.js&quot;&gt;&lt;/script&gt;</code></p>
<p>注意1：第一、二种方法把 JS 写在标签的书中属于结构与行为耦合，不方便维护，而把 JS 写到外部文件中可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>注意2：一个 <code>&lt;script&gt;</code> 标签一旦用于引入外部文件，就不能在其中编写 JS 代码了，即使写了浏览器也会忽略，但若再创建一个 <code>&lt;script&gt;</code> 标签其中的内部 JS 代码可执行</p>
<h1 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h1><h2 id="1、输出与输入"><a href="#1、输出与输入" class="headerlink" title="1、输出与输入"></a>1、输出与输入</h2><p>alert(“xxxxxx”);  //控制浏览器弹出警告框</p>
<p>document.write(“xxxx”);  //向 body 中输出内容，当要换行时不能用 document.write(“xxxx”+”\n”); 而要用 document.write(“xxxx”+”<br>“); </p>
<p>console.log(“xxx”);   //向控制台输出内容</p>
<p>prompt(“提示文字”);   //用户可输入字符串，用户输入内容会以 String 类型作为函数返回值返回</p>
<p>通过类型转换 +prompt(“提示文字”); 会把字符串转为 Number，可用于输入数字</p>
<h2 id="2、字面量和变量"><a href="#2、字面量和变量" class="headerlink" title="2、字面量和变量"></a>2、字面量和变量</h2><h3 id="（1）字面量"><a href="#（1）字面量" class="headerlink" title="（1）字面量"></a>（1）字面量</h3><p>字面量是一些不可改变的值，字面量都是可直接使用的（但一般不会直接使用，而是通过变量）</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>字面量类型（数据类型）六种：
    String     字符串
    Number     数值
    Boolean    布尔值
    Null       空值，专门用来表示一个为空的对象，typeof 检查一个 null 值会返回 object
    Undefined  未定义，typeof 检查一个 null 值会返回 undefined
    Object     对象
    Symbol     ES6 中引入的新类型
其中 String、Number、Boolean、Null、Undefined 是基本数据类型，Object 属于引用数据类型</code></pre>
<p>可利用 <code>typeof 变量名</code>来查看变量的数据类型，它会将变量的类型以字符串形式返回</p>
<h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><pre><code>Number.MAX_VALUE  数字的最大值，若数字超过最大值，会返回
Number.MIN_VALUE  最小的正值，大于 0 的最小值
Infinity   表示正无穷
Infinity   正无穷，也属于数字类型
-Infinity  负无穷
NaN        表示 Not A Number，也属于数字类型</code></pre>
<p>在 JS 中整数运算基本可保证精确，但浮点数运算可能得到不精确结果，因此不要用 JS 进行对精确度要求较高的运算</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><h6 id="1-转换为字符串-String"><a href="#1-转换为字符串-String" class="headerlink" title="1. 转换为字符串 String"></a>1. 转换为字符串 String</h6><p><strong>方式一：</strong>调用 <code>变量.toString()</code>，该方法不会影响原变量，会将转换的结果返回，且 <strong>null 和 undefined 没有 toString() 方法</strong>，若调用会报错</p>
<p><strong>方式二：</strong>调用 <code>String(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回，且<strong>该方式对 null 和 undefined 有效</strong></p>
<p><strong>方式三：</strong>隐式类型转换，将任意数据类型 + 一个 <code>&quot;&quot;</code>，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>String()</code> 函数</p>
<h6 id="2-转换为数字-Number"><a href="#2-转换为数字-Number" class="headerlink" title="2. 转换为数字 Number"></a>2. 转换为数字 Number</h6><p><strong>方式一：</strong>使用 <code>Number(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p>— 若字符串中有非数字内容则转为 NaN，若字符串为空串或是全为空格的字符串会转为 0</p>
<p>— 对于布尔值，true 转为 1，false 转为 0</p>
<p>— null 会转为 0</p>
<p>— undefined 会转为 NaN</p>
<p><strong>方式二：</strong>针对字符串</p>
<p><code>parseInt(变量,进制)</code>可将字符串中的有效整数内容取出并转为 Number，第二个参数可不写，如 “123px” 会转为 123，“123a567” 会转为 123</p>
<p><code>parseFloat(变量)</code>可将字符串中的有效小数内容取出并转为 Number，如 “123.456.789px” 会转为 123.456</p>
<p>若对非 String 使用 <code>parseInt()</code> 或 <code>parseFloat()</code>会先将其转为 String 然后再操作</p>
<p><strong>方式三：</strong>隐式类型转换，可通过一个值 <code>-0</code> 或 <code>*1</code> 或 <code>/1</code> 来将其转为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<p><strong>方式四：</strong>隐式类型转换，将任意数据类型使用 <code>+</code> 来将其转换为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Number()</code> 函数</p>
<h6 id="3-转换为布尔-Boolean"><a href="#3-转换为布尔-Boolean" class="headerlink" title="3. 转换为布尔 Boolean"></a>3. 转换为布尔 Boolean</h6><p><strong>方式一：</strong>调用 <code>Boolean(变量)</code> 函数，该方法不会影响原变量，会将转换的结果返回</p>
<p><strong>方式二：</strong>隐式类型转换，可通过为任意数据类型取两次反来将其转为 Number，隐式类型转换由浏览器自动完成，实际上它也是调用 <code>Boolean()</code> 函数</p>
<p>对于数字 —&gt; 布尔，除了 0 和 NaN，其余都是 true</p>
<p>对于字符串 —&gt; 布尔，除了空串，其余都是 true</p>
<p>null 和 undefined 都会转为 false</p>
<p>对象也会转换为 true</p>
<h4 id="其他进制数字"><a href="#其他进制数字" class="headerlink" title="其他进制数字"></a>其他进制数字</h4><p>JS 中十六进制数字需以 <code>0x</code> 开头，八进制数字需以 <code>0</code> 开头，二进制需以 <code>0b</code> 开头（二进制表示方法浏览器兼容性不好）</p>
<p>注意 <code>a=070</code> 表示八进制，而字符串 <code>a=&quot;070&quot;</code> 转为数字时有些浏览器会当八进制，有些会当十进制转换，可在 <code>parseInt(变量,进制)</code> 中传递进制参数来解决</p>
<h3 id="（2）变量"><a href="#（2）变量" class="headerlink" title="（2）变量"></a>（2）变量</h3><p>变量可用来保存和描述字面量，且变量值可任意改变</p>
<h2 id="3、标识符"><a href="#3、标识符" class="headerlink" title="3、标识符"></a>3、标识符</h2><p>所有可自主命名的都是标识符，如变量名、函数名、属性名</p>
<p>规则：（1）可含有字母、数字、_、$</p>
<p>（2）不能以数字开头</p>
<p>（3）不能是 JS 中的关键字或保留字，如下图</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97.png" alt="关键字和保留字"></p>
<p>（4）一般都采用驼峰命名法：首字母小写，每个单词开头字母大写，其余字母小写</p>
<p>除了（4），其他都是强制要求</p>
<p><strong>注意：JS 底层保存标识符时是采用 Unicode 编码，所以理论上所有 utf-8 中含有的内容都可以作为标识符</strong></p>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="（1）二元运算符"><a href="#（1）二元运算符" class="headerlink" title="（1）二元运算符 + - * /"></a>（1）二元运算符 + - * /</h3><p>当对非 Number 类型的值进行运算时，会先将这些值转换为 Number 再运算（除了 Number 和字符串做<strong>加法</strong>以外），Number 和 字符串做减法/乘法等都是转换为 Number</p>
<p>任何值和 NaN 做运算结果都为 NaN</p>
<p>若对两个字符串作假发，则会把两个字符串拼接为一个字符串</p>
<p>任何值和字符串做加法，都会先转换为字符串，然后再和字符串作拼串操作（可用于 String 强制类型转换）</p>
<p>注意<br>    result = 1 + 2 + “3”;   //结果是“33”<br>    result = “1” + 2 + 3;   //结果是“123”</p>
<p>任何值做 - * / 都会自动转换为 Number（可用于 Number 强制类型转换）</p>
<h3 id="（2）一元运算符"><a href="#（2）一元运算符" class="headerlink" title="（2）一元运算符"></a>（2）一元运算符</h3><p><code>+</code> 正号不会对数字产生影响，<code>-</code> 负号可以对数字取反</p>
<p>对于非 Number 类型的值，会将其先转换为 Number 再运算（可用于 Number 强制类型转换）</p>
<pre><code>result = 1 + &quot;2&quot; + 3;   //结果是“123”
result = 1 + +&quot;2&quot; + 3;   //结果是6</code></pre>
<p>自增/减分为两种：后++（a++）或后–（a–）和前++（++a）或前–（–a），两种值不同</p>
<p>— <code>a++</code>和<code>a--</code>的值等于原变量的值（自增/减前的值）</p>
<p>— <code>++a</code>和<code>--a</code>的值等于原变量新值（自增/减后的值）</p>
<pre><code>var a = 20;
console.log(a++ + ++a + a);  //结果为 20 + 22 + 22
var b = 20;
b = b++;   //结果为 20，因为 b++ 的值为 20</code></pre>
<h3 id="（3）条件（三元）运算符"><a href="#（3）条件（三元）运算符" class="headerlink" title="（3）条件（三元）运算符"></a>（3）条件（三元）运算符</h3><p>语法 <code>条件表达式 ? 语句1 : 语句2;</code>，若条件表达式是非布尔值，则会将其转换为布尔值再比较</p>
<h3 id="（4）逻辑运算符"><a href="#（4）逻辑运算符" class="headerlink" title="（4）逻辑运算符"></a>（4）逻辑运算符</h3><p><code>!</code> 对非布尔值进行运算都会将其转换为布尔值，然后再取反（可用于 Boolean 强制类型转换）</p>
<p>JS 中的 “与&amp;&amp;” 属于短路的 “与”，（即若第一个值为 false 则不会再检查第二个）</p>
<p>JS 中的 “或||” 属于短路的 “或”，（即若第一个值为 true 则不会再检查第二个）</p>
<p>对于非布尔值进行与或运算都会将其转换为布尔值，并返回转换前的值</p>
<p>与运算：若两个值都为 true，则返回后面的值，若两个值中有 false，则返回靠前的 false（即若第一个值为 true 则必然返回第二个值，若第一个值为 false 则直接返回第一个值）</p>
<p>或运算：若两个值都为 false，则返回后面的值，若两个值中有 true，则返回靠前的 true（即若第一个值为 false 则必然返回第二个值，若第一个值为 true 则直接返回第一个值）</p>
<h3 id="（5）关系运算符"><a href="#（5）关系运算符" class="headerlink" title="（5）关系运算符"></a>（5）关系运算符</h3><p>对于非数值进行 &gt; &gt;= &lt; &lt;= 比较时，会将其转换为数字然后再比较</p>
<p>若比较符号两侧都是字符串时不会将其转换为数字，而会分别比较字符串中字符的 Unicode 编码，比较字符编码时是一位一位比较，若两位一样则比较下一位，否则直接返回比较结果（可利用该特性对英文进行排序，比较中文没有意义）</p>
<p>在比较两个字符串型的数字时，一定要转型，转型后比较的就是数字大小，否则会一位一位比较字符串编码</p>
<p>任何值和 NaN 做任何比较都是 false</p>
<pre><code>1 &gt; true     //false
1 &gt;= true     //true
10 &gt; null     //true
10 &gt; &quot;hello&quot;  //false 相当于比较 10 &gt; NaN</code></pre>
<h3 id="（6）相等运算符"><a href="#（6）相等运算符" class="headerlink" title="（6）相等运算符"></a>（6）相等运算符</h3><p>当使用 <code>==</code> 或 <code>!=</code> 比较时若值的类型不同，则会自动进行类型转换，将其转换为相同类型后再比较</p>
<p>undefined 衍生自 null，所以这两个值做相等判断时会返回 true</p>
<p>NaN 不和任何值相等，包括它本身，通过 <code>isNaN()</code> 函数判断一个值是否是 NaN</p>
<pre><code>&quot;1&quot; == 1      //true，转为 Number 比较
true == &quot;1&quot;   //true，二者都转为 Number
null == 0     //false 注意
undefined == null  //true
Nan == Nan    //false</code></pre>
<p><code>===</code> 全等，和 <code>==</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 false；<code>!==</code> 不全等，和 <code>!=</code> 类似，但它们不会做自动类型转换，若两个值类型不同，直接返回 true</p>
<pre><code>undefined === null  //false</code></pre>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>使用 <code>,</code> 可同时声明多个变量并赋值，如<code>var a=1,b=2,c=3</code></p>
<h2 id="5、运算符优先级"><a href="#5、运算符优先级" class="headerlink" title="5、运算符优先级"></a>5、运算符优先级</h2><p>运算符优先如下图，越靠上优先级越高</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p>
<h2 id="6、代码块"><a href="#6、代码块" class="headerlink" title="6、代码块"></a>6、代码块</h2><p>JS 中可使用 <code>&#123;&#125;</code> 为语句分组，同一个 <code>&#123;&#125;</code> 中的语句称为一个代码块，要么都执行，要么都不执行</p>
<p>JS 中的代码块只有分组的作用，没有其他用途，代码块内部的内容在外部是完全可见的</p>
<p>代码块后不用写 <code>;</code></p>
<h2 id="7、流程控制语句"><a href="#7、流程控制语句" class="headerlink" title="7、流程控制语句"></a>7、流程控制语句</h2><p>语句分类：条件判断语句、条件分支语句、循环语句</p>
<p>switch…case 语句中的条件判断是采用全等</p>
<p>for 循环中 <code>()</code> 内三个部分都可以省略，也可以写在外部，若在 for 循环中不写任何表达式，只写两个 <code>;</code> 是个死循环，慎用</p>
<p>可为循环语句创建一个 label，来标识当前循环，用法为 <code>标签名:循环语句</code>，使用 break 或 continue 语句时，可在 break 或 continue 后跟着一个 label，此时 break 将会结束指定的循环，或 continue 将会跳过当前的指定循环，而不是最近的循环</p>
<pre><code>outer:
for(var i=0;i&lt;5;i++)&#123;
    语句...
    for(var j=0;j&lt;5;j++)&#123;
        break outer;  //此时 break 结束的是外层循环
    &#125;
&#125;</code></pre>
<h2 id="8、对象"><a href="#8、对象" class="headerlink" title="8、对象"></a>8、对象</h2><p>基本数据类型创建的变量都是独立的，不饿能成为一个整体</p>
<p>对象不是基本数据类型，而是引用数据类型，是复合数据类型</p>
<p>除了基本数据类型外一切都是对象，网页中看到的所有都是对象</p>
<h3 id="（1）对象的分类"><a href="#（1）对象的分类" class="headerlink" title="（1）对象的分类"></a>（1）对象的分类</h3><p><strong>内建对象</strong></p>
<p>由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用，如 Math、String、Number、Boolean、Function、Object 等</p>
<p><strong>宿主对象</strong></p>
<p>由 JS 的运行环境提供的对象，主要指由浏览器提供的对象，如 BOM、DOM，这是两组对象，由许多对象组成，如 console、document 都是由浏览器创建提供的，是宿主对象</p>
<p><strong>自定义对象</strong></p>
<p>由开发人员自己创建的对象</p>
<h3 id="（2）创建对象"><a href="#（2）创建对象" class="headerlink" title="（2）创建对象"></a>（2）创建对象</h3><p>使用 <code>new</code> 关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数</p>
<p>使用 <code>typeof</code> 检查一个对象时，会返回 object</p>
<h4 id="使用工厂方法创建对象"><a href="#使用工厂方法创建对象" class="headerlink" title="使用工厂方法创建对象"></a>使用工厂方法创建对象</h4><pre><code>function createPerson(name,age,gender)&#123;
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    obj.sayName = function()&#123;
        alert(this.name);
    &#125;
    return obj;
&#125;
var obj1 = createPerson(&quot;xxx&quot;,18,&quot;男&quot;); </code></pre>
<h4 id="创建构造函数来创建对象"><a href="#创建构造函数来创建对象" class="headerlink" title="创建构造函数来创建对象"></a>创建构造函数来创建对象</h4><p>使用同一个构造函数创建的对象称为一类对象，也将一个构造函数称为一个类，将通过构造函数创建的对象称为该类的实例</p>
<p>使用 <code>instanceof</code> 可检查一个对象是否是一个类的实例，<code>对象 instanceof 构造函数</code> 返回布尔值，所有对象都是 Object 的后代，所以任何对象和 Object 做 instanceof 检查时都会返回 true</p>
<p>构造函数就是一个普通函数，不同的是构造函数习惯上首字母大写。</p>
<p><strong>构造函数和普通函数的区别：</strong>普通函数直接调用，而构造函数需要使用 new 关键字调用</p>
<p><strong>构造函数执行流程：</strong></p>
<ol>
<li><p>立刻创建一个新的对象</p>
</li>
<li><p>将新建的对象设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象</p>
</li>
<li><p>逐行执行函数中的代码</p>
</li>
<li><p>将新建的对象作为返回值返回 </p>
<p> function Person(name,age,gender){</p>
<pre><code> this.name = name;
 this.age = age;
 this.gender = gender;
 this.sayName = function()&#123;
     alert(this.name);
 &#125;</code></pre>
<p> }<br> var per = new Person(“xxx”,18,”男”); </p>
</li>
</ol>
<p><strong>构造函数的方法定义</strong></p>
<p>在构造函数内部创建的方法，每执行一次构造函数就会创建一个新的相同方法，所有实例的该方法都是唯一的，这没有必要，所以可使所有对象共享同一个方法</p>
<p>方式一：将方法定义到全局作用域中</p>
<p>但是将函数定义到全局作用域中会污染了全局作用域的命名空间，并且也很不安全，容易被另一个程序猿覆盖</p>
<p>方式二：使用原型对象</p>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><p><code>var 对象名 = new Object();</code> 或 <code>var 对象名 = &#123;&quot;属性名1&quot;:属性值,属性名n:属性值&#125;;</code> 创建对象，第二种方式的对象也叫对象字面量，对象字面量的属性名可加引号也可不加，但若使用一些特殊名字时必须加引号</p>
<p><code>对象.属性名 = 属性值;</code> 向对象添加属性，对象的属性名不强制要求遵守标识符的规范，但尽量按照标识符的规范</p>
<p><code>对象[&quot;属性名&quot;] = 属性值;</code> 向对象添加属性，对于使用特殊的属性名时，不能采用 <code>.</code> 的方式操作</p>
<p><code>对象.属性名;</code> 读取对象中的属性，若读取对象中没有的属性不会报错，而会返回 undefined</p>
<p><code>对象[&quot;属性名&quot;]</code> 读取对象中的属性，这种方式更灵活，因为 <code>[]</code> 中可以传变量，而 <code>.</code> 的方式操作属性会需要准确的属性名。此外，对于使用 <code>对象[&quot;属性名&quot;] = 属性值;</code> 赋值的属性只能用这种方式读取属性</p>
<p><code>对象.属性名 = 新值;</code> 修改对象的属性值</p>
<p><code>delete 对象.属性名;</code> 删除对象的属性</p>
<p><code>&quot;属性名&quot; in 对象</code> 检查对象或其原型中是否含有某属性</p>
<p><code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查对象自身是否含有某属性</p>
<p>枚举对象的属性</p>
<pre><code>for(var 变量 in 对象)&#123;xxx&#125;
对象中有几个属性循环体就会执行几次，其中每次执行时就把对象中的一个属性名赋值给变量</code></pre>
<p>JS 对象的属性值可以是任意的数据类型，甚至也可以是一个对象（如函数）</p>
<p>若函数作为一个对象的属性，则称该函数是这个对象的方法，调用该函数称为调用对象的方法</p>
<h2 id="9、基本数据类型和引用数据类型"><a href="#9、基本数据类型和引用数据类型" class="headerlink" title="9、基本数据类型和引用数据类型"></a>9、基本数据类型和引用数据类型</h2><p>JS 中的变量都是保存到栈内存中，基本数据类型直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量</p>
<p>对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新空间，而变量保存的是对象的内存地址（对象的引用），若两个变量保存的是同一个对象引用，当通过一个变量修改该对象属性时，另一个也会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="基本数据类型和引用数据类型"></p>
<p>但是当两个变量表示同一个对象时，把其中一个变量值设为 null 后另一个变量依然指向对象不会受到影响</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png" alt="基本数据类型和引用数据类型1"></p>
<p>当比较两个基本数据类型时就是比较它们的值，而比较两个引用数据类型时比较的是内存地址，即使两个对象内容一样，但地址不同依然会返回 false</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2.png" alt="基本数据类型和引用数据类型2"></p>
<h2 id="10、函数"><a href="#10、函数" class="headerlink" title="10、函数"></a>10、函数</h2><p>函数也是一个对象，是一个具有功能的对象，使用 <code>typeof</code> 检查一个函数对象时会返回 function</p>
<p><code>var 变量名 = new Function();</code> 使用构造函数创建函数对象，可将要封装的代码以字符串的形式传递给构造函数，如 <code>var fun = new Function(&quot;console.log(&#39;hello world&#39;)&quot;);</code>，但开发中很少使用构造函数来创建一个函数对象</p>
<p><code>function 函数名([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数声明创建一个函数</p>
<p><code>var 函数名 = function([形参1,形参2,...,形参n])&#123;&#125;</code> 使用函数表达式创建函数，相当于声明一个匿名函数并赋值给变量</p>
<p><code>函数对象();</code> 调用函数</p>
<p><code>(function([形参1,形参n])&#123;xxx&#125;)([形参1,形参n])</code> 匿名函数定义完立即被调用，这种函数称为立即执行函数，立即执行函数往往只会执行一次</p>
<p>函数声明中的形参相当于在函数内部声明了相应变量</p>
<p><strong>调用函数时解析器不会检查实参的类型</strong>，所以要注意是否有可能会接收到非法参数，若有可能则需要对参数进行类型检查</p>
<p><strong>调用函数时解析器不会检查实参的数量</strong>，多余的参数不会被赋值，若实参的数量少于形参的数量，则没有对应实参的形参将是 undefined</p>
<p>函数中的参数可以是另一个函数，当实参中的函数是 <code>函数名()</code> 表示调用函数，使用的是函数的返回值，当实参中的函数是 <code>函数名</code> 表示函数对象，相当于直接使用函数对象</p>
<p>若函数的 return 可以返回任意类型的值，若 return 语句后不跟任何值或不写 return 语句，相当于返回 undefined</p>
<h1 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h1><p>JS 中有两种作用域：全局作用域、函数作用域</p>
<h2 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h2><p>直接编写在 <code>&lt;script&gt;</code> 标签中的 JS 代码都在全局作用域，全局作用域中的变量都是全局变量，在页面任意部分都能访问到</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁</p>
<p>全局作用域中有一个全局对象 window，代表一个浏览器的窗口，由浏览器创建可直接使用</p>
<p>在全局作用域中创建的变量都会作为 window 对象的属性保存，创建的函数都会作为 window 对象的方法</p>
<p><strong>变量声明提前：</strong>使用 var 关键字声明的变量，会在所有代码执行之前被声明（但不一定会赋值），但若声明变量时不使用 var 关键字，则变量不会被声明提前</p>
<pre><code>console.log(a);
var a = 123;  //改行对变量 a 的声明实际上会在最开头，只是在这一行被赋值</code></pre>
<p><strong>函数声明提前：</strong>使用函数声明形式 <code>function 函数()&#123;&#125;</code> 创建的函数会在所有代码执行之前被创建，所以可以在函数声明前调用。但是使用函数表达式 <code>var 变量 = function()&#123;&#125;</code> 创建的函数不会被声明提前，所以不能在声明前调用</p>
<h2 id="2、函数作用域"><a href="#2、函数作用域" class="headerlink" title="2、函数作用域"></a>2、函数作用域</h2><p>调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，它们之间相互独立</p>
<p>当在函数作用域中操作一个变量时会先在自身作用域中寻找，若有就直接使用，若没有则向上一级作用域中寻找，直到找到全局作用域，若全局作用域中依然没有找到，则会报错 ReferenceError</p>
<p>在函数中要访问全局变量可使用 window 对象，<code>window.变量名</code></p>
<p>在函数作用域中也有声明提前的特性，使用 var 关键字声明的变量会在函数中所有代码执行之前被声明。函数声明也会在函数中所有代码执行之前执行。定义形参相当于在函数作用域中声明了变量</p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    var c = 10;
&#125;
func();  //此时会输出 “undefined”，因为在 func 函数中var c 变量会声明提前，但是执行到 console 语句时函数作用域中的 c 变量还未被赋值</code></pre>
<p>在函数中不适用 var 声明的变量都会成为全局变量 </p>
<pre><code>var a = 1;
function func()&#123;
    console.log(c);
    c = 10;
&#125;
func();  //此时会输出 1，因为函数中 c 没有使用 var 关键字所以不会提前声明，所以向上一级中找 c</code></pre>
<h1 id="四、this"><a href="#四、this" class="headerlink" title="四、this"></a>四、this</h1><p>解析器在调用函数每次都会向函数内部传递一个隐含的参数 this</p>
<p>this 指向一个对象，这个对象称为函数执行的上下文对象</p>
<p>根据函数<strong>调用方式</strong>的不同，this 会指向不同的对象</p>
<p>— 以函数的形式（<code>函数名()</code>，也相当于 <code>window.函数名()</code>）调用时，this 永远是 window</p>
<p>— 以方法的形式（<code>对象.方法名()</code>）调用时，this 就是调用方法所属的那个对象</p>
<p>— 在构造函数中调用时，this 就是新创建的那个对象</p>
<p>— 使用 call 和 apply 调用时，this 是指定的那个对象</p>
<p>— 在事件响应函数中，this 指向响应函数所绑定的对象（普通情况下）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— addEventListener() 中 this 指向绑定事件的对象</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;— attachEvent() 中 this 指向 window</p>
<h1 id="五、原型对象"><a href="#五、原型对象" class="headerlink" title="五、原型对象"></a>五、原型对象</h1><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>创建的每个函数，解析器都会向函数中添加一个属性 prototype，这个属性对应着一个原型对象</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>若函数作为普通函数调用 prototype 没有任何作用，但当以构造函数形式调用时，它所实例化的对象都会有个隐含属性指向该构造函数的原型对象，可通过 <strong>proto</strong> 来访问该属性</p>
<h2 id="原型对象中的属性、方法"><a href="#原型对象中的属性、方法" class="headerlink" title="原型对象中的属性、方法"></a>原型对象中的属性、方法</h2><p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，可将对象中共有的内容（属性、方法）统一设置到原型对象中</p>
<p>当访问对象的属性或方法时会先在对象自身中寻找，若有则直接使用，若没有则去原型对象中寻找</p>
<pre><code>function Person(name,age,gender)&#123;
    this.name = name;
    this.age = age;
    this.gender = gender;
&#125;
Person.prototype.sayName = function()&#123;
    alert(this.name);
&#125;
var per = new Person(&quot;xxx&quot;,18,&quot;男&quot;); 
per.sayName();</code></pre>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1.png" alt="原型对象"></p>
<p>使用 <code>&quot;属性名&quot; in 对象实例</code> 检查对象中是否含有某属性时，若对象中没有但是原型中有也会返回 true</p>
<p>使用 <code>对象实例.hasOwnProperty(&quot;属性名&quot;)</code> 检查的是对象自身中是否含有该属性</p>
<p>原型对象也是对象，所以它也有原型，当使用一个对象的属性或方法时，先在自身中寻找，若没有则去原型对象中寻找，若依然没有则去原型的原型中寻找，直到找到 Object 对象的原型</p>
<p>Object 对象的原型没有原型，若在 Object 中依然没有找到，则返回 undefined。Object 的 <strong>proto</strong> 是 null</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B.png" alt="原型的原型"></p>
<h2 id="修改原型对象中的方法"><a href="#修改原型对象中的方法" class="headerlink" title="修改原型对象中的方法"></a>修改原型对象中的方法</h2><p>当在页面中打印对象时实际上是输出对象的 toString() 方法的返回值，若不希望输出 [Object Object]，可为当前对象实例添加一个 toString() 方法，或者修改对象原型的 toString()方法</p>
<pre><code>per.toString() = function()&#123; //但该方法只对当前实例有效
    return &quot;xxx&quot;
&#125;
Person.prototype.toString = function()&#123;  //该方法对该对象的所有实例有效
    return &quot;xxxx&quot;
&#125;</code></pre>
<h1 id="六、垃圾回收（GC）"><a href="#六、垃圾回收（GC）" class="headerlink" title="六、垃圾回收（GC）"></a>六、垃圾回收（GC）</h1><p>程序运行过程中会产生垃圾，垃圾积攒过多后会导致程序运行速度过慢</p>
<p>垃圾：当一个对象没有任何的变量或属性对它进行引用，此时将用于无法操作该对象，这是这种对象就是一个垃圾，这种对象过多会占用大量内存空间导致程序运行变慢，须进行清理</p>
<p>JS 中有自动垃圾回收机制，由浏览器、JS 引擎将这些垃圾对象自动从内存中销毁，我们不需要也不能进行垃圾回收操作</p>
<p>我们需要做的只是要将不再使用的对象设置为 null 即可</p>
<p><img src="/2021/12/17/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="垃圾回收"></p>
<h1 id="七、数组"><a href="#七、数组" class="headerlink" title="七、数组"></a>七、数组</h1><p>数组也是个内建对象，和普通对象不同的是普通对象使用字符串作为属性名，而数组使用数字作为索引操作元素</p>
<p>数组的存储性能比普通对象好，开发中常使用数组存储数据</p>
<p>数组中的元素可以是任意数据类型，也可以是对象（函数、数组等）</p>
<p>使用 typeof 检查一个数组时会返回 object</p>
<h2 id="1、数组对象的操作"><a href="#1、数组对象的操作" class="headerlink" title="1、数组对象的操作"></a>1、数组对象的操作</h2><p><code>var 数组名 = new Array(元素1,元素2,...,元素n)</code> 或 <code>var 数组名 = new Array(数组长度)</code> 使用构造函数创建数组对象</p>
<p><code>var 数组名 = [元素1,元素2,...,元素n]</code> 使用字面量创建数组对象</p>
<p><code>数组名[索引] = 值</code> 向数组中添加元素</p>
<p><code>数组名[索引]</code> 读取数组中的元素，若读取不存在的索引不会报错而是返回 undefined</p>
<p><code>数组名.length</code> 设置或获取数组的最大索引+1，即使数组中不连续；通过 length 设置数组长度时，若修改的长度大于原长度则多出部分会空出来，若小于原长度则多出部分会被移除</p>
<p><code>数组名[数组名.length] = 值</code> 向数组最后添加元素</p>
<h2 id="2、数组的方法"><a href="#2、数组的方法" class="headerlink" title="2、数组的方法"></a>2、数组的方法</h2><h3 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a>添加与删除</h3><p><code>push(元素1,元素2,...,元素n)</code> 向数组末尾添加一个或多个元素，并返回数组的新长度</p>
<p><code>pop()</code> 删除数组的最后一个元素，并返回被删除的元素</p>
<p><code>unshift(第一个元素,第二个元素,...,第n个元素)</code> 向数组开头添加一个或多个元素，并返回数组的新长度，新数组中新增元素的顺序和传参顺序一致</p>
<p><code>shift()</code> 删除数组的第一个元素，并返回被删除的元素</p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p><code>数组名.forEach(function(value,index,当前数组))</code> 遍历数组（只支持 IE8 以上的浏览器），需要一个函数作为参数（这种由我们创建不由我们调用的称为回调函数）</p>
<p>数组中有几个元素函数就会执行几次，每次执行时浏览器会将遍历到的元素以实参形式传进来，浏览器会在回调函数中传递三个参数：(当前正遍历的元素, 当前正遍历元素的索引, 正在遍历的数组)</p>
<h3 id="数组片段获取"><a href="#数组片段获取" class="headerlink" title="数组片段获取"></a>数组片段获取</h3><p><code>slice(开始位置,结束位置)</code> 从某个已有的数组返回选定的元素，第二个参数可选，左闭右开，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>splice(开始位置,删除个数,添加元素1,添加元素n)</code> 删除元组并向数组添加新元素，<strong>会修改原数组</strong>，并返回被删除的元素，添加的元素会自动插入开始位置，并且顺序与参数传入顺序一致</p>
<h3 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h3><p><code>数组1.concat(数组2,数组n,元素1,元素n)</code> 连接两个或多个数组，该方法<strong>不会影响原数组</strong>，会返回一个新数组</p>
<p><code>数组.join(连接符)</code> 该方法将数组转换为字符串，方法<strong>不会影响原数组</strong>，默认使用 <code>,</code> 作为连接符</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><code>数组.reverse()</code> 用来反转数组，该方法<strong>直接修改原数组</strong></p>
<p><code>数组.sort()</code> 对数组中元素排序，该方法<strong>直接修改原数组</strong>，默认按照 Unicode 编码排序，所以对数组排序会得到错误结果（1开头都会排在前面）</p>
<p>可在 sort() 中添加回调函数指定排序规则，回调函数中需定义两个形参，浏览器根据回调函数返回值决定元素顺序（返回大于0，元素会交换位置，返回小于等于0，元素位置不变）</p>
<pre><code>数组.sort(function(a,b)&#123;
    return a-b;  //升序排列
&#125;)</code></pre>
<h1 id="八、call-和-apply"><a href="#八、call-和-apply" class="headerlink" title="八、call 和 apply"></a>八、call 和 apply</h1><p>call 和 apply 都是函数对象的方法，需要通过函数对象（不带括号的函数名）调用</p>
<h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>调用函数执行：当对函数调用 call() 和 apply() 都会调用函数执行</p>
<p>修改函数的 this：调用 call() 和 apply() 可将一个对象指定为第一个参数，此时这个对象会成为函数执行时的 this（原先 <code>函数名()</code> 函数调用时的 this 指向 window）</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>call() 方法可将实参在对象之后依次传递</p>
<p>apply() 方法需要将实参封装到一个数组中统一传递</p>
<pre><code>function fun()&#123;
    console.log(this)
&#125;
var obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
var obj2=&#123;name: &quot;obj2&quot;&#125;
fun.call(obj);  //this 指 obj，apply 同理
obj.sayName.call(obj);  //alert 的是 obj，apply 同理
obj.sayName.apply(obj2);  //alert 的是 obj2，call 同理

function fun(a,b)&#123;
    console.log(a);
    console.log(b);
&#125;
obj=&#123;
    name: &quot;obj&quot;,
    sayName:function()&#123;
        alert(this.name);
    &#125;
&#125;
fun.call(obj,2,3);
fun.apply(obj,[2,3]);</code></pre>
<h1 id="九、arguments"><a href="#九、arguments" class="headerlink" title="九、arguments"></a>九、arguments</h1><p>在调用函数时，浏览器每次都会传递两个隐含参数：（1）函数的上下文对象 this（2）封装实参的对象 arguments</p>
<p>arguments 是一个类数组对象，可以通过索引来操作数据，也可以获取长度（arguments.length）</p>
<p>调用函数时，传递的实参都会在 arguments 中保存，即使不定义形参也可通过 arguments 来使用实参（如 arguments[0] 表示第一个实参）</p>
<p>arguments 中有个属性叫 callee，该属性对应当前正在指向的函数对象</p>
<pre><code>function fun(a,b)&#123;
    console.log(arguments.callee == fun);  //输出 true
&#125;</code></pre>
<h1 id="十、Date-对象"><a href="#十、Date-对象" class="headerlink" title="十、Date 对象"></a>十、Date 对象</h1><p>Date 对象也是一个内建对象</p>
<p><code>var 变量 = new Date();</code> 使用构造函数创建 Date 对象，会封装为当前代码执行的时间</p>
<p><code>var 变量 = new Date(&quot;月/日/年 时:分:秒&quot;);</code> 创建指定时间的对象</p>
<p><code>Date对象实例.getDate();</code> 获取当前日期对象的日</p>
<p><code>Date对象实例.getDay();</code> 获取当前日期对象的星期几，会返回 0<del>6 表示周日</del>周六</p>
<p><code>Date对象实例.getMonth();</code> 获取当前日期对象的月，会返回 0<del>11 表示1月</del>12月</p>
<p><code>Date对象实例.getFullYear();</code> 获取当前日期对象的年</p>
<p><code>Date对象实例.getTime();</code> 获取当前日期对象的时间戳，时间戳指从格林威治标准时间1970年1月1日0时0分0秒到当前日期所花费的毫秒数</p>
<pre><code>var d = new Date(&quot;1/1/1970 0:0:0&quot;);
console.log(d.getTime());  //输出为 -28800000，因为系统使用的时背景时间，和格林威治标准时间相差八小时</code></pre>
<p><code>Date.now();</code> 获取当前时间戳</p>
<p>计算机底层在保存时间时使用的都是时间戳</p>
<p>可使用时间戳测试代码的执行性能</p>
<h1 id="十一、Math"><a href="#十一、Math" class="headerlink" title="十一、Math"></a>十一、Math</h1><p>Math 和其他对象（如 Date）不同，它不是一个构造函数，它属于工具类，封装了数学运算相关的属性和方法</p>
<p><code>Math.PI</code> 圆周率</p>
<p><code>Math.abs(数字)</code> 计算绝对值</p>
<p><code>Math.ceil(数字)</code> 向上取整，小数位有就自动进 1</p>
<p><code>Math.floor(数字)</code> 向下取整</p>
<p><code>Math.round(数字)</code> 四舍五入取整</p>
<p><code>Math.random()</code> 生成 0~1 之间（不包括 0 和 1）的随机数  </p>
<p><code>Math.round(Math.random()*x)</code> 生成 0~x 之间（包括 0 和 x）的随机整数    </p>
<p><code>Math.round(Math.random()*(y-x)+x)</code> 生成 x~y 之间（包括 x 和 y）的随机整数</p>
<p><code>Math.max(数字1,数字2,...,数字n)</code> 取最大值</p>
<p><code>Math.min(数字1,数字2,...,数字n)</code> 取最小值 </p>
<p><code>Math.pow(x,y)</code> x 的 y 次幂</p>
<p><code>Math.sqrt(数字)</code> 开方</p>
<h1 id="十二、包装类"><a href="#十二、包装类" class="headerlink" title="十二、包装类"></a>十二、包装类</h1><p>JS 中提供了三个包装类将基本数据类型转换为对象：</p>
<p><code>String()</code> 将基本数据类型字符串转换为 String 对象</p>
<p><code>Number()</code> 将基本数据类型数字转换为 Number 对象</p>
<p><code>Boolean()</code> 将基本数据类型字符串转换为 Boolean 对象</p>
<p>转换成对象后可添加属性</p>
<p>实际应用中不会使用基本数据类型的对象，若使用基本数据类型的对象，在做比较时可能会有不可预料的结果</p>
<p>方法和属性只能添加给对象，不能添加给基本数据类型</p>
<p>但是当对基本数据类型的值调用属性或方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法，调用后再转换回基本数据类型，如基本数据类型调用 toString() 方法</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>在底层字符串是以字符数组的形式保存的，可使用索引和 length</p>
<p><code>字符串.charAt(索引)</code> 返回指定位置的字符，<strong>不会影响原字符串</strong></p>
<p><code>字符串.charCodeAt(索引)</code> 返回指定位置字符的 Unicode 编码 </p>
<p><code>String.fromCharCode(十进制编码或 0x十六进制)</code> 根据字符 Unicode 编码获取字符 </p>
<p><code>字符串.concat(字符串1,字符串2,字符串n)</code> 连接两个或多个字符串,<strong>不会影响原字符串</strong></p>
<p><code>字符串.indexOf(字符,开始检索位置)</code> 返回字符在字符串中第一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.lastIndexOf(字符,开始检索位置)</code> 返回字符在字符串中最后一次出现的索引或 -1（未找到时），第二个参数可选</p>
<p><code>字符串.slice(开始位置,结束位置)</code> 截取字符串，左闭右开，<strong>不会影响原字符串</strong>，若省略第二个参数则默认是字符串末尾，可使用负值参数</p>
<p><code>字符串.substring(开始位置,结束位置)</code> 截取字符串，和 slice 类似，左闭右开，，<strong>不会影响原字符串</strong>，但该方法不能接收负值参数，若传递负值默认使用 0，并且会自动调整参数为升序</p>
<p><code>字符串.substr(开始位置,截取长度)</code> 截取字符串，<strong>不会影响原字符串</strong>，但 ECMAScript 没有对该方法标准化，所以不建议使用</p>
<p><code>字符串.split(分割符)</code> 将字符串拆分为数组，若传递一个空串作为参数，则会拆分出字符串中的每个字符，也可传正则表达式</p>
<p><code>字符串.toUpperCase()</code> 字符串转为大写，<strong>不会影响原字符串</strong></p>
<p><code>字符串.toLowerCase()</code> 字符串转为小写，<strong>不会影响原字符串</strong></p>
<h1 id="十三、正则表达式"><a href="#十三、正则表达式" class="headerlink" title="十三、正则表达式"></a>十三、正则表达式</h1><p>正则表达式用于定义一些字符串的规则，计算机可根据正则表达式，检查一个字符串是否符合规则，或将字符串中符合规则的内容提取出来</p>
<p>正则表达式是个对象，使用 typeof 检查正则对象，会返回 object</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><p><code>var 变量 = new RegExp(正则表达式,匹配模式)</code> 创建正则表达式对象，匹配模式可选值有 <code>&quot;i&quot;</code> 忽略大小写，<code>&quot;g&quot;</code> 全局匹配模式，可设置多个匹配模式，且顺序无要求，这种创建方式更灵活，因为参数中可传变量</p>
<p><code>var 变量 = /正则表达式/匹配模式</code> 使用字面量创建正则表达式，如 <code>var 变量 = /a/i;</code>，在正则表达式中使用 <code>|</code>或 <code>[]</code> 表示或，使用 <code>[^xxx]</code> 表示除了 xxx 以外的内容，这种创建方式更简单</p>
<h2 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h2><p><code>正则对象.test(待检查字符串)</code> 检查字符串是否符合正则表达式规则，返回布尔值</p>
<pre><code>var reg = new RegExp(&quot;a&quot;);  //该正则表达式可检查一个字符串中是否含有 a，默认严格区分大小
console.log(reg.test(&quot;abc&quot;)); //返回 true，因为含有 a

var reg = new RegExp(&quot;ab&quot;,&quot;i&quot;);  //该正则表达式可检查一个字符串中是否含有 ab，忽略大小写
console.log(reg.test(&quot;Abc&quot;)); //返回 true，因为含有 ab

var reg = /a|b|c/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[abc]/;  //检查字符串中是否有 a 或 b 或 c
var reg = /[a-z]/;  //检查字符串中是否有任意小写字母
var reg = /[A-Z]/;  //检查字符串中是否有任意大写字母
var reg = /[A-z]/;  //检查字符串中是否有任意字母
var reg = /[0-9]/;  //检查字符串中是否有任意数字
var reg = /a[bde]c/;  //检查字符串中是否有 abc 或 adc 或 aec
var reg = /[^ab]/;  //检查字符串中是否有除了 ab 以外的内容
var reg = /[^0-9]/;  //检查字符串中是否有除了数字以外的内容</code></pre>
<h2 id="字符串和正则相关方法"><a href="#字符串和正则相关方法" class="headerlink" title="字符串和正则相关方法"></a>字符串和正则相关方法</h2><pre><code>字符串.split(/[A-z]/); 根据任意字母拆分字符串，该方法即使不指定全局匹配也会全都拆分 
字符串.search(/a[bde]c/); 搜索字符串中是否含有指定内容，返回第一次出现索引或 -1，设置全局匹配无效
字符串.match(/[A-z]/gi); 根据正则表达式，从字符串中将符合条件的内容提取出来，默认只找第一个符合要求的内容，可设置为全局匹配 g 模式这样可找符合要求的所有内容，返回数组
字符串.replace(被替换内容,新的内容); 
字符串.replace(/[a-z]/ig,&quot;&quot;);  //可删除所有字母</code></pre>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>通过量词可设置内容出现的次数</p>
<p>量词只对它前边的一个内容起作用</p>
<p><code>&#123;n&#125;</code> 正好出现 n 次</p>
<p><code>&#123;n,m&#125;</code> 出现 n~m 次</p>
<p><code>&#123;n,&#125;</code> 出现 n 次以上</p>
<p><code>n+</code> 至少出现 1 次 n，相当于 <code>&#123;1,&#125;</code></p>
<p><code>n*</code> 出现 0 次或多次 n，相当于 <code>&#123;0,&#125;</code></p>
<p><code>n?</code> 出现 0 次或 1 次 n，相当于 <code>&#123;0,1&#125;</code></p>
<p><code>^n</code> 以 n 开头</p>
<p><code>n$</code> 以 n 结尾</p>
<p><code>^n|n$</code> 以 n 开头或以 n 结尾</p>
<p><code>^n$</code> 字符串只能是 n</p>
<pre><code>var reg = /a&#123;3&#125;/;  字符串中连续出现 3 次 a
var reg = /(ab)&#123;3&#125;/;  字符串中连续出现 3 次 ab
var reg = /ab+c/;  字符串中 abc，其中 b 至少有一个
var reg = /^a/;  字符串中是否以 a 开头
var reg = /a$/;  字符串中是否以 a 结尾</code></pre>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><code>.</code> 表示任意字符，除了换行和行结束符</p>
<p><code>\w</code> 表示任意字母、数字、_</p>
<p><code>\W</code> 除了字母、数字、<em>，相当于 [^A-z0-9</em>]</p>
<p><code>\d</code> 任意数字，相当于 [0-9_]</p>
<p><code>\D</code> 除了数字，相当于 [^0-9_]</p>
<p><code>\s</code> 表示空格</p>
<p><code>\S</code> 除了纯空格</p>
<p><code>\b</code> 表示单词边界，标识是个独立的单词</p>
<p><code>\B</code> 除了单词边界</p>
<p>正则表达式中使用 <code>\</code> 作为转义字符</p>
<p>注意：使用构造函数时，由于它的参数是一个字符串，而 \ 是字符串中转义字符，若使用 \ 则需使用 \ 代替</p>
<pre><code>var reg = /\\/;
reg.test(&quot;b.\&quot;);  //返回 false，因为 \ 转义的是 &quot;
reg.test(&quot;b.\\&quot;);  //返回 true
var reg = new RegExp(&quot;\\.&quot;);  //相当于 var reg = /\./;
var reg = new RegExp(&quot;\\\\&quot;);  //相当于 var reg = /\\/;</code></pre>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>去除字符串中所有空格</p>
<pre><code>字符串.replace(/\s/g,&quot;&quot;)</code></pre>
<p>去除字符串开头的所有空格</p>
<pre><code>字符串.replace(/^\s*/,&quot;&quot;)</code></pre>
<p>去除字符串末尾的所有空格</p>
<pre><code>字符串.replace(/\s*$/,&quot;&quot;)</code></pre>
<p>去除字符串前后的所有空格</p>
<pre><code>字符串.replace(/^\s*|\s*$/g,&quot;&quot;)</code></pre>
<p>检查手机号是否合法：（1）以 1 开头（2）第二位 3-9 任意数字（3）第三位以后任意 9 个数字</p>
<pre><code>var reg = /^1[3-9][0-9]&#123;9&#125;$/  </code></pre>
<p>电子邮箱匹配：任意字母数字下划线.任意字母数字下划线（可有可无） @ 任意字母数字下划线.任意字母数字.任意字母（2-5位）.任意字母（2-5位）</p>
<pre><code>var reg = /^\w&#123;3,&#125;(\.\w+)*@[A-z0-9]+(\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/</code></pre>
<h1 id="十四、DOM"><a href="#十四、DOM" class="headerlink" title="十四、DOM"></a>十四、DOM</h1><h2 id="1、DOM"><a href="#1、DOM" class="headerlink" title="1、DOM"></a>1、DOM</h2><p>DOM（文档对象模型）是宿主对象，JS 中通过 DOM 对 HTML 文档进行操作</p>
<p>— 文档：整个 HTML 网页文档</p>
<p>— 对象：网页中的每个部分都转换为一个对象</p>
<p>— 模型：使用模型表示对象之间的关系，方便获取对象，DOM 树</p>
<h2 id="2、节点"><a href="#2、节点" class="headerlink" title="2、节点"></a>2、节点</h2><p>节点：构成网页的组基本的组成部分（最基本单元），网页中每一部分都可称为节点（如：html 标签、属性、文本、注释、整个文档等），但它们具体类型不同，节点类型不同，则其属性和方法也不同。</p>
<p>常用节点分为四类：</p>
<p>— 文档节点：整个 HTML 文档</p>
<p>— 元素节点：HTML 文档中的 HTML 标签</p>
<p>— 属性节点：元素的属性，并非元素节点的子节点，而是元素节点的一部分</p>
<p>— 文本节点：HTML 标签中的文本内容（任意非 HTML 的文本）</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>节点的共有属性：nodeName、nodeType、nodeValue</p>
<table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<p>浏览器已提供文档节点对象，该对象是 window 的属性，可在页面中直接使用，是全局变量。通过document 对象可在整个文档访问内查找节点对象，并可以通过该对象创建各种节点对象</p>
<h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><p>获取元素节点，都通过 document 对象调用</p>
<pre><code>document.getElementById(&quot;xxx&quot;)   通过 id 获取一个元素节点对象
document.getElementsByTagName(&quot;xxx&quot;)  通过标签名获取一组元素节点对象
document.getElementsByName(&quot;xxx&quot;)   通过 name 属性获取一组元素节点对象
document.documentElement;  获取 html 根标签
document.body;  获取 body 标签，保存的是 body 的引用
document.all;  代表页面中的所有元素
document.getElementsByTagName(&quot;*&quot;);  获取页面中的所有元素，相当于 document.all
document.getElementsByClassName(&quot;xxx&quot;);  根据元素的 class 属性值查询一组元素节点对象，但该方法不支持 IE8 及以下浏览器
document.querySelector(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法只返回唯一一个元素，若有多个满足条件的元素，则返回第一个，IE8也支持
document.querySelectorAll(&quot;CSS选择器&quot;)  可根据一个 CSS 选择器查询一个元素节点对象，但该方法返回符合条件的元素数组</code></pre>
<h3 id="获取-修改元素属性"><a href="#获取-修改元素属性" class="headerlink" title="获取/修改元素属性"></a>获取/修改元素属性</h3><p>获取元素属性：<code>元素.属性名</code>，注意 class 属性不能采用这种方式，因为 class 是 JS 中的保留字</p>
<p>读取 class 属性时需要使用 <code>元素.className</code></p>
<h3 id="获取-修改元素内的文本节点"><a href="#获取-修改元素内的文本节点" class="headerlink" title="获取/修改元素内的文本节点"></a>获取/修改元素内的文本节点</h3><p>修改获取到的元素节点对象属性：<code>变量.innerHTML = &quot;xxx&quot;</code>，注意 innerHTML 对自结束标签没有意义</p>
<p>或者先获取元素的文本子节点，再获取其 nodeValue 就是文本内容，如 <code>var 变量 = 元素对象.firstChild; console.log(变量.nodeValue)</code></p>
<p>注：<code>innerText</code> 可获取元素内部的文本内容，和 <code>innerHTML</code> 类似，不同的是它会自动将 html 标签去除只留下文本内容</p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><p>通过具体元素节点调用</p>
<pre><code>getElementsByTagName(&quot;xxx&quot;)  [方法]，返回当前节点的指定标签名后代节点，注意调用对象
childNodes  [属性]，表示当前节点的所有子节点（包括元素节点、文本节点等），注意 DOM 标签间的空白也会当成一个文本节点（IE8以上和其他浏览器）
children  [属性]，表示当前元素的所有子元素（而非节点，因此不会包含空格换行的文本节点）
firstChild  [属性]，表示当前节点的第一个子节点（包括空白文本节点）
firstElementChild  [属性]，表示当前节点的第一个子元素（不包括空白文本节点），IE8不支持
lastChild  [属性]，表示当前节点的最后一个子节点</code></pre>
<h3 id="获取元素节点的父节点和兄弟节点"><a href="#获取元素节点的父节点和兄弟节点" class="headerlink" title="获取元素节点的父节点和兄弟节点"></a>获取元素节点的父节点和兄弟节点</h3><p>通过具体的节点调用</p>
<pre><code>parentNode  [属性]，表示当前节点的父节点
previousSibling  [属性]，表示当前节点的前一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的前一个兄弟元素（不包括空白文本节点）
nextSibling  [属性]，表示当前节点的后一个兄弟节点（包括空白文本节点）
previousElementSibling  [属性]，表示当前节点的后一个兄弟元素（不包括空白文本节点）</code></pre>
<h3 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h3><pre><code>document.createElement(&quot;标签名&quot;);  可创建一个元素节点对象，并返回创建好的对象
document.createElement(&quot;文本内容&quot;); 可创建一个文本节点对象，并返回新节点
父节点.appendChild(子节点);  可向父节点中添加一个新的子节点
父节点.insertBefore(新子节点,指定的旧子节点);  在指定的子节点前面插入新的子节点
父节点.replaceChild(新子节点,指定的旧子节点);  使用新子节点替换已有子节点
父节点.removeChild(子节点);  删除子节点，相当于 子节点.parentNode.removeChild(子节点)
使用 innerHTML 也可以完成 DOM 的增删改相关操作，但这种方法有时候动静太大</code></pre>
<h2 id="3、文档加载"><a href="#3、文档加载" class="headerlink" title="3、文档加载"></a>3、文档加载</h2><p>浏览器加载页面时，按照自上向下顺序加载，读取到一行就运行一行</p>
<p>事件 JS 代码编写位置的三种情况：</p>
<p>（1）若将 <code>&lt;script&gt;</code> 标签写到页面上边 <code>&lt;head&gt;</code> 里，在代码执行时页面还没加载，则 DOM 对象也没有加载会导致无法获取 DOM 对象</p>
<p>（2）将 JS 代码编写到页面下部就是为了可以在页面加载完后再执行，这样性能也更好</p>
<p>（3）将事件写在 <code>onload</code> 事件中，<code>onload</code> 事件会在整个页面加载完成后才触发，确保代码执行时所有 DOM 对象已经加载完毕，支持该事件的对象有 image，layer，window，<code>window.onload = function()&#123;xxx&#125;</code></p>
<h2 id="4、利用-DOM-修改-CSS-样式"><a href="#4、利用-DOM-修改-CSS-样式" class="headerlink" title="4、利用 DOM 修改 CSS 样式"></a>4、利用 DOM 修改 CSS 样式</h2><h3 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式"></a>操作内联样式</h3><p><code>元素.style.样式名&quot;</code> 读取样式</p>
<p><code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<p>通过 style 属性设置和读取的都是<strong>内联样式</strong>，无法读取样式表中的样式</p>
<p>若 CSS 样式名中含有 <code>-</code>，这种名称在 JS 中是不合法的，如 background-color，需要将这种样式名改为驼峰命名法（去掉 -，将 - 后的字母大写）</p>
<p>因为内联样式有较高优先级，所以通过 JS 修改的样式往往会立即显示，但不会覆盖添加了 <code>!important</code> 的样式</p>
<pre><code>box1.style.width = &quot;200px&quot;;
box1.style.backgroundColor = &quot;red&quot;;</code></pre>
<h3 id="通过类修改样式"><a href="#通过类修改样式" class="headerlink" title="通过类修改样式"></a>通过类修改样式</h3><p>可通过修改元素的 class 属性间接修改样式，<code>元素对象.className = &quot;xxx&quot;</code> 或 <code>元素对象.className += &quot; xxx&quot;</code>（注意新类前面的空格），这样只需修改一次即可同时修改多个样式，浏览器只需重新渲染页面一次，性能较好，并且这种方式可以使表现和行为进一步分离</p>
<h3 id="读取元素样式"><a href="#读取元素样式" class="headerlink" title="读取元素样式"></a>读取元素样式</h3><p>（1）<code>元素.currentStyle.样式名&quot;</code> </p>
<p>获取元素当前正在显示的样式（只有 IE 浏览器支持）</p>
<p>该方法不能修改样式</p>
<p>（2）<code>元素.getComputedStyle(要获取样式的元素，伪元素)</code> </p>
<p>获取元素当前正在显示的样式，第二个参数一般都传 null，该方法返回一个封装了当前元素对应样式的对象</p>
<p>该方法不能修改样式</p>
<p>所有浏览器及 IE9 以上支持</p>
<p>（3）<code>元素.getComputedStyle(要获取样式的元素，伪元素).样式名</code> </p>
<p>获取元素当前正在显示的样式的值，若获取的样式没有设置，则会获取其真实值而非默认值，如若没有设置 width，不会获取到 auto，而会获取其真实宽度</p>
<p>该方法不能修改样式</p>
<p>不支持 IE8 及以下浏览器</p>
<p>（4）同时支持 IE8 和其他浏览器</p>
<p>可通过判断是否有 getComputedStyle 方法，若没有就用 currentStyle</p>
<pre><code>if(window.getComputedStyle)&#123;  
//注意这里需要加 window. 若不加是表示寻找变量，找不到就会报错，而加上表示寻找 window 对象的属性，找不到也不会报错而是返回 undefined
    return getComputedStyle(obj,null)
&#125;else&#123;
    return obj.currentStyle.样式名
&#125;</code></pre>
<h3 id="其他样式相关属性"><a href="#其他样式相关属性" class="headerlink" title="其他样式相关属性"></a>其他样式相关属性</h3><p><code>元素.clientWidth</code> 获取元素的可见宽度（包含内容区和内边距）</p>
<p><code>元素.clientHeight</code> 获取元素的可见高度（包含内容区和内边距）</p>
<p>上述两个属性获取到的值都是不带 px 单位的数字，可直接用于计算，并且是只读的，不能通过该属性修改样式</p>
<p><code>元素.offsetWidth</code> 获取元素的可见宽度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetHeight</code> 获取元素的可见高度（包含内容区、内边距和边框）</p>
<p><code>元素.offsetParent</code> 获取当前元素的定位父元素，获取离当前元素最近的开启了定位的祖先元素，若所有祖先元素都没有开启定位，则返回 body</p>
<p><code>元素.offsetLeft</code> 当前元素相对于其定位父元素的水平偏移量</p>
<p><code>元素.offsetTop</code> 当前元素相对于其定位父元素的垂直偏移量</p>
<p><code>元素.scrollHeight</code> 元素整个滚动区域的高度</p>
<p><code>元素.scrollWidth</code> 元素整个滚动区域的宽度</p>
<p><code>元素.scrollLeft</code> 元素水平滚动条移动的距离</p>
<p><code>元素.scrollTop</code> 元素垂直滚动条移动的距离</p>
<p>onsrcoll 该事件会在元素滚动条滚动时触发</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<h1 id="十五、事件"><a href="#十五、事件" class="headerlink" title="十五、事件"></a>十五、事件</h1><p>事件：就是文档或浏览器窗口中发生的一些特点的交互瞬间（如点击、鼠标移动、按下键盘、关闭窗口等）</p>
<p>JS 与 HTML 间的交互通过事件实现</p>
<p>在事件响应函数中，响应函数给谁绑定的 this 就是谁</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可在事件对应的属性中设置 JS 代码，当事件被触发时这些代码会执行</p>
<p>绑定事件的方式：</p>
<pre><code>方式一：
&lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;xxx&#39;)&quot;&gt;按钮&lt;/button&gt;

方式二：
var btn = document.getElementById(&quot;元素id&quot;)
btn.onclick = function()&#123;xxx&#125;</code></pre>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数（除 IE8 及以下浏览器以外）</p>
<p>IE8 及以下浏览器中，是将事件对象作为 window 对象的属性保存的</p>
<p>在事件对象中封装了当前事件相关的一切信息，如鼠标坐标、键盘哪个键被按下、鼠标滚轮滚动的方向</p>
<p><code>event.clientX</code> 鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>window.event.clientX</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的水平坐标</p>
<p><code>event.clientY</code> 鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>window.event.clientY</code> IE8 中鼠标指针在<strong>当前可见窗口</strong>的垂直坐标</p>
<p><code>event.pageX</code> 鼠标指针相对于<strong>整个页面</strong>的水平坐标，但在 IE8 中不支持</p>
<p><code>event.pageY</code> 鼠标指针相对于<strong>整个页面</strong>的垂直坐标，但在 IE8 中不支持</p>
<p><code>event.target</code> 表示触发事件的对象，而非事件所绑定的对象，区别于在响应函数中的 this 是指事件所绑定的对象</p>
<p>兼容不同浏览器的两种方式：</p>
<pre><code>元素.事件如onmousemove = function(event)&#123;
    if(!event)&#123;                     //方式一
        event = window.event;
    &#125;
    event = event || window.event;  //方式二，更常用
&#125;</code></pre>
<h2 id="事件冒泡（Bubble）"><a href="#事件冒泡（Bubble）" class="headerlink" title="事件冒泡（Bubble）"></a>事件冒泡（Bubble）</h2><p>冒泡指事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件（如都是 onclick ）也会被触发</p>
<p>在开发中大部分情况冒泡是有用的，若不希望发生事件冒泡可通过事件对象的 cancelBubble 属性设置为 true 来取消冒泡</p>
<pre><code>元素对象.onclick = function(event)&#123;
    event = event || window.event;
    event.cancelBubble = true;
&#125;</code></pre>
<h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><p>事件的委派指将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</p>
<p>通过事件委派可以只绑定一次事件即可应用到多个元素上，即使是后添加的元素</p>
<p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</p>
<p>触发事件的对象是期望的元素则执行，否则不执行，可通过判断 <code>if (event.target.className == &#39;xxx&#39;)</code> 来实现</p>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>（1）元素对象.事件 = 函数</p>
<p>当使用 <code>元素对象.事件 = 函数</code> 的形式绑定响应函数时只能同时为一个元素的一个事件绑定一个响应函数，若为同一事件绑定多个响应函数，则后面的会覆盖前面的</p>
<p>（2）addEventListener()</p>
<p>通过该方法也可为元素绑定响应函数，IE8 及以下浏览器不支持，在 IE8 中可使用 attachEvent() 来实现</p>
<p>参数：</p>
<p>— 事件的字符串（不要加on）</p>
<p>— 回调函数（当事件触发时会被调用）</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<pre><code>元素对象.addEventListener(&quot;click&quot;,function()&#123;&#125;,false);</code></pre>
<p>使用 addEventListener() 可以为一个元素的相同事件同时绑定多个响应函数，当事件被触发时，响应函数将会按照函数的绑定顺序执行</p>
<p>addEventListener() 中的 this，是绑定事件的对象</p>
<p>（3）attachEvent()</p>
<p>该方法功能和 addEventListener() 类似，也可以同时为一个事件绑定多个处理函数，不同的是该方法在 IE8 中支持，但在其他浏览器中不支持，并且它是后绑定的先执行，执行顺序和 addEventListener() 相反</p>
<p>参数：</p>
<p>— 事件的字符串（要加on）</p>
<p>— 回调函数</p>
<p>— 是否在捕获阶段触发事件，需要布尔值，一般都传 false</p>
<p>由于 attachEvent() 中的回调函数是由浏览器调用，所以 attachEvent() 中的 this 是 window</p>
<p>（4）兼容所有浏览器</p>
<pre><code>function bind(obj,eventStr,callback)&#123; //(要绑定的事件对象,去掉 on 的事件字符串,回调函数)
    if(obj.addEventListener)&#123;  //大部分浏览器兼容的方式
        obj.addEventListener(eventStr,callback,false);
    &#125;else&#123;  //IE8及以下浏览器
        obj.attachEvent(&quot;on&quot;+eventStr,function()&#123;
            callback.call(obj);
            //因为 this 是谁由调用方式决定，因为加匿名函数前 callback 由浏览器调用，所以外面加个匿名函数，在函数内来指定 callback 由谁调用
        &#125;);
    &#125;
&#125;</code></pre>
<h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p>关于事件传播，网景公司和微软公司由不同的理解和设计</p>
<p>微软认为事件应该是由内向外传播，当事件触发时应先触发当前元素的事件，再向当前元素的祖先元素上传播，即事件应该在冒泡阶段执行</p>
<p>网景公司认为事件应该由外向内传播，当事件触发时，应先触发当前元素的最外层祖先元素的事件，再向内传播给后代元素（即事件捕获）</p>
<p>W3C 综合了两个公司的方案，将事件传播分成了三个阶段</p>
<p>（1）捕获阶段：从最外层的祖先元素（大部分浏览器从 window 开始），向目标元素进行事件的捕获，但是默认此时不会触发事件</p>
<p>（2）目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件</p>
<p>（3）冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</p>
<p>若希望在捕获阶段就触发事件，可以将 addEventListener() 的第三个参数设置为 true，一般情况下不会希望在捕获阶段触发事件，所以这个参数一般是 false</p>
<p>在 IE8 及以下浏览器中没有捕获阶段</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>设置鼠标点击元素按住拖动时保持点击的相对位置不变</p>
<pre><code>鼠标的clientX-元素的offsetLeft
鼠标的clientY-元素的offsetTop</code></pre>
<p>onmousemove 该事件会在鼠标在元素中移动时被触发</p>
<p>onmousedown 鼠标按下</p>
<p>onmouseup 鼠标松开，可用于取消其他事件，如</p>
<pre><code>元素对象.onmouseup = function()&#123;
    对象.onmousemove = null;
    对象.onmouseup = null;
&#125;</code></pre>
<p><code>元素对象.setCapture()</code> 设置元素对鼠标按下相关事件进行捕获，该元素会把下一次所有鼠标按下相关的事件捕获到自身上（该方法只有 IE 支持，在火狐中调用不会报错，但 chrome 会报错）</p>
<p><strong>鼠标拖拽元素的例子：</strong></p>
<pre><code>box.onmousedown = function(event)&#123;  //box是开启一个绝对定位的 div
    box.setCapture &amp;&amp; box.setCapture();  //设置捕获代替解决 IE8 不支持 return false
    event = event || window.event;
    val ol = event.clientX - box.offsetLeft;
    val ot = event.clientY - box.offsetTop;
    document.onmousemove = function(event)&#123;
        event = event || window.event;
        val left = event.clientX - ol;
        val top = event.clientY - ot;
        box.style.left = left + &quot;px&quot;;
        box.style.top = top + &quot;px&quot;;
    &#125;
    document.onmouseup = function()&#123;
        box.onmousemove = null;
        box.onmouseup = null;
        box.releaseCapture &amp;&amp; box.releaseCapture();  //鼠标松开时取消对事件的捕获
    &#125;
    return false;  //因为拖拽时浏览器默认会去搜索引擎中所有内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）
&#125;</code></pre>
<h2 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h2><p>onmousewheel 在鼠标滚轮滚动时触发（火狐不支持该属性）</p>
<p>火狐中滚轮滚动可使用 DOMMouseScroll 来绑定滚动事件，且该事件需要通过 addEventListener() 函数来绑定</p>
<p>event.wheelDelta 获取滚轮滚动的方向，往上为正，往下为负（火狐不支持该属性）</p>
<p>火狐中通过 event.detail 来获取滚动方向，往上为负，往下为正</p>
<p>当 scrollHeight - scrollTop = clientHeight 时表示垂直滚动条滚动到底了</p>
<p>当 scrollWidth - scrollLeft = clientWidth 时表示水平滚动条滚动到底了</p>
<p>当滚轮滚动时，若浏览器由滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为，若使用 addEventListener() 绑定响应函数应使用 event.preventDefault() 取消默认行为(IE8 不支持preventDefault)</p>
<p><strong>随滚轮滚动时元素高度改变的例子：</strong></p>
<pre><code>box.onnmousewheel = function(event)&#123;
    event = event || window.event;
    if(event.wheelDelta&gt;0 || event.wheelDelta&lt;0)&#123;
        //向上滚
        box.style.height = box.clientHeight - 10 + &quot;px&quot;;
    &#125;else&#123;
        //向下滚
        box.style.height = box.clientHeight + 10 + &quot;px&quot;;
    &#125;
    event.preventDefault &amp;&amp; event.preventDefault();
    return false;
&#125;
box.addEventListener(&quot;DOMMouseScroll&quot;,box.onnmousewheel);  //兼容火狐</code></pre>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>onkeydown 某个键盘按键被按下，若一直按着按键不松手事件会一直被触发。当 onkeydown 连续触发时，第一次和第二次之间会间隔稍微长一点（这是为了防止误操作发生）其他次会很快触发</p>
<p>onkeyup 某个键盘按键被松开</p>
<p>event.keyCode 获取按键的 Unicode 编码从而判断哪个按键被按下，数字 0-9 对应编码 48-57</p>
<p>altKey、ctrlKey、shiftKey 判断 alt、ctrl、shift 是否被按下</p>
<p>注意键盘事件一般都会绑定给可以获取焦点的对象（如 input）或者是 document，一般不给 div 绑定</p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123;
        console.log(&quot;ctrl和y都被按下&quot;)
    &#125;
    if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57)&#123;
        return false;  //不能输入数字
    &#125;
&#125;
document.onkeyup = function()&#123;
&#125;</code></pre>
<p><strong>根据方向键移动 div 的例子：</strong></p>
<pre><code>document.onkeydown = function(event)&#123;
    event = event || window.event;
    var speek = 10;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;</code></pre>
<h1 id="十六、BOM"><a href="#十六、BOM" class="headerlink" title="十六、BOM"></a>十六、BOM</h1><p>BOM（浏览器对象模型），BOM 可以使我们可以通过 JS 操作浏览器，DOM 是操作网页文档的，在 BOM 中提供了一组对象来完成对浏览器的操作</p>
<p>BOM 对象有：Window、Navigator、Location、History、Screen</p>
<p>（1）Window：代表整个浏览器的窗口，同时 window 也是网页中的全局对象</p>
<p>（2）Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器</p>
<p>由于历史原因 Navigator 对象中的大部分属性都已经不能识别浏览器了，一般只会使用 userAgent 来判断浏览器的信息，userAgent 是个包含用来描述浏览器信息内容的字符串</p>
<p>注意 IE11 中已经将微软和 IE 相关的表示去掉，所以不能通过 userAgent 识别是否是 IE 浏览器</p>
<p>若通过 userAgent 不能判断，还可通过一些浏览器中特有的对象来判断浏览器信息，如 ActiveXObject 是 IE 独有的</p>
<pre><code>var ua = navigator.userAgent;
if(/firefox/i,test(ua))&#123;
    console.log(&quot;火狐&quot;);
&#125;else if(/chrome/i,test(ua))&#123;
    console.log(&quot;chrome&quot;);
&#125;else if(/msie/i,test(ua))&#123;
    console.log(&quot;IE&quot;);
&#125;else if(&quot;ActiveXObject&quot; in window)&#123;
    console.log(&quot;IE11&quot;);
&#125;</code></pre>
<p>（3）Location：当前浏览器的地址栏信息，通过 Location 可获取地址栏信息或操作浏览器跳转页面</p>
<p>若直接打印 location 可获取地址栏的信息（当前页面的完整路径）</p>
<p>location = “xxxx” 直接将属性修改为一个完整的路径或相对路径则页面会自动跳转到该路径，<strong>并会生成相应的历史记录</strong></p>
<p>location.assign(“路径”) 用来跳转到其他页面，作用和直接修改 location 一样</p>
<p>location.reload() 重新加载当前页面，作用和刷新一样，若传递 true 作为参数则会强制清空缓存刷新页面</p>
<p>location.replace(“路径”) 使用新的页面替换当前页面，调用完毕也会跳转页面，<strong>但不会生成历史记录</strong>，不能使用回退按钮回退</p>
<p>（4）History：代表浏览器的历史记录，可通过该对象操作浏览器的历史记录，由于保护隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，且该操作只在当次访问时有效</p>
<p>history.length 可获取到当次访问的链接数量</p>
<p>history.back() 可用来回退到上一个页面，和浏览器中的回退按钮一样</p>
<p>history.forward() 可跳转到下一个页面，和浏览器的前进按钮一样</p>
<p>history.go(整数) 可跳转到指定的页面，需要整数作为参数</p>
<p>— 1 表示向前跳转一个页面，相当于 forward()</p>
<p>— 2 表示向前跳转两个页面</p>
<p>— -1 表示向后跳转一个页面</p>
<p>— -2 表示向后跳转两个页面</p>
<p>（5）Screen：代表用户的屏幕信息，通过该对象可获取到用户的显示器的相关信息（在移动端用的多）</p>
<p>这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用</p>
<h1 id="十七、定时器"><a href="#十七、定时器" class="headerlink" title="十七、定时器"></a>十七、定时器</h1><p>setInterval(回调函数,调用间隔) 是 window 对象的方法，将回调函数每隔一段时间执行一次，第二个参数的单位是毫秒，会返回 Number 类型的返回值，该返回值作为定时器的唯一标识</p>
<p>注意在开启定时器前一般需要先使用 clearInterval(xx) 将当前元素上的其他定时器关闭</p>
<p>clearInterval(定时器标识) 关闭定时器，可接收任意参数，若参数是一个有效的定时器标识则停止对应定时器，若不是一个有效标识，则什么也不做</p>
<pre><code>var num = 1;
var timer = setInterval(function()&#123;
    num++;
    console.log(num)
    if(num == 11)&#123;
        clearInterval(timer);
    &#125;
&#125;,1000);</code></pre>
<p>setTimeout(回调函数,延时时间) 演示调用一个函数不马上执行，而是隔一段时间后再执行，而且只会执行一次</p>
<p>clearTimeout(延时器标识) 关闭一个延时调用</p>
<p>延时调用和定时调用实际上可以互相代替的，注意定时调用会执行多次，而延时调用只会执行一次</p>
<p><strong>根据方向键移动 div 并解决第一次按下时延时的例子：</strong></p>
<pre><code>var speek = 10;
var dir = 0;
setInterval(function()&#123;
    switch(event.keyCode)&#123;
        case 37:  //向左
            box.style.left = box.offsetLeft - speed + &quot;px&quot;;
            break;
        case 39:  //向右
            box.style.left = box.offsetLeft + speed + &quot;px&quot;;
            break;
        case 38:  //向上
            box.style.top = box.offsetTop - speed+ &quot;px&quot;;
            break;
        case 40:  //向下
            box.style.top = box.offsetTop + speed + &quot;px&quot;;
            break;
    &#125;
&#125;)
document.onkeydown = function(event)&#123;
    event = event || window.event;
    if(event.ctrlKey)&#123;  //按下 ctrl 后速度加快
        speed = 50;
    &#125;else&#123;
        speed = 10;  //松开 ctrl 不加速
    &#125;
    dir = event.keyCode;
&#125;
document.onkeyup = function()&#123;  //松开按键时，div 不再移动
    dir = 0;
&#125;</code></pre>
<h1 id="十八、JSON"><a href="#十八、JSON" class="headerlink" title="十八、JSON"></a>十八、JSON</h1><p>JS 中的对象只有 JS 自己认识，其他语言都不认识</p>
<p>JSON（JavaScript Object Notation，JS 对象表示法）是一个特殊格式的<strong>字符串</strong>，该字符串可被任意的语言识别，并且可转换为任意语言中的对象，JSON 在开发汇总主要用于数据的交互</p>
<p>JSON 和 JS 对象的格式一样，但是 JSON 字符串中的属性名必须加双引号</p>
<p>JSON 分类：</p>
<p>— 对象{}</p>
<p>— 数组[]</p>
<p>JSON 中允许的值有字符串、数值、布尔值、null、普通对象（不包括函数对象）、数值六种</p>
<p>通过工具类 JSON 来互换 JSON 字符串与 JS 中的对象（IE7 及一下浏览器不支持）</p>
<p>json –&gt; js 对象</p>
<pre><code>JSON.parse(JSON字符串)
eval(&quot;(&quot;+JSON字符串+&quot;)&quot;)  //IE7中，但不建议使用
通过引入外部的 js 文件（自定义的 JSON 对象）来处理  //兼容 IE7</code></pre>
<p>js 对象 –&gt; json</p>
<pre><code>JSON.stringify(js对象)</code></pre>
<p>eval() 可用来执行一段字符串形式的 JS 代码，并将执行结果返回，若 eval() 执行的字符串中含有 {}，它会将 {} 当成代码块，若不希望将其当成代码块解析，需在字符串前后各加一个 ()</p>
<p>但在开发中尽量不要使用 eval()，因为它的执行性能比较差，并且有安全隐患</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>1、把 JS 写到外部文件中通过外部文件引入可在不页面同时引用，也可利用到浏览器的缓存机制</p>
<p>2、JS 中每条语句以 <code>;</code> 结尾，若没写分号浏览器会自动添加，但是会消耗一些系统资源，有时浏览器会加错分号</p>
<p>3、把 JS 代码写在 HTML 下方，加载完页面后加载</p>
<p>4、使用 <code>元素.style.样式名 = &quot;样式值&quot;</code> 设置样式时，每修改一个样式，浏览器就重新渲染一次页面，这样执行的性能比较差，且要修改多个样式时不太方便</p>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p><code>console.time(&quot;计时器的名字&quot;)</code> 可用来开启计时器</p>
<p><code>console.timeEnd(&quot;计时器的名字&quot;)</code> 可用来终止计时器</p>
<p>往表格 <code>&lt;table&gt;</code> 里使用 appendChild 添加 <code>&lt;tr&gt;</code> 时会添加在 <code>&lt;tbody&gt;</code> 外部，因此需要获取 tbody 对象后对它使用 appendChild 来添加 tr</p>
<p>对于使用 for 循环遍历元素来给元素添加响应函数，需要注意 for 循环会在页面加载完成后立即执行，而响应函数会在被点击时才执行，当响应函数执行时，for 循环早已执行完毕</p>
<p>浏览器的默认行为</p>
<pre><code>对于表单、超链接等，若不想点击后跳转或提交可在响应函数的最后添加 return false 取消默认行为

拖拽时浏览器默认会去搜索引擎中所有内容，这会导致拖拽功能异常，这是浏览器的默认行为，可通过 return false 来取消（但对 IE8 无效）

当滚轮滚动时，若浏览器由滚动条，滚动条会随之滚动，这是浏览器默认行为，可通过 return false 取消该默认行为

在文本框（如 input）中输入内容属于 onkeydown 的默认行为，可通过 return flase 取消默认行为，取消后输入内容不会出现在文本框中</code></pre>
<p>注意若使用 addEventListener() 方法绑定响应函数时取消默认行为不能用 <code>return false</code>，需要使用 event.preventDefault() 来取消默认行为</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/15/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="less学习笔记">
                  <i class="fa fa-chevron-left"></i> less学习笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/23/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" rel="next" title="JavaScript学习笔记2">
                  JavaScript学习笔记2 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NicoleJay</span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
